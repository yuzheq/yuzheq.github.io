---
title: 内存管理
top: true
cover: false
toc: true
mathjax: true
date: 2021-07-12 11:21:50
password:
summary: 
categories: 计算机基础
tags: 
	- 操作系统
	- linux0.11
---

## 1、内存使用与分段

我们知道，计算机运行的**核心**不外于**取指执行**，而从**哪里取指令**呢，自然是**内存**，更具体的说，是从**磁盘加载到内存**中的一段程序。但指令有很多，我们要取得**哪一个指令的地址**呢？我们从用户视角看，程序是从**main函数**开始执行的，而从汇编的角度来说，就是程序入口**ENTRY之后的地址**。

那首先先让程序进入内存，而程序很**自然**的就要放在entry之后指定的那个地址中。我们假设这段程序就放在以**0x0000为起始地址**的这段内存里。这时**冲突**产生了。这段内存是用于操作系统初始化时放置指令的**固定**的区域。

那么，程序的入口地址显然需要定位到另一段**空闲的内存空间**，用专业术语说，就是指**重定向**。

> 重定向 : 修改程序中的地址，使其变成相对地址

而重定向的方式有两种，**直接定位到新的地址**和**基地址加上变化的偏移地址**，这里我们更多的去使用偏移地址，也就是**相对地址**。

既然知道需要将地址重定向，那我们就试着在运行程序的过程中**引入重定向**，但这又让人犯难了，就拿汇编来说，程序执行的过程需要经过**编译**，**连接**，**运行**三个过程，那我们要在那个阶段重定向呢？

假设在编译时重定向，这时将地址提前进行偏移放置在一段空闲地址中，但运行的时候，这段空闲地址被**别的进程占用**了，嗯，计算机的世界也充满着无常，我们不如试试载入内存时重定向——

这种想法好像还行，起码内存是自己的了。但是谁告诉你重定向只会发生一次呢？为了灵活完成任务，**交换**变得必不可少，难道我要**载入n次**吗？好的，下一位：

那就**运行时载入**吧，这种动态切换的方式的确**满足了所有需求**，它总会申请一段空闲的，在一定时间内被自己使用的内存。

------

到这里已经迈出了一大步，既然初步的想法确定了，我们接下来先将这个想法规范化，这里我们引入**地址翻译**与**逻辑地址**，**物理地址**的概念。

所谓地址翻译，就是指每执行一条指令，都要从逻辑地址算出物理地址。我们来看下面的例子

mov ax , [300]

这里的300是偏移地址，换句话说，这里的[300]指的是逻辑地址，而实际的[300]表示的物理地址等于当前这个**固定的偏移地址**加上**变化的基地址**。

那我既然每执行一条指令都要用到基地址，那基地址应该是一个**全局的变量**，而对于一个运行的程序，也就是进程来说，这个全局的变量应该存储在**PCB**中，又因为它被用到的**频率很高**，进而它会被放置在CPU的零级缓存——**寄存器ldtr**中。

- [x] GDT表示全局描述符，段描述符被放置在GDT中，用来对任务实现隔离。而有GDT，就自然也衍生了LDT，即局部描述符，它专属于某个任务。

这时程序的一次执行已经可以完成了，我们不妨记做**flag1**

------

### 分段

为了更好地使用内存，**分治思想**的引入自然势在必行，程序根据每一段代码的**属性**与**功能**将其分成了多个段，分析每个段的功能变得容易了很多。这个时候，**段**才是程序运行的**单元**。

这个单元有它的**状态**，它的**执行结果**等等，而在程序载入的时候，这些**段**也被载入到**不同的地址**中，降低了管理的复杂度。

为了**描述**这些段的信息，同时方便管理这些个段，就衍生出了进程的**段表**——**LDT**,段表中存放每个段的基地址，段号，长度，权限等等——

![1](https://raw.githubusercontent.com/future727/Pictures/main/img/image-20210627160125632.png)

这个表的思想不是第一次引入，更准确的说，在**操作系统启动**的时候就需要维护一个段表——**GDT**,操作系统故事的大幕也是就此揭开的。

对于内存的使用，大的来说是分**三个阶段**的，首先将**程序分段**，这是在**编译时期**完成的，我们只需要显式的告诉编译器自己声明的不同的段，接着就需要在内存中找出一段**空闲的内存空间**，那是哪一段呢？怎么知道这段内存可以被使用呢？这些是后话了；最后就将分好段的程序**载入**到分好区的内存中执行。

第一步我们已经完成了，我们接下来就来看分区思想是如何引入的，内存又是如何实现分区的？

------

## 2、内存分区与分页

- [x] 如何分区？描述分区后的每段内存，如何表示已经分出去了，如何将这段内存用作特定用途？
- [x] 分成定长的/不定长的；如何描述内存段；分配的算法？分区会导致什么问题？分页

这里首先来说些题外话，在开始这节之前，我试着提出针对内存分区我认为应该提出的问题，但事实证明，我**思维的出发点**是错的，

针对内存分区的具体问题，我开门见山的认为应该有描述分区后的数据结构，这样想固然没错，但更重要的对于一个**实际系统的架构**，从**需求入手才是最切实**的，对于内存分区，为什么要分区，因为**程序分段**的思想，决定**段的大小是不定**的，而与之对应的，加载到的那段内存也应该是与段的大小相匹配的。

------

现在我们开始进入正题，程序分段的引入导致每一个段的长度是不一样的，而**内存**只是一个用来装载指令和数据的**容器**，**容器的大小是由我需要多少水来决定的**，相应的，为每个程序段申请的空闲内存的大小也是由段来决定的，因此，定长的分配内存显然是不可取的，这里我们根据**段的长度**决定**申请的内存空间**。

那申请内存的时候，我们自然就需要知道那段内存是空闲的，这段内存有多大。这样我们就需要一个可以用来**描述这些信息的数据结构**，**分区表**就被引入进来了。当我们需要的内存空间大小和这段空间**近似匹配**的时候，我们就将程序加载进去，执行完了再将内存空间释放。

那在匹配内存空间的时候，就出现了问题，我们是应该**就近匹配**，还是花费时间做**最优匹配**呢？这里没有对错之分，可以参考相应的**时间**，**空间复杂度**和**占用空间大小**灵活选择。

虽然分区解决了内存使用的一部分问题，但我们考虑这样的例子：假如一个200K的段申请了一段500K的内存空间，但剩余的300K，别的段并不能使用。很多这样的**内存碎片**聚少成多，就造成了**内存空间的浪费**。

解决内存碎片直观的想法就是将没有的内存合并，也就是内存紧缩，但内存紧缩时，需要调整**每条指令**的基地址，这个**任务量是巨大的**，这种方式不可取。

这里，我们可以将内存分页，在**操作系统初始化**的时候，**memmap**会将内存分成**4k的页单元**，页单元由**页框号指示**中，而页框号的位置又由**页头指针**来指向，这个指针最终被放到了**寄存器**中。

## 3、多级页表和快表

### 多级页表

上一小节提出了一种**可行**的将**内存分页**的**思想**。但实际应用与理论总是存在**差距**的，我们首先**量化**的来看维护单个页需要的**内存开销**：

一页内存有4K的空间，而32位的系统有32位的地址总线，也就是说它的寻址能力是2的32次方，也就是4GB，那么操作系统就需要维护4GB/4KB=2的**20次方个页表**，也就是**1MB**的内存空间，一个进程需要1MB的内存空间，而多个进程**并发执行**，需要空间就会变得很大，这样显然**不可取**。

但这里有一个**误区**，有很多页表在实际使用中是被**闲置**的，既然它是闲置的，我们就不需要维护它，也就是说我们可以**删去部分不会用到的页表**，这样的话，假设就只需要1KB的空间来存储页表了，但**页表**是存储在**PCB**中的，PCB又是会被加载到**内存**的，而加载到内存的过程也是需要**维护队列等数据结构**的，**访存的开销太大**了。

那能不能有一种方式，既可以使页表连续，也可以占用空间少呢？

> 在平时读书时，我们要锁定某一页，会从找这一页所在的目录，然后浏览这个目录下的具体页就行了。而在操作系统中，多级页表就是这样的目录。多级页表又划分为页目录项和页表，只会将需要的页加载到内存中去。

下面我们来具体分析这个过程——

![image-20210707195238389](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195238389.png)

在**虚拟内存**中，一个具体的地址由**四个字节**来指示，**前十位存储页目录号**，接下来的**10位用来存放页号**，剩下的**12位用来页内地址的偏移**。

页目录在内存中固定驻留，需要占用16K的内存空间。这远小于将所有页表加载到内存的4M。

**页目录号**由**页目录指针**来指向，找到具体的目录后，然后**将这个目录中的页加载到内存**，接着找到具体的页，最终由**页内偏移**找到具体的**物理内存位置**。

### 快表

看书时，作者总会有意给读者标注出**重点的章节**，这样我们找有用知识的**时间又会减少很多**，同样，对于多级页表来说，16K的页表**寻址**起来也是很**浪费时间**的，能不能给我把**常用的页标注起来**呢？

这种思想在互联网中是常见的，**浏览器会将经常访问的域名做缓存**，**数据库会对经常用到的sql语句和数据做缓存**，而在操作系统中，由**TLB**来存储页目录的缓存。

- [x] TCB，也就是快表，它是一种**相连存储的寄存器**

![image-20210707195249863](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195249863.png)

首先在TLB中找是否存在对应的逻辑地址，**如果有**，直接转化**逻辑地址到物理地址**，当然，这一步**对于用户是透明**的。

如果在TLB中**没有找到**逻辑地址，即TLB未命中，那么就需要通过**多级页表**来查找。

那么TLB在理论层面是很好用，但真正应用效果如何呢？

![image-20210707195302146](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195302146.png)

可以看到，TLB的效率的确很高，但是需要建立在TLB命中率高的情况下的，然而实际情况下TLB是不大的，那为什么仍然可以发挥作用呢?这是因为**程序的地址访问**存在**局部性**——

![image-20210707195318860](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195318860.png)

## 4、段页结合的实际内存管理

### 内存管理的模型

段是程序员编写程序的方式，而页是物理内存的使用方式，那如何将段页结合呢？

![image-20210707195330375](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195330375.png)

首先在**虚拟内存**中划分一段**地址空间**用于存放应用程序的段。

- [x] 这里的地址空间只是**逻辑上**的，**物理地址**还需要做进一步的**映射**。

这里的**虚拟内存是分段**的，接着将分段的虚拟内存映射到**分页的物理地址**上去。

而从用户的角度来说：段面向用户，页面向硬件。从逻辑地址到物理地址的映射对于用户时透明的，只有映射到段是对用户可见的。

![image-20210707195343879](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195343879.png)

### 一个实际的段，页结合

要体现实际的内存管理，那就一定要**使用内存**，而使用内存即是**将程序加载到内存**，加载到内存的程序更具体的说它是一个**进程**。

则所谓的内存管理是从**进程创建**开始的，而进程创建时使用**fork系统调用**，故事的大幕也便就此拉开了——

- [x] 这个过程分为**分割虚拟内存**-》**建段表**-》**分配到物理内存**-》**建页表**-》**映射完成**

![image-20210707195411176](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195411176.png)

上图首先在**copy_process函数**中调用**copy_mem函数**，在该函数中首先**分配虚存**，为每个**进程**分配**64MB**的虚存，要注意的是虚存地址是**不重复**的，这样就不会导致相同的地址冲突。

接着**建立段表**，也就是在PCB中建立**段表LDT**，在后期进程切换的时候，PCB也就跟着切换。

接下来开始分配物理内存——

![image-20210707195423193](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195423193.png)

调用**copy_page_tables函数**将虚拟内存的地址**old_data_base映射**到物理内存的地址**new_data_base**，在这个函数中，**虚拟地址用from_dir指代**，**物理地址用to_dir指代**，需要注意的是：

from右移22位得到**目录项的编号**，又因为一个虚拟地址占4个字节，则表现为from>>20

![image-20210707195447747](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195447747.png)

在下面的循环中，将具体的页映射到物理地址——

![image-20210707195510386](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195510386.png)

最终，执行指令，在对应的内存地址空间中完成**写时复制**，即经**地址总线**将数据发送到物理空间中，整个过程的**地址翻译**由**硬件MMU**完成，将**逻辑地址**翻译为**虚拟地址**，再将虚拟地址翻译为**物理地址**——

![image-20210707195523166](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195523166.png)

完结——

![image-20210707195535245](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195535245.png)

------

> 山高路远，静水深流