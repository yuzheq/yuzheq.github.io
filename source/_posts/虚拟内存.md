---
title: 虚拟内存
top: false
cover: false
toc: true
mathjax: true
date: 2021-07-12 11:26:10
password:
summary:
tags: 操作系统
categories: 计算机基础
---

我们在第三章的内存管理中常用的一个概念是虚拟内存，虚拟内存是用**于分离用户与物理层**，且实现物**理内存的扩展**的。

但对于虚拟内存的**内在机理**，我们没有太多的谈及，只是把它当做一个**黑盒子**来使用，在这一章中我们将剖根问底，来揭开谜底。。。

------

## 1.请求调页和内存换入

从用户的视角来看，一个进程是**独享**系统的全部内存的，然而我们知道**物理内存是有限**的，不可能让每个进程真的任意使用所有内存，那这种**内存很大的假象**是如何制造出来的呢？

就是通过**虚拟内存**的引入，在**用户的视角**能看得到的内存地址是**逻辑地址，它是分段使用**的，而分的这些段又最终剥开揉碎成**一页一页的地址空间**。

但仅有这些逻辑地址，也就是现有地址空间是不够的，数据最终是需要被存储在实实在在的存储空间中的，也就是**映射到物理内存**。

但4G的虚拟内存映射1G的物理内存，听起来着实不怎么靠谱，怎么办呢？

- [x] `只有在需要的时候才做映射`

这就好比仓库与门店的关系，门店的**货柜是有限**的，当顾客要求一样东西时，就需要从仓库中取出来放到货架，这样看起来**商店总是不缺货**，但实际上这**归功于仓库**。

这里的从仓库取东西到门店的动作就相当于**从磁盘上请求调页到内存**，那么什么时候要调页呢？显然是**缺页**的时候？

嗯，再来一下灵魂叩问——**为什么会缺页**呢？

用户程序中的地址是逻辑地址，逻辑地址经过地址翻译成为物理地址，逻辑地址需要映射到物理地址才能真正被使用，那假如映射失败呢？**映射失败**也就是说**物理内存中没有对应的地址**。

这时就该请求调页了，从磁盘调页到物理地址，映射成功，继续执行。

### 一个实际系统的请求调页

请求调页时，就会执行缺页中断。那首先要获取缺页中断的**中断号**，而中断号是在**操作系统初始化**的时候设置的，这里我们直接给出：

- [x] 操作系统初始化时设置中断向量表 **interrupt vector table** (**IVT**) ，它里面存储有很多表项，即中断向量，也就是中断处理程序的入口地址。

![image-20201121190122738](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190122738.png)

接下来跳转中断处理程序，首先对**错误码进行压栈**，并将**页的错误线性地址**存储在**寄存器cr2**中——

![image-20201121190333570](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190333570.png)

将状态保存后，跳转**申请物理内存的函数**——

![image-20201121190506454](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190506454.png)

最后**将请求的页加载到物理内存**中，**重新设置映射地址**——

![image-20201121190556951](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190556951.png)

## 2.内存换出

为了保持货架上总有人们想要的商品，我们通常会将货柜中不常用的商品先撤到仓库中以腾出空间。

- [x] 内存也是如此，有换入，就必然有换出。

那怎样实现内存的换出呢？换出哪个对于系统是最有利的呢？

直观的想法，首先应该是**先来先换出**，想法很朴实，但系统中的进程都是有**优先级**的。所以继续往后想——

我们想让**不重要的换出**，那怎样体现不重要呢？直白的说，就是**很少用到**，这就衍生出了**MIN算法**，它的核心在于**换出这个序列中最远的将被使用的那个进程**。

这个想法还是很nice的，但我们无法预知以后发生的事情，也就无法做出有效的预估。

但这种想法是值得借鉴的，由这种想法进而衍生出了**LRU算法**，所谓LRU算法，就是选出**最近最少使用**的那个进程，然后换出。这里也应用了**程序局部性**的特点。

### LRU的准确实现——时间戳

假设存在一个**页序列ABCABDADBCB**，但只有**四个存储块**，这时需要选出**具有最小时间戳的页**。

![image-20201121201707370](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121201707370.png)

但页表ldt也是需要维护的，每更换一次时间戳，就要对页表进行更新，而页表是内存中的，访存次数过多实现代价未免过高。

### LRU的准确实现——页码栈

页码栈的实现代价同样很大，因而不作为实际应用使用，但很有必要了解它的思想——

栈中只有三个页的内存空间，**最底层的空间**存放**最-近最少使用的页**，**最上层的空间**存放**当前使用的页**。

因此在发生缺页时，将**最底层栈内的页弹出**，然后将其压入栈顶。

![image-20201121202032441](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121202032441.png)

一言以蔽之，LRU的准确实现在实际应用中代价太大，不可取。我们来看下实际应用中使用的近似实现：

### LRU的近似实现——将时间和变成是和否

记录时间和的系统开销太大，那我们能不能只维护一个标志位，也就是为使用页框的每一页设置一个**引用位**。

这里我们暂且不考虑多少个页框，也就是多少个帧更为合适。而是着重描述它的运行机制**SCR**(再给一次机会算法)——

我们用**循环队列**来表述**页框**，假如**加载一页**到页框中，**硬件**会自动**设置标志位R=1**，如果**发生缺页**，就**扫描这个循环队列**，如果**标志位R=1**，则将它**置为0**，表示**这个页最近没有被使用过**，如果标志位**R=0**,则**淘汰该页**，并**换入新的页**。

![image-20201121215941114](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215941114.png)

这样就完美了吗？假如很**少发生缺页**，那么指针就不需要置位，也就不**需要移动指针**，这样标志位**R的值会在0和1之间反复切换**，这样SCR算法就会退化为**FIFO**，而这本质上是因为**标志位R记录了太多历史信息**，所以我们需要**清除历史信息**，也就需要引入一个**跑得更快的指针**——

![image-20201121215954545](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215954545.png)

这样的模型更像是一个时钟，因而SCR算法又称**CLOCK算法**

那么置换的策略有了，我们还需要解决一个问题，分配多少帧更合适呢？

假如帧过多，那么就不存在**内存的高效利用**了，如果分的少，又会导致换入频繁，进程总在等待IO，CPU利用率下降，最终发生**颠簸现象**——

![image-20201121215924180](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215924180.png)

这里我们只是提出通过**工作集的算法**可以算出分配多少合适，而不再过多讨论。

------

> 山高路远，静水深流。



