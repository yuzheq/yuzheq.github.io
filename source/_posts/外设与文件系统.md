---
title: 外设与文件系统
top: false
cover: false
toc: true
mathjax: true
date: 2021-07-12 11:28:03
password:
summary:
tags: 操作系统
categories: 计算机基础
---

操作系统的**核心**无非是**多进程图像**和**文件图像**，它们共同支撑了一个计算机**最基础的骨架**，前者使多道程序能够被加载到内存，并有序的运行与切换，这其中又包含有内存的管理；而后者将完成程序如何实现持久化存储，如何对文件进行读写，统一的文件视图是如何搭建的这些任务。

完成多进程，内存这些核心的图像可以使**多道程序**在底层完成运行，但交互是不能实现的。人是通过使用硬件来间接与CPU交互的。因而我们还需要学习使用外设，也就是**用于读和写的终端设备**，而这些读和写操作的对象不一而足，但因为其一致的属性，都把他们归于**文件系统**。

我们先给出一个基本的架构——
![image-20201122092432000](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201122092432000.png)

关于外设与文件系统的故事也就此开始了。。。

------

## 1.IO系统

### 显示器

首先我们给出一个直观的需求，如何在屏幕上使用printf打印出hello,world?

一个直观的的**大致流程**是：首先由**CPU发出写的命令**，这个命令通过**PCI总线**传输到外设控制器中的**寄存器**，然后**外设控制器**向CPU发出**中断**，并**将数据从文件向显存中写入**。

按照我们之前的常识判断，向寄存器中写不就好了吗，为什么还需要文件的视图？

直接向寄存器中写固然可以满足需求，并且在汇编语言的实验中，我们也是这么做的。但它需要查询寄存器的地址，要写入内容的格式和语义，我们要兼顾很多要素，所以这样是不可取的。

这时就需要根据他们共同的特性来抽象出来一个接口，来负责完成基础的功能，而由具体的外设来扩展，这里的接口就是——**文件视图**。

了解了设计的初衷，我们来赏析一段操作外设的程序——

```c
int fd = open("/dev/xxx");
for(int i =0;i<10;i++){
	write(fd,i,sizeof(int));
}
close(fd);
```

通过这个通俗的例子我们得见**接口**的庐山真面目——

不管什么设备，操作系统都为其提供了统一的接口**open,read,write,close**，而这些设备用**/dev/xxx**来标识。通过这个文件，我们可以找到控制器的地址，内容格式等等。

接口呈现给我们的是一个封装好的功能块，而我们不仅要会知道接口的存在，还要通过接口来探寻**底层的故事**：

![image-20201124151108165](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124151108165.png)

大致的流程框架有了，我们来看printf函数是如何在显示器上输出的——

printf库首先**创建缓存buf**，然后将**格式化的输出**都写到缓存中，**缓存满了**以后再写到显存中，而如何写到显存中呢？核心就在于**sys_write函数**，：

```c
int sys_write(unsigned int fd,char *buf,int count){
    struct file* file;
    file = current -> filp(fd);
    inode = file -> f_inode;
}
```

该函数将缓冲区中的数据写入到指定文件描述符的文件中。它实现的**核心过程**是：通过文件描述符fd得到`文件信息`，再通过文件信息中的`句柄指向`找到存放文件属性(比如在磁盘中存放的block位置)的`索引节点inode`.

> 这里非常有必要说下文件描述符fd与索引节点inode。
>
> fd:文件描述符即是`文件地址的引用`，它作为进程文件描述符的表项被存储在其中，也可称fd为进程`文件描述符表的下标`。
>
> inode：inode是一个存储文件信息的数据结构，其中存储有`文件的真正位置`，也就是文件在`磁盘上block的位置`，
>
> inode是fd之后的故事了，通过文件描述符表可以查找到fd对应的那个条目，`取出打开文件的句柄`，通过句柄的指向找到inode。
>
> - [x] 句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。
>
> 上图——

那`文件是如何通过当前进程的信息被找到`的呢？这就是操作系统全局化的雏形了——

![image-20201124152440698](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152440698.png)

这里从当前进程打开的文件序列中找到**dev/tty0文件**，也就是**外设**，那这里的**open系统调用**做了什么呢？

![image-20201124152750656](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152750656.png)

而这些步骤的核心就是建立一个链——

![image-20201124152913538](C:\Users\zyz\AppData\Roaming\Typora\typora-user-images\image-20201124152913538.png)

接着我们需要知道文件的实际物理地址，即通`过inode的结构体找到实际存储在磁盘中的位置`，然后接着往下走——

![image-20201124153222880](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153222880.png)

这里判断外设的类型，得到是**字符型的设备**，然后将输出内容放在**输出队列中**以**字符**的形式输出——

![image-20201124153420690](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153420690.png)

输出的时候即使从**用户缓冲区读取**，然后**调用写函数**去——

![image-20201124153549847](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153549847.png)

开始写入：

![image-20201124153650464](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153650464.png)

那从显存的什么位置开始写入呢？直观的说，是光标所在处，所以我们需要读取光标的位置——

![image-20201124153855802](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153855802.png)

而输出的内容是不仅仅包含字符的，还有它的颜色，因而pos指针需要加2——
![image-20201124154015935](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124154015935.png)

printf系统调用的故事就到此为止了，我们再来回顾一下这个过程——

首先调用printf库函数——》核心是系统调用write——》通过字符设备接口调用基本功能——》tty设备写入缓冲区——》显示器写，即写入缓存，在显示器展示。

------

### 键盘

外设包括显示器和键盘，上一节中我们介绍了**显示器的工作机制**，在接下来的篇幅中我们将了解到**键盘是如何工作的**。

让外设工作起来无非三步：首先**CPU**通过**out指令**向外设控制器的某些**寄存器**发出**读/写**的命令，接着**把out指令以我呢间的形式封装起来**发出**中断**，形成统一的**文件视图**，最终**向内存中读写数据**。

那如何使用键盘呢？从按下键盘开始，也就是从**键盘中断处理**开始，再深入的说，从**中断初始化**开始：

![image-20201124161528247](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161528247.png)

然后需要知道从硬件的哪个**端口扫描**按下的键——
![image-20201124161642136](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161642136.png)

那**60端口**是什么呢？这就是**扫描码**，通过扫描码我们就可以知道**按下了哪个键**，进入分支**key_table**

![image-20201124161856604](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161856604.png)

在这个分支中，可以**知道按下什么键时将触发的函数**。我们进入显示字符函数——**do-self函数**，在这里取得按下键的**ASII码**，并将其放入**缓冲队列read_q的头部**，到这里，我们已经完成了**CPU对字符的读取**，最后我们需要完成**回显**即可——

![image-20201124162445909](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162445909.png)

------

我们来对这个过程做一总结——

![image-20201124162614747](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162614747.png)

至此，外设的工作机制就告一段落了，我们再以外设的视角来切进去——

![image-20201124162727355](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162727355.png)

------

> 山高路远，静水深流。