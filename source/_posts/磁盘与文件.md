---
title: 磁盘与文件
top: false
cover: false
toc: true
mathjax: true
date: 2021-07-12 11:31:02
password:
summary:
tags: 操作系统
categories: 计算机基础
---

# 一、磁盘与文件

------

## 1.生磁盘的使用

生磁盘指单独的磁盘，不包括文件系统。

**磁盘的使用同外设一样**，它的工作机制也是三步走：CPU向磁盘控制器中的**寄存器**读写数据，**磁盘控制器**完成真正的工作，并**向CPU发中断**信息。

学习磁盘从认识磁盘开始，磁盘是长这样的——

![image-20201124193703592](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124193703592.png)

那磁盘是如何工作的呢？我们以**磁盘读写一个字节**为例：

首先移动**磁头**，并移动**磁盘**到**磁道**上，然后旋转磁道到**扇区**，在这个过程中**磁生电**，从扇区中读出一个字节到**内存缓冲区**。

同样的，如果要从内存读取一个字节到磁盘，则应该从内存缓冲区中读取字节，再把它放在相应磁道的特定扇区中。

了解了表层的工作机制，接下来需要将这个过程**具象化**，也就是说要往控制器中写**柱面C，磁头H，扇区S，缓存位置**就可以读写磁盘了。

那用什么写入呢？自然是**out指令**——

![image-20201124194841844](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124194841844.png)

到这里，操作系统已经可以运行了，但**传入的参数太多**了，每次读写都要做这么繁琐的，那能否**将这些操作封装**，我们来看第一层的抽象——

### 通过盘块号读写磁盘

CPU可以通过提供的盘块号来算出上面的三个参数，也就是用**一维的参数来算出三维的参数**，在计算的过程中，就需要使用到**编址**，那么怎样编址才最高效呢？考虑到我们使用文件时通常是**读取block相邻的盘块**，因而编址的设计需要使得**读取相邻的盘块比较快速**。

> 磁盘访问时间=写入控制器时间+寻道时间+旋转时间+传输时间。

在这个过程中，**寻道花费的时间最多**，因为它是一种移动的机械运动。

所以为了节省时间，可以将相邻的盘块放在同一个扇区——

![image-20201124200503945](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124200503945.png)



那么问题是如何**通过C,H,S得到扇区号block**呢？

![image-20201124200629352](C:\Users\zyz\AppData\Roaming\Typora\typora-user-images\image-20201124200629352.png)



![image-20201124201018062](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124201018062.png)

因为访问磁盘的时间绝大部分是用于寻道的，因而随着**读取磁盘扇区增大**，**读写的速度会显著的提高**，但同时也会带来**空间的浪费**，表现为磁盘的碎片增多。

那我们怎样**折中**呢？很抱歉，我们空间多得是，**用空间换时间**是大势所趋。

而随着读写空间的增大，读写的单位也**从扇区变为了盘块**，有头有尾，不过如是。

------

在第二次封装之前，我们补充一点知识，也为下文埋下伏笔：

linux0.11的盘块号有多大呢？

每读取一个盘块，会读取两个扇区，因此可以说盘块等于两个扇区。

### 多个进程通过队列使用磁盘

在上文中，我们说的是CPU分配资源的最小单元——一个进程，但实际应用中多道程序并发执行才是常态，这时就需要引入队列——

![image-20201124202710472](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124202710472.png)

那怎样组织磁盘访问的请求效率最高呢？我们主要考虑**平均访问延迟**和**寻道时间**，而寻求一种相对高效的解决方案，换言之就是寻求一种算法——

说到调度算法，最直观的自然是FCFS。

### FCFS

![image-20201124225422783](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124225422783.png)

我们可以观察到先来先服务的算法会导致**磁头总在长途奔袭**，而不顾它经过的可以**顺便访问**的进程。

在这个基础上改进的想法是先处理离当前磁头近的进程，也就是**SSTF**——**最短寻道时间优先算法**

### SSTF

![image-20201124230201466](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124230201466.png)

这种算法的确解决了磁头耗时的问题，但因为**程序的局部性**，进程对磁盘的**请求总会比较集中**，这会导致**边缘化的进程**即便等待了很久，也**没有得到IO资源**，也就是**饥饿**问题。

所以我们再接下来的改进中既要兼顾最短寻址，也要满足雨露均沾的需要，这就引出了**电梯算法**——SCAN

### SCAN

既然请求有局部性，那我们首先从**请求密集**的地方开始**磁头扫描**，然后磁头沿着某一方向扫描，扫描完后折返，我们来具象化的看下——

![image-20201124231412870](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124231412870.png)

可以看到中间请求密集的地方仍然被扫描多次，这就好比**我要坐着正在往下的电梯去上面，这可不怎么明智**，在现实生活中，我们通常会等电梯先下去，然后我们再乘坐向上的电梯，这个算法的优化也应该如此——

![image-20201124232126400](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124232126400.png)

理论完了，上正菜——

![image-20201124234604990](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124234604990.png)

在这段代码中，首先**将请求加入到队列**中，又IO资源是临界区资源，因此用**cli(),sti()**的方式给临界区上锁，处理完请求后再返回。

至此，调度算法告一段落，我们来做一总结——

![image-20201124235425309](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124235425309.png)

## 2.从生磁盘到文件

前面提及进程通过盘块号从而算出扇区号，那**盘块号是怎样得到的**呢？就是通过**文件**。我们的核心在于了解**如何从文件获取盘块号**。

不使用文件的磁盘是生磁盘，这小结我们就将这生米煮成熟饭，来看**熟磁盘的工作机制**。

那如何引入文件呢？我们对盘块做进一步的抽象，就成了文件。

那从用户视角来看，文件是什么？**文件是用来存储字符的**，因此不妨说**文件是字符流**。

我们的问题转变为要建立**字符流到盘块集合的映射**关系，那映射如何理解呢？基于盘块号的映射又是什么呢，我们来看下面的小例子——

![image-20201125092547498](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125092547498.png)

我们通过映射得到了字符的位置，但这个映射的细节对用户是隐藏的，我们不妨剥茧抽丝，看看映射是通过怎样的结构来实现的？

最常规的映射结构是以连续结构实现文件——

![image-20201125093111022](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093111022.png)

字符的位置确定了，映射建立起来了，为了方便查询，自然就形成了**FCB——文件控制块**，通过查表我们得知了对应的磁盘块：

![image-20201125093355040](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093355040.png)

我们再来回顾一下这个过程——

`首先用户打开一个文件，然后用户操作某些字符流，这些字符流通过查FCB表对应到相应的盘块，然后根据盘块号的得到CHS，最终读写文件。`

------

通过顺序结构查询文件位置，本质上是通过**数组**的方式访问，数组对于词典式的静态文件访问非常友好，但假如在数组中再插入一个元素，就需要对其他元素做位置的移动，显然不方便，那这种动态的写入用怎样的结构实现呢——**链表**

![image-20201125095036685](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125095036685.png)

链表的结构只需要添加一个`逻辑块号`，将这个逻辑块号与物理块号`建立映射关系`，就可以实现动态的在空闲块中写入，但链表的缺点也显而易见，假如需要某个盘块号，它需要遍历之前的所有盘块号，增加了访问时间。

哎，安得世间万全法，不负数组不负卿。

但是吧，还真有，但这就是另一个故事了——**索引结构**

索引结构在生活中很常见，书本的目录就是索引，目录下的页是连续的，符合数组的特点，而目录页是不连续的，也就是链表结构。

我们`查FCB表`可以得到`索引块`，再通过索引块得到`特定盘块的索引`。它是一种连续和链式分配的有效折中。

那索引如何具象表示呢？其实我们之前也提及过，也就是**inode**，即**index node。**

## 3.文件使用磁盘的实现

上一小节中我们完成了生磁盘的使用，而后对生磁盘进行一层层的抽象，最终用文件的形式来使用磁盘，那文件是如何使用磁盘的呢？它与生磁盘的使用有什么异同，通过文件使用磁盘的核心又是什么？

------

我们首先给出一个大致的脉络——
![image-20201125105359803](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105359803.png)

可见，对磁盘的读写不过是在对文件读写的基础上`显示得加了一步`：通过inode找到磁盘盘块号。

这个故事从系统调用**sys_write**开始——

![image-20201125105002918](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105002918.png)

在这段代码中，首先通过**文件描述符fd**得到那个文件**file**，然后通过file得到**文件结构描述信息inode**，最终调用文件写入**file_write函数**。

而file_write就是我们需要的那张地图：

- [ ] **file_write(inode,file,buf,count)**

inode也就是索引节点，从inode中我们可以得到盘块号，从file中我们可以要读写的是那一段字符串，具体的说，file中有一个读写指针fssek，fseek指向这段字符的开始地址，而参数count表示要读写多少个字符，也就是偏移，最后将这段字符写到buf这段缓冲区上去。

大致的脉络有了，我们来看具体的实现——

![image-20201125110645363](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125110645363.png)



如果是追加字符，则首先得到文件的大小，然后指针偏移到文件末尾，最后要实现**将这段字符写入到磁盘中去**。

![image-20201125111052897](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125111052897.png)

首先使用文件末尾的地址除以盘块的大小得到**对应的盘块号**，然后将盘块号放入到**电梯的调度队列**中，接着得到**具体的写入位置**，或者说是在**盘块号内的偏移**。

那具体的盘块号如何算的呢，这同时也是使用**文件区别于使用盘块号的核心**，如下图~



![image-20201125112728570](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125112728570.png)

在操作系统中，万物皆文件，我们上面提及的仅仅是一个普通文件，但如果是一个设备文件呢？

文件的**框架是不变**的，**变化的只是inode**中存储的内容，对于**设备文件**来说，inode中存储有**文件的属性，类型**等——

![image-20201125113249026](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125113249026.png)

整个脉络已经明晰了起来，但隐隐之中还是有一点留白，我们把从文件名得到文件描述符，再通过fd得到inode的过程当做一个黑盒子来使用，至于这个黑盒子是否是潘多拉魔盒，我们会在后一节的学习中看到，至此，我们来概括的看一下文件视图的两条主线：**生磁盘与熟磁盘**——
![image-20201125114043926](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125114043926.png)

# 二、文件系统

## 1.目录与文件系统

在**文件的基础**上，通过**目录**把整个磁盘抽象成**文件系统**的形式，是磁盘的**第四层抽象**。

而这也是最终呈现给用户的视图，在用户眼中，**磁盘就是一堆有组织的文件**。而剥茧抽丝之后，我们知道**文件系统最终会映射到一个个的盘块号**中。

文件系统只是我们先入为主的从主观上得到的抽象，但实际上从文件到文件系统仍是一个**漫长的过程**。

首先我们从**文件**可以很自然的想到**多文件**，那多个文件如何组织起来呢？起初多个文件自然应该是在**一层目录**的，但一层目录管理起来着实困难，所以**目录树**就应运而生了。

假设将文件划分为特定目录下的不同文件，将划分后的集合再进行划分，K次划分后，每个集合中的文件数为**O(logk N)**.

可以看出从多文件到目录树的**核心**是需要**引入目录**的概念，那目录是怎样实现的呢？

那我们首先来看，**目录怎样使用**，我们**使用路径来定位某个文件**，更具体的说，使用路径可以得到某个文件的**FCB**。

换句话说，要识别某个文件，就要得到这个文件的FCB，再对FCB的信息进行匹配，就可以确认这个文件是什么。

而从路径定位文件的过程，直观的说，目录应该要有它目录下的每个文件的FCB和文件名，但是**FCB是庞大**的，将它读入内存显然是**低效**的，那只要将**需要的那个文件的FCB**加载到**内存**中，所以FCB需要被识别，因而需要一个**FCB的编号**，而这个编号需要**FCB数组**来维护。

### 树状目录的完整实现

![image-20201125201135235](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125201135235.png)



现在目录的脉络已经**明晰**了。磁盘只需要维护**FCB数组**和**对应FCB号的数据块**即可，数据块中包含有**文件名**和**对应FCB的地址**。而对于一个**目录**来说，它会维护**目录下文件的FCB数组和数据块**。逐层循环，最终得到需要的文件。

但仅仅这样是不够的的，要想一个**系统能自举**，也就是**可移植**，就需要首先做好**框架**，进一步说，就是有一个**扎实的根基**，也就是**根目录的维护**。

![image-20201125203034066](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125203034066.png)



尽管PPT已经很详细了，但为了加深记忆，我们再来总结一手——

`引导块`：操作系统启动之后加载，即`固化的引导块`

`超级块`：记录位图的空间大小等信息

`i节点的位图`：记录**i节点的事务**，就相当于是动态记录i节点的信息，比如i节点的大小，位置，性质等信息

`盘块位图` ：记录盘块的状态，大小，位置等,可类比计算机网络里P2P体系中的每人持有一部分数据，并使用**位图来表征数据的状态**。

至此，就到了我们熟悉的总结环节了——

![image-20201125204155061](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125204155061.png)

## 2.目录解析代码实现

在上面的流程中，仅有**目录的实现**我们是以**黑盒子**的形式展示的，现在我们来打开这个黑盒子——

**目录同样是文件**，而对文件的探寻，是从**open开始**的，又**以inode作为主线**的：

![image-20201125213742823](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125213742823.png)

首先根据路径名得到索引，通过索引找到目录名，最终进入核心的**get_dir函数**——

![image-20201125214016996](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214016996.png)

在这个函数中，首先获取根目录的inode，指向路径名的指针后移。**目录的inode**是在系统初始化是就存储在**shell进程中**，而**后来创建的进程都要由shell进程创建**，自然也会**拷贝shell进程的内容**，根目录的inode得以流传下来。

> 关键的流程就是首先找到根目录root，接着从路径中读取到目录项，然后从目录项的FCB中找到索引节点号inode，最终根据数据块内容再读取下一个目录。

![image-20201125214627114](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214627114.png)

**操作系统初始化**时，会完成**设备的挂载**，而磁盘的挂载，本质上是**超级块的读取**。

![image-20201125214942682](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214942682.png)

然后根据这个数组中前半部分的占用空间得到**inode的位置**，找到了inode的位置，目录这个文件就不再神秘了——

![image-20201125215119581](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215119581.png)

**循环读取**到叶子结点的文件，**大结局**——
![image-20201125215235130](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215235130.png)

------

> 山高路远，静水深流。