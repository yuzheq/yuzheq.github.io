---
title: Mysql数据库系列——持续更新中
top: true
cover: true
toc: true
mathjax: true
date: 2021-07-12 16:24:45
password:
summary:
categories: 数据库
tags: 
	- Mysql
	- 极客时间
---

## 前言

有一段时间我很困惑，如何在有限的时间内展开繁杂的内容，最终在评论区找到了答案：

> 将每一小节的内容提炼成问题，通过回答这些问题来掌握知识，详略分明且高效！

## 一.一条sql查询语句是如何执行的

### 1.mysql的框架有哪些基本组件，各是什么功能？

所有的故事，都从一张图开始：

![image-20210604153409674](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604153409674.png)

可以看到，mysql大致分为server层与存储引擎层：

- `server层：`包含连接器，查询缓存，分析器，执行器等，涵盖了mysql的大多数的核心功能，以及所有的内置函数(日期，时间，数学，加密函数）,所有跨存储引擎的功能都在这一层实现，如存储过程，触发器，视图。
- `存储引擎层：`它以插件式的架构方式负责数据的存储与提取，支持InnoDB,Memory,MyISAM等存储引擎，默认引擎是**InnoDB**.
- 关系：**所有存储引擎共用一个server层**。

### 2.server层包含哪些组件？它们各是什么作用？

1. `连接器`：连接器负责和mysql服务器端**建立连接，获取权限，维持和管理连接**

   ![image-20210604155808563](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604155808563.png)

   在连接建立后，如果没有使用，就会进入sleep状态。

   ![image-20210604160921192](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604160921192.png)

   如果客户端太久没动作（**wait_timeout=8小时**），连接器就会将其自动断开。

   当然，上面的情况是基于长连接的，而长连接正如我们在计网中了解的一样：**如果客户端持续有请求，则使用同一个连接**。长连接有效减少了频繁建立，销毁连接的成本，但也带来了一些问题：

   - [x] mysql在执行过程中临时使用的内存是管理在连接对象中的，如果连接长期存在，会导致MYsql占用内存过多，最终导致OOM

   而针对长连接占用内存过多的问题，通常有这样两种解决方式：

   - **定期断开连接**
   - MYSQL5.7以后，可以在每次执行比较大的操作后，执行**mysql_reset_connection**来重新初始化连接资源。

2. `查询缓存`：

   首先要明确的是：不建议使用功能缓存，原因如下：

   我们在拿到一个查询请求后，首先会查询缓存，如果缓存中存在**以键值对形式存在的记录**，则直接从缓存中拿，也无须再执行后续环节，直接返回命中结果即可。如果缓存中不存在，则继续流程。

   但如果我们拿到的是一个更新请求呢？那查询缓存不仅没用，还需要清空缓存，也就是我们常说的**缓存失效**，在一个更新语句频繁的系统中，要查询缓存有何用？

   让人戏谑的是，在mysql8.0以后，查询缓存彻底成了过去式。

3. `分析器`：

   1. 词法分析：我们输入是由多个字符串和空格组成的一条sql语句，mysql需要识别里面的字符串分别是啥，如需要把字符串test识别为表test。
   2. 语法分析：简言之，判断sql语句的语法是否正确。

4. `优化器`：

   哪些方面有优化空间呢？**join的连接顺序，索引**，所以优化器会决定选择哪一个。

5. `执行器`：

   在执行之前，首先查看是否具有执行权限，如果没有，返回错误。如果命中，则**在查询缓存返回结果的时候做权限验证**。

   如果有权限，则执行器调用引擎提供的接口，调用API，完成操作。

### 3.存储引擎层有什么作用？

留个坑

------

> 日拱一卒，功不唐捐。

------

## 二.一条sql更新语句是如何执行的？

### 1.redo log的概念是什么？底层实现机制是怎样的？

`redo-log`：即重做日志，它独属于InnoDB引擎，是一种物理日志，记录了在数据页上的操作，可以保证crash safe.

`原理`：假如在执行更新语句后，直接将更新写回磁盘，就会影响即时体验。所以我们需要借鉴这样的思想：

> 《孔乙已》中的酒店掌柜不会直接将还账记录写到**账本(磁盘)**中，而会将**还账(更新**,即做了什么)记录在**粉板(redo-log)**上，在空闲时，在全部写入账本中。

`底层原理`：InnoDB的redo-log是固定大小的，如可以配置为一组4个文件，每个文件大小1GB，记录日志时使用**循环队列**的数据结构，当循环队列已满，会将最久的日志擦除(写入磁盘)，然后使用新的日志填充空间。

redo-log并非直接持久化到磁盘，它会首先存储到`redo-log buffer`，接着存储到文件系统的`page cache`,最后才`持久化`到磁盘。

### 2.什么是WAL（write ahead logging）机制，好处是什么？

直白的说，就是`先写日志，再写入磁盘`，日志是被加载到内存中的，写入速度快，而写入磁盘是机械运动，写入速度非常慢。

### 3.redo log是如何保证crash-safe的？

所谓crash，指的`是数据库异常重启`的场景，显然，如果不使用redo-log机制，此时仅有负责归档(用于备份)的bin-log，数据的更新不会被刷新到磁盘中去。

而redo-log机制负责物理更新刷新到磁盘中去，`不会出现物理与逻辑数据不一致`的状况。

### 4.binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？

`bin-log`:即归档日志，由server层实现，记录数据库的逻辑操作，用于全量备份。当需要恢复数据时，可以取出某个时间段内的bin-log进行重放恢复。

`底层原理`：bin-log区别于redo-log，它没有文件大小的限制，会追加写；

每个线程都有自己的binlog cache,但是会共用一份binlog文件。

持久化到磁盘分为两个阶段：首先将日志写到文件系统的**page cache**,此时并没有持久化到磁盘，所以速度比较快；接着**fsync**,即是将数据持久化到磁盘，一般认为只有fsync才占磁盘的**IOPS**。

`crash-safe`:crash要解决的问题是逻辑数据与物理数据不一致的问题，也就是保证将内存中物理数据刷新到内存，但bin-log表示我做不到~

### 5.对比redo-log和bin-log.

|            | redo-log               | bin-log                                                      |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| 文件大小   | 覆盖写                 | 追加写                                                       |
| 层级       | server层               | InnoDB引擎                                                   |
| 日志形式   | 物理日志               | 逻辑日志                                                     |
| 作用       | 刷新到磁盘，物理一致性 | 归档，逻辑一致性                                             |
| crash-safe | √                      | ×                                                            |
| 实质       | 记录数据页做了什么操作 | statment模式：记录sql语句    row模式：记录更新前后的行，一般使用row模式 |

### 6.一条sql更新语句是如何执行的？

> update test set c=c+1 where id = 1

1. 执行器先找引擎找ID=1的这一行，ID为主键，引擎使用B+树的主键索引找到这一行。如果该行在内存中，直接返回给执行器；否则，先从磁盘读取到内存中，再返回；
2. 执行器执行得到新数据，调用引擎接口写入新的行记录；
3. 引擎将这行记录更新到内存中，并将更新的操作记录写到redo-log中，redo-log进行prepare状态；
4. 执行器生成bin-log，将bin-log写入磁盘；
5. redo-log改为commit状态，更新完成。

### 7.如果数据库误操作，如何将数据恢复？

找到最近一次的全量备份，`从备份时间点开始`，将备份的bin-log依次取出，重放到误删时刻。

### 8.什么是两阶段提交?如果不两阶段提交，会发生什么？

即确定redo-log与bin-log提交时机，通过`两阶段提交来保证跨系统维持数据逻辑一致性`。如果没有两阶段提交，就好比读到了事务的脏数据。

------

> 日拱一卒，功不唐捐。

------

## 三.事务隔离：为什么你改了我还看不见

### 1.事务的概念是什么？

> 事务是对数据库中数据操作的`保证数据逻辑一致性的最小操作单元`。

### 2.简述某一场景下，不同事务隔离级别的区别

有这样的一个场景：

![image-20210606161322663](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606161322663.png)

在该场景下，不同事务隔离级别有不同的返回值：

- `读未提交`：即在事务B没有提交的时候，它做的变更就可以被事务A看到。所以读到的值分别是1,2,2；

- `读已提交`：即只有在事务A提交之后，它做的变更才能被事务A看到，所以读到的值为：1,1,2；
- `可重复读`：即事务A执行期间读到的值和事务A开启时读到的值是一样的，所以读到的值是1,1,2；
- `串行化`：即事务A，事务B对于同一行记录，会通过加读写锁的方式来限制另一个事务。所以读到的值是1,1,2.

### 3.读已提交，可重复读是怎样通过视图构建实现的？

首先了解下视图的概念：

> 视图是对复杂sql语句的封装，可以认为是拷贝静态数据，对视图做的变更不会同步到数据库中。

- `可重复读`：在该隔离级别下，数据库在事务启动时创建了一个视图，访问时以视图的逻辑结果为准，在**事务存在期间**都会使用这个视图。他为mysql的默认隔离级别；
- `读未提交`：直接返回记录最新值，没有视图概念；
- `读已提交`：视图在**sql语句开始执行时**创建。它为oracle的默认隔离级别。

- [x] 注:配置方式：transaction-isolation=READ-COMMITED

### 4.简要说明可重复读的使用场景

在记账的时候很有用。

### 5.事务隔离是怎样通过read-view实现的?

之前我们提到，在事务隔离中，提供了`视图这种数据拷贝`的方式，而在事务隔离级别下，我们会读到不同的数据，这说明是存在多个视图的，也就是read-view。

在MYSQL中，实际上每条记录在更新时都会记录一条`回滚操作`，通过回滚操作，可以得到上一个状态的值：

![image-20210606163851669](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606163851669.png)

也就是说，`同一个记录在数据库中是存在多个版本的`，当我们要读取数据时，要判断这个数据的版本对于当前事务是否可见，如果不可见，就通过`undo-log`计算得到上一个版本，直到找到正确版本为止。

在不需要的时候，数据库系统会将回滚日志删除。

### 6.并发版本控制的概念是什么？如何实现？

`概念`：同一个数据行，在数据库中存在`多个版本号`，这个版本号可以理解为当前操作这行数据的`事务的ID`。

`实现`：在进行并发操作时，会使用`该行的版本号与当前事务的版本号`进行比较，如果刚好等于，也就是说这行数据是由这个事务提交生成的。

### 7.长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？

`概念`：需要执行很久的事务；

`底层`：长事务意味着系统中有非常多的不能被删除的事务视图，这会导致大量的`空间占用`，而在mysql5.5之前，即便长事务被提交，`回滚段被清理，文件也不会变小`，另外长事务还`占用锁资源`，这时其他就会因锁等待重新建立连接，`mysql的连接被占用爆满`，导致拖垮整个库。

`查询`：SELECT * FROM information_schema.INNODB_TRX

`避免`：

1. 设置autocommmit=1,即自动提交；
2. 写脚本监控information_schema.INNODB_TRX的内容，发现长事务就kill掉它；
3. 设置SQL语句所能执行的最大运行时间；
4. 设置回滚表单独存放，便于回收表空间。
5. 尽量去使用小事务。

### 8.事务的启动方式有哪几种？

- `begin:`
- `start trasaction:`与begin效果一致；
- `start trasaction with consistent snaps hot:`该语句执行后，会创建一致性视图，分配事务ID。

### 9.commit work and chain的语法有什么作用？

提交当前事务+开启下一个事务=begin+commit;

------

> 日拱一卒，功不唐捐。

------

## 四.深入浅出索引上

### 1.索引的概念是什么？

**概念**：索引是一个相对抽象的数据结构，在书中，我们通常抽取`目录名与对应的页码号作为目录以快速定位数据`，在数据库系统中，索引就是以这样的作用存在的，它是数据库管理系统中一个`排序`的数据结构)，以`协助快速查询`、更新数据库表中数据。

**类比**：操作系统中使用**inode**来唯一标识文件，在inode中，记录了各个`文件分别包含哪些磁盘块`，给定inode,就可以找到文件的所有块，在inode中，同样存储了文件属性的磁盘地址。

### 2.简述索引模型之哈希表

**概述**：哈希表是一种以`键值对`存储数据的结构，我们只需要输入待查找的key，就可以找到对应的value,哈希表的思路很简单，把值放在数组中，用一个`哈希函数把key换算成一个确定的位置`，然后将value放在数组的这个位置。

**哈希冲突**：使用链表法解决；

**示例**：![image-20210607202153949](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202153949.png)

**特点**：只适用于`等值查询`，可以应用于NoSQL不能做`区间查询`。

### 3.简述索引模型之有序数组

**概述**：将元素按照一定的顺序排列，这里的顺序`不一定是严格自增`，而是按照某一属性从小到大排序。假如有一个按照身份证号排列的有序数组，我们要查询某一个身份证号的名字，通过`二分法`就可以找到。

**示例**：![image-20210607202732018](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202732018.png)

**特点**：对于`等值查找`和`范围查找`都较友好，查询的时间复杂度为`O(logN)`,但实际上有序数组并没有得到大量应用，这是因为在插入元素时需要大量的`数据搬移`，也因此有序数组被大量应用于`静态存储引擎`。

### 4.简述索引模型之B+树

**概述**：B+树是一种二叉搜索树，它的节点遵循严格的大小关系，`二叉搜索树的查询，更新的时间复杂度为O(logN)`,

**示例**：![image-20210607203522696](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607203522696.png)

**特点**：`B+树`即为InnoDB的引擎模型，但考虑到性能，更多被使用的实则是`多叉树`。

### 5.为什么N叉树被广泛应用到数据库引擎中？

我们先设想二叉树存储的场景：假如二叉树`树高20`，存储了100万行数据，`需要读取20个数据块(连续的存储空间)`，在机械硬盘时代，读取硬盘是龟速，而这样的龟速，居然要连续查询20次，那怎么提高查询的性能呢？

减少树高，增加一个数据块中的数据，即`使用N叉树`。

### 6.基于主键索引和普通索引的查询有什么区别？

**前提**：在InnoDB中，`表是根据主键顺序以索引的形式存放`，这种存储方式被称为索引组织表。又因为索引是B+树的数据结构，即数据存储在B+树中，而`每一个索引在InnoDB里面对应一张表`。再进一步，则可以认为表是以多个B+树的形式存储的。

**主键索引**：主键索引的叶子结点存储的是`整行数据`，也因此得名聚簇索引。

**普通索引**：非主键索引的叶子结点存储的是`主键的值`，因此得名二级索引。

**区别**：如果where条件需要走主键索引，则只需要搜索主键的B+树，如果where条件走的是普通索引，则就需要先查询普通索引的B+树，得到主键，再去查询普通索引，即`回表`

### 7.简述维护B+树索引时的页分裂与页合并？

- **页分裂**：在插入数据时，如果当前数据页已满，就会申请一个新的数据页，导致`空间利用率下降`；
- **页合并**：如果因为删除数据，导致`利用率变低`，则页合并就成了可选的优化方式。

### 8.哪些场景下应该使用自增主键，而哪些场景不应该

`自增主键适合递增插入`的场景，这样追加数据时，就不需要数据搬移咯。所以**大多数的场景下，我们都会使用自增主键**。

而在有业务逻辑的字段做主键时，数据成本就会变高啦。

如果在`典型的KV场景下，就需要使用普通索引`。

### 9.删除主键索引与普通索引有什么影响？

删除，重建主键索引后，需要同时`修改普通索引对应的主键索引`，而删除，重建普通索引则让人省心不少。

### 10.索引的优化

1. **覆盖索引：**如果查询条件使用的是普通索引，或者联合索引的最左原则字段，查询结果是联合索引的字段或者主键，`不用回表操作，直接返回结果`，减少磁盘读写的次数，提高IO性能。
2. **最左前缀：**联合索引的`最左N个字段`，也可以是字符串索引的前M个字符；
3. **联合索引：**根据创建`联合索引`的顺序，`以最左原则进行where检索`，比如(age,name)以age=1或者age=1 and name='张三'可以使用索引，单以name="张三"不会使用索引。考虑到存储空间的问题，还需要根据业务需求，将查找频繁的数据进行靠左创建索引。
4. **索引下推：**like "hello%" and age>10检索，在mysql5.6之前，会对匹配的数据进行会回表查询，5.6版本以后，`会先过滤不合法的数据，再对合法的数据进行回表`，从而降低回表率，提升检索率。

------

> 日拱一卒，功不唐捐。

------

## 五.全局锁和表锁：给表加个字段怎么有那么多阻碍

### 1.简述全局锁锁

**概述**：对整个数据库实例加锁。
**加锁方式**：`Flush tables with read lock(FTWRL)`，这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会`被阻塞`。
**使用场景**：全库逻辑备份。
**风险**：
	1.如果在`主库备份`，在备份期间不能更新，`业务停摆`
	2.如果在`从库备份`，备份期间不能执行主库同步的binlog，导致`主从延迟`

### 2.InnoDB是如何实现全局备份的

**mysqldump**：官方自带的逻辑备份工具mysqldump，当mysqldump使用参数`--single-transaction`的时候，会启动一个事务，确保拿到`一致性视图`。而由于`MVCC`的支持，这个过程中数据是可以正常更新的。

一致性读是好，但是前提是引擎要支持这个隔离级别。

## 3.如果要全库只读，为什么不使用set global readonly=true的方式？

1.在有些系统中，`readonly的值会被用来做其他逻辑`，比如判断主备库。所以修改global变量的方式影响太大。
2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会`导致整个库长时间处于不可写状态，风险较高`。

## 4.表锁简述

**概述**：mysql里面表锁有两种：表锁和MDL(元数据锁)，表锁不建议加，MDL会默认加上；

**表锁**：![	](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210608082421097.png)

**MDL**：不需要显式使用，在访问的时候会自动加上，MDL包含`读锁和写锁`，`读锁之间不互斥`，可多线程共享，`写锁互斥`，来保证表结构变更时的安全性。

**风险**：MDL直到事务提交才会被释放，因此为了防止MDL存在时间过长，从而MYSQL异常重启，应该避免长事务。

### 5.如何安全地小表加一个字段

1. 查询长事务，暂停或kill掉长事务；
2. 在alter table语句中指定等待时间，避免阻塞。

------

> 日拱一卒，功不唐捐。

------

## 六.行锁功过：怎么减少行锁对性能的影响

### 1.行锁的概述

行锁即是对数据库的`行记录加锁`，在引擎层实现，仅`InnoDB`支持行锁。

### 2.简述两阶段锁协议

**概念**：在InnoDB事务中，行锁是在需要的时候加上的，但需要等待`事务提交才会释放`；

**建议**：`如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁往后放`。

### 3.简述死锁

**概念**：当两个线程都在等待对方锁持有的资源时，就会产生死锁；

**预防死锁**：

1. 设置`超时参数`，默认为50s，这样显然交互不好，但如果设置过小，又会错将正常等待的线程当做死锁处理，因此**不建议使用这种方案**；

2. `死锁检测`，发现死锁，马上`回滚`。这里可以`类比spring中的循环依赖`，都是需要查看自己所依赖的线程有没有被别人锁住。但这种方案仍有隐患，假设有100个线程并发修改，`都去查看自己依赖的线程有没有锁住，就必然需要大量的CPU资源`，这也是为什么即便很小的并发量，CPU占用率也可能很高的原因。

   > 怎样解决由这种热点行更新导致的性能问题？

   - 在`确认不会发生死锁的情况下，可关闭死锁检测`，但问题在于关掉死锁检测可能导致大量的超时，这是业务有损的；
   - 控制并发度，具体地说，是在数据库服务端实现该逻辑，实现方式自然是`特定大小的等待队列`；
   - 从设计上看，可以考虑将一行改成逻辑上的多行。

------

> 日拱一卒，功不唐捐。

## 番外

### 1.mysql的服务器配置文件

![image-20210607105513978](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607105513978.png)

### 2.my.cnf/my.ini配置文件详解

https://www.cnblogs.com/kuoAT/p/7080770.html

### 3.mysql日志系统详解

https://segmentfault.com/a/1190000023827696

### 4.查看mysql下的几个日志

https://blog.csdn.net/xuheng8600/article/details/79823875

1. **慢查询日志**是记录了执行时间超过参数long_query_time(单位是秒)所设定值的SQL语句日志。

   Note:慢查询日志对于我们发现性能有问题的SQL有很帮助，建议使用并经常分析；

2. **查询日志**记录了clinet的所有的语句。

   Note:由于log日志记录了数据库所有操作，对于访问频繁的系统，此种日志会造成性能影响，建议关闭。

3. **错误日志**在Mysql数据库中很重要，它记录着mysqld启动和停止，以及服务器在运行过程中发生的任何错误的相关信息。

4. **二进制日志**也通常被称为binlog,它记当着所有的DDL和DML，但不包括数据查询语句。

## 面经集锦

1. Explain的主要字段

   ![image-20210613161115048](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613161115048.png)

2. b+树相比B树的优点

   ![image-20210613170513272](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613170513272.png)

3. 可不可以切换索引为哈希索引？

   ![image-20210613162722458](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613162722458.png)

4. 场景题：高并发场景下数据库压力很大，怎么解决？

   `使用索引，使用缓存，分库分表，消息队列`

5. mysql分页查询优化

   **一般查询会从第一条记录开始找起**

   1. **子查询**：这种方式`先定位偏移位置的 id`，然后往后查询，这种方式适用于 id 递增的情况
   2. **id限定**：可以使用 `id between and` 来查询

   一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。

6. mysql 联合索引使用 A>n and B=m 和 A=n and B=m 的区别

   ![image-20210613165722760](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165722760.png)

   ![image-20210613165652454](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165652454.png)

7. MySQL的InnoDB和MyISAM区别

   | 角度         | InnoDB   | MyISAM     |
   | ------------ | -------- | ---------- |
   | 事务         | 支持     | 不支持     |
   | 外键         | 支持     | 不支持     |
   | 索引         | 聚集索引 | 非聚集索引 |
   | 表的具体行数 | 不保存   | 保存       |
   | 锁的粒度     | 行锁     | 表锁       |

8. 索引如何优化

   发现索引走的不好：**慢查询**

   1. 利用`覆盖索引`来进行查询操作，避免回表；
   2. `explain中的字段type`：至少要达到range级别，要求是ref级别，如果为**consts**最好不过。
   3. `联合索引最左前缀原则`。
   4. union，in,or都能够命中索引，建议使用`in`.

9. 简述乐观锁与悲观锁

   **乐观锁**：拿数据时不会上锁，但在提交的时候会判断数据有没有被更新，通常使用版本号/时间戳来实现。

   **悲观锁**：一开始就对商品加上锁（SELECT ... `FOR UPDATE`）

10. 索引一定会命中吗？如何保证命中

    不一定会命中，使用explain中的ref字段判断，force index,强制走某个索引

    ```mysql
    SELECT * FROM test01 FORCE INDEX(uk_index) WHERE NAME = '测试1' AND age=1 ;
    ```

11. mysql数据库为什么要使用N叉树

    一个页就是一棵树B+树的节点，数据库I/O操作的最小单位是页，与数据库相关的内容都会存储在页的结构里。

    在一棵B+树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间

    同一层的节点之间，通过页的结构构成了一个双向链表

    非叶子节点包括了多个索引行，每个索引行里存储索引键和指向下一层页面的指针

    叶子节点为，存储了关键字和行记录，在节点内部(也就是页结构的内部)记录之间是一个单向的链表

    ![img](https://img-blog.csdnimg.cn/20200404223041152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70#pic_center)

12. 说一下你的项目里具体的一个表，有没有建索引，如何建的？

    shop表，主键shopId（主键本身就是一种特殊的索引）,外键userId,shopCategoryId

    **shopId bigint not null auto_invreament primary key**

    在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键，除非高并发写入操作可能需要衡量自增主键

13. innodb 索引文件的存储形式

    思路：一个表——》多个B+树——》叶子节点(页结构，即多个磁盘块)+非叶子结点(页结构，即多个磁盘块)——》行数据+索引数据

14. mysql主键是怎么自增的（其实是说底层的Auto-INC锁）

    **自增长计数器**,**Auto-INC锁**,表锁

------

> 山高路远，静水深流