{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/contact.jpg","path":"medias/contact.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/gzh.jpg","path":"medias/gzh.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/0xbird.png","path":"medias/avatars/0xbird.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","path":"medias/avatars/ajin.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","path":"medias/avatars/antnlp.ico","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","path":"medias/avatars/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/babyq.png","path":"medias/avatars/babyq.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","path":"medias/avatars/bytedtrans.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","path":"medias/avatars/cww97.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","path":"medias/avatars/duyupei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","path":"medias/avatars/feibar.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.png","path":"medias/avatars/feibar.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/fun4go.png","path":"medias/avatars/fun4go.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","path":"medias/avatars/gsy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hael.jpg","path":"medias/avatars/hael.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","path":"medias/avatars/huaji.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","path":"medias/avatars/hzwer.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","path":"medias/avatars/ids2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","path":"medias/avatars/jiejie.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","path":"medias/avatars/jingjing.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","path":"medias/avatars/jitao.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","path":"medias/avatars/kewlgrl.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","path":"medias/avatars/ldy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","path":"medias/avatars/lijiaqian.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","path":"medias/avatars/liyangzone.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","path":"medias/avatars/liyucheng.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","path":"medias/avatars/lyn-draw.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lzh.png","path":"medias/avatars/lzh.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","path":"medias/avatars/mashiro.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","path":"medias/avatars/masterx.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/michael.jpg","path":"medias/avatars/michael.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","path":"medias/avatars/milyyy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","path":"medias/avatars/mizunashi.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","path":"medias/avatars/mouse.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mpy634.png","path":"medias/avatars/mpy634.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","path":"medias/avatars/qiandongwei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qianqian.png","path":"medias/avatars/qianqian.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","path":"medias/avatars/qiqiang.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/spacesac.png","path":"medias/avatars/spacesac.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","path":"medias/avatars/sunchangzhi.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","path":"medias/avatars/taotao.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","path":"medias/avatars/taowei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","path":"medias/avatars/tawn.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","path":"medias/avatars/xiejiadong.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","path":"medias/avatars/xuzhongyou.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/yezijie.png","path":"medias/avatars/yezijie.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","path":"medias/avatars/zhangting.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","path":"medias/avatars/zhangyi.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","path":"medias/avatars/zhaokangzhe.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","path":"medias/avatars/zzw.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/files/cv-en.pdf","path":"medias/files/cv-en.pdf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/files/cv-zh.pdf","path":"medias/files/cv-zh.pdf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"adaaa7fabb1b90d855781ed46ce8bcd6135c0662","modified":1695622342008},{"_id":"source/404.md","hash":"910f7b5b76aaad01f4ada50241f7c64d3abaf169","modified":1695549029841},{"_id":"source/CNAME","hash":"48303ea8c6eb4e599061afb39bc9b2b70af1c4f5","modified":1695616350422},{"_id":"source/categories/index.md","hash":"4253d55d27d30a7e9c5aed4bf9dc14c756e0b672","modified":1695549029844},{"_id":"source/archives/index.md","hash":"f9e1ce8b1b48223c60db60ec64831b41511b1311","modified":1695549029844},{"_id":"source/tags/index.md","hash":"eb99211c6a4710db61592df397ee5337155febe4","modified":1695549029844},{"_id":"source/_posts/JVM系列知识点总结.md","hash":"5dd5ca94e343587c3b34ac0e72c88e464941adc5","modified":1695549029842},{"_id":"source/_posts/Maven从入门到入坑.md","hash":"369962089992cae8bf14a36adb087c0db9ab29ed","modified":1695549029842},{"_id":"source/_posts/Mysql数据库系列——持续更新中.md","hash":"657b9cefb5f61a4a3ab823fb5dd4bc08ab4a71c7","modified":1695549029842},{"_id":"source/_posts/Spring-IOC源码浅析.md","hash":"a1fb673417b4488c23fc4ff03049cf553b8da7bb","modified":1695549029842},{"_id":"source/_posts/X数之和图文详解.md","hash":"080c2785554528f64a30ea444f6b66183fec0540","modified":1695549029842},{"_id":"source/_posts/article-title.md","hash":"b0c33a0d081f2a0607d277fee0b5c7483ce74b90","modified":1695554560587},{"_id":"source/_posts/java多线程的前世今生.md","hash":"4a249ffdf55acf646fb5abb918e7e523494eafea","modified":1695549029842},{"_id":"source/_posts/内存管理.md","hash":"24de9ecf79421835629f0f82363ef0e1993b513c","modified":1695549029842},{"_id":"source/_posts/四种基本的数据结构.md","hash":"3588504678b68a276e971d0cfbd6bf5b8269cabc","modified":1695549029842},{"_id":"source/_posts/外设与文件系统.md","hash":"ef60810650c66b41d7b4e48a2a08837ec4780299","modified":1695549029843},{"_id":"source/_posts/操作系统基础.md","hash":"f3e93b04b40ec58d4320813ab88ea12e3cd28d89","modified":1695549029843},{"_id":"source/_posts/数据结构常见的八大排序图文详解.md","hash":"de9a3ee4325ed2ff061c5ca46494f15df4351485","modified":1695549029843},{"_id":"source/_posts/磁盘与文件.md","hash":"7ad4b4a3aa7767e47c849e2088aecc97daede170","modified":1695549029843},{"_id":"source/_posts/虚拟内存.md","hash":"5a64c08b64deb9c463182f05cae70e9b70a3af2a","modified":1695549029843},{"_id":"source/_posts/计算机网络概述.md","hash":"0d377e837526fca1afa59a16a1ebf2321dec3ed9","modified":1695549029844},{"_id":"source/_posts/计算机网络应用层.md","hash":"58707933125dbad1c6037ffac9519770087ffca4","modified":1695549029843},{"_id":"source/_posts/计算机网络传输层.md","hash":"e9120e64dfb8db00e4f0556f50fe95c06dc86534","modified":1695549029843},{"_id":"source/_posts/进程与线程.md","hash":"ab2bf42d807ad93850caad17371fc98dcadeac6a","modified":1695549029844},{"_id":"source/_posts/递归的基本思想.md","hash":"f1ee8691ac21b256264b0e0a2f14bddc09438499","modified":1695549029844},{"_id":"source/_posts/那年深秋-在教室临窗写下的汇编.md","hash":"ea66ae0608dbe75fd6878eedd6a12a28f7615346","modified":1695549029844},{"_id":"source/_posts/链表算法集锦-图文详解哦.md","hash":"48b3fd8d9f8b409da78751217d779869a92af64f","modified":1695549029844},{"_id":"themes/matery/.DS_Store","hash":"c55111eef87f3fa57b67dfa221cdd18cef7364c4","modified":1695622342004},{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1695554976264},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1695554976264},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1695554976264},{"_id":"themes/matery/_config.yml","hash":"224a5316e28b9c5b3f00613029f44eace2c1b9e7","modified":1695554976265},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1695554976268},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1695554976265},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1695554976268},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1695554976268},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1695554976268},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1695554976268},{"_id":"themes/matery/layout/friends.ejs","hash":"895e40a864796680fbef581e4b09f252fbdd963a","modified":1695554976268},{"_id":"themes/matery/layout/layout.ejs","hash":"2ba4110dc596424b1220a259c8e594da774e7f59","modified":1695554976268},{"_id":"themes/matery/layout/index.ejs","hash":"7fc5a6c4f0229c0be43b7d1315524c468346fbb8","modified":1695554976268},{"_id":"themes/matery/layout/post.ejs","hash":"f1a35f32e5901e167ae9a750e7cb3635549cea2e","modified":1695554976268},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1695554976268},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1695554976268},{"_id":"themes/matery/languages/default.yml","hash":"527c795b8c41fe62bf35603ffebfa6d4a7929a2c","modified":1695554976265},{"_id":"themes/matery/languages/zh-CN.yml","hash":"d92db4b986bb6f0d228e9a8249383103bf56342d","modified":1695554976265},{"_id":"themes/matery/source/favicon.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1695554976269},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1695554976267},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1695554976267},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1695554976267},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1695554976267},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1695554976267},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"6ae58a57b83a5999d0b6a737ec868f084d208f89","modified":1695554976267},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1695554976267},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1695554976267},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1695554976268},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1695554976267},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1695554976268},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1695554976268},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1695554976268},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"ab610754bf6aea844b5ae0802ed37c73b5f1dc9f","modified":1695554976265},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1695554976265},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1695554976265},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1695554976265},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"5bf4294398145695c0cdad317b088ded1b330ecd","modified":1695554976265},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1695554976265},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1695554976266},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1695554976266},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"fb572df037b5a6eb563912caa1f1967ca835a70a","modified":1695554976266},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1695554976265},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1695554976266},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1695554976266},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1695554976266},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"e761f0104fbf431671bbe6bebc91ca82f737f4d2","modified":1695554976266},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"3a82fcb6f31d69971cb564985842c14ac02cdca0","modified":1695554976266},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1695554976266},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1695554976266},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1695554976266},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1695554976266},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1695554976267},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1695554976267},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1695554976266},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1695554976267},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"e2865b3003ec07892e9112692e7ec786ee926ae8","modified":1695554976267},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"c3039180ddb2eb17e724b8441e5f93e79859aef7","modified":1695554976267},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1695554976266},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1695554976267},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1695554976269},{"_id":"themes/matery/source/css/matery.css","hash":"0d345a72318fd7aadcb6fcaa6f3abac94b91001c","modified":1695554976269},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1695554976269},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1695554976269},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1695554976269},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1695554976269},{"_id":"themes/matery/source/medias/logo.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1695554976407},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1695554976328},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1695554976389},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1695554976296},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","hash":"6850c3643f81caf79c8be7c454a501f0d3962e14","modified":1695554976296},{"_id":"themes/matery/source/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1695554976296},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1695554976297},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1695554976298},{"_id":"themes/matery/source/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1695554976299},{"_id":"themes/matery/source/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1695554976301},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1695554976301},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1695554976302},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1695554976301},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1695554976303},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1695554976304},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1695554976304},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1695554976304},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1695554976304},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1695554976310},{"_id":"themes/matery/source/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1695554976310},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1695554976312},{"_id":"themes/matery/source/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1695554976312},{"_id":"themes/matery/source/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1695554976313},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1695554976313},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1695554976314},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1695554976313},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1695554976314},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1695554976314},{"_id":"themes/matery/source/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1695554976315},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1695554976317},{"_id":"themes/matery/source/medias/files/cv-en.pdf","hash":"2a62ab3797f8bc8e2e5e04c4950198525c635139","modified":1695554976404},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"61eb27bc4ec65f4f116d34740903fb5af75bf561","modified":1695554976409},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1695554976270},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1695554976270},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1695554976270},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1695554976270},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1695554976270},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1695554976282},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1695554976282},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1695554976283},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1695554976282},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1695554976282},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1695554976283},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1695554976283},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1695554976289},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1695554976289},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1695554976290},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1695554976290},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1695554976291},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1695554976292},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1695554976293},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1695554976293},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1695554976293},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1695554976293},{"_id":"themes/matery/source/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1695554976293},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1695554976294},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1695554976293},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1695554976294},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1695554976408},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1695554976271},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1695554976408},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1695554976408},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1695554976290},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1695554976290},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1695554976291},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1695554976291},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1695554976291},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1695554976291},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1695554976291},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1695554976291},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1695554976293},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1695554976291},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1695554976293},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1695554976291},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1695554976293},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1695554976293},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1695554976294},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1695554976293},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1695554976294},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1695554976264},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1695554976320},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1695554976296},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1695554976297},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1695554976298},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1695554976301},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1695554976302},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1695554976311},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1695554976311},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1695554976312},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1695554976312},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1695554976315},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1695554976315},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1695554976316},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1695554976317},{"_id":"themes/matery/source/medias/files/cv-zh.pdf","hash":"4f58778031b0a0e669e036b16639741e44fc2375","modified":1695554976406},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"9bade255a1918cfb3c3bcefbbbc8f163bf2e19e3","modified":1695554976409},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1695554976283},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1695554976290},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1695554976290},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"f1558f12d96a352e490166d543a8e821dd3bb2bc","modified":1695554976294},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1695554976282},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1695554976282},{"_id":"themes/matery/source/medias/contact.jpg","hash":"7eb0906c0e2be9d96650e3bc01da0dc66167aa85","modified":1695554976327},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1695554976320},{"_id":"themes/matery/source/medias/gzh.jpg","hash":"2ba0d0e95e8a079f6293cc8578c17034b5e6b8cf","modified":1695554976406},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1695554976321},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1695554976327},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1695554976342},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1695554976343},{"_id":"themes/matery/source/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1695554976296},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1695554976305},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1695554976310},{"_id":"themes/matery/source/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1695554976306},{"_id":"themes/matery/source/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1695554976313},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"f63c7c489524ccb5d95e74fcd6618116c58fb305","modified":1695554976289},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1695554976292},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1695554976292},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1695554976295},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1695554976274},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1695554976280},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1695554976342},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1695554976366},{"_id":"themes/matery/source/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1695554976299},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1695554976275},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1695554976324},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1695554976360},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1695554976373},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1695554976368},{"_id":"themes/matery/source/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1695554976379},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1695554976303},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1695554976323},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1695554976326},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1695554976352},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1695554976375},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1695554976408},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1695554976333},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1695554976384},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1695554976393},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1695554976317},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1695554976353},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1695554976356},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1695554976364},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1695554976370},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1695554976377},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1695554976397},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1695554976303},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1695554976350},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1695554976362},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1695554976277},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1695554976331},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1695554976336},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1695554976400},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1695554976288},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1695554976347},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1695554976403},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1695554976389},{"_id":"public/search.xml","hash":"52dae37eb014f8edd2dc1f39615bd405c772f79f","modified":1695717695025},{"_id":"public/404.html","hash":"53834a138247b8a522a810b1a7463c7dad8dfeac","modified":1695717695025},{"_id":"public/archives/index.html","hash":"753d5e82d89729272c749b023f4435dc7c3bed3c","modified":1695717695025},{"_id":"public/categories/index.html","hash":"ae0238bdfcb0af9577021fe567f7f89cf6f92b70","modified":1695717695025},{"_id":"public/tags/index.html","hash":"66bf8ad774539bd8532ee9744cdd8eda8f494038","modified":1695717695025},{"_id":"public/2023/09/24/article-title/index.html","hash":"48dfe02e58820abeb2e22a24eac2b15584df4798","modified":1695717695025},{"_id":"public/2021/07/12/jvm-xi-lie-zhi-shi-dian-zong-jie/index.html","hash":"0485abcff7d147937e9c33c7e0c021ecbff04087","modified":1695717695025},{"_id":"public/2021/07/12/mysql-shu-ju-ku-xi-lie-chi-xu-geng-xin-zhong/index.html","hash":"1e6ecb935bd037e5632560ac9cd4de1ccd73e445","modified":1695717695025},{"_id":"public/2021/07/12/spring-ioc-yuan-ma-qian-xi/index.html","hash":"675376c7f89218cd0e8c6e1da2e3507c13b2f508","modified":1695717695025},{"_id":"public/2021/07/12/maven-cong-ru-men-dao-ru-keng/index.html","hash":"ed689a8d8513f9065f8525a995c30ffaa3fd2aa6","modified":1695717695025},{"_id":"public/2021/07/12/di-gui-de-ji-ben-si-xiang/index.html","hash":"3bff56e9e9bda861da885fa04482ffda03c2d121","modified":1695717695025},{"_id":"public/2021/07/12/x-shu-zhi-he-tu-wen-xiang-jie/index.html","hash":"592f0e6df6099ca11009bbb958c67703f91c563a","modified":1695717695025},{"_id":"public/2021/07/12/lian-biao-suan-fa-ji-jin-tu-wen-xiang-jie-e/index.html","hash":"b871de09e5ab22e57a0aefd74116c8e485574afe","modified":1695717695025},{"_id":"public/2021/07/12/shu-ju-jie-gou-chang-jian-de-ba-da-pai-xu-tu-wen-xiang-jie/index.html","hash":"6991b2c1dac723b48ca87c07ec6bbe5126d2d34a","modified":1695717695025},{"_id":"public/2021/07/12/si-chong-ji-ben-de-shu-ju-jie-gou/index.html","hash":"48187497a6b8a77350ef404decaf25597a949bb1","modified":1695717695025},{"_id":"public/2021/07/12/ji-suan-ji-wang-luo-chuan-shu-ceng/index.html","hash":"50195a53467aa07a9d47f1008fe933363e4b5e23","modified":1695717695025},{"_id":"public/2021/07/12/na-nian-shen-qiu-zai-jiao-shi-lin-chuang-xie-xia-de-hui-bian/index.html","hash":"54e8c6fa2ceca1b288bd364791adbdd256a760fe","modified":1695717695025},{"_id":"public/2021/07/12/ji-suan-ji-wang-luo-ying-yong-ceng/index.html","hash":"e7afdca8234b9090ae500dc0bb9ef2a6032b83f6","modified":1695717695025},{"_id":"public/2021/07/12/ji-suan-ji-wang-luo-gai-shu/index.html","hash":"a303641b12a6905fd6b865f91629a75ce432868d","modified":1695717695025},{"_id":"public/2021/07/12/java-duo-xian-cheng-de-qian-shi-jin-sheng/index.html","hash":"bc94c9b1c0fcce231143103333f1e26ff489d393","modified":1695717695025},{"_id":"public/2021/07/12/ci-pan-yu-wen-jian/index.html","hash":"677ff719d7d960cc07251037c01f9b408e25e6ce","modified":1695717695025},{"_id":"public/2021/07/12/wai-she-yu-wen-jian-xi-tong/index.html","hash":"bfaba69c496d65fa5864584395c7543b15c07da1","modified":1695717695025},{"_id":"public/2021/07/12/xu-ni-nei-cun/index.html","hash":"e21bd21c3c728b434ab0b9fb86dc275a08f86470","modified":1695717695025},{"_id":"public/2021/07/11/jin-cheng-yu-xian-cheng/index.html","hash":"d240754d741b7b16a22540622c4e2693da0199b2","modified":1695717695025},{"_id":"public/2021/07/12/nei-cun-guan-li/index.html","hash":"2ee7b74611038613d64aea23a94f8cd1cc771ee6","modified":1695717695025},{"_id":"public/2021/07/11/cao-zuo-xi-tong-ji-chu/index.html","hash":"fa81a66cded282e1d40e8704f45906b8bb91eb3d","modified":1695717695025},{"_id":"public/categories/数据结构与算法/index.html","hash":"dd0f59ceca23deae2e68879ad8c7ce640cefd0ed","modified":1695717695025},{"_id":"public/categories/敏捷开发/index.html","hash":"80ababb87a0b87f2352e50410ef591bfdc540f7c","modified":1695717695025},{"_id":"public/categories/算法/index.html","hash":"3ca40281c405884c4d3897f218c5e2eeab3d227b","modified":1695717695025},{"_id":"public/categories/后端/index.html","hash":"f76fbefaa4e3395f284836692d77ba64d1d31415","modified":1695717695025},{"_id":"public/categories/计算机基础/index.html","hash":"b0ce4bb1dae700f460aa3e8288b3f8f24a25ebbb","modified":1695717695025},{"_id":"public/categories/数据库/index.html","hash":"62378e9be9f2563813f7f84428bcac1f5b171f43","modified":1695717695025},{"_id":"public/categories/编程语言/index.html","hash":"751b68d2fe70c5f9cc81fa7af36cd740c0ae0cf2","modified":1695717695025},{"_id":"public/index.html","hash":"a015ef7b26a5cd1df735e6ffb821fa720ee1b735","modified":1695717695025},{"_id":"public/page/2/index.html","hash":"94ef13f2e5f36b8c71f429b6ba539dc7e1de47a8","modified":1695717695025},{"_id":"public/archives/page/2/index.html","hash":"c8cce44c57ca827b3936eee17abe0a7015531e74","modified":1695717695025},{"_id":"public/archives/page/3/index.html","hash":"b835594fac64601ddf21a712406e9ed6b9397056","modified":1695717695025},{"_id":"public/archives/2021/index.html","hash":"acbbf188780b2dcee9a17d4544e5f25731ccc040","modified":1695717695025},{"_id":"public/archives/2021/page/2/index.html","hash":"bfdf10f43e345156bff7835adbe9ba1920b390a4","modified":1695717695025},{"_id":"public/archives/2021/page/3/index.html","hash":"0b2e82cd2c51fb80f5bfcca3097e81c7a10972c9","modified":1695717695025},{"_id":"public/archives/2021/07/index.html","hash":"2e5b9faafa61fce071bd4f931b6844b6cf65eae8","modified":1695717695025},{"_id":"public/archives/2021/07/page/2/index.html","hash":"e349e3b1f291a58f3a1b32a9614015b9cb69d52f","modified":1695717695025},{"_id":"public/archives/2021/07/page/3/index.html","hash":"086e054bec7f48b3e2b0fee09809ad6c50b99903","modified":1695717695025},{"_id":"public/archives/2023/index.html","hash":"4321e05e123c8b9abc65e4f5f10892addd8a2071","modified":1695717695025},{"_id":"public/archives/2023/09/index.html","hash":"caad920c6d74799cef8371224136a755e87d83fc","modified":1695717695025},{"_id":"public/tags/JVM/index.html","hash":"51b498701250cbc3d210f3eca2bfc3e9f6b82832","modified":1695717695025},{"_id":"public/tags/Java/index.html","hash":"c5c8e53bfd93dab071e5ca740020e7eb16a8b657","modified":1695717695025},{"_id":"public/tags/Maven/index.html","hash":"e2976e35cf1b8c9d2ea6baed2c2e620bb08c55dc","modified":1695717695025},{"_id":"public/tags/IDEA/index.html","hash":"ff2c93ca722331a72664b97b158bd8073f9e213d","modified":1695717695025},{"_id":"public/tags/spring/index.html","hash":"510d2c61b160edc8e952b49effcc8f14c8239166","modified":1695717695025},{"_id":"public/tags/数组/index.html","hash":"8f1c62d04c9c1f157a8c19f4736aa0f5da2fb027","modified":1695717695025},{"_id":"public/tags/极客时间/index.html","hash":"e2ed8759a3f4514da31c37e37db02d1db5b5e491","modified":1695717695025},{"_id":"public/tags/操作系统/index.html","hash":"ece78222416a4592a5bbb813580e94c0385e1d5d","modified":1695717695025},{"_id":"public/tags/linux0-11/index.html","hash":"6807b90b0b9d5247c4193317696b87f79b44f52b","modified":1695717695025},{"_id":"public/tags/计算机网络/index.html","hash":"4e06169920f374558c1f98a49af0cbd9f8979149","modified":1695717695025},{"_id":"public/tags/递归/index.html","hash":"5de82b2fe51b3b6fa81a1cca250c24043c303df6","modified":1695717695025},{"_id":"public/tags/Mysql/index.html","hash":"77e92ba29a9cc49699753cb45d5618610b30369c","modified":1695717695025},{"_id":"public/tags/数据结构/index.html","hash":"b4ec177644584faf7eeb0e87e89dfba430f50926","modified":1695717695025},{"_id":"public/tags/排序算法/index.html","hash":"738a2987f48e6bc773fc06c4bd7474e050f890d2","modified":1695717695025},{"_id":"public/tags/java/index.html","hash":"75ad19b76cb628d9502356a9778bb69c5907de2a","modified":1695717695025},{"_id":"public/tags/intel8086汇编/index.html","hash":"e7efaf55386df94d4b65584a495856ba82b85a68","modified":1695717695025},{"_id":"public/tags/链表/index.html","hash":"625237b0272dd4cd028ad8a9fb7a78ce1d09b37d","modified":1695717695025},{"_id":"public/tags/并发编程/index.html","hash":"7ed6e2d292345ce64d5833b6c39b631f0a3a2bce","modified":1695717695025},{"_id":"public/tags/抓包/index.html","hash":"98fd17a690e86921bd470fb20d7b391ec6504201","modified":1695717695025},{"_id":"public/tags/通用模式/index.html","hash":"8fda9279dec10ee22d607f7b5e2d07facbe2aad6","modified":1695717695025},{"_id":"public/CNAME","hash":"48303ea8c6eb4e599061afb39bc9b2b70af1c4f5","modified":1695717695025},{"_id":"public/favicon.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1695717695025},{"_id":"public/medias/logo.png","hash":"0f4145b9a712f9662e4fae1b0086ce74cf1f9fc4","modified":1695717695025},{"_id":"public/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1695717695025},{"_id":"public/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1695717695025},{"_id":"public/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1695717695025},{"_id":"public/medias/avatars/avatar.jpg","hash":"6850c3643f81caf79c8be7c454a501f0d3962e14","modified":1695717695025},{"_id":"public/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1695717695025},{"_id":"public/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1695717695025},{"_id":"public/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1695717695025},{"_id":"public/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1695717695025},{"_id":"public/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1695717695025},{"_id":"public/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1695717695025},{"_id":"public/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1695717695025},{"_id":"public/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1695717695025},{"_id":"public/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1695717695025},{"_id":"public/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1695717695025},{"_id":"public/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1695717695025},{"_id":"public/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1695717695025},{"_id":"public/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1695717695025},{"_id":"public/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1695717695025},{"_id":"public/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1695717695025},{"_id":"public/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1695717695025},{"_id":"public/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1695717695025},{"_id":"public/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1695717695025},{"_id":"public/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1695717695025},{"_id":"public/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1695717695025},{"_id":"public/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1695717695025},{"_id":"public/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1695717695025},{"_id":"public/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1695717695025},{"_id":"public/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1695717695025},{"_id":"public/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1695717695025},{"_id":"public/medias/files/cv-en.pdf","hash":"2a62ab3797f8bc8e2e5e04c4950198525c635139","modified":1695717695025},{"_id":"public/medias/reward/wechat.png","hash":"61eb27bc4ec65f4f116d34740903fb5af75bf561","modified":1695717695025},{"_id":"public/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1695717695025},{"_id":"public/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1695717695025},{"_id":"public/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1695717695025},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1695717695025},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1695717695025},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1695717695025},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1695717695025},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1695717695025},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1695717695025},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1695717695025},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1695717695025},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1695717695025},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1695717695025},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1695717695025},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1695717695025},{"_id":"public/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1695717695025},{"_id":"public/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1695717695025},{"_id":"public/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1695717695025},{"_id":"public/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1695717695025},{"_id":"public/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1695717695025},{"_id":"public/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1695717695025},{"_id":"public/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1695717695025},{"_id":"public/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1695717695025},{"_id":"public/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1695717695025},{"_id":"public/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1695717695025},{"_id":"public/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1695717695025},{"_id":"public/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1695717695025},{"_id":"public/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1695717695025},{"_id":"public/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1695717695025},{"_id":"public/medias/files/cv-zh.pdf","hash":"4f58778031b0a0e669e036b16639741e44fc2375","modified":1695717695025},{"_id":"public/medias/reward/alipay.jpg","hash":"9bade255a1918cfb3c3bcefbbbc8f163bf2e19e3","modified":1695717695025},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1695717695025},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1695717695025},{"_id":"public/medias/contact.jpg","hash":"7eb0906c0e2be9d96650e3bc01da0dc66167aa85","modified":1695717695025},{"_id":"public/medias/gzh.jpg","hash":"2ba0d0e95e8a079f6293cc8578c17034b5e6b8cf","modified":1695717695025},{"_id":"public/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1695717695025},{"_id":"public/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1695717695025},{"_id":"public/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1695717695025},{"_id":"public/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1695717695025},{"_id":"public/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1695717695025},{"_id":"public/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1695717695025},{"_id":"public/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1695717695025},{"_id":"public/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1695717695025},{"_id":"public/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1695717695025},{"_id":"public/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1695717695025},{"_id":"public/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1695717695025},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1695717695025},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1695717695025},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1695717695025},{"_id":"public/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1695717695025},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1695717695025},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1695717695025},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1695717695025},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1695717695025},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1695717695025},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1695717695025},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1695717695025},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1695717695025},{"_id":"public/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1695717695025},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1695717695025},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1695717695025},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1695717695025},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1695717695025},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1695717695025},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1695717695025},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1695717695025},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1695717695025},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1695717695025},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1695717695025},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1695717695025},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1695717695025},{"_id":"public/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1695717695025},{"_id":"public/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1695717695025},{"_id":"public/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1695717695025},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1695717695025},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1695717695025},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1695717695025},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1695717695025},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1695717695025},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1695717695025},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1695717695025},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1695717695025},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1695717695025},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1695717695025},{"_id":"public/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1695717695025},{"_id":"public/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1695717695025},{"_id":"public/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1695717695025},{"_id":"public/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1695717695025},{"_id":"public/css/matery.css","hash":"caa63c2c7908e45ebbbea0fbdc72d09b7b6d5b76","modified":1695717695025},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1695717695025},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1695717695025},{"_id":"public/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1695717695025},{"_id":"public/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1695717695025},{"_id":"public/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1695717695025},{"_id":"public/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1695717695025},{"_id":"public/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1695717695025},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1695717695025},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1695717695025},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1695717695025},{"_id":"public/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1695717695025},{"_id":"public/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1695717695025},{"_id":"public/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1695717695025},{"_id":"public/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1695717695025},{"_id":"public/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1695717695025},{"_id":"public/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1695717695025},{"_id":"public/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1695717695025},{"_id":"public/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1695717695025},{"_id":"public/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1695717695025},{"_id":"public/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1695717695025},{"_id":"public/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1695717695025},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1695717695025},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1695717695025},{"_id":"public/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1695717695025},{"_id":"public/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1695717695025},{"_id":"public/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1695717695025},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1695717695025},{"_id":"public/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1695717695025},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1695717695025},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1695717695025},{"_id":"public/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1695717695025},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1695717695025},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1695717695025},{"_id":"public/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1695717695025},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"28bdb33c9eb609c2f30d431df1a4cf8ca70bf841","modified":1695717695025},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1695717695025},{"_id":"public/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1695717695025},{"_id":"public/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1695717695025},{"_id":"public/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1695717695025},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1695717695025}],"Category":[{"name":"后端","_id":"cln02j7ks0004xjccdhtz1adt"},{"name":"敏捷开发","_id":"cln02j7ky000bxjcc0xun6qw1"},{"name":"数据结构与算法","_id":"cln02j7l3000mxjcchp9dean8"},{"name":"计算机基础","_id":"cln02j7l7000sxjccc8la0ghj"},{"name":"算法","_id":"cln02j7lb001bxjcc38u57gfu"},{"name":"数据库","_id":"cln02j7m0001txjcc3kd6buqf"},{"name":"编程语言","_id":"cln02j7mt002lxjcce2s4atci"}],"Data":[],"Page":[{"title":"404","date":"2021-07-07T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2021-07-07 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2023-09-24T09:50:29.841Z","path":"404.html","comments":1,"_id":"cln02j7kj0000xjcc5akx1xyd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"archives","date":"2021-07-07T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2021-07-07 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2023-09-24T09:50:29.844Z","path":"archives/index.html","comments":1,"_id":"cln02j7kq0002xjcccva067ww","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2021-07-27T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-07-27 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2023-09-24T09:50:29.844Z","path":"categories/index.html","comments":1,"_id":"cln02j7ku0006xjcc52f9czpe","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2021-07-07T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-07-07 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2023-09-24T09:50:29.844Z","path":"tags/index.html","comments":1,"_id":"cln02j7kw0008xjccdctf2tpd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JVM系列知识点总结","top":false,"cover":true,"toc":false,"mathjax":true,"date":"2021-07-12T08:41:37.000Z","password":null,"summary":null,"_content":"\n> 基于诸葛老师公开课\n\n笔记大致长这个样子——\n\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:525px; height:245px;\" src=\"https://www.processon.com/embed/60bf39d31efad44afd674f39\"></iframe>\n\n也可直接访问我的ProcessOn链接：\n\n[JVM知识全景图](https://www.processon.com/view/link/60ec0200f346fb6bcd28aadd)\n\n------\n\n> 山高路远，静水深流","source":"_posts/JVM系列知识点总结.md","raw":"---\ntitle: JVM系列知识点总结\ntop: false\ncover: true\ntoc: false\nmathjax: true\ndate: 2021-07-12 16:41:37\npassword:\nsummary:\ncategories: 后端\ntags: \n\t- JVM \n\t- Java\n---\n\n> 基于诸葛老师公开课\n\n笔记大致长这个样子——\n\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:525px; height:245px;\" src=\"https://www.processon.com/embed/60bf39d31efad44afd674f39\"></iframe>\n\n也可直接访问我的ProcessOn链接：\n\n[JVM知识全景图](https://www.processon.com/view/link/60ec0200f346fb6bcd28aadd)\n\n------\n\n> 山高路远，静水深流","slug":"JVM系列知识点总结","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7km0001xjcc3fn14xvp","content":"<blockquote>\n<p>基于诸葛老师公开课</p>\n</blockquote>\n<p>笔记大致长这个样子——</p>\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:525px; height:245px;\" src=\"https://www.processon.com/embed/60bf39d31efad44afd674f39\"></iframe>\n\n<p>也可直接访问我的ProcessOn链接：</p>\n<p><a href=\"https://www.processon.com/view/link/60ec0200f346fb6bcd28aadd\">JVM知识全景图</a></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>基于诸葛老师公开课</p>\n</blockquote>\n<p>笔记大致长这个样子——</p>\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:525px; height:245px;\" src=\"https://www.processon.com/embed/60bf39d31efad44afd674f39\"></iframe>\n\n<p>也可直接访问我的ProcessOn链接：</p>\n<p><a href=\"https://www.processon.com/view/link/60ec0200f346fb6bcd28aadd\">JVM知识全景图</a></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"Maven从入门到入坑","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T08:13:59.000Z","password":null,"summary":null,"_content":"\n# 学习Maven的基础\n\n目前所有的项目项目都在使用Maven，那到底Maven是什么，为什么Maven可以大行其道，它究竟为我们的项目开发带来了怎样的好处呢——\n\n## 为什么要学习Maven\n\n1. 在开发庞大的项目时，使用package的结构来区分复杂的代码结构就显得力不从心了，这时我们需要引入**模块(Module)**的设计理念。而Maven就使用了这一设计理念；\n2. 每个项目下导入重复的jar包，不符合\"write once,only once\"的追求；\n3. 手动导包时可能会导致漏包，版本不一致，导致项目未执行错误；\n\n## Maven是什么\n\nMaven的核心思想——\n\n> Maven的核心思想：约定大于配置，它用于约定java项目架构，并推出了各种各样的模板项目。\n\n## 使用Maven的好处\n\n1. 通俗的说，Maven可以通过对**pom.xml**的配置实现**自动导包**，且可以解决令人头大的jar包冲突，版本冲突，且可以实现一次配置，多次复用的目的；\n2. Maven模块管理的功能使项目结构更加明晰，通过降低模块间的耦合度使项目的再开发变得容易；\n3. 自动生成包含测试的目录结构就很香；\n4. 通常我们的项目在整合时会包括庞杂的代码，配置文件，打包。甚至web工程的话还需要部署到服务器上。而Maven却可以帮我们构建工程，管理jar包，编译运行测试文件，自动打包，生成*报表*。堪称程序员的贴心小棉袄。\n5. 使用Maven构建的项目，导入的jar包只是一个**坐标**。大大减少了打包后的项目大小。\n\n# Maven的使用\n\n了解了Maven的概况，你心动了吗？\n\n接下来我们首先将进行Maven的安装，因为Maven包含构建的功能，这就需要JAVA_HOME的环境变量配置，当我们安装好Maven后，就要考虑jar包如何获取呢，这时就需要引入Maven仓库。另外，Maven是如何使项目结构令人耳目一新的呢，常说的生命周期又是什么？让我们一探究竟——\n\n------\n\n## Maven的安装与配置\n\n![](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810201856834.png)\n\n1. 因为Maven是服务于java语言的，首先需要查看系统是否配置了JAVA_HOME的环境变量，也就是jdk的路径，即java的运行环境；\n\n2. 配置Maven的相关环境变量\n\n   1. 首先Maven支持一键构建的功能，因而需要配置环境变量**PATH**，此外，Maven安装路径(*无中文，无空格的目录下*)**MAVEN_HOME**的说明也必不可少！\n   2. ![image-20200810202557992](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202557992.png)\n\n   ![image-20200810202753425](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202753425.png)\n\n   1. 验证是否配置成功\n\n      键入**mvn  -v**命令查看maven版本，存在则配置成功！！\n\n## Maven仓库\n\n> Maven最为人所知的功能便是**自动导包**。那导的jar包来源于哪里呢？Maven仓库便是存储jar包的地方。\n\n### Maven仓库的分类\n\nMaven仓库分为本地仓库，远程仓库，中央仓库。\n\n- 本地仓库：默认位置为C:\\Users\\zyz\\.m2\\repository(mine)，也可自己指定仓库位置。\n- 远程仓库：又称私服，当本地仓库找不到jar包或者插件，会默认从远程仓库获取，远程仓库可以在互联网上，也可以在局域网(公司)中；\n- 中央仓库：在Maven软件中内置了一个远程仓库的地址，http://repo1.maven.org/maven2，它由Maven团队维护，提供了全面的jar包，其中包含了世界和是哪个大部分流行的开源项目软件。\n\n### Maven仓库的配置\n\n打开MAVE_HOME/conf目录\n\n![image-20200810205434607](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205434607.png)\n\n在settings.xml文件中配置本地仓库位置\n\n![image-20200810205701220](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205701220.png)\n\n### Maven仓库的使用顺序\n\n![image-20200817104957595](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200817104957595.png)\n\n###  全局setting与用户setting\n\nMaven的仓库地址，私服等的配置信息需要在setting.xml中配置，而它的配置又分为全局setting和用户setting。\n\n- 见名知意，用户setting，指的是在用户文件夹下的setting，即：${user.dir} /.m2/settings.xml，它里面的配置主要是个性配置；\n\n- 全局setting，即为Maven安装目录下的setting，如D:\\Maven\\apache-maven-3.6.3\\conf\\settings.xml。它里面的配置包括使用Maven构建的所有项目\n\n  **小结**：Maven会先找用户配置，如果找不到，就使用全局配置。\n\n## Maven的目录结构\n\n- [x] 注：建议将所有的开发放在一个文件夹**develop**中\n\nMaven工程**约定俗成**的目录结构如下图所示——\n\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811000632615.png\" alt=\"image-20200811000632615\" style=\"zoom: 67%;\" />\n\n目录的每一部分都是不可或缺的。\n\n当项目编译之后，会自动生成***target***目录，目录中存放编译后的class字节码文件以及配置文件。\n\n## Maven的常用命令\n\n- mvn clean：清理之前编译得到的文件\n\n- mvn compile：编译主程序\n\n- mvn test-compile：编译测试程序\n\n- mvn test：执行测试\n\n- mvn package：打包\n\n- mvn install：安装\n\n- mvn deploy:部署\n\n  这里只演示compile和install命令——\n\n  执行compile编译命令，编译指将src目录下的java文件编译为class文件，则首先定位到到项目的src目录，再执行mvn  compile命令。\n\n  ![](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003234622.png)\n\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003633190.png\" alt=\"image-20200811003633190\" style=\"zoom:50%;\" />\n\n## Maven的生命周期\n\nMaven对项目的构建分为**三套**相互独立的**生命周期**\n\n1. **Clean Lifecycle** :在进行真正的构建之前进行一些清理工作。\n2. **Default Lifecycle** :构建的核心部分，编译，测试，打包，部署等等。\n3. **Site Lifecycle** :生成项目报告，站点，发布站点。\n\n# Maven的依赖管理\n\nMaven在pom.xml中对依赖进行配置与管理，那么pom.xml中的依赖配置要符合怎样的规范才能从仓库中取得jar包呢，当使用一个jar包时，它所依赖的jar包还需要导入吗？如果不需要，那因为版本引发的冲突问题如何解决呢？我们来一一解惑——\n\n------\n\n\n\n## Maven的坐标\n\n在pom.xml文件中，将可以找到仓库中对应jar位置的规范叫做**坐标**，坐标在<dependencies>标签下定义，并将每一个第三方依赖写在<dependency>标签下，我们首先来看下坐标的结构——\n\n```java\n <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n </dependency>\n```\n\n- groupId:公司，个人的唯一标识符，通常为域名倒写；\n\n- artifactId:项目唯一标识符，即项目名称\n\n- version:项目的版本，一般来说，使用SVN版本控制工具管理版本，因而一个项目有多个版本，版本的标识有RELEASE，SNAPSHOT\n\n  - **RELEASE**：指正式发布的版本\n  - **SNAPSHOT**：表示正在开发的版本，也就是一个版本的**快照**，快照版本，可以理解为它指定了**某个开发进度的副本**，Maven每次构建的时候都会在在仓库中检查新的快照版本。\n\n- **scope**:每个jar包在编译时应用的时期是不同的，因为需要使用scope来指定**依赖范围**。scope有四个常用的取值，分别是compile(编译阶段)，test(测试阶段)，provide(供应阶段),runtime(运行阶段)——\n\n  |     依赖范围      | 编译有效 | 测试有效 | 运行有效 | 打包有效 |       示例        |\n  | :---------------: | :------: | :------: | :------: | :------: | :---------------: |\n  | compile(**默认**) |    √     |    √     |    √     |    √     |    spring-core    |\n  |       test        |    ×     |    √     |    ×     |    ×     |       junit       |\n  |     provided      |    √     |    √     |    √     |    ×     | javax.servlet-api |\n  |      runtime      |    ×     |    √     |    √     |    √     |     JDBC驱动      |\n\n##  依赖冲突\n\n首先来了解冲突是如何产生的呢？\n\n> 当我们首先引入spring-mvc的坐标后，我们发现spring-mvc所依赖的spring-beans的坐标也被引入了进来，这被称为**依赖传递**。这固然减轻了我们逐个导包的繁复，但也由于**版本冲突**导致坐标不可用。\n\n解决依赖冲突的的调解原则有三种——\n\n1. 第一声明者优先：如果两个包的依赖都包括另一个包，但需要的版本不同，这时以先导入的版本为准；\n2. 路径近者优先：也就是说如果先导入某一个包，再导入依赖这个的包的其他包，会以顺序在前的为准；\n3. 锁定版本：在pom.xml中，有一个properties标签，它的作用是锁定版本。它的用法如下——\n\n```java\n<properties>\n        <spring.version>5.0.2.RELEASE</spring.version>\n        <slf4j.version>1.6.6</slf4j.version>\n        <log4j.version>1.2.12</log4j.version>\n        <oracle.version>12.1.0.1</oracle.version>\n        <mybatis.version>3.4.5</mybatis.version>\n        <spring.security.version>5.0.1.RELEASE</spring.security.version>\n</properties>\n```\n\n# 在IDEA环境下，使用Maven构建SSM工程\n\n当开发比较繁琐的项目时，Maven自动导包和一键构建特性的优势可见一斑——\n\n首先，回顾一下开发项目的基本原则\n\n1. 先从**被依赖的，简单的部分**开始；\n2. 搭好**框架**是重中之重！框架中应该包含开发相关配置文件，分层结构等。\n\n接下来我们总结开发流程\n\n1. 新建使用**webapp骨架**的项目；\n2. 在**pom.xm**文件中编写依赖，**applicationContext**文件，**spring-mvc.xml**，**log.properties**文件，导入**db.properties**文件。\n3. 在数据库新建表，创建**pojo实体类**，编写**xml**映射文件，**dao**层，**service**层，**controller**层，**web**层；\n\n![image-20200818233219851](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233219851.png)\n\n2.填写项目\n\n![image-20200818233351689](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233351689.png)\n\n![image-20200818233900433](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233900433.png)\n\n首先编写pom.xml文件,除了这部分有区别外，其他的可以复用\n\n```java\n<groupId>com.zyz</groupId>\n  <artifactId>mavenTest02</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <!--版本锁定-->\n  <properties>\n    <spring.version>5.0.2.RELEASE</spring.version>\n    <slf4j.version>1.6.6</slf4j.version>\n    <log4j.version>1.2.12</log4j.version>\n    <shiro.version>1.2.3</shiro.version>\n    <oracle.version>12.1.0.1</oracle.version>\n    <mybatis.version>3.4.5</mybatis.version>\n    <spring.security.version>5.0.1.RELEASE</spring.security.version>\n  </properties>\n```\n\n在新建的resources目录下统一存放配置文件\n\n![image-20200818234706165](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234706165.png)\n\n![image-20200818234915712](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234915712.png)\n\n到这里，项目的骨架就已经搭好了，这是最基础，但同时也是最重要的一步。接下来具体编写的内容依需求而易，这里就不再赘述。\n\n写到这里，我们已经了解Maven的全貌了吗？当然不是,Maven的进阶功能——继承与聚合同样值得一谈。\n\n## Maven的继承与聚合\n\n在开发中，如果几个互相依赖的类存在重复的代码，我们会将其提取到父类，在模块中，我们使用相同的思想将其提取到父工程中。同时，为了代码的二次开发，模块的设计也应运而生。我们先来分析一下常见的开发结构——\n\n![image-20200819082820315](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200819082820315.png)\n\n### 理解继承和聚合\n\n1. 何为继承？\n\n> 继承是为了消除重复，如果将dao，service，web分开创建独立的工程，则每个工程的pom.xml文件中的内容存在重复。比如，设置编译版本，锁定spring的版本等，可以将这些重复的配置剔除出来在父工程的pon.xml中定义。\n\n2. 何为聚合？  \n\n> 项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如dao,service,web三个工程最终回答一个独立的war运行。\n\n## 补充\n\n### 虚拟路径映射\n\n流程：配置IDEA中的maven，配置tomcat服务器，在context处可选自定义的虚拟路径，最终部署项目。\n\n### 可能出现的问题\n\n| 序号 | 可能出现的问题              | 解决方式                   |\n| ---- | --------------------------- | -------------------------- |\n| 1    | maven3.6.2显示导包错误      | `版本降级`                 |\n| 2    | 每个项目都要重新配置maven   | `配置maven的全局设置`      |\n| 3    | Maven项目中的tomcat无法访问 | `配置，server->deployment` |\n| 4    | 资源导出失败                | `在builder中配置resource`  |\n\n------\n\n> 山高路远，静水深流\n\n","source":"_posts/Maven从入门到入坑.md","raw":"---\ntitle: Maven从入门到入坑\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 16:13:59\npassword:\nsummary:\ncategories: 敏捷开发\ntags: \n\t- Maven\n\t- IDEA\n---\n\n# 学习Maven的基础\n\n目前所有的项目项目都在使用Maven，那到底Maven是什么，为什么Maven可以大行其道，它究竟为我们的项目开发带来了怎样的好处呢——\n\n## 为什么要学习Maven\n\n1. 在开发庞大的项目时，使用package的结构来区分复杂的代码结构就显得力不从心了，这时我们需要引入**模块(Module)**的设计理念。而Maven就使用了这一设计理念；\n2. 每个项目下导入重复的jar包，不符合\"write once,only once\"的追求；\n3. 手动导包时可能会导致漏包，版本不一致，导致项目未执行错误；\n\n## Maven是什么\n\nMaven的核心思想——\n\n> Maven的核心思想：约定大于配置，它用于约定java项目架构，并推出了各种各样的模板项目。\n\n## 使用Maven的好处\n\n1. 通俗的说，Maven可以通过对**pom.xml**的配置实现**自动导包**，且可以解决令人头大的jar包冲突，版本冲突，且可以实现一次配置，多次复用的目的；\n2. Maven模块管理的功能使项目结构更加明晰，通过降低模块间的耦合度使项目的再开发变得容易；\n3. 自动生成包含测试的目录结构就很香；\n4. 通常我们的项目在整合时会包括庞杂的代码，配置文件，打包。甚至web工程的话还需要部署到服务器上。而Maven却可以帮我们构建工程，管理jar包，编译运行测试文件，自动打包，生成*报表*。堪称程序员的贴心小棉袄。\n5. 使用Maven构建的项目，导入的jar包只是一个**坐标**。大大减少了打包后的项目大小。\n\n# Maven的使用\n\n了解了Maven的概况，你心动了吗？\n\n接下来我们首先将进行Maven的安装，因为Maven包含构建的功能，这就需要JAVA_HOME的环境变量配置，当我们安装好Maven后，就要考虑jar包如何获取呢，这时就需要引入Maven仓库。另外，Maven是如何使项目结构令人耳目一新的呢，常说的生命周期又是什么？让我们一探究竟——\n\n------\n\n## Maven的安装与配置\n\n![](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810201856834.png)\n\n1. 因为Maven是服务于java语言的，首先需要查看系统是否配置了JAVA_HOME的环境变量，也就是jdk的路径，即java的运行环境；\n\n2. 配置Maven的相关环境变量\n\n   1. 首先Maven支持一键构建的功能，因而需要配置环境变量**PATH**，此外，Maven安装路径(*无中文，无空格的目录下*)**MAVEN_HOME**的说明也必不可少！\n   2. ![image-20200810202557992](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202557992.png)\n\n   ![image-20200810202753425](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202753425.png)\n\n   1. 验证是否配置成功\n\n      键入**mvn  -v**命令查看maven版本，存在则配置成功！！\n\n## Maven仓库\n\n> Maven最为人所知的功能便是**自动导包**。那导的jar包来源于哪里呢？Maven仓库便是存储jar包的地方。\n\n### Maven仓库的分类\n\nMaven仓库分为本地仓库，远程仓库，中央仓库。\n\n- 本地仓库：默认位置为C:\\Users\\zyz\\.m2\\repository(mine)，也可自己指定仓库位置。\n- 远程仓库：又称私服，当本地仓库找不到jar包或者插件，会默认从远程仓库获取，远程仓库可以在互联网上，也可以在局域网(公司)中；\n- 中央仓库：在Maven软件中内置了一个远程仓库的地址，http://repo1.maven.org/maven2，它由Maven团队维护，提供了全面的jar包，其中包含了世界和是哪个大部分流行的开源项目软件。\n\n### Maven仓库的配置\n\n打开MAVE_HOME/conf目录\n\n![image-20200810205434607](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205434607.png)\n\n在settings.xml文件中配置本地仓库位置\n\n![image-20200810205701220](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205701220.png)\n\n### Maven仓库的使用顺序\n\n![image-20200817104957595](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200817104957595.png)\n\n###  全局setting与用户setting\n\nMaven的仓库地址，私服等的配置信息需要在setting.xml中配置，而它的配置又分为全局setting和用户setting。\n\n- 见名知意，用户setting，指的是在用户文件夹下的setting，即：${user.dir} /.m2/settings.xml，它里面的配置主要是个性配置；\n\n- 全局setting，即为Maven安装目录下的setting，如D:\\Maven\\apache-maven-3.6.3\\conf\\settings.xml。它里面的配置包括使用Maven构建的所有项目\n\n  **小结**：Maven会先找用户配置，如果找不到，就使用全局配置。\n\n## Maven的目录结构\n\n- [x] 注：建议将所有的开发放在一个文件夹**develop**中\n\nMaven工程**约定俗成**的目录结构如下图所示——\n\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811000632615.png\" alt=\"image-20200811000632615\" style=\"zoom: 67%;\" />\n\n目录的每一部分都是不可或缺的。\n\n当项目编译之后，会自动生成***target***目录，目录中存放编译后的class字节码文件以及配置文件。\n\n## Maven的常用命令\n\n- mvn clean：清理之前编译得到的文件\n\n- mvn compile：编译主程序\n\n- mvn test-compile：编译测试程序\n\n- mvn test：执行测试\n\n- mvn package：打包\n\n- mvn install：安装\n\n- mvn deploy:部署\n\n  这里只演示compile和install命令——\n\n  执行compile编译命令，编译指将src目录下的java文件编译为class文件，则首先定位到到项目的src目录，再执行mvn  compile命令。\n\n  ![](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003234622.png)\n\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003633190.png\" alt=\"image-20200811003633190\" style=\"zoom:50%;\" />\n\n## Maven的生命周期\n\nMaven对项目的构建分为**三套**相互独立的**生命周期**\n\n1. **Clean Lifecycle** :在进行真正的构建之前进行一些清理工作。\n2. **Default Lifecycle** :构建的核心部分，编译，测试，打包，部署等等。\n3. **Site Lifecycle** :生成项目报告，站点，发布站点。\n\n# Maven的依赖管理\n\nMaven在pom.xml中对依赖进行配置与管理，那么pom.xml中的依赖配置要符合怎样的规范才能从仓库中取得jar包呢，当使用一个jar包时，它所依赖的jar包还需要导入吗？如果不需要，那因为版本引发的冲突问题如何解决呢？我们来一一解惑——\n\n------\n\n\n\n## Maven的坐标\n\n在pom.xml文件中，将可以找到仓库中对应jar位置的规范叫做**坐标**，坐标在<dependencies>标签下定义，并将每一个第三方依赖写在<dependency>标签下，我们首先来看下坐标的结构——\n\n```java\n <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n </dependency>\n```\n\n- groupId:公司，个人的唯一标识符，通常为域名倒写；\n\n- artifactId:项目唯一标识符，即项目名称\n\n- version:项目的版本，一般来说，使用SVN版本控制工具管理版本，因而一个项目有多个版本，版本的标识有RELEASE，SNAPSHOT\n\n  - **RELEASE**：指正式发布的版本\n  - **SNAPSHOT**：表示正在开发的版本，也就是一个版本的**快照**，快照版本，可以理解为它指定了**某个开发进度的副本**，Maven每次构建的时候都会在在仓库中检查新的快照版本。\n\n- **scope**:每个jar包在编译时应用的时期是不同的，因为需要使用scope来指定**依赖范围**。scope有四个常用的取值，分别是compile(编译阶段)，test(测试阶段)，provide(供应阶段),runtime(运行阶段)——\n\n  |     依赖范围      | 编译有效 | 测试有效 | 运行有效 | 打包有效 |       示例        |\n  | :---------------: | :------: | :------: | :------: | :------: | :---------------: |\n  | compile(**默认**) |    √     |    √     |    √     |    √     |    spring-core    |\n  |       test        |    ×     |    √     |    ×     |    ×     |       junit       |\n  |     provided      |    √     |    √     |    √     |    ×     | javax.servlet-api |\n  |      runtime      |    ×     |    √     |    √     |    √     |     JDBC驱动      |\n\n##  依赖冲突\n\n首先来了解冲突是如何产生的呢？\n\n> 当我们首先引入spring-mvc的坐标后，我们发现spring-mvc所依赖的spring-beans的坐标也被引入了进来，这被称为**依赖传递**。这固然减轻了我们逐个导包的繁复，但也由于**版本冲突**导致坐标不可用。\n\n解决依赖冲突的的调解原则有三种——\n\n1. 第一声明者优先：如果两个包的依赖都包括另一个包，但需要的版本不同，这时以先导入的版本为准；\n2. 路径近者优先：也就是说如果先导入某一个包，再导入依赖这个的包的其他包，会以顺序在前的为准；\n3. 锁定版本：在pom.xml中，有一个properties标签，它的作用是锁定版本。它的用法如下——\n\n```java\n<properties>\n        <spring.version>5.0.2.RELEASE</spring.version>\n        <slf4j.version>1.6.6</slf4j.version>\n        <log4j.version>1.2.12</log4j.version>\n        <oracle.version>12.1.0.1</oracle.version>\n        <mybatis.version>3.4.5</mybatis.version>\n        <spring.security.version>5.0.1.RELEASE</spring.security.version>\n</properties>\n```\n\n# 在IDEA环境下，使用Maven构建SSM工程\n\n当开发比较繁琐的项目时，Maven自动导包和一键构建特性的优势可见一斑——\n\n首先，回顾一下开发项目的基本原则\n\n1. 先从**被依赖的，简单的部分**开始；\n2. 搭好**框架**是重中之重！框架中应该包含开发相关配置文件，分层结构等。\n\n接下来我们总结开发流程\n\n1. 新建使用**webapp骨架**的项目；\n2. 在**pom.xm**文件中编写依赖，**applicationContext**文件，**spring-mvc.xml**，**log.properties**文件，导入**db.properties**文件。\n3. 在数据库新建表，创建**pojo实体类**，编写**xml**映射文件，**dao**层，**service**层，**controller**层，**web**层；\n\n![image-20200818233219851](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233219851.png)\n\n2.填写项目\n\n![image-20200818233351689](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233351689.png)\n\n![image-20200818233900433](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233900433.png)\n\n首先编写pom.xml文件,除了这部分有区别外，其他的可以复用\n\n```java\n<groupId>com.zyz</groupId>\n  <artifactId>mavenTest02</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <!--版本锁定-->\n  <properties>\n    <spring.version>5.0.2.RELEASE</spring.version>\n    <slf4j.version>1.6.6</slf4j.version>\n    <log4j.version>1.2.12</log4j.version>\n    <shiro.version>1.2.3</shiro.version>\n    <oracle.version>12.1.0.1</oracle.version>\n    <mybatis.version>3.4.5</mybatis.version>\n    <spring.security.version>5.0.1.RELEASE</spring.security.version>\n  </properties>\n```\n\n在新建的resources目录下统一存放配置文件\n\n![image-20200818234706165](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234706165.png)\n\n![image-20200818234915712](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234915712.png)\n\n到这里，项目的骨架就已经搭好了，这是最基础，但同时也是最重要的一步。接下来具体编写的内容依需求而易，这里就不再赘述。\n\n写到这里，我们已经了解Maven的全貌了吗？当然不是,Maven的进阶功能——继承与聚合同样值得一谈。\n\n## Maven的继承与聚合\n\n在开发中，如果几个互相依赖的类存在重复的代码，我们会将其提取到父类，在模块中，我们使用相同的思想将其提取到父工程中。同时，为了代码的二次开发，模块的设计也应运而生。我们先来分析一下常见的开发结构——\n\n![image-20200819082820315](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200819082820315.png)\n\n### 理解继承和聚合\n\n1. 何为继承？\n\n> 继承是为了消除重复，如果将dao，service，web分开创建独立的工程，则每个工程的pom.xml文件中的内容存在重复。比如，设置编译版本，锁定spring的版本等，可以将这些重复的配置剔除出来在父工程的pon.xml中定义。\n\n2. 何为聚合？  \n\n> 项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如dao,service,web三个工程最终回答一个独立的war运行。\n\n## 补充\n\n### 虚拟路径映射\n\n流程：配置IDEA中的maven，配置tomcat服务器，在context处可选自定义的虚拟路径，最终部署项目。\n\n### 可能出现的问题\n\n| 序号 | 可能出现的问题              | 解决方式                   |\n| ---- | --------------------------- | -------------------------- |\n| 1    | maven3.6.2显示导包错误      | `版本降级`                 |\n| 2    | 每个项目都要重新配置maven   | `配置maven的全局设置`      |\n| 3    | Maven项目中的tomcat无法访问 | `配置，server->deployment` |\n| 4    | 资源导出失败                | `在builder中配置resource`  |\n\n------\n\n> 山高路远，静水深流\n\n","slug":"Maven从入门到入坑","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7kq0003xjccdu295qdn","content":"<h1 id=\"学习Maven的基础\"><a href=\"#学习Maven的基础\" class=\"headerlink\" title=\"学习Maven的基础\"></a>学习Maven的基础</h1><p>目前所有的项目项目都在使用Maven，那到底Maven是什么，为什么Maven可以大行其道，它究竟为我们的项目开发带来了怎样的好处呢——</p>\n<h2 id=\"为什么要学习Maven\"><a href=\"#为什么要学习Maven\" class=\"headerlink\" title=\"为什么要学习Maven\"></a>为什么要学习Maven</h2><ol>\n<li>在开发庞大的项目时，使用package的结构来区分复杂的代码结构就显得力不从心了，这时我们需要引入**模块(Module)**的设计理念。而Maven就使用了这一设计理念；</li>\n<li>每个项目下导入重复的jar包，不符合”write once,only once”的追求；</li>\n<li>手动导包时可能会导致漏包，版本不一致，导致项目未执行错误；</li>\n</ol>\n<h2 id=\"Maven是什么\"><a href=\"#Maven是什么\" class=\"headerlink\" title=\"Maven是什么\"></a>Maven是什么</h2><p>Maven的核心思想——</p>\n<blockquote>\n<p>Maven的核心思想：约定大于配置，它用于约定java项目架构，并推出了各种各样的模板项目。</p>\n</blockquote>\n<h2 id=\"使用Maven的好处\"><a href=\"#使用Maven的好处\" class=\"headerlink\" title=\"使用Maven的好处\"></a>使用Maven的好处</h2><ol>\n<li>通俗的说，Maven可以通过对<strong>pom.xml</strong>的配置实现<strong>自动导包</strong>，且可以解决令人头大的jar包冲突，版本冲突，且可以实现一次配置，多次复用的目的；</li>\n<li>Maven模块管理的功能使项目结构更加明晰，通过降低模块间的耦合度使项目的再开发变得容易；</li>\n<li>自动生成包含测试的目录结构就很香；</li>\n<li>通常我们的项目在整合时会包括庞杂的代码，配置文件，打包。甚至web工程的话还需要部署到服务器上。而Maven却可以帮我们构建工程，管理jar包，编译运行测试文件，自动打包，生成<em>报表</em>。堪称程序员的贴心小棉袄。</li>\n<li>使用Maven构建的项目，导入的jar包只是一个<strong>坐标</strong>。大大减少了打包后的项目大小。</li>\n</ol>\n<h1 id=\"Maven的使用\"><a href=\"#Maven的使用\" class=\"headerlink\" title=\"Maven的使用\"></a>Maven的使用</h1><p>了解了Maven的概况，你心动了吗？</p>\n<p>接下来我们首先将进行Maven的安装，因为Maven包含构建的功能，这就需要JAVA_HOME的环境变量配置，当我们安装好Maven后，就要考虑jar包如何获取呢，这时就需要引入Maven仓库。另外，Maven是如何使项目结构令人耳目一新的呢，常说的生命周期又是什么？让我们一探究竟——</p>\n<hr>\n<h2 id=\"Maven的安装与配置\"><a href=\"#Maven的安装与配置\" class=\"headerlink\" title=\"Maven的安装与配置\"></a>Maven的安装与配置</h2><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810201856834.png\"></p>\n<ol>\n<li><p>因为Maven是服务于java语言的，首先需要查看系统是否配置了JAVA_HOME的环境变量，也就是jdk的路径，即java的运行环境；</p>\n</li>\n<li><p>配置Maven的相关环境变量</p>\n<ol>\n<li>首先Maven支持一键构建的功能，因而需要配置环境变量<strong>PATH</strong>，此外，Maven安装路径(<em>无中文，无空格的目录下</em>)<strong>MAVEN_HOME</strong>的说明也必不可少！</li>\n<li><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202557992.png\" alt=\"image-20200810202557992\"></li>\n</ol>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202753425.png\" alt=\"image-20200810202753425\"></p>\n<ol>\n<li><p>验证是否配置成功</p>\n<p>键入<strong>mvn  -v</strong>命令查看maven版本，存在则配置成功！！</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Maven仓库\"><a href=\"#Maven仓库\" class=\"headerlink\" title=\"Maven仓库\"></a>Maven仓库</h2><blockquote>\n<p>Maven最为人所知的功能便是<strong>自动导包</strong>。那导的jar包来源于哪里呢？Maven仓库便是存储jar包的地方。</p>\n</blockquote>\n<h3 id=\"Maven仓库的分类\"><a href=\"#Maven仓库的分类\" class=\"headerlink\" title=\"Maven仓库的分类\"></a>Maven仓库的分类</h3><p>Maven仓库分为本地仓库，远程仓库，中央仓库。</p>\n<ul>\n<li>本地仓库：默认位置为C:\\Users\\zyz.m2\\repository(mine)，也可自己指定仓库位置。</li>\n<li>远程仓库：又称私服，当本地仓库找不到jar包或者插件，会默认从远程仓库获取，远程仓库可以在互联网上，也可以在局域网(公司)中；</li>\n<li>中央仓库：在Maven软件中内置了一个远程仓库的地址，<a href=\"http://repo1.maven.org/maven2%EF%BC%8C%E5%AE%83%E7%94%B1Maven%E5%9B%A2%E9%98%9F%E7%BB%B4%E6%8A%A4%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%BA%86%E5%85%A8%E9%9D%A2%E7%9A%84jar%E5%8C%85%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E4%B8%96%E7%95%8C%E5%92%8C%E6%98%AF%E5%93%AA%E4%B8%AA%E5%A4%A7%E9%83%A8%E5%88%86%E6%B5%81%E8%A1%8C%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6%E3%80%82\">http://repo1.maven.org/maven2，它由Maven团队维护，提供了全面的jar包，其中包含了世界和是哪个大部分流行的开源项目软件。</a></li>\n</ul>\n<h3 id=\"Maven仓库的配置\"><a href=\"#Maven仓库的配置\" class=\"headerlink\" title=\"Maven仓库的配置\"></a>Maven仓库的配置</h3><p>打开MAVE_HOME/conf目录</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205434607.png\" alt=\"image-20200810205434607\"></p>\n<p>在settings.xml文件中配置本地仓库位置</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205701220.png\" alt=\"image-20200810205701220\"></p>\n<h3 id=\"Maven仓库的使用顺序\"><a href=\"#Maven仓库的使用顺序\" class=\"headerlink\" title=\"Maven仓库的使用顺序\"></a>Maven仓库的使用顺序</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200817104957595.png\" alt=\"image-20200817104957595\"></p>\n<h3 id=\"全局setting与用户setting\"><a href=\"#全局setting与用户setting\" class=\"headerlink\" title=\"全局setting与用户setting\"></a>全局setting与用户setting</h3><p>Maven的仓库地址，私服等的配置信息需要在setting.xml中配置，而它的配置又分为全局setting和用户setting。</p>\n<ul>\n<li><p>见名知意，用户setting，指的是在用户文件夹下的setting，即：${user.dir} /.m2/settings.xml，它里面的配置主要是个性配置；</p>\n</li>\n<li><p>全局setting，即为Maven安装目录下的setting，如D:\\Maven\\apache-maven-3.6.3\\conf\\settings.xml。它里面的配置包括使用Maven构建的所有项目</p>\n<p><strong>小结</strong>：Maven会先找用户配置，如果找不到，就使用全局配置。</p>\n</li>\n</ul>\n<h2 id=\"Maven的目录结构\"><a href=\"#Maven的目录结构\" class=\"headerlink\" title=\"Maven的目录结构\"></a>Maven的目录结构</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 注：建议将所有的开发放在一个文件夹<strong>develop</strong>中</li>\n</ul>\n<p>Maven工程<strong>约定俗成</strong>的目录结构如下图所示——</p>\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811000632615.png\" alt=\"image-20200811000632615\" style=\"zoom: 67%;\" />\n\n<p>目录的每一部分都是不可或缺的。</p>\n<p>当项目编译之后，会自动生成<em><strong>target</strong></em>目录，目录中存放编译后的class字节码文件以及配置文件。</p>\n<h2 id=\"Maven的常用命令\"><a href=\"#Maven的常用命令\" class=\"headerlink\" title=\"Maven的常用命令\"></a>Maven的常用命令</h2><ul>\n<li><p>mvn clean：清理之前编译得到的文件</p>\n</li>\n<li><p>mvn compile：编译主程序</p>\n</li>\n<li><p>mvn test-compile：编译测试程序</p>\n</li>\n<li><p>mvn test：执行测试</p>\n</li>\n<li><p>mvn package：打包</p>\n</li>\n<li><p>mvn install：安装</p>\n</li>\n<li><p>mvn deploy:部署</p>\n<p>这里只演示compile和install命令——</p>\n<p>执行compile编译命令，编译指将src目录下的java文件编译为class文件，则首先定位到到项目的src目录，再执行mvn  compile命令。</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003234622.png\"></p>\n</li>\n</ul>\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003633190.png\" alt=\"image-20200811003633190\" style=\"zoom:50%;\" />\n\n<h2 id=\"Maven的生命周期\"><a href=\"#Maven的生命周期\" class=\"headerlink\" title=\"Maven的生命周期\"></a>Maven的生命周期</h2><p>Maven对项目的构建分为<strong>三套</strong>相互独立的<strong>生命周期</strong></p>\n<ol>\n<li><strong>Clean Lifecycle</strong> :在进行真正的构建之前进行一些清理工作。</li>\n<li><strong>Default Lifecycle</strong> :构建的核心部分，编译，测试，打包，部署等等。</li>\n<li><strong>Site Lifecycle</strong> :生成项目报告，站点，发布站点。</li>\n</ol>\n<h1 id=\"Maven的依赖管理\"><a href=\"#Maven的依赖管理\" class=\"headerlink\" title=\"Maven的依赖管理\"></a>Maven的依赖管理</h1><p>Maven在pom.xml中对依赖进行配置与管理，那么pom.xml中的依赖配置要符合怎样的规范才能从仓库中取得jar包呢，当使用一个jar包时，它所依赖的jar包还需要导入吗？如果不需要，那因为版本引发的冲突问题如何解决呢？我们来一一解惑——</p>\n<hr>\n<h2 id=\"Maven的坐标\"><a href=\"#Maven的坐标\" class=\"headerlink\" title=\"Maven的坐标\"></a>Maven的坐标</h2><p>在pom.xml文件中，将可以找到仓库中对应jar位置的规范叫做<strong>坐标</strong>，坐标在<dependencies>标签下定义，并将每一个第三方依赖写在<dependency>标签下，我们首先来看下坐标的结构——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>dependency<span class=\"token punctuation\">></span></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>junit<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>junit<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">4.12</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>version<span class=\"token operator\">></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>scope<span class=\"token punctuation\">></span></span>test<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>scope<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependency<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>groupId:公司，个人的唯一标识符，通常为域名倒写；</p>\n</li>\n<li><p>artifactId:项目唯一标识符，即项目名称</p>\n</li>\n<li><p>version:项目的版本，一般来说，使用SVN版本控制工具管理版本，因而一个项目有多个版本，版本的标识有RELEASE，SNAPSHOT</p>\n<ul>\n<li><strong>RELEASE</strong>：指正式发布的版本</li>\n<li><strong>SNAPSHOT</strong>：表示正在开发的版本，也就是一个版本的<strong>快照</strong>，快照版本，可以理解为它指定了<strong>某个开发进度的副本</strong>，Maven每次构建的时候都会在在仓库中检查新的快照版本。</li>\n</ul>\n</li>\n<li><p><strong>scope</strong>:每个jar包在编译时应用的时期是不同的，因为需要使用scope来指定<strong>依赖范围</strong>。scope有四个常用的取值，分别是compile(编译阶段)，test(测试阶段)，provide(供应阶段),runtime(运行阶段)——</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">依赖范围</th>\n<th align=\"center\">编译有效</th>\n<th align=\"center\">测试有效</th>\n<th align=\"center\">运行有效</th>\n<th align=\"center\">打包有效</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">compile(<strong>默认</strong>)</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">spring-core</td>\n</tr>\n<tr>\n<td align=\"center\">test</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">junit</td>\n</tr>\n<tr>\n<td align=\"center\">provided</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">javax.servlet-api</td>\n</tr>\n<tr>\n<td align=\"center\">runtime</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">JDBC驱动</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"依赖冲突\"><a href=\"#依赖冲突\" class=\"headerlink\" title=\"依赖冲突\"></a>依赖冲突</h2><p>首先来了解冲突是如何产生的呢？</p>\n<blockquote>\n<p>当我们首先引入spring-mvc的坐标后，我们发现spring-mvc所依赖的spring-beans的坐标也被引入了进来，这被称为<strong>依赖传递</strong>。这固然减轻了我们逐个导包的繁复，但也由于<strong>版本冲突</strong>导致坐标不可用。</p>\n</blockquote>\n<p>解决依赖冲突的的调解原则有三种——</p>\n<ol>\n<li>第一声明者优先：如果两个包的依赖都包括另一个包，但需要的版本不同，这时以先导入的版本为准；</li>\n<li>路径近者优先：也就是说如果先导入某一个包，再导入依赖这个的包的其他包，会以顺序在前的为准；</li>\n<li>锁定版本：在pom.xml中，有一个properties标签，它的作用是锁定版本。它的用法如下——</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>properties<span class=\"token punctuation\">></span></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.2</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.6</span><span class=\"token number\">.6</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.2</span><span class=\"token number\">.12</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">12.1</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">3.4</span><span class=\"token number\">.5</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.1</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>properties<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"在IDEA环境下，使用Maven构建SSM工程\"><a href=\"#在IDEA环境下，使用Maven构建SSM工程\" class=\"headerlink\" title=\"在IDEA环境下，使用Maven构建SSM工程\"></a>在IDEA环境下，使用Maven构建SSM工程</h1><p>当开发比较繁琐的项目时，Maven自动导包和一键构建特性的优势可见一斑——</p>\n<p>首先，回顾一下开发项目的基本原则</p>\n<ol>\n<li>先从<strong>被依赖的，简单的部分</strong>开始；</li>\n<li>搭好<strong>框架</strong>是重中之重！框架中应该包含开发相关配置文件，分层结构等。</li>\n</ol>\n<p>接下来我们总结开发流程</p>\n<ol>\n<li>新建使用<strong>webapp骨架</strong>的项目；</li>\n<li>在<strong>pom.xm</strong>文件中编写依赖，<strong>applicationContext</strong>文件，<strong>spring-mvc.xml</strong>，<strong>log.properties</strong>文件，导入<strong>db.properties</strong>文件。</li>\n<li>在数据库新建表，创建<strong>pojo实体类</strong>，编写<strong>xml</strong>映射文件，<strong>dao</strong>层，<strong>service</strong>层，<strong>controller</strong>层，<strong>web</strong>层；</li>\n</ol>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233219851.png\" alt=\"image-20200818233219851\"></p>\n<p>2.填写项目</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233351689.png\" alt=\"image-20200818233351689\"></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233900433.png\" alt=\"image-20200818233900433\"></p>\n<p>首先编写pom.xml文件,除了这部分有区别外，其他的可以复用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>com<span class=\"token punctuation\">.</span>zyz<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>mavenTest02<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.0</span><span class=\"token operator\">-</span>SNAPSHOT<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>version<span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>packaging<span class=\"token punctuation\">></span></span>war<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>packaging<span class=\"token operator\">></span>\n\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>版本锁定<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>properties<span class=\"token punctuation\">></span></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.2</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.6</span><span class=\"token number\">.6</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.2</span><span class=\"token number\">.12</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>shiro<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.2</span><span class=\"token number\">.3</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>shiro<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">12.1</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">3.4</span><span class=\"token number\">.5</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.1</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>properties<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在新建的resources目录下统一存放配置文件</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234706165.png\" alt=\"image-20200818234706165\"></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234915712.png\" alt=\"image-20200818234915712\"></p>\n<p>到这里，项目的骨架就已经搭好了，这是最基础，但同时也是最重要的一步。接下来具体编写的内容依需求而易，这里就不再赘述。</p>\n<p>写到这里，我们已经了解Maven的全貌了吗？当然不是,Maven的进阶功能——继承与聚合同样值得一谈。</p>\n<h2 id=\"Maven的继承与聚合\"><a href=\"#Maven的继承与聚合\" class=\"headerlink\" title=\"Maven的继承与聚合\"></a>Maven的继承与聚合</h2><p>在开发中，如果几个互相依赖的类存在重复的代码，我们会将其提取到父类，在模块中，我们使用相同的思想将其提取到父工程中。同时，为了代码的二次开发，模块的设计也应运而生。我们先来分析一下常见的开发结构——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200819082820315.png\" alt=\"image-20200819082820315\"></p>\n<h3 id=\"理解继承和聚合\"><a href=\"#理解继承和聚合\" class=\"headerlink\" title=\"理解继承和聚合\"></a>理解继承和聚合</h3><ol>\n<li>何为继承？</li>\n</ol>\n<blockquote>\n<p>继承是为了消除重复，如果将dao，service，web分开创建独立的工程，则每个工程的pom.xml文件中的内容存在重复。比如，设置编译版本，锁定spring的版本等，可以将这些重复的配置剔除出来在父工程的pon.xml中定义。</p>\n</blockquote>\n<ol start=\"2\">\n<li>何为聚合？  </li>\n</ol>\n<blockquote>\n<p>项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如dao,service,web三个工程最终回答一个独立的war运行。</p>\n</blockquote>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"虚拟路径映射\"><a href=\"#虚拟路径映射\" class=\"headerlink\" title=\"虚拟路径映射\"></a>虚拟路径映射</h3><p>流程：配置IDEA中的maven，配置tomcat服务器，在context处可选自定义的虚拟路径，最终部署项目。</p>\n<h3 id=\"可能出现的问题\"><a href=\"#可能出现的问题\" class=\"headerlink\" title=\"可能出现的问题\"></a>可能出现的问题</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>可能出现的问题</th>\n<th>解决方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>maven3.6.2显示导包错误</td>\n<td><code>版本降级</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td>每个项目都要重新配置maven</td>\n<td><code>配置maven的全局设置</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Maven项目中的tomcat无法访问</td>\n<td><code>配置，server-&gt;deployment</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td>资源导出失败</td>\n<td><code>在builder中配置resource</code></td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"学习Maven的基础\"><a href=\"#学习Maven的基础\" class=\"headerlink\" title=\"学习Maven的基础\"></a>学习Maven的基础</h1><p>目前所有的项目项目都在使用Maven，那到底Maven是什么，为什么Maven可以大行其道，它究竟为我们的项目开发带来了怎样的好处呢——</p>\n<h2 id=\"为什么要学习Maven\"><a href=\"#为什么要学习Maven\" class=\"headerlink\" title=\"为什么要学习Maven\"></a>为什么要学习Maven</h2><ol>\n<li>在开发庞大的项目时，使用package的结构来区分复杂的代码结构就显得力不从心了，这时我们需要引入**模块(Module)**的设计理念。而Maven就使用了这一设计理念；</li>\n<li>每个项目下导入重复的jar包，不符合”write once,only once”的追求；</li>\n<li>手动导包时可能会导致漏包，版本不一致，导致项目未执行错误；</li>\n</ol>\n<h2 id=\"Maven是什么\"><a href=\"#Maven是什么\" class=\"headerlink\" title=\"Maven是什么\"></a>Maven是什么</h2><p>Maven的核心思想——</p>\n<blockquote>\n<p>Maven的核心思想：约定大于配置，它用于约定java项目架构，并推出了各种各样的模板项目。</p>\n</blockquote>\n<h2 id=\"使用Maven的好处\"><a href=\"#使用Maven的好处\" class=\"headerlink\" title=\"使用Maven的好处\"></a>使用Maven的好处</h2><ol>\n<li>通俗的说，Maven可以通过对<strong>pom.xml</strong>的配置实现<strong>自动导包</strong>，且可以解决令人头大的jar包冲突，版本冲突，且可以实现一次配置，多次复用的目的；</li>\n<li>Maven模块管理的功能使项目结构更加明晰，通过降低模块间的耦合度使项目的再开发变得容易；</li>\n<li>自动生成包含测试的目录结构就很香；</li>\n<li>通常我们的项目在整合时会包括庞杂的代码，配置文件，打包。甚至web工程的话还需要部署到服务器上。而Maven却可以帮我们构建工程，管理jar包，编译运行测试文件，自动打包，生成<em>报表</em>。堪称程序员的贴心小棉袄。</li>\n<li>使用Maven构建的项目，导入的jar包只是一个<strong>坐标</strong>。大大减少了打包后的项目大小。</li>\n</ol>\n<h1 id=\"Maven的使用\"><a href=\"#Maven的使用\" class=\"headerlink\" title=\"Maven的使用\"></a>Maven的使用</h1><p>了解了Maven的概况，你心动了吗？</p>\n<p>接下来我们首先将进行Maven的安装，因为Maven包含构建的功能，这就需要JAVA_HOME的环境变量配置，当我们安装好Maven后，就要考虑jar包如何获取呢，这时就需要引入Maven仓库。另外，Maven是如何使项目结构令人耳目一新的呢，常说的生命周期又是什么？让我们一探究竟——</p>\n<hr>\n<h2 id=\"Maven的安装与配置\"><a href=\"#Maven的安装与配置\" class=\"headerlink\" title=\"Maven的安装与配置\"></a>Maven的安装与配置</h2><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810201856834.png\"></p>\n<ol>\n<li><p>因为Maven是服务于java语言的，首先需要查看系统是否配置了JAVA_HOME的环境变量，也就是jdk的路径，即java的运行环境；</p>\n</li>\n<li><p>配置Maven的相关环境变量</p>\n<ol>\n<li>首先Maven支持一键构建的功能，因而需要配置环境变量<strong>PATH</strong>，此外，Maven安装路径(<em>无中文，无空格的目录下</em>)<strong>MAVEN_HOME</strong>的说明也必不可少！</li>\n<li><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202557992.png\" alt=\"image-20200810202557992\"></li>\n</ol>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810202753425.png\" alt=\"image-20200810202753425\"></p>\n<ol>\n<li><p>验证是否配置成功</p>\n<p>键入<strong>mvn  -v</strong>命令查看maven版本，存在则配置成功！！</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Maven仓库\"><a href=\"#Maven仓库\" class=\"headerlink\" title=\"Maven仓库\"></a>Maven仓库</h2><blockquote>\n<p>Maven最为人所知的功能便是<strong>自动导包</strong>。那导的jar包来源于哪里呢？Maven仓库便是存储jar包的地方。</p>\n</blockquote>\n<h3 id=\"Maven仓库的分类\"><a href=\"#Maven仓库的分类\" class=\"headerlink\" title=\"Maven仓库的分类\"></a>Maven仓库的分类</h3><p>Maven仓库分为本地仓库，远程仓库，中央仓库。</p>\n<ul>\n<li>本地仓库：默认位置为C:\\Users\\zyz.m2\\repository(mine)，也可自己指定仓库位置。</li>\n<li>远程仓库：又称私服，当本地仓库找不到jar包或者插件，会默认从远程仓库获取，远程仓库可以在互联网上，也可以在局域网(公司)中；</li>\n<li>中央仓库：在Maven软件中内置了一个远程仓库的地址，<a href=\"http://repo1.maven.org/maven2%EF%BC%8C%E5%AE%83%E7%94%B1Maven%E5%9B%A2%E9%98%9F%E7%BB%B4%E6%8A%A4%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%BA%86%E5%85%A8%E9%9D%A2%E7%9A%84jar%E5%8C%85%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E4%B8%96%E7%95%8C%E5%92%8C%E6%98%AF%E5%93%AA%E4%B8%AA%E5%A4%A7%E9%83%A8%E5%88%86%E6%B5%81%E8%A1%8C%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6%E3%80%82\">http://repo1.maven.org/maven2，它由Maven团队维护，提供了全面的jar包，其中包含了世界和是哪个大部分流行的开源项目软件。</a></li>\n</ul>\n<h3 id=\"Maven仓库的配置\"><a href=\"#Maven仓库的配置\" class=\"headerlink\" title=\"Maven仓库的配置\"></a>Maven仓库的配置</h3><p>打开MAVE_HOME/conf目录</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205434607.png\" alt=\"image-20200810205434607\"></p>\n<p>在settings.xml文件中配置本地仓库位置</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200810205701220.png\" alt=\"image-20200810205701220\"></p>\n<h3 id=\"Maven仓库的使用顺序\"><a href=\"#Maven仓库的使用顺序\" class=\"headerlink\" title=\"Maven仓库的使用顺序\"></a>Maven仓库的使用顺序</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200817104957595.png\" alt=\"image-20200817104957595\"></p>\n<h3 id=\"全局setting与用户setting\"><a href=\"#全局setting与用户setting\" class=\"headerlink\" title=\"全局setting与用户setting\"></a>全局setting与用户setting</h3><p>Maven的仓库地址，私服等的配置信息需要在setting.xml中配置，而它的配置又分为全局setting和用户setting。</p>\n<ul>\n<li><p>见名知意，用户setting，指的是在用户文件夹下的setting，即：${user.dir} /.m2/settings.xml，它里面的配置主要是个性配置；</p>\n</li>\n<li><p>全局setting，即为Maven安装目录下的setting，如D:\\Maven\\apache-maven-3.6.3\\conf\\settings.xml。它里面的配置包括使用Maven构建的所有项目</p>\n<p><strong>小结</strong>：Maven会先找用户配置，如果找不到，就使用全局配置。</p>\n</li>\n</ul>\n<h2 id=\"Maven的目录结构\"><a href=\"#Maven的目录结构\" class=\"headerlink\" title=\"Maven的目录结构\"></a>Maven的目录结构</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 注：建议将所有的开发放在一个文件夹<strong>develop</strong>中</li>\n</ul>\n<p>Maven工程<strong>约定俗成</strong>的目录结构如下图所示——</p>\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811000632615.png\" alt=\"image-20200811000632615\" style=\"zoom: 67%;\" />\n\n<p>目录的每一部分都是不可或缺的。</p>\n<p>当项目编译之后，会自动生成<em><strong>target</strong></em>目录，目录中存放编译后的class字节码文件以及配置文件。</p>\n<h2 id=\"Maven的常用命令\"><a href=\"#Maven的常用命令\" class=\"headerlink\" title=\"Maven的常用命令\"></a>Maven的常用命令</h2><ul>\n<li><p>mvn clean：清理之前编译得到的文件</p>\n</li>\n<li><p>mvn compile：编译主程序</p>\n</li>\n<li><p>mvn test-compile：编译测试程序</p>\n</li>\n<li><p>mvn test：执行测试</p>\n</li>\n<li><p>mvn package：打包</p>\n</li>\n<li><p>mvn install：安装</p>\n</li>\n<li><p>mvn deploy:部署</p>\n<p>这里只演示compile和install命令——</p>\n<p>执行compile编译命令，编译指将src目录下的java文件编译为class文件，则首先定位到到项目的src目录，再执行mvn  compile命令。</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003234622.png\"></p>\n</li>\n</ul>\n<img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200811003633190.png\" alt=\"image-20200811003633190\" style=\"zoom:50%;\" />\n\n<h2 id=\"Maven的生命周期\"><a href=\"#Maven的生命周期\" class=\"headerlink\" title=\"Maven的生命周期\"></a>Maven的生命周期</h2><p>Maven对项目的构建分为<strong>三套</strong>相互独立的<strong>生命周期</strong></p>\n<ol>\n<li><strong>Clean Lifecycle</strong> :在进行真正的构建之前进行一些清理工作。</li>\n<li><strong>Default Lifecycle</strong> :构建的核心部分，编译，测试，打包，部署等等。</li>\n<li><strong>Site Lifecycle</strong> :生成项目报告，站点，发布站点。</li>\n</ol>\n<h1 id=\"Maven的依赖管理\"><a href=\"#Maven的依赖管理\" class=\"headerlink\" title=\"Maven的依赖管理\"></a>Maven的依赖管理</h1><p>Maven在pom.xml中对依赖进行配置与管理，那么pom.xml中的依赖配置要符合怎样的规范才能从仓库中取得jar包呢，当使用一个jar包时，它所依赖的jar包还需要导入吗？如果不需要，那因为版本引发的冲突问题如何解决呢？我们来一一解惑——</p>\n<hr>\n<h2 id=\"Maven的坐标\"><a href=\"#Maven的坐标\" class=\"headerlink\" title=\"Maven的坐标\"></a>Maven的坐标</h2><p>在pom.xml文件中，将可以找到仓库中对应jar位置的规范叫做<strong>坐标</strong>，坐标在<dependencies>标签下定义，并将每一个第三方依赖写在<dependency>标签下，我们首先来看下坐标的结构——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>dependency<span class=\"token punctuation\">></span></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>junit<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>junit<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">4.12</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>version<span class=\"token operator\">></span>\n           <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>scope<span class=\"token punctuation\">></span></span>test<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>scope<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependency<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>groupId:公司，个人的唯一标识符，通常为域名倒写；</p>\n</li>\n<li><p>artifactId:项目唯一标识符，即项目名称</p>\n</li>\n<li><p>version:项目的版本，一般来说，使用SVN版本控制工具管理版本，因而一个项目有多个版本，版本的标识有RELEASE，SNAPSHOT</p>\n<ul>\n<li><strong>RELEASE</strong>：指正式发布的版本</li>\n<li><strong>SNAPSHOT</strong>：表示正在开发的版本，也就是一个版本的<strong>快照</strong>，快照版本，可以理解为它指定了<strong>某个开发进度的副本</strong>，Maven每次构建的时候都会在在仓库中检查新的快照版本。</li>\n</ul>\n</li>\n<li><p><strong>scope</strong>:每个jar包在编译时应用的时期是不同的，因为需要使用scope来指定<strong>依赖范围</strong>。scope有四个常用的取值，分别是compile(编译阶段)，test(测试阶段)，provide(供应阶段),runtime(运行阶段)——</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">依赖范围</th>\n<th align=\"center\">编译有效</th>\n<th align=\"center\">测试有效</th>\n<th align=\"center\">运行有效</th>\n<th align=\"center\">打包有效</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">compile(<strong>默认</strong>)</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">spring-core</td>\n</tr>\n<tr>\n<td align=\"center\">test</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">junit</td>\n</tr>\n<tr>\n<td align=\"center\">provided</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">javax.servlet-api</td>\n</tr>\n<tr>\n<td align=\"center\">runtime</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">JDBC驱动</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"依赖冲突\"><a href=\"#依赖冲突\" class=\"headerlink\" title=\"依赖冲突\"></a>依赖冲突</h2><p>首先来了解冲突是如何产生的呢？</p>\n<blockquote>\n<p>当我们首先引入spring-mvc的坐标后，我们发现spring-mvc所依赖的spring-beans的坐标也被引入了进来，这被称为<strong>依赖传递</strong>。这固然减轻了我们逐个导包的繁复，但也由于<strong>版本冲突</strong>导致坐标不可用。</p>\n</blockquote>\n<p>解决依赖冲突的的调解原则有三种——</p>\n<ol>\n<li>第一声明者优先：如果两个包的依赖都包括另一个包，但需要的版本不同，这时以先导入的版本为准；</li>\n<li>路径近者优先：也就是说如果先导入某一个包，再导入依赖这个的包的其他包，会以顺序在前的为准；</li>\n<li>锁定版本：在pom.xml中，有一个properties标签，它的作用是锁定版本。它的用法如下——</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>properties<span class=\"token punctuation\">></span></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.2</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.6</span><span class=\"token number\">.6</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.2</span><span class=\"token number\">.12</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">12.1</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">3.4</span><span class=\"token number\">.5</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.1</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>properties<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"在IDEA环境下，使用Maven构建SSM工程\"><a href=\"#在IDEA环境下，使用Maven构建SSM工程\" class=\"headerlink\" title=\"在IDEA环境下，使用Maven构建SSM工程\"></a>在IDEA环境下，使用Maven构建SSM工程</h1><p>当开发比较繁琐的项目时，Maven自动导包和一键构建特性的优势可见一斑——</p>\n<p>首先，回顾一下开发项目的基本原则</p>\n<ol>\n<li>先从<strong>被依赖的，简单的部分</strong>开始；</li>\n<li>搭好<strong>框架</strong>是重中之重！框架中应该包含开发相关配置文件，分层结构等。</li>\n</ol>\n<p>接下来我们总结开发流程</p>\n<ol>\n<li>新建使用<strong>webapp骨架</strong>的项目；</li>\n<li>在<strong>pom.xm</strong>文件中编写依赖，<strong>applicationContext</strong>文件，<strong>spring-mvc.xml</strong>，<strong>log.properties</strong>文件，导入<strong>db.properties</strong>文件。</li>\n<li>在数据库新建表，创建<strong>pojo实体类</strong>，编写<strong>xml</strong>映射文件，<strong>dao</strong>层，<strong>service</strong>层，<strong>controller</strong>层，<strong>web</strong>层；</li>\n</ol>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233219851.png\" alt=\"image-20200818233219851\"></p>\n<p>2.填写项目</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233351689.png\" alt=\"image-20200818233351689\"></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818233900433.png\" alt=\"image-20200818233900433\"></p>\n<p>首先编写pom.xml文件,除了这部分有区别外，其他的可以复用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>com<span class=\"token punctuation\">.</span>zyz<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>mavenTest02<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.0</span><span class=\"token operator\">-</span>SNAPSHOT<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>version<span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>packaging<span class=\"token punctuation\">></span></span>war<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>packaging<span class=\"token operator\">></span>\n\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>版本锁定<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n  <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>properties<span class=\"token punctuation\">></span></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.2</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.6</span><span class=\"token number\">.6</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>slf4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.2</span><span class=\"token number\">.12</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>log4j<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>shiro<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">1.2</span><span class=\"token number\">.3</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>shiro<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">12.1</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>oracle<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">3.4</span><span class=\"token number\">.5</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>mybatis<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">5.0</span><span class=\"token number\">.1</span><span class=\"token punctuation\">.</span>RELEASE<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>security<span class=\"token punctuation\">.</span>version<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>properties<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在新建的resources目录下统一存放配置文件</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234706165.png\" alt=\"image-20200818234706165\"></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200818234915712.png\" alt=\"image-20200818234915712\"></p>\n<p>到这里，项目的骨架就已经搭好了，这是最基础，但同时也是最重要的一步。接下来具体编写的内容依需求而易，这里就不再赘述。</p>\n<p>写到这里，我们已经了解Maven的全貌了吗？当然不是,Maven的进阶功能——继承与聚合同样值得一谈。</p>\n<h2 id=\"Maven的继承与聚合\"><a href=\"#Maven的继承与聚合\" class=\"headerlink\" title=\"Maven的继承与聚合\"></a>Maven的继承与聚合</h2><p>在开发中，如果几个互相依赖的类存在重复的代码，我们会将其提取到父类，在模块中，我们使用相同的思想将其提取到父工程中。同时，为了代码的二次开发，模块的设计也应运而生。我们先来分析一下常见的开发结构——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20200819082820315.png\" alt=\"image-20200819082820315\"></p>\n<h3 id=\"理解继承和聚合\"><a href=\"#理解继承和聚合\" class=\"headerlink\" title=\"理解继承和聚合\"></a>理解继承和聚合</h3><ol>\n<li>何为继承？</li>\n</ol>\n<blockquote>\n<p>继承是为了消除重复，如果将dao，service，web分开创建独立的工程，则每个工程的pom.xml文件中的内容存在重复。比如，设置编译版本，锁定spring的版本等，可以将这些重复的配置剔除出来在父工程的pon.xml中定义。</p>\n</blockquote>\n<ol start=\"2\">\n<li>何为聚合？  </li>\n</ol>\n<blockquote>\n<p>项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如dao,service,web三个工程最终回答一个独立的war运行。</p>\n</blockquote>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"虚拟路径映射\"><a href=\"#虚拟路径映射\" class=\"headerlink\" title=\"虚拟路径映射\"></a>虚拟路径映射</h3><p>流程：配置IDEA中的maven，配置tomcat服务器，在context处可选自定义的虚拟路径，最终部署项目。</p>\n<h3 id=\"可能出现的问题\"><a href=\"#可能出现的问题\" class=\"headerlink\" title=\"可能出现的问题\"></a>可能出现的问题</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>可能出现的问题</th>\n<th>解决方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>maven3.6.2显示导包错误</td>\n<td><code>版本降级</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td>每个项目都要重新配置maven</td>\n<td><code>配置maven的全局设置</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Maven项目中的tomcat无法访问</td>\n<td><code>配置，server-&gt;deployment</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td>资源导出失败</td>\n<td><code>在builder中配置resource</code></td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"Spring IOC源码浅析","top":false,"cover":true,"toc":true,"mathjax":true,"date":"2021-07-12T08:18:46.000Z","password":null,"summary":null,"_content":"\n## 一点思考\n\n在开始分析spring IOC的源码之前，我们有必要先理清大致的脉络，而有**三个问题**对脉络的构建至关重要——\n\n1. **从哪里出发**：hello world~ 要想通这一点，我们需要把视角拉回`java web`，不可置否的是javaweb通过servlet组件可以实现一个完整的功能，但对于一个HTTP请求，我们处理的全过程包含`接收请求，处理请求，返回请求`，在这其中只有处理请求的`核心业务逻辑是需要我们去完成`的.\n\n   而接收请求，返回请求是所有业务场景依托的通用部分，它们完成了报文的`解复用，解析，封装`，这里的任何一项留给程序员去做，都足以`让人头皮发麻`。而框架的实现者深知这一点，把最复杂，但也最通用的部分提取了出来。\n\n   > 如果我们想运行任何一个项目，一句简单的helloworld就能像点睛之笔一般让项目枯木逢春。\n\n   转念去想，我们学习任何知识似乎都只需要一句的hello world，看来所有的框架都认为我们不怎么聪明的亚子。。\n\n2. **以什么为参考**：ioc容器的功能是创建并管理对象，所以对象什么时候被创建，什么时候被初始化是核心。\n\n3. **解析的技巧**：让人诟病的框架通常差的千奇百怪，但往往一个优秀的框架在各个方面都无可挑剔，比如`注释，名称`。\n\n   这些**路标**能够指引更高效的前行。\n\n   ------\n\n##  准备工作\n\n我们首先在spring的配置文件中配置了**两个bean对象**：\n\n![image-20210508101816973](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508101816973.png)\n\n并通过简易的helloworld类中**打断点观察源码**的运行轨迹——\n\n![image-20210508102002505](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102002505.png)\n\n如果我们直接运行项目，会在控制台观察到这些信息：\n\n![image-20210508102357843](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102357843.png)\n\n接下来我们为创建IOC容器这一步打断点，看看会发生什么——\n\n## 第一站\n\n> 所有的故事都从这一句代码开始了：ioc = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n\n首先来看debug之后的版面分布：\n\n![image-20210508102839427](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102839427.png)\n\n核心的逻辑都在创建IOC容器的过程中完成，我们F5进去瞅瞅：\n\n![image-20210508103054925](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103054925.png)\n\n显然，这是在做类加载相关的事情，F6继续：\n\n![image-20210508103210061](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103210061.png)\n\n在构造方法中又调用了另一个构造方法，有趣的是不论构造方法怎样重构，最终调用的都是这一句，看来它就是核心啦，贴出来看看——\n\n![image-20210508103417772](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103417772.png)\n\n显然，配置文件的路径被作为一个**String数组**传入，refresh是个布尔值，它是之后的核心，parent就是老生常谈。\n\n接下来解析xml——\n\n![image-20210508103951949](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103951949.png)\n\n这一步无非是框架对于XML文件的解析，XML文件中的信息都是String类型的，显然需要将它们提取出来还原为真实的数据类型。但这不是我们的重点，先过咯：\n\n![image-20210508104315170](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104315170.png)\n\n进入到refresh方法，映入眼帘的是复杂但有迹可循的方法，从这里开始，我们已经揭开了它的第一层面纱，开始第二站\n\n## 第二站\n\nrefresh方法起手就是一个同步锁，这样能够保证IOC容器只会被创建一次，继续——\n\n![image-20210508104811500](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104811500.png)\n\n放过这一句后，控制台打印出了**正在欲刷新ApplicationContext的信息**，不是我们核心关注点，next->\n\n![image-20210508105131661](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105131661.png)\n\n这一步直观的看，**刷新内部bean工厂创建出子类ConfigurableListableBeanFactory**，来看下BeanFactory的顶层设计：\n\n![image-20210508105727464](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105727464.png)\n\n看来ConfigurableListableBeanFactory的地位不高，它的祖爷爷**BeanFactory才是万恶之源**，可以看出，它独有的两个方法一个用于**返回遍历bean名称的迭代器**，一个是不知道有啥用的**冻结配置**(你只读的，我怎么改...)。\n\n当我们放过这句后，控制台表示我有话说：\n\n![image-20210508110312292](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508110312292.png)\n\n也就是说，它实现的是**解析XML配置文件的Bean定义，并加载到一个容器中**那加载到哪里呢？ConfigurableListableBeanFactory？我们一看便知：\n\n![image-20210508111122589](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111122589.png)\n\nIOC容器读取XML中的配置到Bean工厂中以待使用，更具体的说，它`将Bean对象的定义放入了旗下的两个Map`中，徐徐图之：\n\n![image-20210508111658655](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111658655.png)\n\n见名知意，准备Bean工厂，放过后控制台，变量没有任何表示，next->\n\n![image-20210508111908977](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111908977.png)\n\n接下来是这个后置处理器的专场，但控制台，变量并没有发生变化，显然并不核心，我们简要的说明他们的功能——\n\nIOC容器的核心功能是创建并管理Bean对象，但它的功能却不仅包含这个，它有不同类型的bean，它还要支撑框架自身的功能，而后置处理器就是做这个事情的。下一步咯：\n\n![image-20210508112239897](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112239897.png)\n\n初始化消息源？其实这一步是用于支持**国际化功能**的，但它在spring MVC才会一展身手，这里还不是它出场的时机，下一步——\n\n![image-20210508112447315](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112447315.png)\n\n这里**初始化了事件的转化器**，看不懂，也不属于核心，过：\n\n![image-20210508112616745](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112616745.png)\n\n留给子类实现？妙，起码暂时不用我关心了嘿嘿，下一个——\n\n![image-20210508112735726](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112735726.png)\n\n初始化所有不是懒加载(饿汉模式，即**容器启动以后，对象就会被创建**)的**单例对象**。放过试试-》\n\n![image-20210508120936682](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508120936682.png)\n\n这里初始化了所有的单实例bean对象，终于到了最核心的部分，我们的第三步就从这里开始吧——\n\n## 第三步\n\n![image-20210508121322991](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508121322991.png)\n\n值得一提的是，这个方式隶属于`AbstractApplicationContext`,它是`ConfigurableApplicationContext`的实现类，将`ConfigurableListableBeanFactory`(我们刚才创建的Bean工厂)作为参数传入。\n\n在刚开始的部分**初始化类型转换服务**，不是核心部分，继续-》\n\n![image-20210508122420754](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122420754.png)\n\n这一步就是在为解析做准备了，那下一步自然就是需要解析的部分：\n\n![image-20210508122755207](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122755207.png)\n\n由于我们没有需要Autowire的部分，所以这一步可以直接过啦——\n\n![image-20210508122955688](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122955688.png)\n\n继续：\n\n![image-20210508123214114](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508123214114.png)\n\n## 黎明时分\n\n这里比较核心，我们不再截图，上代码：\n\n```java\n@Override\n\tpublic void preInstantiateSingletons() throws BeansException {\n        \t//日志记录\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(\"Pre-instantiating singletons in \" + this);\n\t\t}、\n        \t//从beanDefinitionNames中取得bean名称\n\t\tList<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n        \t//按照xml配置的bean名称创建bean对象\n\t\tfor (String beanName : beanNames) {\n            \t   //获取bean的配置信息\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n            \t    //确认过代码，是我们需要的bean对象\n\t\t\tif (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n                \t\t//显然得到的bean名称是我们希望容器创建的普通bean，而不是factoryBean\n\t\t\t\tif (isFactoryBean(beanName)) {\n\t\t\t\t\tfinal FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\t\tboolean isEagerInit;\n\t\t\t\t\tif (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n\t\t\t\t\t\tisEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>) () ->\n\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory).isEagerInit(),\n\t\t\t\t\t\t\t\tgetAccessControlContext());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisEagerInit = (factory instanceof SmartFactoryBean &&\n\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory).isEagerInit());\n\t\t\t\t\t}\n\t\t\t\t\tif (isEagerInit) {\n\t\t\t\t\t\tgetBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n                \t\t//我神经都蹦一块了，你就给我看这个~\n\t\t\t\telse {\n\t\t\t\t\tgetBean(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Trigger post-initialization callback for all applicable beans...\n\t\tfor (String beanName : beanNames) {\n            \t   //通过名称开始创建对象啦\n\t\t\tObject singletonInstance = getSingleton(beanName);\n\t\t\tif (singletonInstance instanceof SmartInitializingSingleton) {\n\t\t\t\tfinal SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n\t\t\t\tif (System.getSecurityManager() != null) {\n\t\t\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}, getAccessControlContext());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n我们来大致理理思绪：\n\n![image-20210508124603963](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124603963.png)\n\n`根据bean名称获取到bean的配置信息-》从配置信息中判断是否是我们需要的bean对象-》如果是，再判断是工厂Bean还是普通Bean-》普通bean，调用getBean。`\n\n看来最终创建bean对象的就是这个getbean方法咯，F6一手：\n\n![image-20210508124353828](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124353828.png)\n\n一个bean被创建，我们来看看怎样实现的：\n\n![image-20210508124938259](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124938259.png)\n\n进去看看：\n\n![image-20210508125251963](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508125251963.png)\n\n也就是查询缓存咯，因为我们是第一次注册，显然不存在这个Bean，继续：\n\n![image-20210508130650268](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130650268.png)\n\n继续，来到了这：\n\n![image-20210508130939660](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130939660.png)\n\n如果存在依赖的bean，就需要首先先把这个bean创建出来，当前没有，继续：\n\n![image-20210508131336008](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131336008.png)\n\n终于创建bean对象了，拼夕夕的套路也没你深^-^  \n\n![image-20210508131922757](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131922757.png)\n\n创建完成啦，但是流程还没完~\n\n![image-20210508133621893](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133621893.png)\n\n这一步**将创建的singtonObject加入到singletonObjects**这个集合中去，而这个集合又隶属于我们刚才创建的bean工厂`ConfigurableListableBeanFactory`，也就是说我们创建的这个IOC容器是一个多集合的容器，而单例对象容器不过是它的众多集合之一。\n\n![image-20210508133336593](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133336593.png)\n\n到此，容器终于创建了，那我们来获取bean对象试试——\n\n![image-20210508134719909](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134719909.png)\n\n先获取ioc容器，然后调用getbean方法从单实例集合中获取指定名称的bean：\n\n![image-20210508134941817](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134941817.png)\n\n## 终曲\n\n> 简述ApplicationContext与BeanFactory的区别？\n\n从框架设计来看，ApplicationContext是BeanFactory的子接口，BeanFactory是spring框架最底层的接口，它基于最基础，最通用，**最核心的功能创建bean对象**，而ApplicationContext它在BeanFactory的基础上，**更多的关注容器功能的实现**，也就是我们熟识的**IOC,DI,AOP**，再进一步说，**BeanFactory是给ApplicationContext等子接口用的**，而**ApplicationContext直接对接开发人员**，\n\n另外值得一提的是，spring中应用最多的模式即为工厂模式，可以认为我们通过**配置文件，注解来整合成一个制造说明说书**，而底层的工厂帮我们去制造！\n\n------\n\n> 山高路远，静水深流","source":"_posts/Spring-IOC源码浅析.md","raw":"---\ntitle: Spring IOC源码浅析\ntop: false\ncover: true\ntoc: true\nmathjax: true\ndate: 2021-07-12 16:18:46\npassword:\nsummary:\ntags: spring\ncategories: 后端\n---\n\n## 一点思考\n\n在开始分析spring IOC的源码之前，我们有必要先理清大致的脉络，而有**三个问题**对脉络的构建至关重要——\n\n1. **从哪里出发**：hello world~ 要想通这一点，我们需要把视角拉回`java web`，不可置否的是javaweb通过servlet组件可以实现一个完整的功能，但对于一个HTTP请求，我们处理的全过程包含`接收请求，处理请求，返回请求`，在这其中只有处理请求的`核心业务逻辑是需要我们去完成`的.\n\n   而接收请求，返回请求是所有业务场景依托的通用部分，它们完成了报文的`解复用，解析，封装`，这里的任何一项留给程序员去做，都足以`让人头皮发麻`。而框架的实现者深知这一点，把最复杂，但也最通用的部分提取了出来。\n\n   > 如果我们想运行任何一个项目，一句简单的helloworld就能像点睛之笔一般让项目枯木逢春。\n\n   转念去想，我们学习任何知识似乎都只需要一句的hello world，看来所有的框架都认为我们不怎么聪明的亚子。。\n\n2. **以什么为参考**：ioc容器的功能是创建并管理对象，所以对象什么时候被创建，什么时候被初始化是核心。\n\n3. **解析的技巧**：让人诟病的框架通常差的千奇百怪，但往往一个优秀的框架在各个方面都无可挑剔，比如`注释，名称`。\n\n   这些**路标**能够指引更高效的前行。\n\n   ------\n\n##  准备工作\n\n我们首先在spring的配置文件中配置了**两个bean对象**：\n\n![image-20210508101816973](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508101816973.png)\n\n并通过简易的helloworld类中**打断点观察源码**的运行轨迹——\n\n![image-20210508102002505](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102002505.png)\n\n如果我们直接运行项目，会在控制台观察到这些信息：\n\n![image-20210508102357843](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102357843.png)\n\n接下来我们为创建IOC容器这一步打断点，看看会发生什么——\n\n## 第一站\n\n> 所有的故事都从这一句代码开始了：ioc = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n\n首先来看debug之后的版面分布：\n\n![image-20210508102839427](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102839427.png)\n\n核心的逻辑都在创建IOC容器的过程中完成，我们F5进去瞅瞅：\n\n![image-20210508103054925](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103054925.png)\n\n显然，这是在做类加载相关的事情，F6继续：\n\n![image-20210508103210061](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103210061.png)\n\n在构造方法中又调用了另一个构造方法，有趣的是不论构造方法怎样重构，最终调用的都是这一句，看来它就是核心啦，贴出来看看——\n\n![image-20210508103417772](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103417772.png)\n\n显然，配置文件的路径被作为一个**String数组**传入，refresh是个布尔值，它是之后的核心，parent就是老生常谈。\n\n接下来解析xml——\n\n![image-20210508103951949](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103951949.png)\n\n这一步无非是框架对于XML文件的解析，XML文件中的信息都是String类型的，显然需要将它们提取出来还原为真实的数据类型。但这不是我们的重点，先过咯：\n\n![image-20210508104315170](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104315170.png)\n\n进入到refresh方法，映入眼帘的是复杂但有迹可循的方法，从这里开始，我们已经揭开了它的第一层面纱，开始第二站\n\n## 第二站\n\nrefresh方法起手就是一个同步锁，这样能够保证IOC容器只会被创建一次，继续——\n\n![image-20210508104811500](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104811500.png)\n\n放过这一句后，控制台打印出了**正在欲刷新ApplicationContext的信息**，不是我们核心关注点，next->\n\n![image-20210508105131661](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105131661.png)\n\n这一步直观的看，**刷新内部bean工厂创建出子类ConfigurableListableBeanFactory**，来看下BeanFactory的顶层设计：\n\n![image-20210508105727464](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105727464.png)\n\n看来ConfigurableListableBeanFactory的地位不高，它的祖爷爷**BeanFactory才是万恶之源**，可以看出，它独有的两个方法一个用于**返回遍历bean名称的迭代器**，一个是不知道有啥用的**冻结配置**(你只读的，我怎么改...)。\n\n当我们放过这句后，控制台表示我有话说：\n\n![image-20210508110312292](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508110312292.png)\n\n也就是说，它实现的是**解析XML配置文件的Bean定义，并加载到一个容器中**那加载到哪里呢？ConfigurableListableBeanFactory？我们一看便知：\n\n![image-20210508111122589](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111122589.png)\n\nIOC容器读取XML中的配置到Bean工厂中以待使用，更具体的说，它`将Bean对象的定义放入了旗下的两个Map`中，徐徐图之：\n\n![image-20210508111658655](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111658655.png)\n\n见名知意，准备Bean工厂，放过后控制台，变量没有任何表示，next->\n\n![image-20210508111908977](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111908977.png)\n\n接下来是这个后置处理器的专场，但控制台，变量并没有发生变化，显然并不核心，我们简要的说明他们的功能——\n\nIOC容器的核心功能是创建并管理Bean对象，但它的功能却不仅包含这个，它有不同类型的bean，它还要支撑框架自身的功能，而后置处理器就是做这个事情的。下一步咯：\n\n![image-20210508112239897](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112239897.png)\n\n初始化消息源？其实这一步是用于支持**国际化功能**的，但它在spring MVC才会一展身手，这里还不是它出场的时机，下一步——\n\n![image-20210508112447315](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112447315.png)\n\n这里**初始化了事件的转化器**，看不懂，也不属于核心，过：\n\n![image-20210508112616745](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112616745.png)\n\n留给子类实现？妙，起码暂时不用我关心了嘿嘿，下一个——\n\n![image-20210508112735726](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112735726.png)\n\n初始化所有不是懒加载(饿汉模式，即**容器启动以后，对象就会被创建**)的**单例对象**。放过试试-》\n\n![image-20210508120936682](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508120936682.png)\n\n这里初始化了所有的单实例bean对象，终于到了最核心的部分，我们的第三步就从这里开始吧——\n\n## 第三步\n\n![image-20210508121322991](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508121322991.png)\n\n值得一提的是，这个方式隶属于`AbstractApplicationContext`,它是`ConfigurableApplicationContext`的实现类，将`ConfigurableListableBeanFactory`(我们刚才创建的Bean工厂)作为参数传入。\n\n在刚开始的部分**初始化类型转换服务**，不是核心部分，继续-》\n\n![image-20210508122420754](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122420754.png)\n\n这一步就是在为解析做准备了，那下一步自然就是需要解析的部分：\n\n![image-20210508122755207](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122755207.png)\n\n由于我们没有需要Autowire的部分，所以这一步可以直接过啦——\n\n![image-20210508122955688](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122955688.png)\n\n继续：\n\n![image-20210508123214114](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508123214114.png)\n\n## 黎明时分\n\n这里比较核心，我们不再截图，上代码：\n\n```java\n@Override\n\tpublic void preInstantiateSingletons() throws BeansException {\n        \t//日志记录\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(\"Pre-instantiating singletons in \" + this);\n\t\t}、\n        \t//从beanDefinitionNames中取得bean名称\n\t\tList<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n        \t//按照xml配置的bean名称创建bean对象\n\t\tfor (String beanName : beanNames) {\n            \t   //获取bean的配置信息\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n            \t    //确认过代码，是我们需要的bean对象\n\t\t\tif (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n                \t\t//显然得到的bean名称是我们希望容器创建的普通bean，而不是factoryBean\n\t\t\t\tif (isFactoryBean(beanName)) {\n\t\t\t\t\tfinal FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\t\tboolean isEagerInit;\n\t\t\t\t\tif (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n\t\t\t\t\t\tisEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>) () ->\n\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory).isEagerInit(),\n\t\t\t\t\t\t\t\tgetAccessControlContext());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisEagerInit = (factory instanceof SmartFactoryBean &&\n\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory).isEagerInit());\n\t\t\t\t\t}\n\t\t\t\t\tif (isEagerInit) {\n\t\t\t\t\t\tgetBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n                \t\t//我神经都蹦一块了，你就给我看这个~\n\t\t\t\telse {\n\t\t\t\t\tgetBean(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Trigger post-initialization callback for all applicable beans...\n\t\tfor (String beanName : beanNames) {\n            \t   //通过名称开始创建对象啦\n\t\t\tObject singletonInstance = getSingleton(beanName);\n\t\t\tif (singletonInstance instanceof SmartInitializingSingleton) {\n\t\t\t\tfinal SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n\t\t\t\tif (System.getSecurityManager() != null) {\n\t\t\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}, getAccessControlContext());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n我们来大致理理思绪：\n\n![image-20210508124603963](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124603963.png)\n\n`根据bean名称获取到bean的配置信息-》从配置信息中判断是否是我们需要的bean对象-》如果是，再判断是工厂Bean还是普通Bean-》普通bean，调用getBean。`\n\n看来最终创建bean对象的就是这个getbean方法咯，F6一手：\n\n![image-20210508124353828](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124353828.png)\n\n一个bean被创建，我们来看看怎样实现的：\n\n![image-20210508124938259](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124938259.png)\n\n进去看看：\n\n![image-20210508125251963](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508125251963.png)\n\n也就是查询缓存咯，因为我们是第一次注册，显然不存在这个Bean，继续：\n\n![image-20210508130650268](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130650268.png)\n\n继续，来到了这：\n\n![image-20210508130939660](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130939660.png)\n\n如果存在依赖的bean，就需要首先先把这个bean创建出来，当前没有，继续：\n\n![image-20210508131336008](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131336008.png)\n\n终于创建bean对象了，拼夕夕的套路也没你深^-^  \n\n![image-20210508131922757](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131922757.png)\n\n创建完成啦，但是流程还没完~\n\n![image-20210508133621893](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133621893.png)\n\n这一步**将创建的singtonObject加入到singletonObjects**这个集合中去，而这个集合又隶属于我们刚才创建的bean工厂`ConfigurableListableBeanFactory`，也就是说我们创建的这个IOC容器是一个多集合的容器，而单例对象容器不过是它的众多集合之一。\n\n![image-20210508133336593](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133336593.png)\n\n到此，容器终于创建了，那我们来获取bean对象试试——\n\n![image-20210508134719909](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134719909.png)\n\n先获取ioc容器，然后调用getbean方法从单实例集合中获取指定名称的bean：\n\n![image-20210508134941817](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134941817.png)\n\n## 终曲\n\n> 简述ApplicationContext与BeanFactory的区别？\n\n从框架设计来看，ApplicationContext是BeanFactory的子接口，BeanFactory是spring框架最底层的接口，它基于最基础，最通用，**最核心的功能创建bean对象**，而ApplicationContext它在BeanFactory的基础上，**更多的关注容器功能的实现**，也就是我们熟识的**IOC,DI,AOP**，再进一步说，**BeanFactory是给ApplicationContext等子接口用的**，而**ApplicationContext直接对接开发人员**，\n\n另外值得一提的是，spring中应用最多的模式即为工厂模式，可以认为我们通过**配置文件，注解来整合成一个制造说明说书**，而底层的工厂帮我们去制造！\n\n------\n\n> 山高路远，静水深流","slug":"Spring-IOC源码浅析","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7kv0007xjccbvrf83bs","content":"<h2 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h2><p>在开始分析spring IOC的源码之前，我们有必要先理清大致的脉络，而有<strong>三个问题</strong>对脉络的构建至关重要——</p>\n<ol>\n<li><p><strong>从哪里出发</strong>：hello world~ 要想通这一点，我们需要把视角拉回<code>java web</code>，不可置否的是javaweb通过servlet组件可以实现一个完整的功能，但对于一个HTTP请求，我们处理的全过程包含<code>接收请求，处理请求，返回请求</code>，在这其中只有处理请求的<code>核心业务逻辑是需要我们去完成</code>的.</p>\n<p>而接收请求，返回请求是所有业务场景依托的通用部分，它们完成了报文的<code>解复用，解析，封装</code>，这里的任何一项留给程序员去做，都足以<code>让人头皮发麻</code>。而框架的实现者深知这一点，把最复杂，但也最通用的部分提取了出来。</p>\n<blockquote>\n<p>如果我们想运行任何一个项目，一句简单的helloworld就能像点睛之笔一般让项目枯木逢春。</p>\n</blockquote>\n<p>转念去想，我们学习任何知识似乎都只需要一句的hello world，看来所有的框架都认为我们不怎么聪明的亚子。。</p>\n</li>\n<li><p><strong>以什么为参考</strong>：ioc容器的功能是创建并管理对象，所以对象什么时候被创建，什么时候被初始化是核心。</p>\n</li>\n<li><p><strong>解析的技巧</strong>：让人诟病的框架通常差的千奇百怪，但往往一个优秀的框架在各个方面都无可挑剔，比如<code>注释，名称</code>。</p>\n<p>这些<strong>路标</strong>能够指引更高效的前行。</p>\n<hr>\n</li>\n</ol>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>我们首先在spring的配置文件中配置了<strong>两个bean对象</strong>：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508101816973.png\" alt=\"image-20210508101816973\"></p>\n<p>并通过简易的helloworld类中<strong>打断点观察源码</strong>的运行轨迹——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102002505.png\" alt=\"image-20210508102002505\"></p>\n<p>如果我们直接运行项目，会在控制台观察到这些信息：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102357843.png\" alt=\"image-20210508102357843\"></p>\n<p>接下来我们为创建IOC容器这一步打断点，看看会发生什么——</p>\n<h2 id=\"第一站\"><a href=\"#第一站\" class=\"headerlink\" title=\"第一站\"></a>第一站</h2><blockquote>\n<p>所有的故事都从这一句代码开始了：ioc = new ClassPathXmlApplicationContext(“classpath:applicationContext.xml”);</p>\n</blockquote>\n<p>首先来看debug之后的版面分布：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102839427.png\" alt=\"image-20210508102839427\"></p>\n<p>核心的逻辑都在创建IOC容器的过程中完成，我们F5进去瞅瞅：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103054925.png\" alt=\"image-20210508103054925\"></p>\n<p>显然，这是在做类加载相关的事情，F6继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103210061.png\" alt=\"image-20210508103210061\"></p>\n<p>在构造方法中又调用了另一个构造方法，有趣的是不论构造方法怎样重构，最终调用的都是这一句，看来它就是核心啦，贴出来看看——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103417772.png\" alt=\"image-20210508103417772\"></p>\n<p>显然，配置文件的路径被作为一个<strong>String数组</strong>传入，refresh是个布尔值，它是之后的核心，parent就是老生常谈。</p>\n<p>接下来解析xml——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103951949.png\" alt=\"image-20210508103951949\"></p>\n<p>这一步无非是框架对于XML文件的解析，XML文件中的信息都是String类型的，显然需要将它们提取出来还原为真实的数据类型。但这不是我们的重点，先过咯：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104315170.png\" alt=\"image-20210508104315170\"></p>\n<p>进入到refresh方法，映入眼帘的是复杂但有迹可循的方法，从这里开始，我们已经揭开了它的第一层面纱，开始第二站</p>\n<h2 id=\"第二站\"><a href=\"#第二站\" class=\"headerlink\" title=\"第二站\"></a>第二站</h2><p>refresh方法起手就是一个同步锁，这样能够保证IOC容器只会被创建一次，继续——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104811500.png\" alt=\"image-20210508104811500\"></p>\n<p>放过这一句后，控制台打印出了<strong>正在欲刷新ApplicationContext的信息</strong>，不是我们核心关注点，next-&gt;</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105131661.png\" alt=\"image-20210508105131661\"></p>\n<p>这一步直观的看，<strong>刷新内部bean工厂创建出子类ConfigurableListableBeanFactory</strong>，来看下BeanFactory的顶层设计：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105727464.png\" alt=\"image-20210508105727464\"></p>\n<p>看来ConfigurableListableBeanFactory的地位不高，它的祖爷爷<strong>BeanFactory才是万恶之源</strong>，可以看出，它独有的两个方法一个用于<strong>返回遍历bean名称的迭代器</strong>，一个是不知道有啥用的<strong>冻结配置</strong>(你只读的，我怎么改…)。</p>\n<p>当我们放过这句后，控制台表示我有话说：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508110312292.png\" alt=\"image-20210508110312292\"></p>\n<p>也就是说，它实现的是<strong>解析XML配置文件的Bean定义，并加载到一个容器中</strong>那加载到哪里呢？ConfigurableListableBeanFactory？我们一看便知：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111122589.png\" alt=\"image-20210508111122589\"></p>\n<p>IOC容器读取XML中的配置到Bean工厂中以待使用，更具体的说，它<code>将Bean对象的定义放入了旗下的两个Map</code>中，徐徐图之：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111658655.png\" alt=\"image-20210508111658655\"></p>\n<p>见名知意，准备Bean工厂，放过后控制台，变量没有任何表示，next-&gt;</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111908977.png\" alt=\"image-20210508111908977\"></p>\n<p>接下来是这个后置处理器的专场，但控制台，变量并没有发生变化，显然并不核心，我们简要的说明他们的功能——</p>\n<p>IOC容器的核心功能是创建并管理Bean对象，但它的功能却不仅包含这个，它有不同类型的bean，它还要支撑框架自身的功能，而后置处理器就是做这个事情的。下一步咯：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112239897.png\" alt=\"image-20210508112239897\"></p>\n<p>初始化消息源？其实这一步是用于支持<strong>国际化功能</strong>的，但它在spring MVC才会一展身手，这里还不是它出场的时机，下一步——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112447315.png\" alt=\"image-20210508112447315\"></p>\n<p>这里<strong>初始化了事件的转化器</strong>，看不懂，也不属于核心，过：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112616745.png\" alt=\"image-20210508112616745\"></p>\n<p>留给子类实现？妙，起码暂时不用我关心了嘿嘿，下一个——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112735726.png\" alt=\"image-20210508112735726\"></p>\n<p>初始化所有不是懒加载(饿汉模式，即<strong>容器启动以后，对象就会被创建</strong>)的<strong>单例对象</strong>。放过试试-》</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508120936682.png\" alt=\"image-20210508120936682\"></p>\n<p>这里初始化了所有的单实例bean对象，终于到了最核心的部分，我们的第三步就从这里开始吧——</p>\n<h2 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h2><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508121322991.png\" alt=\"image-20210508121322991\"></p>\n<p>值得一提的是，这个方式隶属于<code>AbstractApplicationContext</code>,它是<code>ConfigurableApplicationContext</code>的实现类，将<code>ConfigurableListableBeanFactory</code>(我们刚才创建的Bean工厂)作为参数传入。</p>\n<p>在刚开始的部分<strong>初始化类型转换服务</strong>，不是核心部分，继续-》</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122420754.png\" alt=\"image-20210508122420754\"></p>\n<p>这一步就是在为解析做准备了，那下一步自然就是需要解析的部分：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122755207.png\" alt=\"image-20210508122755207\"></p>\n<p>由于我们没有需要Autowire的部分，所以这一步可以直接过啦——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122955688.png\" alt=\"image-20210508122955688\"></p>\n<p>继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508123214114.png\" alt=\"image-20210508123214114\"></p>\n<h2 id=\"黎明时分\"><a href=\"#黎明时分\" class=\"headerlink\" title=\"黎明时分\"></a>黎明时分</h2><p>这里比较核心，我们不再截图，上代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">preInstantiateSingletons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span> <span class=\"token punctuation\">&#123;</span>\n        \t<span class=\"token comment\">//日志记录</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">isDebugEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Pre-instantiating singletons in \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>、\n        \t<span class=\"token comment\">//从beanDefinitionNames中取得bean名称</span>\n\t\t<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> beanNames <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beanDefinitionNames<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        \t<span class=\"token comment\">//按照xml配置的bean名称创建bean对象</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName <span class=\"token operator\">:</span> beanNames<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            \t   <span class=\"token comment\">//获取bean的配置信息</span>\n\t\t\t<span class=\"token class-name\">RootBeanDefinition</span> bd <span class=\"token operator\">=</span> <span class=\"token function\">getMergedLocalBeanDefinition</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            \t    <span class=\"token comment\">//确认过代码，是我们需要的bean对象</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>bd<span class=\"token punctuation\">.</span><span class=\"token function\">isAbstract</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> bd<span class=\"token punctuation\">.</span><span class=\"token function\">isSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>bd<span class=\"token punctuation\">.</span><span class=\"token function\">isLazyInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                \t\t<span class=\"token comment\">//显然得到的bean名称是我们希望容器创建的普通bean，而不是factoryBean</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isFactoryBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t<span class=\"token keyword\">final</span> <span class=\"token class-name\">FactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> factory <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>FACTORY_BEAN_PREFIX <span class=\"token operator\">+</span> beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token keyword\">boolean</span> isEagerInit<span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSecurityManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> factory <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartFactoryBean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\tisEagerInit <span class=\"token operator\">=</span> <span class=\"token class-name\">AccessController</span><span class=\"token punctuation\">.</span><span class=\"token function\">doPrivileged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PrivilegedAction</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span>\n\t\t\t\t\t\t\t\t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SmartFactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEagerInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t\t<span class=\"token function\">getAccessControlContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\tisEagerInit <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>factory <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartFactoryBean</span> <span class=\"token operator\">&amp;&amp;</span>\n\t\t\t\t\t\t\t\t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SmartFactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEagerInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isEagerInit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\t<span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n                \t\t<span class=\"token comment\">//我神经都蹦一块了，你就给我看这个~</span>\n\t\t\t\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t<span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\n\t\t<span class=\"token comment\">// Trigger post-initialization callback for all applicable beans...</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName <span class=\"token operator\">:</span> beanNames<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            \t   <span class=\"token comment\">//通过名称开始创建对象啦</span>\n\t\t\t<span class=\"token class-name\">Object</span> singletonInstance <span class=\"token operator\">=</span> <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singletonInstance <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartInitializingSingleton</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t<span class=\"token keyword\">final</span> <span class=\"token class-name\">SmartInitializingSingleton</span> smartSingleton <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SmartInitializingSingleton</span><span class=\"token punctuation\">)</span> singletonInstance<span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSecurityManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t<span class=\"token class-name\">AccessController</span><span class=\"token punctuation\">.</span><span class=\"token function\">doPrivileged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PrivilegedAction</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\tsmartSingleton<span class=\"token punctuation\">.</span><span class=\"token function\">afterSingletonsInstantiated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getAccessControlContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\tsmartSingleton<span class=\"token punctuation\">.</span><span class=\"token function\">afterSingletonsInstantiated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们来大致理理思绪：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124603963.png\" alt=\"image-20210508124603963\"></p>\n<p><code>根据bean名称获取到bean的配置信息-》从配置信息中判断是否是我们需要的bean对象-》如果是，再判断是工厂Bean还是普通Bean-》普通bean，调用getBean。</code></p>\n<p>看来最终创建bean对象的就是这个getbean方法咯，F6一手：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124353828.png\" alt=\"image-20210508124353828\"></p>\n<p>一个bean被创建，我们来看看怎样实现的：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124938259.png\" alt=\"image-20210508124938259\"></p>\n<p>进去看看：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508125251963.png\" alt=\"image-20210508125251963\"></p>\n<p>也就是查询缓存咯，因为我们是第一次注册，显然不存在这个Bean，继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130650268.png\" alt=\"image-20210508130650268\"></p>\n<p>继续，来到了这：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130939660.png\" alt=\"image-20210508130939660\"></p>\n<p>如果存在依赖的bean，就需要首先先把这个bean创建出来，当前没有，继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131336008.png\" alt=\"image-20210508131336008\"></p>\n<p>终于创建bean对象了，拼夕夕的套路也没你深^-^  </p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131922757.png\" alt=\"image-20210508131922757\"></p>\n<p>创建完成啦，但是流程还没完~</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133621893.png\" alt=\"image-20210508133621893\"></p>\n<p>这一步<strong>将创建的singtonObject加入到singletonObjects</strong>这个集合中去，而这个集合又隶属于我们刚才创建的bean工厂<code>ConfigurableListableBeanFactory</code>，也就是说我们创建的这个IOC容器是一个多集合的容器，而单例对象容器不过是它的众多集合之一。</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133336593.png\" alt=\"image-20210508133336593\"></p>\n<p>到此，容器终于创建了，那我们来获取bean对象试试——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134719909.png\" alt=\"image-20210508134719909\"></p>\n<p>先获取ioc容器，然后调用getbean方法从单实例集合中获取指定名称的bean：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134941817.png\" alt=\"image-20210508134941817\"></p>\n<h2 id=\"终曲\"><a href=\"#终曲\" class=\"headerlink\" title=\"终曲\"></a>终曲</h2><blockquote>\n<p>简述ApplicationContext与BeanFactory的区别？</p>\n</blockquote>\n<p>从框架设计来看，ApplicationContext是BeanFactory的子接口，BeanFactory是spring框架最底层的接口，它基于最基础，最通用，<strong>最核心的功能创建bean对象</strong>，而ApplicationContext它在BeanFactory的基础上，<strong>更多的关注容器功能的实现</strong>，也就是我们熟识的<strong>IOC,DI,AOP</strong>，再进一步说，<strong>BeanFactory是给ApplicationContext等子接口用的</strong>，而<strong>ApplicationContext直接对接开发人员</strong>，</p>\n<p>另外值得一提的是，spring中应用最多的模式即为工厂模式，可以认为我们通过<strong>配置文件，注解来整合成一个制造说明说书</strong>，而底层的工厂帮我们去制造！</p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h2><p>在开始分析spring IOC的源码之前，我们有必要先理清大致的脉络，而有<strong>三个问题</strong>对脉络的构建至关重要——</p>\n<ol>\n<li><p><strong>从哪里出发</strong>：hello world~ 要想通这一点，我们需要把视角拉回<code>java web</code>，不可置否的是javaweb通过servlet组件可以实现一个完整的功能，但对于一个HTTP请求，我们处理的全过程包含<code>接收请求，处理请求，返回请求</code>，在这其中只有处理请求的<code>核心业务逻辑是需要我们去完成</code>的.</p>\n<p>而接收请求，返回请求是所有业务场景依托的通用部分，它们完成了报文的<code>解复用，解析，封装</code>，这里的任何一项留给程序员去做，都足以<code>让人头皮发麻</code>。而框架的实现者深知这一点，把最复杂，但也最通用的部分提取了出来。</p>\n<blockquote>\n<p>如果我们想运行任何一个项目，一句简单的helloworld就能像点睛之笔一般让项目枯木逢春。</p>\n</blockquote>\n<p>转念去想，我们学习任何知识似乎都只需要一句的hello world，看来所有的框架都认为我们不怎么聪明的亚子。。</p>\n</li>\n<li><p><strong>以什么为参考</strong>：ioc容器的功能是创建并管理对象，所以对象什么时候被创建，什么时候被初始化是核心。</p>\n</li>\n<li><p><strong>解析的技巧</strong>：让人诟病的框架通常差的千奇百怪，但往往一个优秀的框架在各个方面都无可挑剔，比如<code>注释，名称</code>。</p>\n<p>这些<strong>路标</strong>能够指引更高效的前行。</p>\n<hr>\n</li>\n</ol>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>我们首先在spring的配置文件中配置了<strong>两个bean对象</strong>：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508101816973.png\" alt=\"image-20210508101816973\"></p>\n<p>并通过简易的helloworld类中<strong>打断点观察源码</strong>的运行轨迹——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102002505.png\" alt=\"image-20210508102002505\"></p>\n<p>如果我们直接运行项目，会在控制台观察到这些信息：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102357843.png\" alt=\"image-20210508102357843\"></p>\n<p>接下来我们为创建IOC容器这一步打断点，看看会发生什么——</p>\n<h2 id=\"第一站\"><a href=\"#第一站\" class=\"headerlink\" title=\"第一站\"></a>第一站</h2><blockquote>\n<p>所有的故事都从这一句代码开始了：ioc = new ClassPathXmlApplicationContext(“classpath:applicationContext.xml”);</p>\n</blockquote>\n<p>首先来看debug之后的版面分布：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508102839427.png\" alt=\"image-20210508102839427\"></p>\n<p>核心的逻辑都在创建IOC容器的过程中完成，我们F5进去瞅瞅：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103054925.png\" alt=\"image-20210508103054925\"></p>\n<p>显然，这是在做类加载相关的事情，F6继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103210061.png\" alt=\"image-20210508103210061\"></p>\n<p>在构造方法中又调用了另一个构造方法，有趣的是不论构造方法怎样重构，最终调用的都是这一句，看来它就是核心啦，贴出来看看——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103417772.png\" alt=\"image-20210508103417772\"></p>\n<p>显然，配置文件的路径被作为一个<strong>String数组</strong>传入，refresh是个布尔值，它是之后的核心，parent就是老生常谈。</p>\n<p>接下来解析xml——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508103951949.png\" alt=\"image-20210508103951949\"></p>\n<p>这一步无非是框架对于XML文件的解析，XML文件中的信息都是String类型的，显然需要将它们提取出来还原为真实的数据类型。但这不是我们的重点，先过咯：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104315170.png\" alt=\"image-20210508104315170\"></p>\n<p>进入到refresh方法，映入眼帘的是复杂但有迹可循的方法，从这里开始，我们已经揭开了它的第一层面纱，开始第二站</p>\n<h2 id=\"第二站\"><a href=\"#第二站\" class=\"headerlink\" title=\"第二站\"></a>第二站</h2><p>refresh方法起手就是一个同步锁，这样能够保证IOC容器只会被创建一次，继续——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508104811500.png\" alt=\"image-20210508104811500\"></p>\n<p>放过这一句后，控制台打印出了<strong>正在欲刷新ApplicationContext的信息</strong>，不是我们核心关注点，next-&gt;</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105131661.png\" alt=\"image-20210508105131661\"></p>\n<p>这一步直观的看，<strong>刷新内部bean工厂创建出子类ConfigurableListableBeanFactory</strong>，来看下BeanFactory的顶层设计：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508105727464.png\" alt=\"image-20210508105727464\"></p>\n<p>看来ConfigurableListableBeanFactory的地位不高，它的祖爷爷<strong>BeanFactory才是万恶之源</strong>，可以看出，它独有的两个方法一个用于<strong>返回遍历bean名称的迭代器</strong>，一个是不知道有啥用的<strong>冻结配置</strong>(你只读的，我怎么改…)。</p>\n<p>当我们放过这句后，控制台表示我有话说：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508110312292.png\" alt=\"image-20210508110312292\"></p>\n<p>也就是说，它实现的是<strong>解析XML配置文件的Bean定义，并加载到一个容器中</strong>那加载到哪里呢？ConfigurableListableBeanFactory？我们一看便知：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111122589.png\" alt=\"image-20210508111122589\"></p>\n<p>IOC容器读取XML中的配置到Bean工厂中以待使用，更具体的说，它<code>将Bean对象的定义放入了旗下的两个Map</code>中，徐徐图之：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111658655.png\" alt=\"image-20210508111658655\"></p>\n<p>见名知意，准备Bean工厂，放过后控制台，变量没有任何表示，next-&gt;</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508111908977.png\" alt=\"image-20210508111908977\"></p>\n<p>接下来是这个后置处理器的专场，但控制台，变量并没有发生变化，显然并不核心，我们简要的说明他们的功能——</p>\n<p>IOC容器的核心功能是创建并管理Bean对象，但它的功能却不仅包含这个，它有不同类型的bean，它还要支撑框架自身的功能，而后置处理器就是做这个事情的。下一步咯：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112239897.png\" alt=\"image-20210508112239897\"></p>\n<p>初始化消息源？其实这一步是用于支持<strong>国际化功能</strong>的，但它在spring MVC才会一展身手，这里还不是它出场的时机，下一步——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112447315.png\" alt=\"image-20210508112447315\"></p>\n<p>这里<strong>初始化了事件的转化器</strong>，看不懂，也不属于核心，过：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112616745.png\" alt=\"image-20210508112616745\"></p>\n<p>留给子类实现？妙，起码暂时不用我关心了嘿嘿，下一个——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508112735726.png\" alt=\"image-20210508112735726\"></p>\n<p>初始化所有不是懒加载(饿汉模式，即<strong>容器启动以后，对象就会被创建</strong>)的<strong>单例对象</strong>。放过试试-》</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508120936682.png\" alt=\"image-20210508120936682\"></p>\n<p>这里初始化了所有的单实例bean对象，终于到了最核心的部分，我们的第三步就从这里开始吧——</p>\n<h2 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h2><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508121322991.png\" alt=\"image-20210508121322991\"></p>\n<p>值得一提的是，这个方式隶属于<code>AbstractApplicationContext</code>,它是<code>ConfigurableApplicationContext</code>的实现类，将<code>ConfigurableListableBeanFactory</code>(我们刚才创建的Bean工厂)作为参数传入。</p>\n<p>在刚开始的部分<strong>初始化类型转换服务</strong>，不是核心部分，继续-》</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122420754.png\" alt=\"image-20210508122420754\"></p>\n<p>这一步就是在为解析做准备了，那下一步自然就是需要解析的部分：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122755207.png\" alt=\"image-20210508122755207\"></p>\n<p>由于我们没有需要Autowire的部分，所以这一步可以直接过啦——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508122955688.png\" alt=\"image-20210508122955688\"></p>\n<p>继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508123214114.png\" alt=\"image-20210508123214114\"></p>\n<h2 id=\"黎明时分\"><a href=\"#黎明时分\" class=\"headerlink\" title=\"黎明时分\"></a>黎明时分</h2><p>这里比较核心，我们不再截图，上代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">preInstantiateSingletons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span> <span class=\"token punctuation\">&#123;</span>\n        \t<span class=\"token comment\">//日志记录</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">isDebugEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Pre-instantiating singletons in \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>、\n        \t<span class=\"token comment\">//从beanDefinitionNames中取得bean名称</span>\n\t\t<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> beanNames <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beanDefinitionNames<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        \t<span class=\"token comment\">//按照xml配置的bean名称创建bean对象</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName <span class=\"token operator\">:</span> beanNames<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            \t   <span class=\"token comment\">//获取bean的配置信息</span>\n\t\t\t<span class=\"token class-name\">RootBeanDefinition</span> bd <span class=\"token operator\">=</span> <span class=\"token function\">getMergedLocalBeanDefinition</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            \t    <span class=\"token comment\">//确认过代码，是我们需要的bean对象</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>bd<span class=\"token punctuation\">.</span><span class=\"token function\">isAbstract</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> bd<span class=\"token punctuation\">.</span><span class=\"token function\">isSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>bd<span class=\"token punctuation\">.</span><span class=\"token function\">isLazyInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                \t\t<span class=\"token comment\">//显然得到的bean名称是我们希望容器创建的普通bean，而不是factoryBean</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isFactoryBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t<span class=\"token keyword\">final</span> <span class=\"token class-name\">FactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> factory <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>FACTORY_BEAN_PREFIX <span class=\"token operator\">+</span> beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token keyword\">boolean</span> isEagerInit<span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSecurityManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> factory <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartFactoryBean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\tisEagerInit <span class=\"token operator\">=</span> <span class=\"token class-name\">AccessController</span><span class=\"token punctuation\">.</span><span class=\"token function\">doPrivileged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PrivilegedAction</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span>\n\t\t\t\t\t\t\t\t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SmartFactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEagerInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t\t<span class=\"token function\">getAccessControlContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\tisEagerInit <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>factory <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartFactoryBean</span> <span class=\"token operator\">&amp;&amp;</span>\n\t\t\t\t\t\t\t\t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SmartFactoryBean</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEagerInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isEagerInit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\t<span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n                \t\t<span class=\"token comment\">//我神经都蹦一块了，你就给我看这个~</span>\n\t\t\t\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t<span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\n\t\t<span class=\"token comment\">// Trigger post-initialization callback for all applicable beans...</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName <span class=\"token operator\">:</span> beanNames<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            \t   <span class=\"token comment\">//通过名称开始创建对象啦</span>\n\t\t\t<span class=\"token class-name\">Object</span> singletonInstance <span class=\"token operator\">=</span> <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singletonInstance <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartInitializingSingleton</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t<span class=\"token keyword\">final</span> <span class=\"token class-name\">SmartInitializingSingleton</span> smartSingleton <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SmartInitializingSingleton</span><span class=\"token punctuation\">)</span> singletonInstance<span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSecurityManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t<span class=\"token class-name\">AccessController</span><span class=\"token punctuation\">.</span><span class=\"token function\">doPrivileged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PrivilegedAction</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\t\tsmartSingleton<span class=\"token punctuation\">.</span><span class=\"token function\">afterSingletonsInstantiated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getAccessControlContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t\t\tsmartSingleton<span class=\"token punctuation\">.</span><span class=\"token function\">afterSingletonsInstantiated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们来大致理理思绪：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124603963.png\" alt=\"image-20210508124603963\"></p>\n<p><code>根据bean名称获取到bean的配置信息-》从配置信息中判断是否是我们需要的bean对象-》如果是，再判断是工厂Bean还是普通Bean-》普通bean，调用getBean。</code></p>\n<p>看来最终创建bean对象的就是这个getbean方法咯，F6一手：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124353828.png\" alt=\"image-20210508124353828\"></p>\n<p>一个bean被创建，我们来看看怎样实现的：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508124938259.png\" alt=\"image-20210508124938259\"></p>\n<p>进去看看：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508125251963.png\" alt=\"image-20210508125251963\"></p>\n<p>也就是查询缓存咯，因为我们是第一次注册，显然不存在这个Bean，继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130650268.png\" alt=\"image-20210508130650268\"></p>\n<p>继续，来到了这：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508130939660.png\" alt=\"image-20210508130939660\"></p>\n<p>如果存在依赖的bean，就需要首先先把这个bean创建出来，当前没有，继续：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131336008.png\" alt=\"image-20210508131336008\"></p>\n<p>终于创建bean对象了，拼夕夕的套路也没你深^-^  </p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508131922757.png\" alt=\"image-20210508131922757\"></p>\n<p>创建完成啦，但是流程还没完~</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133621893.png\" alt=\"image-20210508133621893\"></p>\n<p>这一步<strong>将创建的singtonObject加入到singletonObjects</strong>这个集合中去，而这个集合又隶属于我们刚才创建的bean工厂<code>ConfigurableListableBeanFactory</code>，也就是说我们创建的这个IOC容器是一个多集合的容器，而单例对象容器不过是它的众多集合之一。</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508133336593.png\" alt=\"image-20210508133336593\"></p>\n<p>到此，容器终于创建了，那我们来获取bean对象试试——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134719909.png\" alt=\"image-20210508134719909\"></p>\n<p>先获取ioc容器，然后调用getbean方法从单实例集合中获取指定名称的bean：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210508134941817.png\" alt=\"image-20210508134941817\"></p>\n<h2 id=\"终曲\"><a href=\"#终曲\" class=\"headerlink\" title=\"终曲\"></a>终曲</h2><blockquote>\n<p>简述ApplicationContext与BeanFactory的区别？</p>\n</blockquote>\n<p>从框架设计来看，ApplicationContext是BeanFactory的子接口，BeanFactory是spring框架最底层的接口，它基于最基础，最通用，<strong>最核心的功能创建bean对象</strong>，而ApplicationContext它在BeanFactory的基础上，<strong>更多的关注容器功能的实现</strong>，也就是我们熟识的<strong>IOC,DI,AOP</strong>，再进一步说，<strong>BeanFactory是给ApplicationContext等子接口用的</strong>，而<strong>ApplicationContext直接对接开发人员</strong>，</p>\n<p>另外值得一提的是，spring中应用最多的模式即为工厂模式，可以认为我们通过<strong>配置文件，注解来整合成一个制造说明说书</strong>，而底层的工厂帮我们去制造！</p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"X数之和图文详解","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T07:56:02.000Z","password":null,"summary":null,"_content":"\n## 1.两数之和\n\n### 1.1 题目描述\n\n> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n>\n> 你可以按任意顺序返回答案。\n\n### 1.2 思路及复杂度分析\n\n首先大家直观的想法，会考虑使用两层循环分别遍历数组，并将其相加的和与目标值相比较。这样的解法其平均时间复杂度为O(N2)，着实不怎么优雅。\n\n那优化的空间在哪呢？既然通过第一层已经确定了一个值，那满足要求的值就呼之欲出了，也就是说问题转化为**在一个数组中快速地找目标值**。首先给出答案，通过**基于散列表的哈希查找的平均时间复杂度为O(1)**，我们简要的聊下哈希查找；\n\n> **散列表**（**Hash table**，也叫**哈希表**），是根据[键](https://zh.wikipedia.org/wiki/鍵)（Key）而直接访问内存储存位置的[数据结构](https://zh.wikipedia.org/wiki/数据结构)。也就是说，它通过计算一个关于键值的函数，将所需查询的数据[映射](https://zh.wikipedia.org/wiki/映射)到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://zh.wikipedia.org/wiki/散列函数)，存放记录的数组称做**散列表**。\n\n也就是说在哈希表中，键值和元素存在唯一的映射关系，那这个键值如何获取呢？需要通过**哈希函数**，这里只简要讨论**除留余数法**——\n\n若已知整个哈希表的最大长度m，可以取一个不大于m的数p，然后对该关键字key做取余运算。如： key = key % p。\n\n很显然，通过哈希函数得到的值是有可能冲突的，当发生**哈希冲突**时，就需要为引起冲突的元素重新确定哈希值，这里我们介绍解决哈希冲突的方法之一——**线性探测法**\n\n在线性探测法中，当遇到冲突时，从发生冲突位置起，每次 +1，向右探测，直到不发生哈希冲突为止。\n\n### 1.3 图解演示\n\n图片来自于https://leetcode-cn.com/problems/two-sum/solution/yi-miao-jiu-neng-gao-dong-de-dong-tu-jie-cp6x/\n\n![两数之和](https://pic.leetcode-cn.com/1610336380-bKlBYP-file_1610336383206)\n\n### 1.4 代码演示\n\n```java\nclass Solution {\n  public int[] twoSum(int[] nums, int target) {\n    //创建一个hashmap\n    Map<Integer, Integer> map = new HashMap<>();\n    for(int i = 0; i< nums.length; i++) {\n      //如果哈希表中存在目标元素，就将其封装返回\n      if(map.containsKey(target - nums[i])) {\n        return new int[] {map.get(target-nums[i]),i};\n\t  }\n      //不存在的话，就将其加入哈希表，这里好理解的写法是在哈希表初始化以后就将数组元素全部添加进去，但放在这个位置，动态添加，时间复杂度更低\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n}\n```\n\n> 日拱一卒，功不唐捐。\n\n## 2.三数之和\n\n### 2.1 题目描述\n\n> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n>\n> 注意：答案中**不可以包含重复的三元组**。\n\n### 2.2 思路及复杂度分析\n\n三数之和无疑是两数之和的进阶了，迷惑的是，居然还有四数之和，其实呢，掌握了三数之和，四数之和是很easy的，接下来我们言归正传——\n\n直接想到**排序+双指针**的朋友还是有的，但我个人并不推荐直接上手就使用优化的思路。大多数朋友的思维是没有那么跳跃的，比如我。我们不妨**从最直观的方法写起**，一步步优化，方可有的放矢。\n\n最直观的无非是使用**三重循环**，首先排序，每层循环的值不重复，再对三个数的加和与目标值做判断，就OK了，但讲真确实不优雅。\n\n三层循环的时间复杂度O(N3)太感人了，能不能降低循环的层数，也就是说**在数组中找第三个值的时间复杂度要为O(1),**在两数之和中使用的**哈希表是一个可取的思路**，但为了拓宽视野，我们考虑别的方式，很显然，确定了第一个值，那么剩下的**两个数就满足加和等于target-nums[i]**,所以一层循环解决两个数就变的可行了，**第三个数从数组末尾开始倒序访问**即可。\n\n到这里，核心的思路已经解决了。但是仍旧需要额外做一些修修补补，也就是**特判**。首先如果数组的长度小于3或者第一个元素的值就大于target,那就没有继续的必要了。其次，同一层循环如果碰到相同的值，应该跳过。最后，为了避免第二个数和第三个数重复，可以设置左指针的位置小于右指针的位置。\n\n### 2.3 动图解析\n\n大家可以移步leetcode题解区(大佬牛逼)：https://leetcode-cn.com/problems/3sum/solution/yi-miao-jiu-neng-kan-dong-de-dong-tu-jie-unfp/\n\n### 2.4 代码演示\n\n```java\nclass Solution {\n  public List<List<Integer>> threeSum(int[] nums) {\n    //创建二维数组\n    List<List<Integer>> lists = new ArrayList<>();\n    //将数据先排序\n    Arrays.sort(nums);\n    //一层循环，确保当前循环的数和上一次循环的数不同\n    if(nums.length<=2 || nums[0]>0)\n      return lists;\n    int i = 0;\n    for(;i<nums.length-2;i++){\n      if(nums[i]>0)\n        break;\n      if(i > 0 && nums[i] == nums[i-1])\n        continue;\n      int target = -nums[i];\n      //声明双指针的位置\n      int left = i+1;\n      int right = nums.length-1;\n      while(left < right){\n        if(nums[left] + nums[right] == target) {\n          lists.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));\n          //这里是许多朋友容易困惑的地方，合理的顺序是下面这样的，可以理解为下面这部分都是为下一次的操作数做准备。\n          left++;\n          right--;\n          while (left<right&&nums[left] == nums[left - 1])\n            left++;\n          while (left<right&&nums[right] == nums[right + 1])\n            right--;\n        }else if(nums[left] + nums[right] > target){\n          right--;\n        }else{\n          left++;\n        }\n      }\n    }\n    return lists;\n  }\n}\n```\n\n## 3.四数之和\n\n可能很多人看到这里比较火大，这还有完没完了~ 要不你给我整个N数之和。。。\n\n其实呢，我也觉得到四数之和这里已经没有新的解法，技巧融合进去了，就姑且当做是三数之和的练习题咯，水个题数(嘿嘿)。好了，进入正题——\n\n### 3.1 题目描述\n\n> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n>\n> 注意：\n>\n> 答案中不可以包含重复的四元组。\n\n### 3.2 算法思路和复杂度分析\n\n好吧，从思路上来说的确毫无新意，但解法中需要注意的细节还是很多的，这里我们只描述容易出错的细节——\n\n1.  当用双指针实现时，所用时间会下降很多，究其根本，是因为双指针类似于二分查找，时间复杂度为O(logN),而哈希表的查找时的时间复杂度是O(1).\n2.  预估的最小值大于目标值，则break,而最大值小于目标值，需要使用continue.这个坑在初次写的时候义无反顾的跳了。。\n3.  在比较重复元素时，判断条件之一是当前层循环变量的值大于上一层循环变量的值加一。通俗的说，这个值需要取它有可能取的值，这么说是有点绕了，但自己打一遍代码就觉得非常有必要了。\n\n### 3.3 动图演示\n\n请移步leetcode大佬做的动图：https://leetcode-cn.com/problems/4sum/solution/yi-miao-jiu-neng-gao-dong-de-duo-ge-qiu-ya50w/\n\n### 3.4 代码展示\n\n```java\nclass Solution {\n  public List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> lists = new ArrayList<>();\n    //排好序\n    Arrays.sort(nums);\n    //特判，数组长度小于4返回空\n    if(nums.length<4)\n      return lists;\n    //将数组元素添加到哈希表中\n    HashMap<Integer, Integer> map = new HashMap<>();\n    for(int i=0;i<nums.length;i++){\n      map.put(nums[i],i);\n    }\n    //遍历数组中的所有元素\n    int i = 0;\n    int n = nums.length;\n    for(;i<nums.length-3;i++){\n      //当出现重复元素，则跳过开始下一次循环\n      if(i>0 && nums[i]==nums[i-1])\n        continue;\n      //特判，即该层循环中最大的和小于target或者最小的和大于target\n      if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target)\n       \t  break;\n      if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target)\n          continue;\n      int j = i+1;\n      //从第二个元素开始遍历数组\n      for(;j<nums.length-2;j++){\n          //当出现重复元素，则开始下一次循环\n        if(j>i+1 && nums[j]==nums[j-1])\n          continue;\n        //特判，即当前循环中最大的和小于target或者最小的和大于target\n        if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target)\n          break;\n        if(nums[i]+nums[j]+nums[n-1]+nums[n-2]<target)\n          continue;\n        int k = j+1;\n        for(;k<nums.length-1;k++){\n          //当出现重复元素，则开始下一次循环\n          if(k>j+1 && nums[k]==nums[k-1])\n            continue;\n          int num = target-nums[i]-nums[j]-nums[k];\n          if(map.containsKey(num) && map.get(num)>k){\n            lists.add(new ArrayList<>(Arrays.asList(nums[i],nums[j],nums[k],target-nums[i]-nums[j]-nums[k])));\n         }\n        }\n      }\n    }\n    return lists;\n  }\n}\n\n```\n\n------\n\n> 山高路远，静水深流","source":"_posts/X数之和图文详解.md","raw":"---\ntitle: X数之和图文详解\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 15:56:02\npassword:\nsummary:\ncategories: 数据结构与算法\ntags: \n\t- 数组\n\t- 极客时间\n---\n\n## 1.两数之和\n\n### 1.1 题目描述\n\n> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n>\n> 你可以按任意顺序返回答案。\n\n### 1.2 思路及复杂度分析\n\n首先大家直观的想法，会考虑使用两层循环分别遍历数组，并将其相加的和与目标值相比较。这样的解法其平均时间复杂度为O(N2)，着实不怎么优雅。\n\n那优化的空间在哪呢？既然通过第一层已经确定了一个值，那满足要求的值就呼之欲出了，也就是说问题转化为**在一个数组中快速地找目标值**。首先给出答案，通过**基于散列表的哈希查找的平均时间复杂度为O(1)**，我们简要的聊下哈希查找；\n\n> **散列表**（**Hash table**，也叫**哈希表**），是根据[键](https://zh.wikipedia.org/wiki/鍵)（Key）而直接访问内存储存位置的[数据结构](https://zh.wikipedia.org/wiki/数据结构)。也就是说，它通过计算一个关于键值的函数，将所需查询的数据[映射](https://zh.wikipedia.org/wiki/映射)到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://zh.wikipedia.org/wiki/散列函数)，存放记录的数组称做**散列表**。\n\n也就是说在哈希表中，键值和元素存在唯一的映射关系，那这个键值如何获取呢？需要通过**哈希函数**，这里只简要讨论**除留余数法**——\n\n若已知整个哈希表的最大长度m，可以取一个不大于m的数p，然后对该关键字key做取余运算。如： key = key % p。\n\n很显然，通过哈希函数得到的值是有可能冲突的，当发生**哈希冲突**时，就需要为引起冲突的元素重新确定哈希值，这里我们介绍解决哈希冲突的方法之一——**线性探测法**\n\n在线性探测法中，当遇到冲突时，从发生冲突位置起，每次 +1，向右探测，直到不发生哈希冲突为止。\n\n### 1.3 图解演示\n\n图片来自于https://leetcode-cn.com/problems/two-sum/solution/yi-miao-jiu-neng-gao-dong-de-dong-tu-jie-cp6x/\n\n![两数之和](https://pic.leetcode-cn.com/1610336380-bKlBYP-file_1610336383206)\n\n### 1.4 代码演示\n\n```java\nclass Solution {\n  public int[] twoSum(int[] nums, int target) {\n    //创建一个hashmap\n    Map<Integer, Integer> map = new HashMap<>();\n    for(int i = 0; i< nums.length; i++) {\n      //如果哈希表中存在目标元素，就将其封装返回\n      if(map.containsKey(target - nums[i])) {\n        return new int[] {map.get(target-nums[i]),i};\n\t  }\n      //不存在的话，就将其加入哈希表，这里好理解的写法是在哈希表初始化以后就将数组元素全部添加进去，但放在这个位置，动态添加，时间复杂度更低\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n}\n```\n\n> 日拱一卒，功不唐捐。\n\n## 2.三数之和\n\n### 2.1 题目描述\n\n> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n>\n> 注意：答案中**不可以包含重复的三元组**。\n\n### 2.2 思路及复杂度分析\n\n三数之和无疑是两数之和的进阶了，迷惑的是，居然还有四数之和，其实呢，掌握了三数之和，四数之和是很easy的，接下来我们言归正传——\n\n直接想到**排序+双指针**的朋友还是有的，但我个人并不推荐直接上手就使用优化的思路。大多数朋友的思维是没有那么跳跃的，比如我。我们不妨**从最直观的方法写起**，一步步优化，方可有的放矢。\n\n最直观的无非是使用**三重循环**，首先排序，每层循环的值不重复，再对三个数的加和与目标值做判断，就OK了，但讲真确实不优雅。\n\n三层循环的时间复杂度O(N3)太感人了，能不能降低循环的层数，也就是说**在数组中找第三个值的时间复杂度要为O(1),**在两数之和中使用的**哈希表是一个可取的思路**，但为了拓宽视野，我们考虑别的方式，很显然，确定了第一个值，那么剩下的**两个数就满足加和等于target-nums[i]**,所以一层循环解决两个数就变的可行了，**第三个数从数组末尾开始倒序访问**即可。\n\n到这里，核心的思路已经解决了。但是仍旧需要额外做一些修修补补，也就是**特判**。首先如果数组的长度小于3或者第一个元素的值就大于target,那就没有继续的必要了。其次，同一层循环如果碰到相同的值，应该跳过。最后，为了避免第二个数和第三个数重复，可以设置左指针的位置小于右指针的位置。\n\n### 2.3 动图解析\n\n大家可以移步leetcode题解区(大佬牛逼)：https://leetcode-cn.com/problems/3sum/solution/yi-miao-jiu-neng-kan-dong-de-dong-tu-jie-unfp/\n\n### 2.4 代码演示\n\n```java\nclass Solution {\n  public List<List<Integer>> threeSum(int[] nums) {\n    //创建二维数组\n    List<List<Integer>> lists = new ArrayList<>();\n    //将数据先排序\n    Arrays.sort(nums);\n    //一层循环，确保当前循环的数和上一次循环的数不同\n    if(nums.length<=2 || nums[0]>0)\n      return lists;\n    int i = 0;\n    for(;i<nums.length-2;i++){\n      if(nums[i]>0)\n        break;\n      if(i > 0 && nums[i] == nums[i-1])\n        continue;\n      int target = -nums[i];\n      //声明双指针的位置\n      int left = i+1;\n      int right = nums.length-1;\n      while(left < right){\n        if(nums[left] + nums[right] == target) {\n          lists.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));\n          //这里是许多朋友容易困惑的地方，合理的顺序是下面这样的，可以理解为下面这部分都是为下一次的操作数做准备。\n          left++;\n          right--;\n          while (left<right&&nums[left] == nums[left - 1])\n            left++;\n          while (left<right&&nums[right] == nums[right + 1])\n            right--;\n        }else if(nums[left] + nums[right] > target){\n          right--;\n        }else{\n          left++;\n        }\n      }\n    }\n    return lists;\n  }\n}\n```\n\n## 3.四数之和\n\n可能很多人看到这里比较火大，这还有完没完了~ 要不你给我整个N数之和。。。\n\n其实呢，我也觉得到四数之和这里已经没有新的解法，技巧融合进去了，就姑且当做是三数之和的练习题咯，水个题数(嘿嘿)。好了，进入正题——\n\n### 3.1 题目描述\n\n> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n>\n> 注意：\n>\n> 答案中不可以包含重复的四元组。\n\n### 3.2 算法思路和复杂度分析\n\n好吧，从思路上来说的确毫无新意，但解法中需要注意的细节还是很多的，这里我们只描述容易出错的细节——\n\n1.  当用双指针实现时，所用时间会下降很多，究其根本，是因为双指针类似于二分查找，时间复杂度为O(logN),而哈希表的查找时的时间复杂度是O(1).\n2.  预估的最小值大于目标值，则break,而最大值小于目标值，需要使用continue.这个坑在初次写的时候义无反顾的跳了。。\n3.  在比较重复元素时，判断条件之一是当前层循环变量的值大于上一层循环变量的值加一。通俗的说，这个值需要取它有可能取的值，这么说是有点绕了，但自己打一遍代码就觉得非常有必要了。\n\n### 3.3 动图演示\n\n请移步leetcode大佬做的动图：https://leetcode-cn.com/problems/4sum/solution/yi-miao-jiu-neng-gao-dong-de-duo-ge-qiu-ya50w/\n\n### 3.4 代码展示\n\n```java\nclass Solution {\n  public List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> lists = new ArrayList<>();\n    //排好序\n    Arrays.sort(nums);\n    //特判，数组长度小于4返回空\n    if(nums.length<4)\n      return lists;\n    //将数组元素添加到哈希表中\n    HashMap<Integer, Integer> map = new HashMap<>();\n    for(int i=0;i<nums.length;i++){\n      map.put(nums[i],i);\n    }\n    //遍历数组中的所有元素\n    int i = 0;\n    int n = nums.length;\n    for(;i<nums.length-3;i++){\n      //当出现重复元素，则跳过开始下一次循环\n      if(i>0 && nums[i]==nums[i-1])\n        continue;\n      //特判，即该层循环中最大的和小于target或者最小的和大于target\n      if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target)\n       \t  break;\n      if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target)\n          continue;\n      int j = i+1;\n      //从第二个元素开始遍历数组\n      for(;j<nums.length-2;j++){\n          //当出现重复元素，则开始下一次循环\n        if(j>i+1 && nums[j]==nums[j-1])\n          continue;\n        //特判，即当前循环中最大的和小于target或者最小的和大于target\n        if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target)\n          break;\n        if(nums[i]+nums[j]+nums[n-1]+nums[n-2]<target)\n          continue;\n        int k = j+1;\n        for(;k<nums.length-1;k++){\n          //当出现重复元素，则开始下一次循环\n          if(k>j+1 && nums[k]==nums[k-1])\n            continue;\n          int num = target-nums[i]-nums[j]-nums[k];\n          if(map.containsKey(num) && map.get(num)>k){\n            lists.add(new ArrayList<>(Arrays.asList(nums[i],nums[j],nums[k],target-nums[i]-nums[j]-nums[k])));\n         }\n        }\n      }\n    }\n    return lists;\n  }\n}\n\n```\n\n------\n\n> 山高路远，静水深流","slug":"X数之和图文详解","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7kw0009xjccecmpbu64","content":"<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h2><h3 id=\"1-1-题目描述\"><a href=\"#1-1-题目描述\" class=\"headerlink\" title=\"1.1 题目描述\"></a>1.1 题目描述</h3><blockquote>\n<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n<p>你可以按任意顺序返回答案。</p>\n</blockquote>\n<h3 id=\"1-2-思路及复杂度分析\"><a href=\"#1-2-思路及复杂度分析\" class=\"headerlink\" title=\"1.2 思路及复杂度分析\"></a>1.2 思路及复杂度分析</h3><p>首先大家直观的想法，会考虑使用两层循环分别遍历数组，并将其相加的和与目标值相比较。这样的解法其平均时间复杂度为O(N2)，着实不怎么优雅。</p>\n<p>那优化的空间在哪呢？既然通过第一层已经确定了一个值，那满足要求的值就呼之欲出了，也就是说问题转化为<strong>在一个数组中快速地找目标值</strong>。首先给出答案，通过**基于散列表的哈希查找的平均时间复杂度为O(1)**，我们简要的聊下哈希查找；</p>\n<blockquote>\n<p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<a href=\"https://zh.wikipedia.org/wiki/%E9%8D%B5\">键</a>（Key）而直接访问内存储存位置的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a href=\"https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84\">映射</a>到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<a href=\"https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\">散列函数</a>，存放记录的数组称做<strong>散列表</strong>。</p>\n</blockquote>\n<p>也就是说在哈希表中，键值和元素存在唯一的映射关系，那这个键值如何获取呢？需要通过<strong>哈希函数</strong>，这里只简要讨论<strong>除留余数法</strong>——</p>\n<p>若已知整个哈希表的最大长度m，可以取一个不大于m的数p，然后对该关键字key做取余运算。如： key = key % p。</p>\n<p>很显然，通过哈希函数得到的值是有可能冲突的，当发生<strong>哈希冲突</strong>时，就需要为引起冲突的元素重新确定哈希值，这里我们介绍解决哈希冲突的方法之一——<strong>线性探测法</strong></p>\n<p>在线性探测法中，当遇到冲突时，从发生冲突位置起，每次 +1，向右探测，直到不发生哈希冲突为止。</p>\n<h3 id=\"1-3-图解演示\"><a href=\"#1-3-图解演示\" class=\"headerlink\" title=\"1.3 图解演示\"></a>1.3 图解演示</h3><p>图片来自于<a href=\"https://leetcode-cn.com/problems/two-sum/solution/yi-miao-jiu-neng-gao-dong-de-dong-tu-jie-cp6x/\">https://leetcode-cn.com/problems/two-sum/solution/yi-miao-jiu-neng-gao-dong-de-dong-tu-jie-cp6x/</a></p>\n<p><img src=\"https://pic.leetcode-cn.com/1610336380-bKlBYP-file_1610336383206\" alt=\"两数之和\"></p>\n<h3 id=\"1-4-代码演示\"><a href=\"#1-4-代码演示\" class=\"headerlink\" title=\"1.4 代码演示\"></a>1.4 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建一个hashmap</span>\n    <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//如果哈希表中存在目标元素，就将其封装返回</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>target <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#123;</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\t  <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token comment\">//不存在的话，就将其加入哈希表，这里好理解的写法是在哈希表初始化以后就将数组元素全部添加进去，但放在这个位置，动态添加，时间复杂度更低</span>\n      map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No two sum solution\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<h2 id=\"2-三数之和\"><a href=\"#2-三数之和\" class=\"headerlink\" title=\"2.三数之和\"></a>2.三数之和</h2><h3 id=\"2-1-题目描述\"><a href=\"#2-1-题目描述\" class=\"headerlink\" title=\"2.1 题目描述\"></a>2.1 题目描述</h3><blockquote>\n<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>\n<p>注意：答案中<strong>不可以包含重复的三元组</strong>。</p>\n</blockquote>\n<h3 id=\"2-2-思路及复杂度分析\"><a href=\"#2-2-思路及复杂度分析\" class=\"headerlink\" title=\"2.2 思路及复杂度分析\"></a>2.2 思路及复杂度分析</h3><p>三数之和无疑是两数之和的进阶了，迷惑的是，居然还有四数之和，其实呢，掌握了三数之和，四数之和是很easy的，接下来我们言归正传——</p>\n<p>直接想到<strong>排序+双指针</strong>的朋友还是有的，但我个人并不推荐直接上手就使用优化的思路。大多数朋友的思维是没有那么跳跃的，比如我。我们不妨<strong>从最直观的方法写起</strong>，一步步优化，方可有的放矢。</p>\n<p>最直观的无非是使用<strong>三重循环</strong>，首先排序，每层循环的值不重复，再对三个数的加和与目标值做判断，就OK了，但讲真确实不优雅。</p>\n<p>三层循环的时间复杂度O(N3)太感人了，能不能降低循环的层数，也就是说<strong>在数组中找第三个值的时间复杂度要为O(1),<strong>在两数之和中使用的</strong>哈希表是一个可取的思路</strong>，但为了拓宽视野，我们考虑别的方式，很显然，确定了第一个值，那么剩下的<strong>两个数就满足加和等于target-nums[i]</strong>,所以一层循环解决两个数就变的可行了，<strong>第三个数从数组末尾开始倒序访问</strong>即可。</p>\n<p>到这里，核心的思路已经解决了。但是仍旧需要额外做一些修修补补，也就是<strong>特判</strong>。首先如果数组的长度小于3或者第一个元素的值就大于target,那就没有继续的必要了。其次，同一层循环如果碰到相同的值，应该跳过。最后，为了避免第二个数和第三个数重复，可以设置左指针的位置小于右指针的位置。</p>\n<h3 id=\"2-3-动图解析\"><a href=\"#2-3-动图解析\" class=\"headerlink\" title=\"2.3 动图解析\"></a>2.3 动图解析</h3><p>大家可以移步leetcode题解区(大佬牛逼)：<a href=\"https://leetcode-cn.com/problems/3sum/solution/yi-miao-jiu-neng-kan-dong-de-dong-tu-jie-unfp/\">https://leetcode-cn.com/problems/3sum/solution/yi-miao-jiu-neng-kan-dong-de-dong-tu-jie-unfp/</a></p>\n<h3 id=\"2-4-代码演示\"><a href=\"#2-4-代码演示\" class=\"headerlink\" title=\"2.4 代码演示\"></a>2.4 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">threeSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建二维数组</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> lists <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//将数据先排序</span>\n    <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//一层循环，确保当前循环的数和上一次循环的数不同</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">&lt;=</span><span class=\"token number\">2</span> <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> target <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//声明双指针的位置</span>\n      <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          lists<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token comment\">//这里是许多朋友容易困惑的地方，合理的顺序是下面这样的，可以理解为下面这部分都是为下一次的操作数做准备。</span>\n          left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n          right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token operator\">&amp;&amp;</span>nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>left <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token operator\">&amp;&amp;</span>nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n          right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n          left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3-四数之和\"><a href=\"#3-四数之和\" class=\"headerlink\" title=\"3.四数之和\"></a>3.四数之和</h2><p>可能很多人看到这里比较火大，这还有完没完了~ 要不你给我整个N数之和。。。</p>\n<p>其实呢，我也觉得到四数之和这里已经没有新的解法，技巧融合进去了，就姑且当做是三数之和的练习题咯，水个题数(嘿嘿)。好了，进入正题——</p>\n<h3 id=\"3-1-题目描述\"><a href=\"#3-1-题目描述\" class=\"headerlink\" title=\"3.1 题目描述\"></a>3.1 题目描述</h3><blockquote>\n<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>\n<p>注意：</p>\n<p>答案中不可以包含重复的四元组。</p>\n</blockquote>\n<h3 id=\"3-2-算法思路和复杂度分析\"><a href=\"#3-2-算法思路和复杂度分析\" class=\"headerlink\" title=\"3.2 算法思路和复杂度分析\"></a>3.2 算法思路和复杂度分析</h3><p>好吧，从思路上来说的确毫无新意，但解法中需要注意的细节还是很多的，这里我们只描述容易出错的细节——</p>\n<ol>\n<li> 当用双指针实现时，所用时间会下降很多，究其根本，是因为双指针类似于二分查找，时间复杂度为O(logN),而哈希表的查找时的时间复杂度是O(1).</li>\n<li> 预估的最小值大于目标值，则break,而最大值小于目标值，需要使用continue.这个坑在初次写的时候义无反顾的跳了。。</li>\n<li> 在比较重复元素时，判断条件之一是当前层循环变量的值大于上一层循环变量的值加一。通俗的说，这个值需要取它有可能取的值，这么说是有点绕了，但自己打一遍代码就觉得非常有必要了。</li>\n</ol>\n<h3 id=\"3-3-动图演示\"><a href=\"#3-3-动图演示\" class=\"headerlink\" title=\"3.3 动图演示\"></a>3.3 动图演示</h3><p>请移步leetcode大佬做的动图：<a href=\"https://leetcode-cn.com/problems/4sum/solution/yi-miao-jiu-neng-gao-dong-de-duo-ge-qiu-ya50w/\">https://leetcode-cn.com/problems/4sum/solution/yi-miao-jiu-neng-gao-dong-de-duo-ge-qiu-ya50w/</a></p>\n<h3 id=\"3-4-代码展示\"><a href=\"#3-4-代码展示\" class=\"headerlink\" title=\"3.4 代码展示\"></a>3.4 代码展示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">fourSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> lists <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//排好序</span>\n    <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//特判，数组长度小于4返回空</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//将数组元素添加到哈希表中</span>\n    <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//遍历数组中的所有元素</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//当出现重复元素，则跳过开始下一次循环</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">></span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//特判，即该层循环中最大的和小于target或者最小的和大于target</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>target<span class=\"token punctuation\">)</span>\n       \t  <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>target<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//从第二个元素开始遍历数组</span>\n      <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n          <span class=\"token comment\">//当出现重复元素，则开始下一次循环</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">></span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//特判，即当前循环中最大的和小于target或者最小的和大于target</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>target<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>target<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n          <span class=\"token comment\">//当出现重复元素，则开始下一次循环</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k<span class=\"token operator\">></span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> target<span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token operator\">></span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            lists<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>target<span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h2><h3 id=\"1-1-题目描述\"><a href=\"#1-1-题目描述\" class=\"headerlink\" title=\"1.1 题目描述\"></a>1.1 题目描述</h3><blockquote>\n<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n<p>你可以按任意顺序返回答案。</p>\n</blockquote>\n<h3 id=\"1-2-思路及复杂度分析\"><a href=\"#1-2-思路及复杂度分析\" class=\"headerlink\" title=\"1.2 思路及复杂度分析\"></a>1.2 思路及复杂度分析</h3><p>首先大家直观的想法，会考虑使用两层循环分别遍历数组，并将其相加的和与目标值相比较。这样的解法其平均时间复杂度为O(N2)，着实不怎么优雅。</p>\n<p>那优化的空间在哪呢？既然通过第一层已经确定了一个值，那满足要求的值就呼之欲出了，也就是说问题转化为<strong>在一个数组中快速地找目标值</strong>。首先给出答案，通过**基于散列表的哈希查找的平均时间复杂度为O(1)**，我们简要的聊下哈希查找；</p>\n<blockquote>\n<p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<a href=\"https://zh.wikipedia.org/wiki/%E9%8D%B5\">键</a>（Key）而直接访问内存储存位置的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a href=\"https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84\">映射</a>到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<a href=\"https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\">散列函数</a>，存放记录的数组称做<strong>散列表</strong>。</p>\n</blockquote>\n<p>也就是说在哈希表中，键值和元素存在唯一的映射关系，那这个键值如何获取呢？需要通过<strong>哈希函数</strong>，这里只简要讨论<strong>除留余数法</strong>——</p>\n<p>若已知整个哈希表的最大长度m，可以取一个不大于m的数p，然后对该关键字key做取余运算。如： key = key % p。</p>\n<p>很显然，通过哈希函数得到的值是有可能冲突的，当发生<strong>哈希冲突</strong>时，就需要为引起冲突的元素重新确定哈希值，这里我们介绍解决哈希冲突的方法之一——<strong>线性探测法</strong></p>\n<p>在线性探测法中，当遇到冲突时，从发生冲突位置起，每次 +1，向右探测，直到不发生哈希冲突为止。</p>\n<h3 id=\"1-3-图解演示\"><a href=\"#1-3-图解演示\" class=\"headerlink\" title=\"1.3 图解演示\"></a>1.3 图解演示</h3><p>图片来自于<a href=\"https://leetcode-cn.com/problems/two-sum/solution/yi-miao-jiu-neng-gao-dong-de-dong-tu-jie-cp6x/\">https://leetcode-cn.com/problems/two-sum/solution/yi-miao-jiu-neng-gao-dong-de-dong-tu-jie-cp6x/</a></p>\n<p><img src=\"https://pic.leetcode-cn.com/1610336380-bKlBYP-file_1610336383206\" alt=\"两数之和\"></p>\n<h3 id=\"1-4-代码演示\"><a href=\"#1-4-代码演示\" class=\"headerlink\" title=\"1.4 代码演示\"></a>1.4 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建一个hashmap</span>\n    <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//如果哈希表中存在目标元素，就将其封装返回</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>target <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#123;</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\t  <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token comment\">//不存在的话，就将其加入哈希表，这里好理解的写法是在哈希表初始化以后就将数组元素全部添加进去，但放在这个位置，动态添加，时间复杂度更低</span>\n      map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No two sum solution\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<h2 id=\"2-三数之和\"><a href=\"#2-三数之和\" class=\"headerlink\" title=\"2.三数之和\"></a>2.三数之和</h2><h3 id=\"2-1-题目描述\"><a href=\"#2-1-题目描述\" class=\"headerlink\" title=\"2.1 题目描述\"></a>2.1 题目描述</h3><blockquote>\n<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>\n<p>注意：答案中<strong>不可以包含重复的三元组</strong>。</p>\n</blockquote>\n<h3 id=\"2-2-思路及复杂度分析\"><a href=\"#2-2-思路及复杂度分析\" class=\"headerlink\" title=\"2.2 思路及复杂度分析\"></a>2.2 思路及复杂度分析</h3><p>三数之和无疑是两数之和的进阶了，迷惑的是，居然还有四数之和，其实呢，掌握了三数之和，四数之和是很easy的，接下来我们言归正传——</p>\n<p>直接想到<strong>排序+双指针</strong>的朋友还是有的，但我个人并不推荐直接上手就使用优化的思路。大多数朋友的思维是没有那么跳跃的，比如我。我们不妨<strong>从最直观的方法写起</strong>，一步步优化，方可有的放矢。</p>\n<p>最直观的无非是使用<strong>三重循环</strong>，首先排序，每层循环的值不重复，再对三个数的加和与目标值做判断，就OK了，但讲真确实不优雅。</p>\n<p>三层循环的时间复杂度O(N3)太感人了，能不能降低循环的层数，也就是说<strong>在数组中找第三个值的时间复杂度要为O(1),<strong>在两数之和中使用的</strong>哈希表是一个可取的思路</strong>，但为了拓宽视野，我们考虑别的方式，很显然，确定了第一个值，那么剩下的<strong>两个数就满足加和等于target-nums[i]</strong>,所以一层循环解决两个数就变的可行了，<strong>第三个数从数组末尾开始倒序访问</strong>即可。</p>\n<p>到这里，核心的思路已经解决了。但是仍旧需要额外做一些修修补补，也就是<strong>特判</strong>。首先如果数组的长度小于3或者第一个元素的值就大于target,那就没有继续的必要了。其次，同一层循环如果碰到相同的值，应该跳过。最后，为了避免第二个数和第三个数重复，可以设置左指针的位置小于右指针的位置。</p>\n<h3 id=\"2-3-动图解析\"><a href=\"#2-3-动图解析\" class=\"headerlink\" title=\"2.3 动图解析\"></a>2.3 动图解析</h3><p>大家可以移步leetcode题解区(大佬牛逼)：<a href=\"https://leetcode-cn.com/problems/3sum/solution/yi-miao-jiu-neng-kan-dong-de-dong-tu-jie-unfp/\">https://leetcode-cn.com/problems/3sum/solution/yi-miao-jiu-neng-kan-dong-de-dong-tu-jie-unfp/</a></p>\n<h3 id=\"2-4-代码演示\"><a href=\"#2-4-代码演示\" class=\"headerlink\" title=\"2.4 代码演示\"></a>2.4 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">threeSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建二维数组</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> lists <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//将数据先排序</span>\n    <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//一层循环，确保当前循环的数和上一次循环的数不同</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">&lt;=</span><span class=\"token number\">2</span> <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> target <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//声明双指针的位置</span>\n      <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          lists<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token comment\">//这里是许多朋友容易困惑的地方，合理的顺序是下面这样的，可以理解为下面这部分都是为下一次的操作数做准备。</span>\n          left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n          right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token operator\">&amp;&amp;</span>nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>left <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token operator\">&amp;&amp;</span>nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n          right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n          left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3-四数之和\"><a href=\"#3-四数之和\" class=\"headerlink\" title=\"3.四数之和\"></a>3.四数之和</h2><p>可能很多人看到这里比较火大，这还有完没完了~ 要不你给我整个N数之和。。。</p>\n<p>其实呢，我也觉得到四数之和这里已经没有新的解法，技巧融合进去了，就姑且当做是三数之和的练习题咯，水个题数(嘿嘿)。好了，进入正题——</p>\n<h3 id=\"3-1-题目描述\"><a href=\"#3-1-题目描述\" class=\"headerlink\" title=\"3.1 题目描述\"></a>3.1 题目描述</h3><blockquote>\n<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>\n<p>注意：</p>\n<p>答案中不可以包含重复的四元组。</p>\n</blockquote>\n<h3 id=\"3-2-算法思路和复杂度分析\"><a href=\"#3-2-算法思路和复杂度分析\" class=\"headerlink\" title=\"3.2 算法思路和复杂度分析\"></a>3.2 算法思路和复杂度分析</h3><p>好吧，从思路上来说的确毫无新意，但解法中需要注意的细节还是很多的，这里我们只描述容易出错的细节——</p>\n<ol>\n<li> 当用双指针实现时，所用时间会下降很多，究其根本，是因为双指针类似于二分查找，时间复杂度为O(logN),而哈希表的查找时的时间复杂度是O(1).</li>\n<li> 预估的最小值大于目标值，则break,而最大值小于目标值，需要使用continue.这个坑在初次写的时候义无反顾的跳了。。</li>\n<li> 在比较重复元素时，判断条件之一是当前层循环变量的值大于上一层循环变量的值加一。通俗的说，这个值需要取它有可能取的值，这么说是有点绕了，但自己打一遍代码就觉得非常有必要了。</li>\n</ol>\n<h3 id=\"3-3-动图演示\"><a href=\"#3-3-动图演示\" class=\"headerlink\" title=\"3.3 动图演示\"></a>3.3 动图演示</h3><p>请移步leetcode大佬做的动图：<a href=\"https://leetcode-cn.com/problems/4sum/solution/yi-miao-jiu-neng-gao-dong-de-duo-ge-qiu-ya50w/\">https://leetcode-cn.com/problems/4sum/solution/yi-miao-jiu-neng-gao-dong-de-duo-ge-qiu-ya50w/</a></p>\n<h3 id=\"3-4-代码展示\"><a href=\"#3-4-代码展示\" class=\"headerlink\" title=\"3.4 代码展示\"></a>3.4 代码展示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">fourSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> lists <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//排好序</span>\n    <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//特判，数组长度小于4返回空</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//将数组元素添加到哈希表中</span>\n    <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//遍历数组中的所有元素</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//当出现重复元素，则跳过开始下一次循环</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">></span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//特判，即该层循环中最大的和小于target或者最小的和大于target</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>target<span class=\"token punctuation\">)</span>\n       \t  <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>target<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//从第二个元素开始遍历数组</span>\n      <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n          <span class=\"token comment\">//当出现重复元素，则开始下一次循环</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">></span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//特判，即当前循环中最大的和小于target或者最小的和大于target</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>target<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>target<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n          <span class=\"token comment\">//当出现重复元素，则开始下一次循环</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k<span class=\"token operator\">></span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> target<span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token operator\">></span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            lists<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>target<span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"article title","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2023-09-24T11:21:46.000Z","password":null,"summary":null,"_content":"bihihiiibbio","source":"_posts/article-title.md","raw":"---\ntitle: article title\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2023-09-24 19:21:46\npassword:\nsummary:\ntags:\ncategories:\n---\nbihihiiibbio","slug":"article-title","published":1,"updated":"2023-09-24T11:22:40.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7kx000axjcc3iyi3n72","content":"<p>bihihiiibbio</p>\n","site":{"data":{}},"excerpt":"","more":"<p>bihihiiibbio</p>\n"},{"title":"内存管理","top":true,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T03:21:50.000Z","password":null,"summary":null,"_content":"\n## 1、内存使用与分段\n\n我们知道，计算机运行的**核心**不外于**取指执行**，而从**哪里取指令**呢，自然是**内存**，更具体的说，是从**磁盘加载到内存**中的一段程序。但指令有很多，我们要取得**哪一个指令的地址**呢？我们从用户视角看，程序是从**main函数**开始执行的，而从汇编的角度来说，就是程序入口**ENTRY之后的地址**。\n\n那首先先让程序进入内存，而程序很**自然**的就要放在entry之后指定的那个地址中。我们假设这段程序就放在以**0x0000为起始地址**的这段内存里。这时**冲突**产生了。这段内存是用于操作系统初始化时放置指令的**固定**的区域。\n\n那么，程序的入口地址显然需要定位到另一段**空闲的内存空间**，用专业术语说，就是指**重定向**。\n\n> 重定向 : 修改程序中的地址，使其变成相对地址\n\n而重定向的方式有两种，**直接定位到新的地址**和**基地址加上变化的偏移地址**，这里我们更多的去使用偏移地址，也就是**相对地址**。\n\n既然知道需要将地址重定向，那我们就试着在运行程序的过程中**引入重定向**，但这又让人犯难了，就拿汇编来说，程序执行的过程需要经过**编译**，**连接**，**运行**三个过程，那我们要在那个阶段重定向呢？\n\n假设在编译时重定向，这时将地址提前进行偏移放置在一段空闲地址中，但运行的时候，这段空闲地址被**别的进程占用**了，嗯，计算机的世界也充满着无常，我们不如试试载入内存时重定向——\n\n这种想法好像还行，起码内存是自己的了。但是谁告诉你重定向只会发生一次呢？为了灵活完成任务，**交换**变得必不可少，难道我要**载入n次**吗？好的，下一位：\n\n那就**运行时载入**吧，这种动态切换的方式的确**满足了所有需求**，它总会申请一段空闲的，在一定时间内被自己使用的内存。\n\n------\n\n到这里已经迈出了一大步，既然初步的想法确定了，我们接下来先将这个想法规范化，这里我们引入**地址翻译**与**逻辑地址**，**物理地址**的概念。\n\n所谓地址翻译，就是指每执行一条指令，都要从逻辑地址算出物理地址。我们来看下面的例子\n\nmov ax , [300]\n\n这里的300是偏移地址，换句话说，这里的[300]指的是逻辑地址，而实际的[300]表示的物理地址等于当前这个**固定的偏移地址**加上**变化的基地址**。\n\n那我既然每执行一条指令都要用到基地址，那基地址应该是一个**全局的变量**，而对于一个运行的程序，也就是进程来说，这个全局的变量应该存储在**PCB**中，又因为它被用到的**频率很高**，进而它会被放置在CPU的零级缓存——**寄存器ldtr**中。\n\n- [x] GDT表示全局描述符，段描述符被放置在GDT中，用来对任务实现隔离。而有GDT，就自然也衍生了LDT，即局部描述符，它专属于某个任务。\n\n这时程序的一次执行已经可以完成了，我们不妨记做**flag1**\n\n------\n\n### 分段\n\n为了更好地使用内存，**分治思想**的引入自然势在必行，程序根据每一段代码的**属性**与**功能**将其分成了多个段，分析每个段的功能变得容易了很多。这个时候，**段**才是程序运行的**单元**。\n\n这个单元有它的**状态**，它的**执行结果**等等，而在程序载入的时候，这些**段**也被载入到**不同的地址**中，降低了管理的复杂度。\n\n为了**描述**这些段的信息，同时方便管理这些个段，就衍生出了进程的**段表**——**LDT**,段表中存放每个段的基地址，段号，长度，权限等等——\n\n![1](https://raw.githubusercontent.com/future727/Pictures/main/img/image-20210627160125632.png)\n\n这个表的思想不是第一次引入，更准确的说，在**操作系统启动**的时候就需要维护一个段表——**GDT**,操作系统故事的大幕也是就此揭开的。\n\n对于内存的使用，大的来说是分**三个阶段**的，首先将**程序分段**，这是在**编译时期**完成的，我们只需要显式的告诉编译器自己声明的不同的段，接着就需要在内存中找出一段**空闲的内存空间**，那是哪一段呢？怎么知道这段内存可以被使用呢？这些是后话了；最后就将分好段的程序**载入**到分好区的内存中执行。\n\n第一步我们已经完成了，我们接下来就来看分区思想是如何引入的，内存又是如何实现分区的？\n\n------\n\n## 2、内存分区与分页\n\n- [x] 如何分区？描述分区后的每段内存，如何表示已经分出去了，如何将这段内存用作特定用途？\n- [x] 分成定长的/不定长的；如何描述内存段；分配的算法？分区会导致什么问题？分页\n\n这里首先来说些题外话，在开始这节之前，我试着提出针对内存分区我认为应该提出的问题，但事实证明，我**思维的出发点**是错的，\n\n针对内存分区的具体问题，我开门见山的认为应该有描述分区后的数据结构，这样想固然没错，但更重要的对于一个**实际系统的架构**，从**需求入手才是最切实**的，对于内存分区，为什么要分区，因为**程序分段**的思想，决定**段的大小是不定**的，而与之对应的，加载到的那段内存也应该是与段的大小相匹配的。\n\n------\n\n现在我们开始进入正题，程序分段的引入导致每一个段的长度是不一样的，而**内存**只是一个用来装载指令和数据的**容器**，**容器的大小是由我需要多少水来决定的**，相应的，为每个程序段申请的空闲内存的大小也是由段来决定的，因此，定长的分配内存显然是不可取的，这里我们根据**段的长度**决定**申请的内存空间**。\n\n那申请内存的时候，我们自然就需要知道那段内存是空闲的，这段内存有多大。这样我们就需要一个可以用来**描述这些信息的数据结构**，**分区表**就被引入进来了。当我们需要的内存空间大小和这段空间**近似匹配**的时候，我们就将程序加载进去，执行完了再将内存空间释放。\n\n那在匹配内存空间的时候，就出现了问题，我们是应该**就近匹配**，还是花费时间做**最优匹配**呢？这里没有对错之分，可以参考相应的**时间**，**空间复杂度**和**占用空间大小**灵活选择。\n\n虽然分区解决了内存使用的一部分问题，但我们考虑这样的例子：假如一个200K的段申请了一段500K的内存空间，但剩余的300K，别的段并不能使用。很多这样的**内存碎片**聚少成多，就造成了**内存空间的浪费**。\n\n解决内存碎片直观的想法就是将没有的内存合并，也就是内存紧缩，但内存紧缩时，需要调整**每条指令**的基地址，这个**任务量是巨大的**，这种方式不可取。\n\n这里，我们可以将内存分页，在**操作系统初始化**的时候，**memmap**会将内存分成**4k的页单元**，页单元由**页框号指示**中，而页框号的位置又由**页头指针**来指向，这个指针最终被放到了**寄存器**中。\n\n## 3、多级页表和快表\n\n### 多级页表\n\n上一小节提出了一种**可行**的将**内存分页**的**思想**。但实际应用与理论总是存在**差距**的，我们首先**量化**的来看维护单个页需要的**内存开销**：\n\n一页内存有4K的空间，而32位的系统有32位的地址总线，也就是说它的寻址能力是2的32次方，也就是4GB，那么操作系统就需要维护4GB/4KB=2的**20次方个页表**，也就是**1MB**的内存空间，一个进程需要1MB的内存空间，而多个进程**并发执行**，需要空间就会变得很大，这样显然**不可取**。\n\n但这里有一个**误区**，有很多页表在实际使用中是被**闲置**的，既然它是闲置的，我们就不需要维护它，也就是说我们可以**删去部分不会用到的页表**，这样的话，假设就只需要1KB的空间来存储页表了，但**页表**是存储在**PCB**中的，PCB又是会被加载到**内存**的，而加载到内存的过程也是需要**维护队列等数据结构**的，**访存的开销太大**了。\n\n那能不能有一种方式，既可以使页表连续，也可以占用空间少呢？\n\n> 在平时读书时，我们要锁定某一页，会从找这一页所在的目录，然后浏览这个目录下的具体页就行了。而在操作系统中，多级页表就是这样的目录。多级页表又划分为页目录项和页表，只会将需要的页加载到内存中去。\n\n下面我们来具体分析这个过程——\n\n![image-20210707195238389](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195238389.png)\n\n在**虚拟内存**中，一个具体的地址由**四个字节**来指示，**前十位存储页目录号**，接下来的**10位用来存放页号**，剩下的**12位用来页内地址的偏移**。\n\n页目录在内存中固定驻留，需要占用16K的内存空间。这远小于将所有页表加载到内存的4M。\n\n**页目录号**由**页目录指针**来指向，找到具体的目录后，然后**将这个目录中的页加载到内存**，接着找到具体的页，最终由**页内偏移**找到具体的**物理内存位置**。\n\n### 快表\n\n看书时，作者总会有意给读者标注出**重点的章节**，这样我们找有用知识的**时间又会减少很多**，同样，对于多级页表来说，16K的页表**寻址**起来也是很**浪费时间**的，能不能给我把**常用的页标注起来**呢？\n\n这种思想在互联网中是常见的，**浏览器会将经常访问的域名做缓存**，**数据库会对经常用到的sql语句和数据做缓存**，而在操作系统中，由**TLB**来存储页目录的缓存。\n\n- [x] TCB，也就是快表，它是一种**相连存储的寄存器**\n\n![image-20210707195249863](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195249863.png)\n\n首先在TLB中找是否存在对应的逻辑地址，**如果有**，直接转化**逻辑地址到物理地址**，当然，这一步**对于用户是透明**的。\n\n如果在TLB中**没有找到**逻辑地址，即TLB未命中，那么就需要通过**多级页表**来查找。\n\n那么TLB在理论层面是很好用，但真正应用效果如何呢？\n\n![image-20210707195302146](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195302146.png)\n\n可以看到，TLB的效率的确很高，但是需要建立在TLB命中率高的情况下的，然而实际情况下TLB是不大的，那为什么仍然可以发挥作用呢?这是因为**程序的地址访问**存在**局部性**——\n\n![image-20210707195318860](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195318860.png)\n\n## 4、段页结合的实际内存管理\n\n### 内存管理的模型\n\n段是程序员编写程序的方式，而页是物理内存的使用方式，那如何将段页结合呢？\n\n![image-20210707195330375](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195330375.png)\n\n首先在**虚拟内存**中划分一段**地址空间**用于存放应用程序的段。\n\n- [x] 这里的地址空间只是**逻辑上**的，**物理地址**还需要做进一步的**映射**。\n\n这里的**虚拟内存是分段**的，接着将分段的虚拟内存映射到**分页的物理地址**上去。\n\n而从用户的角度来说：段面向用户，页面向硬件。从逻辑地址到物理地址的映射对于用户时透明的，只有映射到段是对用户可见的。\n\n![image-20210707195343879](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195343879.png)\n\n### 一个实际的段，页结合\n\n要体现实际的内存管理，那就一定要**使用内存**，而使用内存即是**将程序加载到内存**，加载到内存的程序更具体的说它是一个**进程**。\n\n则所谓的内存管理是从**进程创建**开始的，而进程创建时使用**fork系统调用**，故事的大幕也便就此拉开了——\n\n- [x] 这个过程分为**分割虚拟内存**-》**建段表**-》**分配到物理内存**-》**建页表**-》**映射完成**\n\n![image-20210707195411176](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195411176.png)\n\n上图首先在**copy_process函数**中调用**copy_mem函数**，在该函数中首先**分配虚存**，为每个**进程**分配**64MB**的虚存，要注意的是虚存地址是**不重复**的，这样就不会导致相同的地址冲突。\n\n接着**建立段表**，也就是在PCB中建立**段表LDT**，在后期进程切换的时候，PCB也就跟着切换。\n\n接下来开始分配物理内存——\n\n![image-20210707195423193](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195423193.png)\n\n调用**copy_page_tables函数**将虚拟内存的地址**old_data_base映射**到物理内存的地址**new_data_base**，在这个函数中，**虚拟地址用from_dir指代**，**物理地址用to_dir指代**，需要注意的是：\n\nfrom右移22位得到**目录项的编号**，又因为一个虚拟地址占4个字节，则表现为from>>20\n\n![image-20210707195447747](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195447747.png)\n\n在下面的循环中，将具体的页映射到物理地址——\n\n![image-20210707195510386](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195510386.png)\n\n最终，执行指令，在对应的内存地址空间中完成**写时复制**，即经**地址总线**将数据发送到物理空间中，整个过程的**地址翻译**由**硬件MMU**完成，将**逻辑地址**翻译为**虚拟地址**，再将虚拟地址翻译为**物理地址**——\n\n![image-20210707195523166](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195523166.png)\n\n完结——\n\n![image-20210707195535245](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195535245.png)\n\n------\n\n> 山高路远，静水深流","source":"_posts/内存管理.md","raw":"---\ntitle: 内存管理\ntop: true\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 11:21:50\npassword:\nsummary: \ncategories: 计算机基础\ntags: \n\t- 操作系统\n\t- linux0.11\n---\n\n## 1、内存使用与分段\n\n我们知道，计算机运行的**核心**不外于**取指执行**，而从**哪里取指令**呢，自然是**内存**，更具体的说，是从**磁盘加载到内存**中的一段程序。但指令有很多，我们要取得**哪一个指令的地址**呢？我们从用户视角看，程序是从**main函数**开始执行的，而从汇编的角度来说，就是程序入口**ENTRY之后的地址**。\n\n那首先先让程序进入内存，而程序很**自然**的就要放在entry之后指定的那个地址中。我们假设这段程序就放在以**0x0000为起始地址**的这段内存里。这时**冲突**产生了。这段内存是用于操作系统初始化时放置指令的**固定**的区域。\n\n那么，程序的入口地址显然需要定位到另一段**空闲的内存空间**，用专业术语说，就是指**重定向**。\n\n> 重定向 : 修改程序中的地址，使其变成相对地址\n\n而重定向的方式有两种，**直接定位到新的地址**和**基地址加上变化的偏移地址**，这里我们更多的去使用偏移地址，也就是**相对地址**。\n\n既然知道需要将地址重定向，那我们就试着在运行程序的过程中**引入重定向**，但这又让人犯难了，就拿汇编来说，程序执行的过程需要经过**编译**，**连接**，**运行**三个过程，那我们要在那个阶段重定向呢？\n\n假设在编译时重定向，这时将地址提前进行偏移放置在一段空闲地址中，但运行的时候，这段空闲地址被**别的进程占用**了，嗯，计算机的世界也充满着无常，我们不如试试载入内存时重定向——\n\n这种想法好像还行，起码内存是自己的了。但是谁告诉你重定向只会发生一次呢？为了灵活完成任务，**交换**变得必不可少，难道我要**载入n次**吗？好的，下一位：\n\n那就**运行时载入**吧，这种动态切换的方式的确**满足了所有需求**，它总会申请一段空闲的，在一定时间内被自己使用的内存。\n\n------\n\n到这里已经迈出了一大步，既然初步的想法确定了，我们接下来先将这个想法规范化，这里我们引入**地址翻译**与**逻辑地址**，**物理地址**的概念。\n\n所谓地址翻译，就是指每执行一条指令，都要从逻辑地址算出物理地址。我们来看下面的例子\n\nmov ax , [300]\n\n这里的300是偏移地址，换句话说，这里的[300]指的是逻辑地址，而实际的[300]表示的物理地址等于当前这个**固定的偏移地址**加上**变化的基地址**。\n\n那我既然每执行一条指令都要用到基地址，那基地址应该是一个**全局的变量**，而对于一个运行的程序，也就是进程来说，这个全局的变量应该存储在**PCB**中，又因为它被用到的**频率很高**，进而它会被放置在CPU的零级缓存——**寄存器ldtr**中。\n\n- [x] GDT表示全局描述符，段描述符被放置在GDT中，用来对任务实现隔离。而有GDT，就自然也衍生了LDT，即局部描述符，它专属于某个任务。\n\n这时程序的一次执行已经可以完成了，我们不妨记做**flag1**\n\n------\n\n### 分段\n\n为了更好地使用内存，**分治思想**的引入自然势在必行，程序根据每一段代码的**属性**与**功能**将其分成了多个段，分析每个段的功能变得容易了很多。这个时候，**段**才是程序运行的**单元**。\n\n这个单元有它的**状态**，它的**执行结果**等等，而在程序载入的时候，这些**段**也被载入到**不同的地址**中，降低了管理的复杂度。\n\n为了**描述**这些段的信息，同时方便管理这些个段，就衍生出了进程的**段表**——**LDT**,段表中存放每个段的基地址，段号，长度，权限等等——\n\n![1](https://raw.githubusercontent.com/future727/Pictures/main/img/image-20210627160125632.png)\n\n这个表的思想不是第一次引入，更准确的说，在**操作系统启动**的时候就需要维护一个段表——**GDT**,操作系统故事的大幕也是就此揭开的。\n\n对于内存的使用，大的来说是分**三个阶段**的，首先将**程序分段**，这是在**编译时期**完成的，我们只需要显式的告诉编译器自己声明的不同的段，接着就需要在内存中找出一段**空闲的内存空间**，那是哪一段呢？怎么知道这段内存可以被使用呢？这些是后话了；最后就将分好段的程序**载入**到分好区的内存中执行。\n\n第一步我们已经完成了，我们接下来就来看分区思想是如何引入的，内存又是如何实现分区的？\n\n------\n\n## 2、内存分区与分页\n\n- [x] 如何分区？描述分区后的每段内存，如何表示已经分出去了，如何将这段内存用作特定用途？\n- [x] 分成定长的/不定长的；如何描述内存段；分配的算法？分区会导致什么问题？分页\n\n这里首先来说些题外话，在开始这节之前，我试着提出针对内存分区我认为应该提出的问题，但事实证明，我**思维的出发点**是错的，\n\n针对内存分区的具体问题，我开门见山的认为应该有描述分区后的数据结构，这样想固然没错，但更重要的对于一个**实际系统的架构**，从**需求入手才是最切实**的，对于内存分区，为什么要分区，因为**程序分段**的思想，决定**段的大小是不定**的，而与之对应的，加载到的那段内存也应该是与段的大小相匹配的。\n\n------\n\n现在我们开始进入正题，程序分段的引入导致每一个段的长度是不一样的，而**内存**只是一个用来装载指令和数据的**容器**，**容器的大小是由我需要多少水来决定的**，相应的，为每个程序段申请的空闲内存的大小也是由段来决定的，因此，定长的分配内存显然是不可取的，这里我们根据**段的长度**决定**申请的内存空间**。\n\n那申请内存的时候，我们自然就需要知道那段内存是空闲的，这段内存有多大。这样我们就需要一个可以用来**描述这些信息的数据结构**，**分区表**就被引入进来了。当我们需要的内存空间大小和这段空间**近似匹配**的时候，我们就将程序加载进去，执行完了再将内存空间释放。\n\n那在匹配内存空间的时候，就出现了问题，我们是应该**就近匹配**，还是花费时间做**最优匹配**呢？这里没有对错之分，可以参考相应的**时间**，**空间复杂度**和**占用空间大小**灵活选择。\n\n虽然分区解决了内存使用的一部分问题，但我们考虑这样的例子：假如一个200K的段申请了一段500K的内存空间，但剩余的300K，别的段并不能使用。很多这样的**内存碎片**聚少成多，就造成了**内存空间的浪费**。\n\n解决内存碎片直观的想法就是将没有的内存合并，也就是内存紧缩，但内存紧缩时，需要调整**每条指令**的基地址，这个**任务量是巨大的**，这种方式不可取。\n\n这里，我们可以将内存分页，在**操作系统初始化**的时候，**memmap**会将内存分成**4k的页单元**，页单元由**页框号指示**中，而页框号的位置又由**页头指针**来指向，这个指针最终被放到了**寄存器**中。\n\n## 3、多级页表和快表\n\n### 多级页表\n\n上一小节提出了一种**可行**的将**内存分页**的**思想**。但实际应用与理论总是存在**差距**的，我们首先**量化**的来看维护单个页需要的**内存开销**：\n\n一页内存有4K的空间，而32位的系统有32位的地址总线，也就是说它的寻址能力是2的32次方，也就是4GB，那么操作系统就需要维护4GB/4KB=2的**20次方个页表**，也就是**1MB**的内存空间，一个进程需要1MB的内存空间，而多个进程**并发执行**，需要空间就会变得很大，这样显然**不可取**。\n\n但这里有一个**误区**，有很多页表在实际使用中是被**闲置**的，既然它是闲置的，我们就不需要维护它，也就是说我们可以**删去部分不会用到的页表**，这样的话，假设就只需要1KB的空间来存储页表了，但**页表**是存储在**PCB**中的，PCB又是会被加载到**内存**的，而加载到内存的过程也是需要**维护队列等数据结构**的，**访存的开销太大**了。\n\n那能不能有一种方式，既可以使页表连续，也可以占用空间少呢？\n\n> 在平时读书时，我们要锁定某一页，会从找这一页所在的目录，然后浏览这个目录下的具体页就行了。而在操作系统中，多级页表就是这样的目录。多级页表又划分为页目录项和页表，只会将需要的页加载到内存中去。\n\n下面我们来具体分析这个过程——\n\n![image-20210707195238389](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195238389.png)\n\n在**虚拟内存**中，一个具体的地址由**四个字节**来指示，**前十位存储页目录号**，接下来的**10位用来存放页号**，剩下的**12位用来页内地址的偏移**。\n\n页目录在内存中固定驻留，需要占用16K的内存空间。这远小于将所有页表加载到内存的4M。\n\n**页目录号**由**页目录指针**来指向，找到具体的目录后，然后**将这个目录中的页加载到内存**，接着找到具体的页，最终由**页内偏移**找到具体的**物理内存位置**。\n\n### 快表\n\n看书时，作者总会有意给读者标注出**重点的章节**，这样我们找有用知识的**时间又会减少很多**，同样，对于多级页表来说，16K的页表**寻址**起来也是很**浪费时间**的，能不能给我把**常用的页标注起来**呢？\n\n这种思想在互联网中是常见的，**浏览器会将经常访问的域名做缓存**，**数据库会对经常用到的sql语句和数据做缓存**，而在操作系统中，由**TLB**来存储页目录的缓存。\n\n- [x] TCB，也就是快表，它是一种**相连存储的寄存器**\n\n![image-20210707195249863](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195249863.png)\n\n首先在TLB中找是否存在对应的逻辑地址，**如果有**，直接转化**逻辑地址到物理地址**，当然，这一步**对于用户是透明**的。\n\n如果在TLB中**没有找到**逻辑地址，即TLB未命中，那么就需要通过**多级页表**来查找。\n\n那么TLB在理论层面是很好用，但真正应用效果如何呢？\n\n![image-20210707195302146](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195302146.png)\n\n可以看到，TLB的效率的确很高，但是需要建立在TLB命中率高的情况下的，然而实际情况下TLB是不大的，那为什么仍然可以发挥作用呢?这是因为**程序的地址访问**存在**局部性**——\n\n![image-20210707195318860](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195318860.png)\n\n## 4、段页结合的实际内存管理\n\n### 内存管理的模型\n\n段是程序员编写程序的方式，而页是物理内存的使用方式，那如何将段页结合呢？\n\n![image-20210707195330375](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195330375.png)\n\n首先在**虚拟内存**中划分一段**地址空间**用于存放应用程序的段。\n\n- [x] 这里的地址空间只是**逻辑上**的，**物理地址**还需要做进一步的**映射**。\n\n这里的**虚拟内存是分段**的，接着将分段的虚拟内存映射到**分页的物理地址**上去。\n\n而从用户的角度来说：段面向用户，页面向硬件。从逻辑地址到物理地址的映射对于用户时透明的，只有映射到段是对用户可见的。\n\n![image-20210707195343879](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195343879.png)\n\n### 一个实际的段，页结合\n\n要体现实际的内存管理，那就一定要**使用内存**，而使用内存即是**将程序加载到内存**，加载到内存的程序更具体的说它是一个**进程**。\n\n则所谓的内存管理是从**进程创建**开始的，而进程创建时使用**fork系统调用**，故事的大幕也便就此拉开了——\n\n- [x] 这个过程分为**分割虚拟内存**-》**建段表**-》**分配到物理内存**-》**建页表**-》**映射完成**\n\n![image-20210707195411176](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195411176.png)\n\n上图首先在**copy_process函数**中调用**copy_mem函数**，在该函数中首先**分配虚存**，为每个**进程**分配**64MB**的虚存，要注意的是虚存地址是**不重复**的，这样就不会导致相同的地址冲突。\n\n接着**建立段表**，也就是在PCB中建立**段表LDT**，在后期进程切换的时候，PCB也就跟着切换。\n\n接下来开始分配物理内存——\n\n![image-20210707195423193](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195423193.png)\n\n调用**copy_page_tables函数**将虚拟内存的地址**old_data_base映射**到物理内存的地址**new_data_base**，在这个函数中，**虚拟地址用from_dir指代**，**物理地址用to_dir指代**，需要注意的是：\n\nfrom右移22位得到**目录项的编号**，又因为一个虚拟地址占4个字节，则表现为from>>20\n\n![image-20210707195447747](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195447747.png)\n\n在下面的循环中，将具体的页映射到物理地址——\n\n![image-20210707195510386](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195510386.png)\n\n最终，执行指令，在对应的内存地址空间中完成**写时复制**，即经**地址总线**将数据发送到物理空间中，整个过程的**地址翻译**由**硬件MMU**完成，将**逻辑地址**翻译为**虚拟地址**，再将虚拟地址翻译为**物理地址**——\n\n![image-20210707195523166](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195523166.png)\n\n完结——\n\n![image-20210707195535245](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195535245.png)\n\n------\n\n> 山高路远，静水深流","slug":"内存管理","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7kz000dxjcc0zt6fjzb","content":"<h2 id=\"1、内存使用与分段\"><a href=\"#1、内存使用与分段\" class=\"headerlink\" title=\"1、内存使用与分段\"></a>1、内存使用与分段</h2><p>我们知道，计算机运行的<strong>核心</strong>不外于<strong>取指执行</strong>，而从<strong>哪里取指令</strong>呢，自然是<strong>内存</strong>，更具体的说，是从<strong>磁盘加载到内存</strong>中的一段程序。但指令有很多，我们要取得<strong>哪一个指令的地址</strong>呢？我们从用户视角看，程序是从<strong>main函数</strong>开始执行的，而从汇编的角度来说，就是程序入口<strong>ENTRY之后的地址</strong>。</p>\n<p>那首先先让程序进入内存，而程序很<strong>自然</strong>的就要放在entry之后指定的那个地址中。我们假设这段程序就放在以<strong>0x0000为起始地址</strong>的这段内存里。这时<strong>冲突</strong>产生了。这段内存是用于操作系统初始化时放置指令的<strong>固定</strong>的区域。</p>\n<p>那么，程序的入口地址显然需要定位到另一段<strong>空闲的内存空间</strong>，用专业术语说，就是指<strong>重定向</strong>。</p>\n<blockquote>\n<p>重定向 : 修改程序中的地址，使其变成相对地址</p>\n</blockquote>\n<p>而重定向的方式有两种，<strong>直接定位到新的地址</strong>和<strong>基地址加上变化的偏移地址</strong>，这里我们更多的去使用偏移地址，也就是<strong>相对地址</strong>。</p>\n<p>既然知道需要将地址重定向，那我们就试着在运行程序的过程中<strong>引入重定向</strong>，但这又让人犯难了，就拿汇编来说，程序执行的过程需要经过<strong>编译</strong>，<strong>连接</strong>，<strong>运行</strong>三个过程，那我们要在那个阶段重定向呢？</p>\n<p>假设在编译时重定向，这时将地址提前进行偏移放置在一段空闲地址中，但运行的时候，这段空闲地址被<strong>别的进程占用</strong>了，嗯，计算机的世界也充满着无常，我们不如试试载入内存时重定向——</p>\n<p>这种想法好像还行，起码内存是自己的了。但是谁告诉你重定向只会发生一次呢？为了灵活完成任务，<strong>交换</strong>变得必不可少，难道我要<strong>载入n次</strong>吗？好的，下一位：</p>\n<p>那就<strong>运行时载入</strong>吧，这种动态切换的方式的确<strong>满足了所有需求</strong>，它总会申请一段空闲的，在一定时间内被自己使用的内存。</p>\n<hr>\n<p>到这里已经迈出了一大步，既然初步的想法确定了，我们接下来先将这个想法规范化，这里我们引入<strong>地址翻译</strong>与<strong>逻辑地址</strong>，<strong>物理地址</strong>的概念。</p>\n<p>所谓地址翻译，就是指每执行一条指令，都要从逻辑地址算出物理地址。我们来看下面的例子</p>\n<p>mov ax , [300]</p>\n<p>这里的300是偏移地址，换句话说，这里的[300]指的是逻辑地址，而实际的[300]表示的物理地址等于当前这个<strong>固定的偏移地址</strong>加上<strong>变化的基地址</strong>。</p>\n<p>那我既然每执行一条指令都要用到基地址，那基地址应该是一个<strong>全局的变量</strong>，而对于一个运行的程序，也就是进程来说，这个全局的变量应该存储在<strong>PCB</strong>中，又因为它被用到的<strong>频率很高</strong>，进而它会被放置在CPU的零级缓存——<strong>寄存器ldtr</strong>中。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> GDT表示全局描述符，段描述符被放置在GDT中，用来对任务实现隔离。而有GDT，就自然也衍生了LDT，即局部描述符，它专属于某个任务。</li>\n</ul>\n<p>这时程序的一次执行已经可以完成了，我们不妨记做<strong>flag1</strong></p>\n<hr>\n<h3 id=\"分段\"><a href=\"#分段\" class=\"headerlink\" title=\"分段\"></a>分段</h3><p>为了更好地使用内存，<strong>分治思想</strong>的引入自然势在必行，程序根据每一段代码的<strong>属性</strong>与<strong>功能</strong>将其分成了多个段，分析每个段的功能变得容易了很多。这个时候，<strong>段</strong>才是程序运行的<strong>单元</strong>。</p>\n<p>这个单元有它的<strong>状态</strong>，它的<strong>执行结果</strong>等等，而在程序载入的时候，这些<strong>段</strong>也被载入到<strong>不同的地址</strong>中，降低了管理的复杂度。</p>\n<p>为了<strong>描述</strong>这些段的信息，同时方便管理这些个段，就衍生出了进程的<strong>段表</strong>——<strong>LDT</strong>,段表中存放每个段的基地址，段号，长度，权限等等——</p>\n<p><img src=\"https://raw.githubusercontent.com/future727/Pictures/main/img/image-20210627160125632.png\" alt=\"1\"></p>\n<p>这个表的思想不是第一次引入，更准确的说，在<strong>操作系统启动</strong>的时候就需要维护一个段表——<strong>GDT</strong>,操作系统故事的大幕也是就此揭开的。</p>\n<p>对于内存的使用，大的来说是分<strong>三个阶段</strong>的，首先将<strong>程序分段</strong>，这是在<strong>编译时期</strong>完成的，我们只需要显式的告诉编译器自己声明的不同的段，接着就需要在内存中找出一段<strong>空闲的内存空间</strong>，那是哪一段呢？怎么知道这段内存可以被使用呢？这些是后话了；最后就将分好段的程序<strong>载入</strong>到分好区的内存中执行。</p>\n<p>第一步我们已经完成了，我们接下来就来看分区思想是如何引入的，内存又是如何实现分区的？</p>\n<hr>\n<h2 id=\"2、内存分区与分页\"><a href=\"#2、内存分区与分页\" class=\"headerlink\" title=\"2、内存分区与分页\"></a>2、内存分区与分页</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 如何分区？描述分区后的每段内存，如何表示已经分出去了，如何将这段内存用作特定用途？</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 分成定长的/不定长的；如何描述内存段；分配的算法？分区会导致什么问题？分页</li>\n</ul>\n<p>这里首先来说些题外话，在开始这节之前，我试着提出针对内存分区我认为应该提出的问题，但事实证明，我<strong>思维的出发点</strong>是错的，</p>\n<p>针对内存分区的具体问题，我开门见山的认为应该有描述分区后的数据结构，这样想固然没错，但更重要的对于一个<strong>实际系统的架构</strong>，从<strong>需求入手才是最切实</strong>的，对于内存分区，为什么要分区，因为<strong>程序分段</strong>的思想，决定<strong>段的大小是不定</strong>的，而与之对应的，加载到的那段内存也应该是与段的大小相匹配的。</p>\n<hr>\n<p>现在我们开始进入正题，程序分段的引入导致每一个段的长度是不一样的，而<strong>内存</strong>只是一个用来装载指令和数据的<strong>容器</strong>，<strong>容器的大小是由我需要多少水来决定的</strong>，相应的，为每个程序段申请的空闲内存的大小也是由段来决定的，因此，定长的分配内存显然是不可取的，这里我们根据<strong>段的长度</strong>决定<strong>申请的内存空间</strong>。</p>\n<p>那申请内存的时候，我们自然就需要知道那段内存是空闲的，这段内存有多大。这样我们就需要一个可以用来<strong>描述这些信息的数据结构</strong>，<strong>分区表</strong>就被引入进来了。当我们需要的内存空间大小和这段空间<strong>近似匹配</strong>的时候，我们就将程序加载进去，执行完了再将内存空间释放。</p>\n<p>那在匹配内存空间的时候，就出现了问题，我们是应该<strong>就近匹配</strong>，还是花费时间做<strong>最优匹配</strong>呢？这里没有对错之分，可以参考相应的<strong>时间</strong>，<strong>空间复杂度</strong>和<strong>占用空间大小</strong>灵活选择。</p>\n<p>虽然分区解决了内存使用的一部分问题，但我们考虑这样的例子：假如一个200K的段申请了一段500K的内存空间，但剩余的300K，别的段并不能使用。很多这样的<strong>内存碎片</strong>聚少成多，就造成了<strong>内存空间的浪费</strong>。</p>\n<p>解决内存碎片直观的想法就是将没有的内存合并，也就是内存紧缩，但内存紧缩时，需要调整<strong>每条指令</strong>的基地址，这个<strong>任务量是巨大的</strong>，这种方式不可取。</p>\n<p>这里，我们可以将内存分页，在<strong>操作系统初始化</strong>的时候，<strong>memmap</strong>会将内存分成<strong>4k的页单元</strong>，页单元由<strong>页框号指示</strong>中，而页框号的位置又由<strong>页头指针</strong>来指向，这个指针最终被放到了<strong>寄存器</strong>中。</p>\n<h2 id=\"3、多级页表和快表\"><a href=\"#3、多级页表和快表\" class=\"headerlink\" title=\"3、多级页表和快表\"></a>3、多级页表和快表</h2><h3 id=\"多级页表\"><a href=\"#多级页表\" class=\"headerlink\" title=\"多级页表\"></a>多级页表</h3><p>上一小节提出了一种<strong>可行</strong>的将<strong>内存分页</strong>的<strong>思想</strong>。但实际应用与理论总是存在<strong>差距</strong>的，我们首先<strong>量化</strong>的来看维护单个页需要的<strong>内存开销</strong>：</p>\n<p>一页内存有4K的空间，而32位的系统有32位的地址总线，也就是说它的寻址能力是2的32次方，也就是4GB，那么操作系统就需要维护4GB/4KB=2的<strong>20次方个页表</strong>，也就是<strong>1MB</strong>的内存空间，一个进程需要1MB的内存空间，而多个进程<strong>并发执行</strong>，需要空间就会变得很大，这样显然<strong>不可取</strong>。</p>\n<p>但这里有一个<strong>误区</strong>，有很多页表在实际使用中是被<strong>闲置</strong>的，既然它是闲置的，我们就不需要维护它，也就是说我们可以<strong>删去部分不会用到的页表</strong>，这样的话，假设就只需要1KB的空间来存储页表了，但<strong>页表</strong>是存储在<strong>PCB</strong>中的，PCB又是会被加载到<strong>内存</strong>的，而加载到内存的过程也是需要<strong>维护队列等数据结构</strong>的，<strong>访存的开销太大</strong>了。</p>\n<p>那能不能有一种方式，既可以使页表连续，也可以占用空间少呢？</p>\n<blockquote>\n<p>在平时读书时，我们要锁定某一页，会从找这一页所在的目录，然后浏览这个目录下的具体页就行了。而在操作系统中，多级页表就是这样的目录。多级页表又划分为页目录项和页表，只会将需要的页加载到内存中去。</p>\n</blockquote>\n<p>下面我们来具体分析这个过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195238389.png\" alt=\"image-20210707195238389\"></p>\n<p>在<strong>虚拟内存</strong>中，一个具体的地址由<strong>四个字节</strong>来指示，<strong>前十位存储页目录号</strong>，接下来的<strong>10位用来存放页号</strong>，剩下的<strong>12位用来页内地址的偏移</strong>。</p>\n<p>页目录在内存中固定驻留，需要占用16K的内存空间。这远小于将所有页表加载到内存的4M。</p>\n<p><strong>页目录号</strong>由<strong>页目录指针</strong>来指向，找到具体的目录后，然后<strong>将这个目录中的页加载到内存</strong>，接着找到具体的页，最终由<strong>页内偏移</strong>找到具体的<strong>物理内存位置</strong>。</p>\n<h3 id=\"快表\"><a href=\"#快表\" class=\"headerlink\" title=\"快表\"></a>快表</h3><p>看书时，作者总会有意给读者标注出<strong>重点的章节</strong>，这样我们找有用知识的<strong>时间又会减少很多</strong>，同样，对于多级页表来说，16K的页表<strong>寻址</strong>起来也是很<strong>浪费时间</strong>的，能不能给我把<strong>常用的页标注起来</strong>呢？</p>\n<p>这种思想在互联网中是常见的，<strong>浏览器会将经常访问的域名做缓存</strong>，<strong>数据库会对经常用到的sql语句和数据做缓存</strong>，而在操作系统中，由<strong>TLB</strong>来存储页目录的缓存。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> TCB，也就是快表，它是一种<strong>相连存储的寄存器</strong></li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195249863.png\" alt=\"image-20210707195249863\"></p>\n<p>首先在TLB中找是否存在对应的逻辑地址，<strong>如果有</strong>，直接转化<strong>逻辑地址到物理地址</strong>，当然，这一步<strong>对于用户是透明</strong>的。</p>\n<p>如果在TLB中<strong>没有找到</strong>逻辑地址，即TLB未命中，那么就需要通过<strong>多级页表</strong>来查找。</p>\n<p>那么TLB在理论层面是很好用，但真正应用效果如何呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195302146.png\" alt=\"image-20210707195302146\"></p>\n<p>可以看到，TLB的效率的确很高，但是需要建立在TLB命中率高的情况下的，然而实际情况下TLB是不大的，那为什么仍然可以发挥作用呢?这是因为<strong>程序的地址访问</strong>存在<strong>局部性</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195318860.png\" alt=\"image-20210707195318860\"></p>\n<h2 id=\"4、段页结合的实际内存管理\"><a href=\"#4、段页结合的实际内存管理\" class=\"headerlink\" title=\"4、段页结合的实际内存管理\"></a>4、段页结合的实际内存管理</h2><h3 id=\"内存管理的模型\"><a href=\"#内存管理的模型\" class=\"headerlink\" title=\"内存管理的模型\"></a>内存管理的模型</h3><p>段是程序员编写程序的方式，而页是物理内存的使用方式，那如何将段页结合呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195330375.png\" alt=\"image-20210707195330375\"></p>\n<p>首先在<strong>虚拟内存</strong>中划分一段<strong>地址空间</strong>用于存放应用程序的段。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 这里的地址空间只是<strong>逻辑上</strong>的，<strong>物理地址</strong>还需要做进一步的<strong>映射</strong>。</li>\n</ul>\n<p>这里的<strong>虚拟内存是分段</strong>的，接着将分段的虚拟内存映射到<strong>分页的物理地址</strong>上去。</p>\n<p>而从用户的角度来说：段面向用户，页面向硬件。从逻辑地址到物理地址的映射对于用户时透明的，只有映射到段是对用户可见的。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195343879.png\" alt=\"image-20210707195343879\"></p>\n<h3 id=\"一个实际的段，页结合\"><a href=\"#一个实际的段，页结合\" class=\"headerlink\" title=\"一个实际的段，页结合\"></a>一个实际的段，页结合</h3><p>要体现实际的内存管理，那就一定要<strong>使用内存</strong>，而使用内存即是<strong>将程序加载到内存</strong>，加载到内存的程序更具体的说它是一个<strong>进程</strong>。</p>\n<p>则所谓的内存管理是从<strong>进程创建</strong>开始的，而进程创建时使用<strong>fork系统调用</strong>，故事的大幕也便就此拉开了——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 这个过程分为<strong>分割虚拟内存</strong>-》<strong>建段表</strong>-》<strong>分配到物理内存</strong>-》<strong>建页表</strong>-》<strong>映射完成</strong></li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195411176.png\" alt=\"image-20210707195411176\"></p>\n<p>上图首先在<strong>copy_process函数</strong>中调用<strong>copy_mem函数</strong>，在该函数中首先<strong>分配虚存</strong>，为每个<strong>进程</strong>分配<strong>64MB</strong>的虚存，要注意的是虚存地址是<strong>不重复</strong>的，这样就不会导致相同的地址冲突。</p>\n<p>接着<strong>建立段表</strong>，也就是在PCB中建立<strong>段表LDT</strong>，在后期进程切换的时候，PCB也就跟着切换。</p>\n<p>接下来开始分配物理内存——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195423193.png\" alt=\"image-20210707195423193\"></p>\n<p>调用<strong>copy_page_tables函数</strong>将虚拟内存的地址<strong>old_data_base映射</strong>到物理内存的地址<strong>new_data_base</strong>，在这个函数中，<strong>虚拟地址用from_dir指代</strong>，<strong>物理地址用to_dir指代</strong>，需要注意的是：</p>\n<p>from右移22位得到<strong>目录项的编号</strong>，又因为一个虚拟地址占4个字节，则表现为from&gt;&gt;20</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195447747.png\" alt=\"image-20210707195447747\"></p>\n<p>在下面的循环中，将具体的页映射到物理地址——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195510386.png\" alt=\"image-20210707195510386\"></p>\n<p>最终，执行指令，在对应的内存地址空间中完成<strong>写时复制</strong>，即经<strong>地址总线</strong>将数据发送到物理空间中，整个过程的<strong>地址翻译</strong>由<strong>硬件MMU</strong>完成，将<strong>逻辑地址</strong>翻译为<strong>虚拟地址</strong>，再将虚拟地址翻译为<strong>物理地址</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195523166.png\" alt=\"image-20210707195523166\"></p>\n<p>完结——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195535245.png\" alt=\"image-20210707195535245\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、内存使用与分段\"><a href=\"#1、内存使用与分段\" class=\"headerlink\" title=\"1、内存使用与分段\"></a>1、内存使用与分段</h2><p>我们知道，计算机运行的<strong>核心</strong>不外于<strong>取指执行</strong>，而从<strong>哪里取指令</strong>呢，自然是<strong>内存</strong>，更具体的说，是从<strong>磁盘加载到内存</strong>中的一段程序。但指令有很多，我们要取得<strong>哪一个指令的地址</strong>呢？我们从用户视角看，程序是从<strong>main函数</strong>开始执行的，而从汇编的角度来说，就是程序入口<strong>ENTRY之后的地址</strong>。</p>\n<p>那首先先让程序进入内存，而程序很<strong>自然</strong>的就要放在entry之后指定的那个地址中。我们假设这段程序就放在以<strong>0x0000为起始地址</strong>的这段内存里。这时<strong>冲突</strong>产生了。这段内存是用于操作系统初始化时放置指令的<strong>固定</strong>的区域。</p>\n<p>那么，程序的入口地址显然需要定位到另一段<strong>空闲的内存空间</strong>，用专业术语说，就是指<strong>重定向</strong>。</p>\n<blockquote>\n<p>重定向 : 修改程序中的地址，使其变成相对地址</p>\n</blockquote>\n<p>而重定向的方式有两种，<strong>直接定位到新的地址</strong>和<strong>基地址加上变化的偏移地址</strong>，这里我们更多的去使用偏移地址，也就是<strong>相对地址</strong>。</p>\n<p>既然知道需要将地址重定向，那我们就试着在运行程序的过程中<strong>引入重定向</strong>，但这又让人犯难了，就拿汇编来说，程序执行的过程需要经过<strong>编译</strong>，<strong>连接</strong>，<strong>运行</strong>三个过程，那我们要在那个阶段重定向呢？</p>\n<p>假设在编译时重定向，这时将地址提前进行偏移放置在一段空闲地址中，但运行的时候，这段空闲地址被<strong>别的进程占用</strong>了，嗯，计算机的世界也充满着无常，我们不如试试载入内存时重定向——</p>\n<p>这种想法好像还行，起码内存是自己的了。但是谁告诉你重定向只会发生一次呢？为了灵活完成任务，<strong>交换</strong>变得必不可少，难道我要<strong>载入n次</strong>吗？好的，下一位：</p>\n<p>那就<strong>运行时载入</strong>吧，这种动态切换的方式的确<strong>满足了所有需求</strong>，它总会申请一段空闲的，在一定时间内被自己使用的内存。</p>\n<hr>\n<p>到这里已经迈出了一大步，既然初步的想法确定了，我们接下来先将这个想法规范化，这里我们引入<strong>地址翻译</strong>与<strong>逻辑地址</strong>，<strong>物理地址</strong>的概念。</p>\n<p>所谓地址翻译，就是指每执行一条指令，都要从逻辑地址算出物理地址。我们来看下面的例子</p>\n<p>mov ax , [300]</p>\n<p>这里的300是偏移地址，换句话说，这里的[300]指的是逻辑地址，而实际的[300]表示的物理地址等于当前这个<strong>固定的偏移地址</strong>加上<strong>变化的基地址</strong>。</p>\n<p>那我既然每执行一条指令都要用到基地址，那基地址应该是一个<strong>全局的变量</strong>，而对于一个运行的程序，也就是进程来说，这个全局的变量应该存储在<strong>PCB</strong>中，又因为它被用到的<strong>频率很高</strong>，进而它会被放置在CPU的零级缓存——<strong>寄存器ldtr</strong>中。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> GDT表示全局描述符，段描述符被放置在GDT中，用来对任务实现隔离。而有GDT，就自然也衍生了LDT，即局部描述符，它专属于某个任务。</li>\n</ul>\n<p>这时程序的一次执行已经可以完成了，我们不妨记做<strong>flag1</strong></p>\n<hr>\n<h3 id=\"分段\"><a href=\"#分段\" class=\"headerlink\" title=\"分段\"></a>分段</h3><p>为了更好地使用内存，<strong>分治思想</strong>的引入自然势在必行，程序根据每一段代码的<strong>属性</strong>与<strong>功能</strong>将其分成了多个段，分析每个段的功能变得容易了很多。这个时候，<strong>段</strong>才是程序运行的<strong>单元</strong>。</p>\n<p>这个单元有它的<strong>状态</strong>，它的<strong>执行结果</strong>等等，而在程序载入的时候，这些<strong>段</strong>也被载入到<strong>不同的地址</strong>中，降低了管理的复杂度。</p>\n<p>为了<strong>描述</strong>这些段的信息，同时方便管理这些个段，就衍生出了进程的<strong>段表</strong>——<strong>LDT</strong>,段表中存放每个段的基地址，段号，长度，权限等等——</p>\n<p><img src=\"https://raw.githubusercontent.com/future727/Pictures/main/img/image-20210627160125632.png\" alt=\"1\"></p>\n<p>这个表的思想不是第一次引入，更准确的说，在<strong>操作系统启动</strong>的时候就需要维护一个段表——<strong>GDT</strong>,操作系统故事的大幕也是就此揭开的。</p>\n<p>对于内存的使用，大的来说是分<strong>三个阶段</strong>的，首先将<strong>程序分段</strong>，这是在<strong>编译时期</strong>完成的，我们只需要显式的告诉编译器自己声明的不同的段，接着就需要在内存中找出一段<strong>空闲的内存空间</strong>，那是哪一段呢？怎么知道这段内存可以被使用呢？这些是后话了；最后就将分好段的程序<strong>载入</strong>到分好区的内存中执行。</p>\n<p>第一步我们已经完成了，我们接下来就来看分区思想是如何引入的，内存又是如何实现分区的？</p>\n<hr>\n<h2 id=\"2、内存分区与分页\"><a href=\"#2、内存分区与分页\" class=\"headerlink\" title=\"2、内存分区与分页\"></a>2、内存分区与分页</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 如何分区？描述分区后的每段内存，如何表示已经分出去了，如何将这段内存用作特定用途？</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 分成定长的/不定长的；如何描述内存段；分配的算法？分区会导致什么问题？分页</li>\n</ul>\n<p>这里首先来说些题外话，在开始这节之前，我试着提出针对内存分区我认为应该提出的问题，但事实证明，我<strong>思维的出发点</strong>是错的，</p>\n<p>针对内存分区的具体问题，我开门见山的认为应该有描述分区后的数据结构，这样想固然没错，但更重要的对于一个<strong>实际系统的架构</strong>，从<strong>需求入手才是最切实</strong>的，对于内存分区，为什么要分区，因为<strong>程序分段</strong>的思想，决定<strong>段的大小是不定</strong>的，而与之对应的，加载到的那段内存也应该是与段的大小相匹配的。</p>\n<hr>\n<p>现在我们开始进入正题，程序分段的引入导致每一个段的长度是不一样的，而<strong>内存</strong>只是一个用来装载指令和数据的<strong>容器</strong>，<strong>容器的大小是由我需要多少水来决定的</strong>，相应的，为每个程序段申请的空闲内存的大小也是由段来决定的，因此，定长的分配内存显然是不可取的，这里我们根据<strong>段的长度</strong>决定<strong>申请的内存空间</strong>。</p>\n<p>那申请内存的时候，我们自然就需要知道那段内存是空闲的，这段内存有多大。这样我们就需要一个可以用来<strong>描述这些信息的数据结构</strong>，<strong>分区表</strong>就被引入进来了。当我们需要的内存空间大小和这段空间<strong>近似匹配</strong>的时候，我们就将程序加载进去，执行完了再将内存空间释放。</p>\n<p>那在匹配内存空间的时候，就出现了问题，我们是应该<strong>就近匹配</strong>，还是花费时间做<strong>最优匹配</strong>呢？这里没有对错之分，可以参考相应的<strong>时间</strong>，<strong>空间复杂度</strong>和<strong>占用空间大小</strong>灵活选择。</p>\n<p>虽然分区解决了内存使用的一部分问题，但我们考虑这样的例子：假如一个200K的段申请了一段500K的内存空间，但剩余的300K，别的段并不能使用。很多这样的<strong>内存碎片</strong>聚少成多，就造成了<strong>内存空间的浪费</strong>。</p>\n<p>解决内存碎片直观的想法就是将没有的内存合并，也就是内存紧缩，但内存紧缩时，需要调整<strong>每条指令</strong>的基地址，这个<strong>任务量是巨大的</strong>，这种方式不可取。</p>\n<p>这里，我们可以将内存分页，在<strong>操作系统初始化</strong>的时候，<strong>memmap</strong>会将内存分成<strong>4k的页单元</strong>，页单元由<strong>页框号指示</strong>中，而页框号的位置又由<strong>页头指针</strong>来指向，这个指针最终被放到了<strong>寄存器</strong>中。</p>\n<h2 id=\"3、多级页表和快表\"><a href=\"#3、多级页表和快表\" class=\"headerlink\" title=\"3、多级页表和快表\"></a>3、多级页表和快表</h2><h3 id=\"多级页表\"><a href=\"#多级页表\" class=\"headerlink\" title=\"多级页表\"></a>多级页表</h3><p>上一小节提出了一种<strong>可行</strong>的将<strong>内存分页</strong>的<strong>思想</strong>。但实际应用与理论总是存在<strong>差距</strong>的，我们首先<strong>量化</strong>的来看维护单个页需要的<strong>内存开销</strong>：</p>\n<p>一页内存有4K的空间，而32位的系统有32位的地址总线，也就是说它的寻址能力是2的32次方，也就是4GB，那么操作系统就需要维护4GB/4KB=2的<strong>20次方个页表</strong>，也就是<strong>1MB</strong>的内存空间，一个进程需要1MB的内存空间，而多个进程<strong>并发执行</strong>，需要空间就会变得很大，这样显然<strong>不可取</strong>。</p>\n<p>但这里有一个<strong>误区</strong>，有很多页表在实际使用中是被<strong>闲置</strong>的，既然它是闲置的，我们就不需要维护它，也就是说我们可以<strong>删去部分不会用到的页表</strong>，这样的话，假设就只需要1KB的空间来存储页表了，但<strong>页表</strong>是存储在<strong>PCB</strong>中的，PCB又是会被加载到<strong>内存</strong>的，而加载到内存的过程也是需要<strong>维护队列等数据结构</strong>的，<strong>访存的开销太大</strong>了。</p>\n<p>那能不能有一种方式，既可以使页表连续，也可以占用空间少呢？</p>\n<blockquote>\n<p>在平时读书时，我们要锁定某一页，会从找这一页所在的目录，然后浏览这个目录下的具体页就行了。而在操作系统中，多级页表就是这样的目录。多级页表又划分为页目录项和页表，只会将需要的页加载到内存中去。</p>\n</blockquote>\n<p>下面我们来具体分析这个过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195238389.png\" alt=\"image-20210707195238389\"></p>\n<p>在<strong>虚拟内存</strong>中，一个具体的地址由<strong>四个字节</strong>来指示，<strong>前十位存储页目录号</strong>，接下来的<strong>10位用来存放页号</strong>，剩下的<strong>12位用来页内地址的偏移</strong>。</p>\n<p>页目录在内存中固定驻留，需要占用16K的内存空间。这远小于将所有页表加载到内存的4M。</p>\n<p><strong>页目录号</strong>由<strong>页目录指针</strong>来指向，找到具体的目录后，然后<strong>将这个目录中的页加载到内存</strong>，接着找到具体的页，最终由<strong>页内偏移</strong>找到具体的<strong>物理内存位置</strong>。</p>\n<h3 id=\"快表\"><a href=\"#快表\" class=\"headerlink\" title=\"快表\"></a>快表</h3><p>看书时，作者总会有意给读者标注出<strong>重点的章节</strong>，这样我们找有用知识的<strong>时间又会减少很多</strong>，同样，对于多级页表来说，16K的页表<strong>寻址</strong>起来也是很<strong>浪费时间</strong>的，能不能给我把<strong>常用的页标注起来</strong>呢？</p>\n<p>这种思想在互联网中是常见的，<strong>浏览器会将经常访问的域名做缓存</strong>，<strong>数据库会对经常用到的sql语句和数据做缓存</strong>，而在操作系统中，由<strong>TLB</strong>来存储页目录的缓存。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> TCB，也就是快表，它是一种<strong>相连存储的寄存器</strong></li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195249863.png\" alt=\"image-20210707195249863\"></p>\n<p>首先在TLB中找是否存在对应的逻辑地址，<strong>如果有</strong>，直接转化<strong>逻辑地址到物理地址</strong>，当然，这一步<strong>对于用户是透明</strong>的。</p>\n<p>如果在TLB中<strong>没有找到</strong>逻辑地址，即TLB未命中，那么就需要通过<strong>多级页表</strong>来查找。</p>\n<p>那么TLB在理论层面是很好用，但真正应用效果如何呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195302146.png\" alt=\"image-20210707195302146\"></p>\n<p>可以看到，TLB的效率的确很高，但是需要建立在TLB命中率高的情况下的，然而实际情况下TLB是不大的，那为什么仍然可以发挥作用呢?这是因为<strong>程序的地址访问</strong>存在<strong>局部性</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195318860.png\" alt=\"image-20210707195318860\"></p>\n<h2 id=\"4、段页结合的实际内存管理\"><a href=\"#4、段页结合的实际内存管理\" class=\"headerlink\" title=\"4、段页结合的实际内存管理\"></a>4、段页结合的实际内存管理</h2><h3 id=\"内存管理的模型\"><a href=\"#内存管理的模型\" class=\"headerlink\" title=\"内存管理的模型\"></a>内存管理的模型</h3><p>段是程序员编写程序的方式，而页是物理内存的使用方式，那如何将段页结合呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195330375.png\" alt=\"image-20210707195330375\"></p>\n<p>首先在<strong>虚拟内存</strong>中划分一段<strong>地址空间</strong>用于存放应用程序的段。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 这里的地址空间只是<strong>逻辑上</strong>的，<strong>物理地址</strong>还需要做进一步的<strong>映射</strong>。</li>\n</ul>\n<p>这里的<strong>虚拟内存是分段</strong>的，接着将分段的虚拟内存映射到<strong>分页的物理地址</strong>上去。</p>\n<p>而从用户的角度来说：段面向用户，页面向硬件。从逻辑地址到物理地址的映射对于用户时透明的，只有映射到段是对用户可见的。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195343879.png\" alt=\"image-20210707195343879\"></p>\n<h3 id=\"一个实际的段，页结合\"><a href=\"#一个实际的段，页结合\" class=\"headerlink\" title=\"一个实际的段，页结合\"></a>一个实际的段，页结合</h3><p>要体现实际的内存管理，那就一定要<strong>使用内存</strong>，而使用内存即是<strong>将程序加载到内存</strong>，加载到内存的程序更具体的说它是一个<strong>进程</strong>。</p>\n<p>则所谓的内存管理是从<strong>进程创建</strong>开始的，而进程创建时使用<strong>fork系统调用</strong>，故事的大幕也便就此拉开了——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 这个过程分为<strong>分割虚拟内存</strong>-》<strong>建段表</strong>-》<strong>分配到物理内存</strong>-》<strong>建页表</strong>-》<strong>映射完成</strong></li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195411176.png\" alt=\"image-20210707195411176\"></p>\n<p>上图首先在<strong>copy_process函数</strong>中调用<strong>copy_mem函数</strong>，在该函数中首先<strong>分配虚存</strong>，为每个<strong>进程</strong>分配<strong>64MB</strong>的虚存，要注意的是虚存地址是<strong>不重复</strong>的，这样就不会导致相同的地址冲突。</p>\n<p>接着<strong>建立段表</strong>，也就是在PCB中建立<strong>段表LDT</strong>，在后期进程切换的时候，PCB也就跟着切换。</p>\n<p>接下来开始分配物理内存——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195423193.png\" alt=\"image-20210707195423193\"></p>\n<p>调用<strong>copy_page_tables函数</strong>将虚拟内存的地址<strong>old_data_base映射</strong>到物理内存的地址<strong>new_data_base</strong>，在这个函数中，<strong>虚拟地址用from_dir指代</strong>，<strong>物理地址用to_dir指代</strong>，需要注意的是：</p>\n<p>from右移22位得到<strong>目录项的编号</strong>，又因为一个虚拟地址占4个字节，则表现为from&gt;&gt;20</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195447747.png\" alt=\"image-20210707195447747\"></p>\n<p>在下面的循环中，将具体的页映射到物理地址——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195510386.png\" alt=\"image-20210707195510386\"></p>\n<p>最终，执行指令，在对应的内存地址空间中完成<strong>写时复制</strong>，即经<strong>地址总线</strong>将数据发送到物理空间中，整个过程的<strong>地址翻译</strong>由<strong>硬件MMU</strong>完成，将<strong>逻辑地址</strong>翻译为<strong>虚拟地址</strong>，再将虚拟地址翻译为<strong>物理地址</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195523166.png\" alt=\"image-20210707195523166\"></p>\n<p>完结——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707195535245.png\" alt=\"image-20210707195535245\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"外设与文件系统","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T03:28:03.000Z","password":null,"summary":null,"_content":"\n操作系统的**核心**无非是**多进程图像**和**文件图像**，它们共同支撑了一个计算机**最基础的骨架**，前者使多道程序能够被加载到内存，并有序的运行与切换，这其中又包含有内存的管理；而后者将完成程序如何实现持久化存储，如何对文件进行读写，统一的文件视图是如何搭建的这些任务。\n\n完成多进程，内存这些核心的图像可以使**多道程序**在底层完成运行，但交互是不能实现的。人是通过使用硬件来间接与CPU交互的。因而我们还需要学习使用外设，也就是**用于读和写的终端设备**，而这些读和写操作的对象不一而足，但因为其一致的属性，都把他们归于**文件系统**。\n\n我们先给出一个基本的架构——\n![image-20201122092432000](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201122092432000.png)\n\n关于外设与文件系统的故事也就此开始了。。。\n\n------\n\n## 1.IO系统\n\n### 显示器\n\n首先我们给出一个直观的需求，如何在屏幕上使用printf打印出hello,world?\n\n一个直观的的**大致流程**是：首先由**CPU发出写的命令**，这个命令通过**PCI总线**传输到外设控制器中的**寄存器**，然后**外设控制器**向CPU发出**中断**，并**将数据从文件向显存中写入**。\n\n按照我们之前的常识判断，向寄存器中写不就好了吗，为什么还需要文件的视图？\n\n直接向寄存器中写固然可以满足需求，并且在汇编语言的实验中，我们也是这么做的。但它需要查询寄存器的地址，要写入内容的格式和语义，我们要兼顾很多要素，所以这样是不可取的。\n\n这时就需要根据他们共同的特性来抽象出来一个接口，来负责完成基础的功能，而由具体的外设来扩展，这里的接口就是——**文件视图**。\n\n了解了设计的初衷，我们来赏析一段操作外设的程序——\n\n```c\nint fd = open(\"/dev/xxx\");\nfor(int i =0;i<10;i++){\n\twrite(fd,i,sizeof(int));\n}\nclose(fd);\n```\n\n通过这个通俗的例子我们得见**接口**的庐山真面目——\n\n不管什么设备，操作系统都为其提供了统一的接口**open,read,write,close**，而这些设备用**/dev/xxx**来标识。通过这个文件，我们可以找到控制器的地址，内容格式等等。\n\n接口呈现给我们的是一个封装好的功能块，而我们不仅要会知道接口的存在，还要通过接口来探寻**底层的故事**：\n\n![image-20201124151108165](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124151108165.png)\n\n大致的流程框架有了，我们来看printf函数是如何在显示器上输出的——\n\nprintf库首先**创建缓存buf**，然后将**格式化的输出**都写到缓存中，**缓存满了**以后再写到显存中，而如何写到显存中呢？核心就在于**sys_write函数**，：\n\n```c\nint sys_write(unsigned int fd,char *buf,int count){\n    struct file* file;\n    file = current -> filp(fd);\n    inode = file -> f_inode;\n}\n```\n\n该函数将缓冲区中的数据写入到指定文件描述符的文件中。它实现的**核心过程**是：通过文件描述符fd得到`文件信息`，再通过文件信息中的`句柄指向`找到存放文件属性(比如在磁盘中存放的block位置)的`索引节点inode`.\n\n> 这里非常有必要说下文件描述符fd与索引节点inode。\n>\n> fd:文件描述符即是`文件地址的引用`，它作为进程文件描述符的表项被存储在其中，也可称fd为进程`文件描述符表的下标`。\n>\n> inode：inode是一个存储文件信息的数据结构，其中存储有`文件的真正位置`，也就是文件在`磁盘上block的位置`，\n>\n> inode是fd之后的故事了，通过文件描述符表可以查找到fd对应的那个条目，`取出打开文件的句柄`，通过句柄的指向找到inode。\n>\n> - [x] 句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。\n>\n> 上图——\n\n那`文件是如何通过当前进程的信息被找到`的呢？这就是操作系统全局化的雏形了——\n\n![image-20201124152440698](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152440698.png)\n\n这里从当前进程打开的文件序列中找到**dev/tty0文件**，也就是**外设**，那这里的**open系统调用**做了什么呢？\n\n![image-20201124152750656](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152750656.png)\n\n而这些步骤的核心就是建立一个链——\n\n![image-20201124152913538](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124152913538.png)\n\n接着我们需要知道文件的实际物理地址，即通`过inode的结构体找到实际存储在磁盘中的位置`，然后接着往下走——\n\n![image-20201124153222880](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153222880.png)\n\n这里判断外设的类型，得到是**字符型的设备**，然后将输出内容放在**输出队列中**以**字符**的形式输出——\n\n![image-20201124153420690](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153420690.png)\n\n输出的时候即使从**用户缓冲区读取**，然后**调用写函数**去——\n\n![image-20201124153549847](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153549847.png)\n\n开始写入：\n\n![image-20201124153650464](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153650464.png)\n\n那从显存的什么位置开始写入呢？直观的说，是光标所在处，所以我们需要读取光标的位置——\n\n![image-20201124153855802](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153855802.png)\n\n而输出的内容是不仅仅包含字符的，还有它的颜色，因而pos指针需要加2——\n![image-20201124154015935](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124154015935.png)\n\nprintf系统调用的故事就到此为止了，我们再来回顾一下这个过程——\n\n首先调用printf库函数——》核心是系统调用write——》通过字符设备接口调用基本功能——》tty设备写入缓冲区——》显示器写，即写入缓存，在显示器展示。\n\n------\n\n### 键盘\n\n外设包括显示器和键盘，上一节中我们介绍了**显示器的工作机制**，在接下来的篇幅中我们将了解到**键盘是如何工作的**。\n\n让外设工作起来无非三步：首先**CPU**通过**out指令**向外设控制器的某些**寄存器**发出**读/写**的命令，接着**把out指令以我呢间的形式封装起来**发出**中断**，形成统一的**文件视图**，最终**向内存中读写数据**。\n\n那如何使用键盘呢？从按下键盘开始，也就是从**键盘中断处理**开始，再深入的说，从**中断初始化**开始：\n\n![image-20201124161528247](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161528247.png)\n\n然后需要知道从硬件的哪个**端口扫描**按下的键——\n![image-20201124161642136](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161642136.png)\n\n那**60端口**是什么呢？这就是**扫描码**，通过扫描码我们就可以知道**按下了哪个键**，进入分支**key_table**\n\n![image-20201124161856604](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161856604.png)\n\n在这个分支中，可以**知道按下什么键时将触发的函数**。我们进入显示字符函数——**do-self函数**，在这里取得按下键的**ASII码**，并将其放入**缓冲队列read_q的头部**，到这里，我们已经完成了**CPU对字符的读取**，最后我们需要完成**回显**即可——\n\n![image-20201124162445909](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162445909.png)\n\n------\n\n我们来对这个过程做一总结——\n\n![image-20201124162614747](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162614747.png)\n\n至此，外设的工作机制就告一段落了，我们再以外设的视角来切进去——\n\n![image-20201124162727355](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162727355.png)\n\n------\n\n> 山高路远，静水深流。","source":"_posts/外设与文件系统.md","raw":"---\ntitle: 外设与文件系统\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 11:28:03\npassword:\nsummary:\ntags: 操作系统\ncategories: 计算机基础\n---\n\n操作系统的**核心**无非是**多进程图像**和**文件图像**，它们共同支撑了一个计算机**最基础的骨架**，前者使多道程序能够被加载到内存，并有序的运行与切换，这其中又包含有内存的管理；而后者将完成程序如何实现持久化存储，如何对文件进行读写，统一的文件视图是如何搭建的这些任务。\n\n完成多进程，内存这些核心的图像可以使**多道程序**在底层完成运行，但交互是不能实现的。人是通过使用硬件来间接与CPU交互的。因而我们还需要学习使用外设，也就是**用于读和写的终端设备**，而这些读和写操作的对象不一而足，但因为其一致的属性，都把他们归于**文件系统**。\n\n我们先给出一个基本的架构——\n![image-20201122092432000](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201122092432000.png)\n\n关于外设与文件系统的故事也就此开始了。。。\n\n------\n\n## 1.IO系统\n\n### 显示器\n\n首先我们给出一个直观的需求，如何在屏幕上使用printf打印出hello,world?\n\n一个直观的的**大致流程**是：首先由**CPU发出写的命令**，这个命令通过**PCI总线**传输到外设控制器中的**寄存器**，然后**外设控制器**向CPU发出**中断**，并**将数据从文件向显存中写入**。\n\n按照我们之前的常识判断，向寄存器中写不就好了吗，为什么还需要文件的视图？\n\n直接向寄存器中写固然可以满足需求，并且在汇编语言的实验中，我们也是这么做的。但它需要查询寄存器的地址，要写入内容的格式和语义，我们要兼顾很多要素，所以这样是不可取的。\n\n这时就需要根据他们共同的特性来抽象出来一个接口，来负责完成基础的功能，而由具体的外设来扩展，这里的接口就是——**文件视图**。\n\n了解了设计的初衷，我们来赏析一段操作外设的程序——\n\n```c\nint fd = open(\"/dev/xxx\");\nfor(int i =0;i<10;i++){\n\twrite(fd,i,sizeof(int));\n}\nclose(fd);\n```\n\n通过这个通俗的例子我们得见**接口**的庐山真面目——\n\n不管什么设备，操作系统都为其提供了统一的接口**open,read,write,close**，而这些设备用**/dev/xxx**来标识。通过这个文件，我们可以找到控制器的地址，内容格式等等。\n\n接口呈现给我们的是一个封装好的功能块，而我们不仅要会知道接口的存在，还要通过接口来探寻**底层的故事**：\n\n![image-20201124151108165](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124151108165.png)\n\n大致的流程框架有了，我们来看printf函数是如何在显示器上输出的——\n\nprintf库首先**创建缓存buf**，然后将**格式化的输出**都写到缓存中，**缓存满了**以后再写到显存中，而如何写到显存中呢？核心就在于**sys_write函数**，：\n\n```c\nint sys_write(unsigned int fd,char *buf,int count){\n    struct file* file;\n    file = current -> filp(fd);\n    inode = file -> f_inode;\n}\n```\n\n该函数将缓冲区中的数据写入到指定文件描述符的文件中。它实现的**核心过程**是：通过文件描述符fd得到`文件信息`，再通过文件信息中的`句柄指向`找到存放文件属性(比如在磁盘中存放的block位置)的`索引节点inode`.\n\n> 这里非常有必要说下文件描述符fd与索引节点inode。\n>\n> fd:文件描述符即是`文件地址的引用`，它作为进程文件描述符的表项被存储在其中，也可称fd为进程`文件描述符表的下标`。\n>\n> inode：inode是一个存储文件信息的数据结构，其中存储有`文件的真正位置`，也就是文件在`磁盘上block的位置`，\n>\n> inode是fd之后的故事了，通过文件描述符表可以查找到fd对应的那个条目，`取出打开文件的句柄`，通过句柄的指向找到inode。\n>\n> - [x] 句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。\n>\n> 上图——\n\n那`文件是如何通过当前进程的信息被找到`的呢？这就是操作系统全局化的雏形了——\n\n![image-20201124152440698](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152440698.png)\n\n这里从当前进程打开的文件序列中找到**dev/tty0文件**，也就是**外设**，那这里的**open系统调用**做了什么呢？\n\n![image-20201124152750656](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152750656.png)\n\n而这些步骤的核心就是建立一个链——\n\n![image-20201124152913538](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124152913538.png)\n\n接着我们需要知道文件的实际物理地址，即通`过inode的结构体找到实际存储在磁盘中的位置`，然后接着往下走——\n\n![image-20201124153222880](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153222880.png)\n\n这里判断外设的类型，得到是**字符型的设备**，然后将输出内容放在**输出队列中**以**字符**的形式输出——\n\n![image-20201124153420690](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153420690.png)\n\n输出的时候即使从**用户缓冲区读取**，然后**调用写函数**去——\n\n![image-20201124153549847](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153549847.png)\n\n开始写入：\n\n![image-20201124153650464](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153650464.png)\n\n那从显存的什么位置开始写入呢？直观的说，是光标所在处，所以我们需要读取光标的位置——\n\n![image-20201124153855802](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153855802.png)\n\n而输出的内容是不仅仅包含字符的，还有它的颜色，因而pos指针需要加2——\n![image-20201124154015935](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124154015935.png)\n\nprintf系统调用的故事就到此为止了，我们再来回顾一下这个过程——\n\n首先调用printf库函数——》核心是系统调用write——》通过字符设备接口调用基本功能——》tty设备写入缓冲区——》显示器写，即写入缓存，在显示器展示。\n\n------\n\n### 键盘\n\n外设包括显示器和键盘，上一节中我们介绍了**显示器的工作机制**，在接下来的篇幅中我们将了解到**键盘是如何工作的**。\n\n让外设工作起来无非三步：首先**CPU**通过**out指令**向外设控制器的某些**寄存器**发出**读/写**的命令，接着**把out指令以我呢间的形式封装起来**发出**中断**，形成统一的**文件视图**，最终**向内存中读写数据**。\n\n那如何使用键盘呢？从按下键盘开始，也就是从**键盘中断处理**开始，再深入的说，从**中断初始化**开始：\n\n![image-20201124161528247](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161528247.png)\n\n然后需要知道从硬件的哪个**端口扫描**按下的键——\n![image-20201124161642136](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161642136.png)\n\n那**60端口**是什么呢？这就是**扫描码**，通过扫描码我们就可以知道**按下了哪个键**，进入分支**key_table**\n\n![image-20201124161856604](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161856604.png)\n\n在这个分支中，可以**知道按下什么键时将触发的函数**。我们进入显示字符函数——**do-self函数**，在这里取得按下键的**ASII码**，并将其放入**缓冲队列read_q的头部**，到这里，我们已经完成了**CPU对字符的读取**，最后我们需要完成**回显**即可——\n\n![image-20201124162445909](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162445909.png)\n\n------\n\n我们来对这个过程做一总结——\n\n![image-20201124162614747](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162614747.png)\n\n至此，外设的工作机制就告一段落了，我们再以外设的视角来切进去——\n\n![image-20201124162727355](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162727355.png)\n\n------\n\n> 山高路远，静水深流。","slug":"外设与文件系统","published":1,"updated":"2023-09-24T09:50:29.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7l0000exjcc4k511h5f","content":"<p>操作系统的<strong>核心</strong>无非是<strong>多进程图像</strong>和<strong>文件图像</strong>，它们共同支撑了一个计算机<strong>最基础的骨架</strong>，前者使多道程序能够被加载到内存，并有序的运行与切换，这其中又包含有内存的管理；而后者将完成程序如何实现持久化存储，如何对文件进行读写，统一的文件视图是如何搭建的这些任务。</p>\n<p>完成多进程，内存这些核心的图像可以使<strong>多道程序</strong>在底层完成运行，但交互是不能实现的。人是通过使用硬件来间接与CPU交互的。因而我们还需要学习使用外设，也就是<strong>用于读和写的终端设备</strong>，而这些读和写操作的对象不一而足，但因为其一致的属性，都把他们归于<strong>文件系统</strong>。</p>\n<p>我们先给出一个基本的架构——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201122092432000.png\" alt=\"image-20201122092432000\"></p>\n<p>关于外设与文件系统的故事也就此开始了。。。</p>\n<hr>\n<h2 id=\"1-IO系统\"><a href=\"#1-IO系统\" class=\"headerlink\" title=\"1.IO系统\"></a>1.IO系统</h2><h3 id=\"显示器\"><a href=\"#显示器\" class=\"headerlink\" title=\"显示器\"></a>显示器</h3><p>首先我们给出一个直观的需求，如何在屏幕上使用printf打印出hello,world?</p>\n<p>一个直观的的<strong>大致流程</strong>是：首先由<strong>CPU发出写的命令</strong>，这个命令通过<strong>PCI总线</strong>传输到外设控制器中的<strong>寄存器</strong>，然后<strong>外设控制器</strong>向CPU发出<strong>中断</strong>，并<strong>将数据从文件向显存中写入</strong>。</p>\n<p>按照我们之前的常识判断，向寄存器中写不就好了吗，为什么还需要文件的视图？</p>\n<p>直接向寄存器中写固然可以满足需求，并且在汇编语言的实验中，我们也是这么做的。但它需要查询寄存器的地址，要写入内容的格式和语义，我们要兼顾很多要素，所以这样是不可取的。</p>\n<p>这时就需要根据他们共同的特性来抽象出来一个接口，来负责完成基础的功能，而由具体的外设来扩展，这里的接口就是——<strong>文件视图</strong>。</p>\n<p>了解了设计的初衷，我们来赏析一段操作外设的程序——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/dev/xxx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过这个通俗的例子我们得见<strong>接口</strong>的庐山真面目——</p>\n<p>不管什么设备，操作系统都为其提供了统一的接口<strong>open,read,write,close</strong>，而这些设备用**/dev/xxx**来标识。通过这个文件，我们可以找到控制器的地址，内容格式等等。</p>\n<p>接口呈现给我们的是一个封装好的功能块，而我们不仅要会知道接口的存在，还要通过接口来探寻<strong>底层的故事</strong>：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124151108165.png\" alt=\"image-20201124151108165\"></p>\n<p>大致的流程框架有了，我们来看printf函数是如何在显示器上输出的——</p>\n<p>printf库首先<strong>创建缓存buf</strong>，然后将<strong>格式化的输出</strong>都写到缓存中，<strong>缓存满了</strong>以后再写到显存中，而如何写到显存中呢？核心就在于<strong>sys_write函数</strong>，：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">sys_write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>buf<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">file</span><span class=\"token operator\">*</span> file<span class=\"token punctuation\">;</span>\n    file <span class=\"token operator\">=</span> current <span class=\"token operator\">-></span> <span class=\"token function\">filp</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    inode <span class=\"token operator\">=</span> file <span class=\"token operator\">-></span> f_inode<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>该函数将缓冲区中的数据写入到指定文件描述符的文件中。它实现的<strong>核心过程</strong>是：通过文件描述符fd得到<code>文件信息</code>，再通过文件信息中的<code>句柄指向</code>找到存放文件属性(比如在磁盘中存放的block位置)的<code>索引节点inode</code>.</p>\n<blockquote>\n<p>这里非常有必要说下文件描述符fd与索引节点inode。</p>\n<p>fd:文件描述符即是<code>文件地址的引用</code>，它作为进程文件描述符的表项被存储在其中，也可称fd为进程<code>文件描述符表的下标</code>。</p>\n<p>inode：inode是一个存储文件信息的数据结构，其中存储有<code>文件的真正位置</code>，也就是文件在<code>磁盘上block的位置</code>，</p>\n<p>inode是fd之后的故事了，通过文件描述符表可以查找到fd对应的那个条目，<code>取出打开文件的句柄</code>，通过句柄的指向找到inode。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。</li>\n</ul>\n<p>上图——</p>\n</blockquote>\n<p>那<code>文件是如何通过当前进程的信息被找到</code>的呢？这就是操作系统全局化的雏形了——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152440698.png\" alt=\"image-20201124152440698\"></p>\n<p>这里从当前进程打开的文件序列中找到<strong>dev/tty0文件</strong>，也就是<strong>外设</strong>，那这里的<strong>open系统调用</strong>做了什么呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152750656.png\" alt=\"image-20201124152750656\"></p>\n<p>而这些步骤的核心就是建立一个链——</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124152913538.png\" alt=\"image-20201124152913538\"></p>\n<p>接着我们需要知道文件的实际物理地址，即通<code>过inode的结构体找到实际存储在磁盘中的位置</code>，然后接着往下走——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153222880.png\" alt=\"image-20201124153222880\"></p>\n<p>这里判断外设的类型，得到是<strong>字符型的设备</strong>，然后将输出内容放在<strong>输出队列中</strong>以<strong>字符</strong>的形式输出——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153420690.png\" alt=\"image-20201124153420690\"></p>\n<p>输出的时候即使从<strong>用户缓冲区读取</strong>，然后<strong>调用写函数</strong>去——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153549847.png\" alt=\"image-20201124153549847\"></p>\n<p>开始写入：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153650464.png\" alt=\"image-20201124153650464\"></p>\n<p>那从显存的什么位置开始写入呢？直观的说，是光标所在处，所以我们需要读取光标的位置——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153855802.png\" alt=\"image-20201124153855802\"></p>\n<p>而输出的内容是不仅仅包含字符的，还有它的颜色，因而pos指针需要加2——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124154015935.png\" alt=\"image-20201124154015935\"></p>\n<p>printf系统调用的故事就到此为止了，我们再来回顾一下这个过程——</p>\n<p>首先调用printf库函数——》核心是系统调用write——》通过字符设备接口调用基本功能——》tty设备写入缓冲区——》显示器写，即写入缓存，在显示器展示。</p>\n<hr>\n<h3 id=\"键盘\"><a href=\"#键盘\" class=\"headerlink\" title=\"键盘\"></a>键盘</h3><p>外设包括显示器和键盘，上一节中我们介绍了<strong>显示器的工作机制</strong>，在接下来的篇幅中我们将了解到<strong>键盘是如何工作的</strong>。</p>\n<p>让外设工作起来无非三步：首先<strong>CPU</strong>通过<strong>out指令</strong>向外设控制器的某些<strong>寄存器</strong>发出<strong>读/写</strong>的命令，接着<strong>把out指令以我呢间的形式封装起来</strong>发出<strong>中断</strong>，形成统一的<strong>文件视图</strong>，最终<strong>向内存中读写数据</strong>。</p>\n<p>那如何使用键盘呢？从按下键盘开始，也就是从<strong>键盘中断处理</strong>开始，再深入的说，从<strong>中断初始化</strong>开始：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161528247.png\" alt=\"image-20201124161528247\"></p>\n<p>然后需要知道从硬件的哪个<strong>端口扫描</strong>按下的键——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161642136.png\" alt=\"image-20201124161642136\"></p>\n<p>那<strong>60端口</strong>是什么呢？这就是<strong>扫描码</strong>，通过扫描码我们就可以知道<strong>按下了哪个键</strong>，进入分支<strong>key_table</strong></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161856604.png\" alt=\"image-20201124161856604\"></p>\n<p>在这个分支中，可以<strong>知道按下什么键时将触发的函数</strong>。我们进入显示字符函数——<strong>do-self函数</strong>，在这里取得按下键的<strong>ASII码</strong>，并将其放入<strong>缓冲队列read_q的头部</strong>，到这里，我们已经完成了<strong>CPU对字符的读取</strong>，最后我们需要完成<strong>回显</strong>即可——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162445909.png\" alt=\"image-20201124162445909\"></p>\n<hr>\n<p>我们来对这个过程做一总结——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162614747.png\" alt=\"image-20201124162614747\"></p>\n<p>至此，外设的工作机制就告一段落了，我们再以外设的视角来切进去——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162727355.png\" alt=\"image-20201124162727355\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>操作系统的<strong>核心</strong>无非是<strong>多进程图像</strong>和<strong>文件图像</strong>，它们共同支撑了一个计算机<strong>最基础的骨架</strong>，前者使多道程序能够被加载到内存，并有序的运行与切换，这其中又包含有内存的管理；而后者将完成程序如何实现持久化存储，如何对文件进行读写，统一的文件视图是如何搭建的这些任务。</p>\n<p>完成多进程，内存这些核心的图像可以使<strong>多道程序</strong>在底层完成运行，但交互是不能实现的。人是通过使用硬件来间接与CPU交互的。因而我们还需要学习使用外设，也就是<strong>用于读和写的终端设备</strong>，而这些读和写操作的对象不一而足，但因为其一致的属性，都把他们归于<strong>文件系统</strong>。</p>\n<p>我们先给出一个基本的架构——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201122092432000.png\" alt=\"image-20201122092432000\"></p>\n<p>关于外设与文件系统的故事也就此开始了。。。</p>\n<hr>\n<h2 id=\"1-IO系统\"><a href=\"#1-IO系统\" class=\"headerlink\" title=\"1.IO系统\"></a>1.IO系统</h2><h3 id=\"显示器\"><a href=\"#显示器\" class=\"headerlink\" title=\"显示器\"></a>显示器</h3><p>首先我们给出一个直观的需求，如何在屏幕上使用printf打印出hello,world?</p>\n<p>一个直观的的<strong>大致流程</strong>是：首先由<strong>CPU发出写的命令</strong>，这个命令通过<strong>PCI总线</strong>传输到外设控制器中的<strong>寄存器</strong>，然后<strong>外设控制器</strong>向CPU发出<strong>中断</strong>，并<strong>将数据从文件向显存中写入</strong>。</p>\n<p>按照我们之前的常识判断，向寄存器中写不就好了吗，为什么还需要文件的视图？</p>\n<p>直接向寄存器中写固然可以满足需求，并且在汇编语言的实验中，我们也是这么做的。但它需要查询寄存器的地址，要写入内容的格式和语义，我们要兼顾很多要素，所以这样是不可取的。</p>\n<p>这时就需要根据他们共同的特性来抽象出来一个接口，来负责完成基础的功能，而由具体的外设来扩展，这里的接口就是——<strong>文件视图</strong>。</p>\n<p>了解了设计的初衷，我们来赏析一段操作外设的程序——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/dev/xxx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过这个通俗的例子我们得见<strong>接口</strong>的庐山真面目——</p>\n<p>不管什么设备，操作系统都为其提供了统一的接口<strong>open,read,write,close</strong>，而这些设备用**/dev/xxx**来标识。通过这个文件，我们可以找到控制器的地址，内容格式等等。</p>\n<p>接口呈现给我们的是一个封装好的功能块，而我们不仅要会知道接口的存在，还要通过接口来探寻<strong>底层的故事</strong>：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124151108165.png\" alt=\"image-20201124151108165\"></p>\n<p>大致的流程框架有了，我们来看printf函数是如何在显示器上输出的——</p>\n<p>printf库首先<strong>创建缓存buf</strong>，然后将<strong>格式化的输出</strong>都写到缓存中，<strong>缓存满了</strong>以后再写到显存中，而如何写到显存中呢？核心就在于<strong>sys_write函数</strong>，：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">sys_write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>buf<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">file</span><span class=\"token operator\">*</span> file<span class=\"token punctuation\">;</span>\n    file <span class=\"token operator\">=</span> current <span class=\"token operator\">-></span> <span class=\"token function\">filp</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    inode <span class=\"token operator\">=</span> file <span class=\"token operator\">-></span> f_inode<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>该函数将缓冲区中的数据写入到指定文件描述符的文件中。它实现的<strong>核心过程</strong>是：通过文件描述符fd得到<code>文件信息</code>，再通过文件信息中的<code>句柄指向</code>找到存放文件属性(比如在磁盘中存放的block位置)的<code>索引节点inode</code>.</p>\n<blockquote>\n<p>这里非常有必要说下文件描述符fd与索引节点inode。</p>\n<p>fd:文件描述符即是<code>文件地址的引用</code>，它作为进程文件描述符的表项被存储在其中，也可称fd为进程<code>文件描述符表的下标</code>。</p>\n<p>inode：inode是一个存储文件信息的数据结构，其中存储有<code>文件的真正位置</code>，也就是文件在<code>磁盘上block的位置</code>，</p>\n<p>inode是fd之后的故事了，通过文件描述符表可以查找到fd对应的那个条目，<code>取出打开文件的句柄</code>，通过句柄的指向找到inode。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。</li>\n</ul>\n<p>上图——</p>\n</blockquote>\n<p>那<code>文件是如何通过当前进程的信息被找到</code>的呢？这就是操作系统全局化的雏形了——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152440698.png\" alt=\"image-20201124152440698\"></p>\n<p>这里从当前进程打开的文件序列中找到<strong>dev/tty0文件</strong>，也就是<strong>外设</strong>，那这里的<strong>open系统调用</strong>做了什么呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124152750656.png\" alt=\"image-20201124152750656\"></p>\n<p>而这些步骤的核心就是建立一个链——</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124152913538.png\" alt=\"image-20201124152913538\"></p>\n<p>接着我们需要知道文件的实际物理地址，即通<code>过inode的结构体找到实际存储在磁盘中的位置</code>，然后接着往下走——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153222880.png\" alt=\"image-20201124153222880\"></p>\n<p>这里判断外设的类型，得到是<strong>字符型的设备</strong>，然后将输出内容放在<strong>输出队列中</strong>以<strong>字符</strong>的形式输出——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153420690.png\" alt=\"image-20201124153420690\"></p>\n<p>输出的时候即使从<strong>用户缓冲区读取</strong>，然后<strong>调用写函数</strong>去——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153549847.png\" alt=\"image-20201124153549847\"></p>\n<p>开始写入：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153650464.png\" alt=\"image-20201124153650464\"></p>\n<p>那从显存的什么位置开始写入呢？直观的说，是光标所在处，所以我们需要读取光标的位置——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124153855802.png\" alt=\"image-20201124153855802\"></p>\n<p>而输出的内容是不仅仅包含字符的，还有它的颜色，因而pos指针需要加2——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124154015935.png\" alt=\"image-20201124154015935\"></p>\n<p>printf系统调用的故事就到此为止了，我们再来回顾一下这个过程——</p>\n<p>首先调用printf库函数——》核心是系统调用write——》通过字符设备接口调用基本功能——》tty设备写入缓冲区——》显示器写，即写入缓存，在显示器展示。</p>\n<hr>\n<h3 id=\"键盘\"><a href=\"#键盘\" class=\"headerlink\" title=\"键盘\"></a>键盘</h3><p>外设包括显示器和键盘，上一节中我们介绍了<strong>显示器的工作机制</strong>，在接下来的篇幅中我们将了解到<strong>键盘是如何工作的</strong>。</p>\n<p>让外设工作起来无非三步：首先<strong>CPU</strong>通过<strong>out指令</strong>向外设控制器的某些<strong>寄存器</strong>发出<strong>读/写</strong>的命令，接着<strong>把out指令以我呢间的形式封装起来</strong>发出<strong>中断</strong>，形成统一的<strong>文件视图</strong>，最终<strong>向内存中读写数据</strong>。</p>\n<p>那如何使用键盘呢？从按下键盘开始，也就是从<strong>键盘中断处理</strong>开始，再深入的说，从<strong>中断初始化</strong>开始：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161528247.png\" alt=\"image-20201124161528247\"></p>\n<p>然后需要知道从硬件的哪个<strong>端口扫描</strong>按下的键——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161642136.png\" alt=\"image-20201124161642136\"></p>\n<p>那<strong>60端口</strong>是什么呢？这就是<strong>扫描码</strong>，通过扫描码我们就可以知道<strong>按下了哪个键</strong>，进入分支<strong>key_table</strong></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124161856604.png\" alt=\"image-20201124161856604\"></p>\n<p>在这个分支中，可以<strong>知道按下什么键时将触发的函数</strong>。我们进入显示字符函数——<strong>do-self函数</strong>，在这里取得按下键的<strong>ASII码</strong>，并将其放入<strong>缓冲队列read_q的头部</strong>，到这里，我们已经完成了<strong>CPU对字符的读取</strong>，最后我们需要完成<strong>回显</strong>即可——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162445909.png\" alt=\"image-20201124162445909\"></p>\n<hr>\n<p>我们来对这个过程做一总结——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162614747.png\" alt=\"image-20201124162614747\"></p>\n<p>至此，外设的工作机制就告一段落了，我们再以外设的视角来切进去——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124162727355.png\" alt=\"image-20201124162727355\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n"},{"title":"操作系统基础","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-11T11:58:23.000Z","password":null,"summary":"从操作系统的定义起笔，追溯操作系统的发展，着眼启动的故事，落笔于系统调用。操作系统的系列故事也将就此拉开序幕~","_content":"\n## 一、什么是操作系统\n\n### 1.引言\n\n首先我们来看**计算机硬件**设备的分布\n\n![image-20210619004641611](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004641611.png)\n\n**image-20210619004641611**\n\n\n\n\n\n\n那么有了这些硬件设备，计算机可以干什么呢，计算机可以帮助我们解决很多实际的问题，比如当我们在键盘上输入“hello world”，计算机会帮我们将其展示在显示器上，这里我们给出实现的机制：\n\n\n\n![image-20210619004659758](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004659758.png)\n\n**image-20210619004659758**\n\n\n\n但在实际实现的时候，我们只需键入即可，而底层复杂的操作对于用户来说就像一个黑盒子，是不可见的。那这个封装起来的黑盒子是由什么实现的呢，\n\n这里我们先给出结论——`操作系统`\n\n### 2.定义\n\n> 操作系统OperatingSystem，简称OSOperatingSystem，简称OS是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。\n\n下面我们来对定义进行剖析\n\n操作系统管理的计算机硬件都有什么？\n\n- **cpu管理**\n- **内存管理**\n- **终端管理**\n- **磁盘管理**\n- **文件管理**\n- 网络管理\n- 电源管理\n- 多核管理\n\n而对于操作系统，我们应该做到**能改操作系统**。\n\n## 二、打开钢琴的盖子\n\n我们不妨把操作系统比作一个钢琴，要弹出美妙的乐曲，我们不仅要了解每个琴键的作用，也要可以打开盖子，通过调整琴弦的粗细长短改变音调。\n\n我们不妨试着打开计算机的盖子，从打开电源的那一刻开始，操作系统的故事就已然开始了——\n\n首先，我们先根据认知猜测一下，打开电源后显示”loading …”,那这些数据是通过怎样的曲折最终发送到显存的呢？开机后，整个IO设备和文件系统都可以用了，是不是在开机时完成的初始化呢，如果是，又做了怎样的初始化呢？\n\n这一切，都要从最核心的思想——**冯诺依曼结构**谈起。\n\n### 1.冯诺依曼结构\n\n艺术来源于生活，技术也不例外，计算机说到底就是一个计算模型，当人要计算1+1=2的时候，我们会先将1+1写在纸上，然后大脑运算出结果2，再将其写到纸上。这里，`纸就如同一个存储器，而大脑就是运算器，控制器，笔是输入输出设备`。很酷对吧，但是1*1=？怎么搞呢？2/2呢，看来这个计算模型还需要存储多种模式，而运算器能识别不同的模式。至此，无龙珠集齐，我们可以召唤神龙——冯诺依曼结构\n\n\n\n![image-20210619004719586](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004719586.png)\n\n**image-20210619004719586**\n\n\n\n**所谓大道至简，不过如是**\n\n------\n\n## 三、操纵系统启动过程\n\n小小的分割一手，因为以上知识帮助我们在脑海中形成了一个操作系统的最小单元，接下来就要一探究竟了。\n\n计算机对应用程序的处理，也就是取指执行的过程，那么它指向内存何处呢？\n\n1. X86 PC刚开机时CPU处于**实模式**，此时**CS=0XFFFF,IP=0X0000**,寻址到**0XFFFFO**,也就是**ROM BIOS映射区**，接着检查**RAM,键盘，显示器，软硬磁盘**，将**磁盘的0磁道0扇区**读入**0X7C00**处，设置cs=0x7c0,ip=0x0000\n\n2. 为什么要跳转到0X7C00处呢？这块内存区域存储的是什么呢？\n\n   这里存放的是磁盘引导扇区读入的512个字节，也是开机后执行的第一段我们可以控制的程序，操作系统的故事从这里开始……..\n\n   \n\n   ![image-20210619004735500](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004735500.png)\n\n   **image-20210619004735500**\n\n   \n\n   代码很多，我们不追求每句都能看懂，而要抓住核心点——\n\n   这段代码将引导扇区的代码`以字节为单位循环加载到CS=INITSEG，ip= GO`处,或称**段间跳转**\n\n   \n\n   ![image-20210619004753041](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004753041.png)\n\n   **image-20210619004753041**\n\n   \n\n   在bootsect.s中**加载load_setup模块**，该模块通过中断信号0X13读取到扇区数量，并跳转**ok_load_setup**模块，\n\n   \n\n   ![image-20210619004806578](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004806578.png)\n\n   **image-20210619004806578**\n\n   \n\n   在该模块中获取磁盘参数，读取光标位置，循环写入24个字符，并在最后跳转**read_it标号**，而该标号属于**System模块**\n\n   \n\n   ![image-20210619004820607](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004820607.png)\n\n   **image-20210619004820607**\n\n   \n\n   在System模块中，读取磁道，重新回到setup模块执行，CPU进入保护模式，并初始化中断控制，那CPU是如何进入保护模式的呢？自然需要标志寄存器cr0.当`PE=1时启动保护模式，PG=1时自动分页`，CPU在进入保护模式后，有一个关键跳转，即jmpi 0, 8,这里设置cs=8是用来查询GDT表，即中断向量表。这里我们简单那描述一下GDT表的表项——\n\n   \n\n   ![image-20210619004835241](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004835241.png)\n\n   **image-20210619004835241**\n\n   \n\n   那么程序计数器PC跳转到了哪呢？那就是关键的System模块，\n\n   \n\n   ![image-20210619004851277](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004851277.png)\n\n   **image-20210619004851277**\n\n   \n\n   \n\n   ![image-20210619004906587](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004906587.png)\n\n   **image-20210619004906587**\n\n   \n\n   \n\n   ![image-20210619005014321](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005014321.png)\n\n   **image-20210619005014321**\n\n   \n\n   开局几张图，剩下全靠编，假装有”**汇**字”\n\n   才疏学浅，这几张图以我的水准实在无法给出一个容易理解的答案，等什么时候经过时间沉淀突然悟了，再回来讲述这些汇编背后的故事………\n\n## 四、操作系统的接口\n\n要学习操作系统的接口，我们必须先了解接口是什么，在日常生活中，我们使用插座，油门这种类型的物件，其实就是在使用接口。牛津词典是这样定义接口的：\n\n> 接口是连接两个东西，屏蔽细节，用于信号转换的\n\n那么什么是操作系统的接口呢？\n\n\n\n![image-20210619005049553](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005049553.png)\n\n**image-20210619005049553**\n\n\n\n可见，操作系统接口将上层软件和操作系统连接起来。表面上看用户可以直接与操作系统交互，然而操作系统接口是面对用户的吗？\n\n显然不是，我们通常使用计算机的方式有三种，分别是\n\n- 命令行\n\n- 图形化界面\n\n- 应用程序\n\n  \n\n  ![image-20210619005102257](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005102257.png)\n\n  **image-20210619005102257**\n\n  \n\n由此可以看出操作系统接口不是面向用户的，这三种方式都归于调用系统常用的C语言函数及普通函数(**应用程序接口**)来实现。\n\n到这里，我们可以给出操作系统接口一个相对贴近的定义了——\n\n> 操作系统接口：接口表现为调用，又由系统提供，因而称操作系统接口为系统调用\n\n既然交互的过程是通过函数来实现的，那通常会调用那些函数呢，IEEE组织针对系统调用制定了一个标准族，即**POSIX**\n\n> **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行的软件，而定义API的一系列互相关联的标准的总称\n\n-  参考目录：\n\n1. 哈工大李志军老师操作系统\n2. 蓝桥实验楼\n\n------\n\n> 山高路远，静水深流。","source":"_posts/操作系统基础.md","raw":"---\ntitle: 操作系统基础\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-11 19:58:23\npassword:\nsummary: 从操作系统的定义起笔，追溯操作系统的发展，着眼启动的故事，落笔于系统调用。操作系统的系列故事也将就此拉开序幕~\ntags: 操作系统\ncategories: 计算机基础\n---\n\n## 一、什么是操作系统\n\n### 1.引言\n\n首先我们来看**计算机硬件**设备的分布\n\n![image-20210619004641611](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004641611.png)\n\n**image-20210619004641611**\n\n\n\n\n\n\n那么有了这些硬件设备，计算机可以干什么呢，计算机可以帮助我们解决很多实际的问题，比如当我们在键盘上输入“hello world”，计算机会帮我们将其展示在显示器上，这里我们给出实现的机制：\n\n\n\n![image-20210619004659758](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004659758.png)\n\n**image-20210619004659758**\n\n\n\n但在实际实现的时候，我们只需键入即可，而底层复杂的操作对于用户来说就像一个黑盒子，是不可见的。那这个封装起来的黑盒子是由什么实现的呢，\n\n这里我们先给出结论——`操作系统`\n\n### 2.定义\n\n> 操作系统OperatingSystem，简称OSOperatingSystem，简称OS是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。\n\n下面我们来对定义进行剖析\n\n操作系统管理的计算机硬件都有什么？\n\n- **cpu管理**\n- **内存管理**\n- **终端管理**\n- **磁盘管理**\n- **文件管理**\n- 网络管理\n- 电源管理\n- 多核管理\n\n而对于操作系统，我们应该做到**能改操作系统**。\n\n## 二、打开钢琴的盖子\n\n我们不妨把操作系统比作一个钢琴，要弹出美妙的乐曲，我们不仅要了解每个琴键的作用，也要可以打开盖子，通过调整琴弦的粗细长短改变音调。\n\n我们不妨试着打开计算机的盖子，从打开电源的那一刻开始，操作系统的故事就已然开始了——\n\n首先，我们先根据认知猜测一下，打开电源后显示”loading …”,那这些数据是通过怎样的曲折最终发送到显存的呢？开机后，整个IO设备和文件系统都可以用了，是不是在开机时完成的初始化呢，如果是，又做了怎样的初始化呢？\n\n这一切，都要从最核心的思想——**冯诺依曼结构**谈起。\n\n### 1.冯诺依曼结构\n\n艺术来源于生活，技术也不例外，计算机说到底就是一个计算模型，当人要计算1+1=2的时候，我们会先将1+1写在纸上，然后大脑运算出结果2，再将其写到纸上。这里，`纸就如同一个存储器，而大脑就是运算器，控制器，笔是输入输出设备`。很酷对吧，但是1*1=？怎么搞呢？2/2呢，看来这个计算模型还需要存储多种模式，而运算器能识别不同的模式。至此，无龙珠集齐，我们可以召唤神龙——冯诺依曼结构\n\n\n\n![image-20210619004719586](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004719586.png)\n\n**image-20210619004719586**\n\n\n\n**所谓大道至简，不过如是**\n\n------\n\n## 三、操纵系统启动过程\n\n小小的分割一手，因为以上知识帮助我们在脑海中形成了一个操作系统的最小单元，接下来就要一探究竟了。\n\n计算机对应用程序的处理，也就是取指执行的过程，那么它指向内存何处呢？\n\n1. X86 PC刚开机时CPU处于**实模式**，此时**CS=0XFFFF,IP=0X0000**,寻址到**0XFFFFO**,也就是**ROM BIOS映射区**，接着检查**RAM,键盘，显示器，软硬磁盘**，将**磁盘的0磁道0扇区**读入**0X7C00**处，设置cs=0x7c0,ip=0x0000\n\n2. 为什么要跳转到0X7C00处呢？这块内存区域存储的是什么呢？\n\n   这里存放的是磁盘引导扇区读入的512个字节，也是开机后执行的第一段我们可以控制的程序，操作系统的故事从这里开始……..\n\n   \n\n   ![image-20210619004735500](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004735500.png)\n\n   **image-20210619004735500**\n\n   \n\n   代码很多，我们不追求每句都能看懂，而要抓住核心点——\n\n   这段代码将引导扇区的代码`以字节为单位循环加载到CS=INITSEG，ip= GO`处,或称**段间跳转**\n\n   \n\n   ![image-20210619004753041](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004753041.png)\n\n   **image-20210619004753041**\n\n   \n\n   在bootsect.s中**加载load_setup模块**，该模块通过中断信号0X13读取到扇区数量，并跳转**ok_load_setup**模块，\n\n   \n\n   ![image-20210619004806578](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004806578.png)\n\n   **image-20210619004806578**\n\n   \n\n   在该模块中获取磁盘参数，读取光标位置，循环写入24个字符，并在最后跳转**read_it标号**，而该标号属于**System模块**\n\n   \n\n   ![image-20210619004820607](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004820607.png)\n\n   **image-20210619004820607**\n\n   \n\n   在System模块中，读取磁道，重新回到setup模块执行，CPU进入保护模式，并初始化中断控制，那CPU是如何进入保护模式的呢？自然需要标志寄存器cr0.当`PE=1时启动保护模式，PG=1时自动分页`，CPU在进入保护模式后，有一个关键跳转，即jmpi 0, 8,这里设置cs=8是用来查询GDT表，即中断向量表。这里我们简单那描述一下GDT表的表项——\n\n   \n\n   ![image-20210619004835241](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004835241.png)\n\n   **image-20210619004835241**\n\n   \n\n   那么程序计数器PC跳转到了哪呢？那就是关键的System模块，\n\n   \n\n   ![image-20210619004851277](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004851277.png)\n\n   **image-20210619004851277**\n\n   \n\n   \n\n   ![image-20210619004906587](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004906587.png)\n\n   **image-20210619004906587**\n\n   \n\n   \n\n   ![image-20210619005014321](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005014321.png)\n\n   **image-20210619005014321**\n\n   \n\n   开局几张图，剩下全靠编，假装有”**汇**字”\n\n   才疏学浅，这几张图以我的水准实在无法给出一个容易理解的答案，等什么时候经过时间沉淀突然悟了，再回来讲述这些汇编背后的故事………\n\n## 四、操作系统的接口\n\n要学习操作系统的接口，我们必须先了解接口是什么，在日常生活中，我们使用插座，油门这种类型的物件，其实就是在使用接口。牛津词典是这样定义接口的：\n\n> 接口是连接两个东西，屏蔽细节，用于信号转换的\n\n那么什么是操作系统的接口呢？\n\n\n\n![image-20210619005049553](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005049553.png)\n\n**image-20210619005049553**\n\n\n\n可见，操作系统接口将上层软件和操作系统连接起来。表面上看用户可以直接与操作系统交互，然而操作系统接口是面对用户的吗？\n\n显然不是，我们通常使用计算机的方式有三种，分别是\n\n- 命令行\n\n- 图形化界面\n\n- 应用程序\n\n  \n\n  ![image-20210619005102257](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005102257.png)\n\n  **image-20210619005102257**\n\n  \n\n由此可以看出操作系统接口不是面向用户的，这三种方式都归于调用系统常用的C语言函数及普通函数(**应用程序接口**)来实现。\n\n到这里，我们可以给出操作系统接口一个相对贴近的定义了——\n\n> 操作系统接口：接口表现为调用，又由系统提供，因而称操作系统接口为系统调用\n\n既然交互的过程是通过函数来实现的，那通常会调用那些函数呢，IEEE组织针对系统调用制定了一个标准族，即**POSIX**\n\n> **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行的软件，而定义API的一系列互相关联的标准的总称\n\n-  参考目录：\n\n1. 哈工大李志军老师操作系统\n2. 蓝桥实验楼\n\n------\n\n> 山高路远，静水深流。","slug":"操作系统基础","published":1,"updated":"2023-09-24T09:50:29.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7l2000ixjcc3dse7roh","content":"<h2 id=\"一、什么是操作系统\"><a href=\"#一、什么是操作系统\" class=\"headerlink\" title=\"一、什么是操作系统\"></a>一、什么是操作系统</h2><h3 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1.引言\"></a>1.引言</h3><p>首先我们来看<strong>计算机硬件</strong>设备的分布</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004641611.png\" alt=\"image-20210619004641611\"></p>\n<p><strong>image-20210619004641611</strong></p>\n<p>那么有了这些硬件设备，计算机可以干什么呢，计算机可以帮助我们解决很多实际的问题，比如当我们在键盘上输入“hello world”，计算机会帮我们将其展示在显示器上，这里我们给出实现的机制：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004659758.png\" alt=\"image-20210619004659758\"></p>\n<p><strong>image-20210619004659758</strong></p>\n<p>但在实际实现的时候，我们只需键入即可，而底层复杂的操作对于用户来说就像一个黑盒子，是不可见的。那这个封装起来的黑盒子是由什么实现的呢，</p>\n<p>这里我们先给出结论——<code>操作系统</code></p>\n<h3 id=\"2-定义\"><a href=\"#2-定义\" class=\"headerlink\" title=\"2.定义\"></a>2.定义</h3><blockquote>\n<p>操作系统OperatingSystem，简称OSOperatingSystem，简称OS是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p>\n</blockquote>\n<p>下面我们来对定义进行剖析</p>\n<p>操作系统管理的计算机硬件都有什么？</p>\n<ul>\n<li><strong>cpu管理</strong></li>\n<li><strong>内存管理</strong></li>\n<li><strong>终端管理</strong></li>\n<li><strong>磁盘管理</strong></li>\n<li><strong>文件管理</strong></li>\n<li>网络管理</li>\n<li>电源管理</li>\n<li>多核管理</li>\n</ul>\n<p>而对于操作系统，我们应该做到<strong>能改操作系统</strong>。</p>\n<h2 id=\"二、打开钢琴的盖子\"><a href=\"#二、打开钢琴的盖子\" class=\"headerlink\" title=\"二、打开钢琴的盖子\"></a>二、打开钢琴的盖子</h2><p>我们不妨把操作系统比作一个钢琴，要弹出美妙的乐曲，我们不仅要了解每个琴键的作用，也要可以打开盖子，通过调整琴弦的粗细长短改变音调。</p>\n<p>我们不妨试着打开计算机的盖子，从打开电源的那一刻开始，操作系统的故事就已然开始了——</p>\n<p>首先，我们先根据认知猜测一下，打开电源后显示”loading …”,那这些数据是通过怎样的曲折最终发送到显存的呢？开机后，整个IO设备和文件系统都可以用了，是不是在开机时完成的初始化呢，如果是，又做了怎样的初始化呢？</p>\n<p>这一切，都要从最核心的思想——<strong>冯诺依曼结构</strong>谈起。</p>\n<h3 id=\"1-冯诺依曼结构\"><a href=\"#1-冯诺依曼结构\" class=\"headerlink\" title=\"1.冯诺依曼结构\"></a>1.冯诺依曼结构</h3><p>艺术来源于生活，技术也不例外，计算机说到底就是一个计算模型，当人要计算1+1=2的时候，我们会先将1+1写在纸上，然后大脑运算出结果2，再将其写到纸上。这里，<code>纸就如同一个存储器，而大脑就是运算器，控制器，笔是输入输出设备</code>。很酷对吧，但是1*1=？怎么搞呢？2/2呢，看来这个计算模型还需要存储多种模式，而运算器能识别不同的模式。至此，无龙珠集齐，我们可以召唤神龙——冯诺依曼结构</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004719586.png\" alt=\"image-20210619004719586\"></p>\n<p><strong>image-20210619004719586</strong></p>\n<p><strong>所谓大道至简，不过如是</strong></p>\n<hr>\n<h2 id=\"三、操纵系统启动过程\"><a href=\"#三、操纵系统启动过程\" class=\"headerlink\" title=\"三、操纵系统启动过程\"></a>三、操纵系统启动过程</h2><p>小小的分割一手，因为以上知识帮助我们在脑海中形成了一个操作系统的最小单元，接下来就要一探究竟了。</p>\n<p>计算机对应用程序的处理，也就是取指执行的过程，那么它指向内存何处呢？</p>\n<ol>\n<li><p>X86 PC刚开机时CPU处于<strong>实模式</strong>，此时<strong>CS=0XFFFF,IP=0X0000</strong>,寻址到<strong>0XFFFFO</strong>,也就是<strong>ROM BIOS映射区</strong>，接着检查<strong>RAM,键盘，显示器，软硬磁盘</strong>，将<strong>磁盘的0磁道0扇区</strong>读入<strong>0X7C00</strong>处，设置cs=0x7c0,ip=0x0000</p>\n</li>\n<li><p>为什么要跳转到0X7C00处呢？这块内存区域存储的是什么呢？</p>\n<p>这里存放的是磁盘引导扇区读入的512个字节，也是开机后执行的第一段我们可以控制的程序，操作系统的故事从这里开始……..</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004735500.png\" alt=\"image-20210619004735500\"></p>\n<p><strong>image-20210619004735500</strong></p>\n<p>代码很多，我们不追求每句都能看懂，而要抓住核心点——</p>\n<p>这段代码将引导扇区的代码<code>以字节为单位循环加载到CS=INITSEG，ip= GO</code>处,或称<strong>段间跳转</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004753041.png\" alt=\"image-20210619004753041\"></p>\n<p><strong>image-20210619004753041</strong></p>\n<p>在bootsect.s中<strong>加载load_setup模块</strong>，该模块通过中断信号0X13读取到扇区数量，并跳转<strong>ok_load_setup</strong>模块，</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004806578.png\" alt=\"image-20210619004806578\"></p>\n<p><strong>image-20210619004806578</strong></p>\n<p>在该模块中获取磁盘参数，读取光标位置，循环写入24个字符，并在最后跳转<strong>read_it标号</strong>，而该标号属于<strong>System模块</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004820607.png\" alt=\"image-20210619004820607\"></p>\n<p><strong>image-20210619004820607</strong></p>\n<p>在System模块中，读取磁道，重新回到setup模块执行，CPU进入保护模式，并初始化中断控制，那CPU是如何进入保护模式的呢？自然需要标志寄存器cr0.当<code>PE=1时启动保护模式，PG=1时自动分页</code>，CPU在进入保护模式后，有一个关键跳转，即jmpi 0, 8,这里设置cs=8是用来查询GDT表，即中断向量表。这里我们简单那描述一下GDT表的表项——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004835241.png\" alt=\"image-20210619004835241\"></p>\n<p><strong>image-20210619004835241</strong></p>\n<p>那么程序计数器PC跳转到了哪呢？那就是关键的System模块，</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004851277.png\" alt=\"image-20210619004851277\"></p>\n<p><strong>image-20210619004851277</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004906587.png\" alt=\"image-20210619004906587\"></p>\n<p><strong>image-20210619004906587</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005014321.png\" alt=\"image-20210619005014321\"></p>\n<p><strong>image-20210619005014321</strong></p>\n<p>开局几张图，剩下全靠编，假装有”<strong>汇</strong>字”</p>\n<p>才疏学浅，这几张图以我的水准实在无法给出一个容易理解的答案，等什么时候经过时间沉淀突然悟了，再回来讲述这些汇编背后的故事………</p>\n</li>\n</ol>\n<h2 id=\"四、操作系统的接口\"><a href=\"#四、操作系统的接口\" class=\"headerlink\" title=\"四、操作系统的接口\"></a>四、操作系统的接口</h2><p>要学习操作系统的接口，我们必须先了解接口是什么，在日常生活中，我们使用插座，油门这种类型的物件，其实就是在使用接口。牛津词典是这样定义接口的：</p>\n<blockquote>\n<p>接口是连接两个东西，屏蔽细节，用于信号转换的</p>\n</blockquote>\n<p>那么什么是操作系统的接口呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005049553.png\" alt=\"image-20210619005049553\"></p>\n<p><strong>image-20210619005049553</strong></p>\n<p>可见，操作系统接口将上层软件和操作系统连接起来。表面上看用户可以直接与操作系统交互，然而操作系统接口是面对用户的吗？</p>\n<p>显然不是，我们通常使用计算机的方式有三种，分别是</p>\n<ul>\n<li><p>命令行</p>\n</li>\n<li><p>图形化界面</p>\n</li>\n<li><p>应用程序</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005102257.png\" alt=\"image-20210619005102257\"></p>\n<p><strong>image-20210619005102257</strong></p>\n</li>\n</ul>\n<p>由此可以看出操作系统接口不是面向用户的，这三种方式都归于调用系统常用的C语言函数及普通函数(<strong>应用程序接口</strong>)来实现。</p>\n<p>到这里，我们可以给出操作系统接口一个相对贴近的定义了——</p>\n<blockquote>\n<p>操作系统接口：接口表现为调用，又由系统提供，因而称操作系统接口为系统调用</p>\n</blockquote>\n<p>既然交互的过程是通过函数来实现的，那通常会调用那些函数呢，IEEE组织针对系统调用制定了一个标准族，即<strong>POSIX</strong></p>\n<blockquote>\n<p><strong>可移植操作系统接口</strong>（英语：Portable Operating System Interface，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行的软件，而定义API的一系列互相关联的标准的总称</p>\n</blockquote>\n<ul>\n<li> 参考目录：</li>\n</ul>\n<ol>\n<li>哈工大李志军老师操作系统</li>\n<li>蓝桥实验楼</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、什么是操作系统\"><a href=\"#一、什么是操作系统\" class=\"headerlink\" title=\"一、什么是操作系统\"></a>一、什么是操作系统</h2><h3 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1.引言\"></a>1.引言</h3><p>首先我们来看<strong>计算机硬件</strong>设备的分布</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004641611.png\" alt=\"image-20210619004641611\"></p>\n<p><strong>image-20210619004641611</strong></p>\n<p>那么有了这些硬件设备，计算机可以干什么呢，计算机可以帮助我们解决很多实际的问题，比如当我们在键盘上输入“hello world”，计算机会帮我们将其展示在显示器上，这里我们给出实现的机制：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004659758.png\" alt=\"image-20210619004659758\"></p>\n<p><strong>image-20210619004659758</strong></p>\n<p>但在实际实现的时候，我们只需键入即可，而底层复杂的操作对于用户来说就像一个黑盒子，是不可见的。那这个封装起来的黑盒子是由什么实现的呢，</p>\n<p>这里我们先给出结论——<code>操作系统</code></p>\n<h3 id=\"2-定义\"><a href=\"#2-定义\" class=\"headerlink\" title=\"2.定义\"></a>2.定义</h3><blockquote>\n<p>操作系统OperatingSystem，简称OSOperatingSystem，简称OS是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p>\n</blockquote>\n<p>下面我们来对定义进行剖析</p>\n<p>操作系统管理的计算机硬件都有什么？</p>\n<ul>\n<li><strong>cpu管理</strong></li>\n<li><strong>内存管理</strong></li>\n<li><strong>终端管理</strong></li>\n<li><strong>磁盘管理</strong></li>\n<li><strong>文件管理</strong></li>\n<li>网络管理</li>\n<li>电源管理</li>\n<li>多核管理</li>\n</ul>\n<p>而对于操作系统，我们应该做到<strong>能改操作系统</strong>。</p>\n<h2 id=\"二、打开钢琴的盖子\"><a href=\"#二、打开钢琴的盖子\" class=\"headerlink\" title=\"二、打开钢琴的盖子\"></a>二、打开钢琴的盖子</h2><p>我们不妨把操作系统比作一个钢琴，要弹出美妙的乐曲，我们不仅要了解每个琴键的作用，也要可以打开盖子，通过调整琴弦的粗细长短改变音调。</p>\n<p>我们不妨试着打开计算机的盖子，从打开电源的那一刻开始，操作系统的故事就已然开始了——</p>\n<p>首先，我们先根据认知猜测一下，打开电源后显示”loading …”,那这些数据是通过怎样的曲折最终发送到显存的呢？开机后，整个IO设备和文件系统都可以用了，是不是在开机时完成的初始化呢，如果是，又做了怎样的初始化呢？</p>\n<p>这一切，都要从最核心的思想——<strong>冯诺依曼结构</strong>谈起。</p>\n<h3 id=\"1-冯诺依曼结构\"><a href=\"#1-冯诺依曼结构\" class=\"headerlink\" title=\"1.冯诺依曼结构\"></a>1.冯诺依曼结构</h3><p>艺术来源于生活，技术也不例外，计算机说到底就是一个计算模型，当人要计算1+1=2的时候，我们会先将1+1写在纸上，然后大脑运算出结果2，再将其写到纸上。这里，<code>纸就如同一个存储器，而大脑就是运算器，控制器，笔是输入输出设备</code>。很酷对吧，但是1*1=？怎么搞呢？2/2呢，看来这个计算模型还需要存储多种模式，而运算器能识别不同的模式。至此，无龙珠集齐，我们可以召唤神龙——冯诺依曼结构</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004719586.png\" alt=\"image-20210619004719586\"></p>\n<p><strong>image-20210619004719586</strong></p>\n<p><strong>所谓大道至简，不过如是</strong></p>\n<hr>\n<h2 id=\"三、操纵系统启动过程\"><a href=\"#三、操纵系统启动过程\" class=\"headerlink\" title=\"三、操纵系统启动过程\"></a>三、操纵系统启动过程</h2><p>小小的分割一手，因为以上知识帮助我们在脑海中形成了一个操作系统的最小单元，接下来就要一探究竟了。</p>\n<p>计算机对应用程序的处理，也就是取指执行的过程，那么它指向内存何处呢？</p>\n<ol>\n<li><p>X86 PC刚开机时CPU处于<strong>实模式</strong>，此时<strong>CS=0XFFFF,IP=0X0000</strong>,寻址到<strong>0XFFFFO</strong>,也就是<strong>ROM BIOS映射区</strong>，接着检查<strong>RAM,键盘，显示器，软硬磁盘</strong>，将<strong>磁盘的0磁道0扇区</strong>读入<strong>0X7C00</strong>处，设置cs=0x7c0,ip=0x0000</p>\n</li>\n<li><p>为什么要跳转到0X7C00处呢？这块内存区域存储的是什么呢？</p>\n<p>这里存放的是磁盘引导扇区读入的512个字节，也是开机后执行的第一段我们可以控制的程序，操作系统的故事从这里开始……..</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004735500.png\" alt=\"image-20210619004735500\"></p>\n<p><strong>image-20210619004735500</strong></p>\n<p>代码很多，我们不追求每句都能看懂，而要抓住核心点——</p>\n<p>这段代码将引导扇区的代码<code>以字节为单位循环加载到CS=INITSEG，ip= GO</code>处,或称<strong>段间跳转</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004753041.png\" alt=\"image-20210619004753041\"></p>\n<p><strong>image-20210619004753041</strong></p>\n<p>在bootsect.s中<strong>加载load_setup模块</strong>，该模块通过中断信号0X13读取到扇区数量，并跳转<strong>ok_load_setup</strong>模块，</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004806578.png\" alt=\"image-20210619004806578\"></p>\n<p><strong>image-20210619004806578</strong></p>\n<p>在该模块中获取磁盘参数，读取光标位置，循环写入24个字符，并在最后跳转<strong>read_it标号</strong>，而该标号属于<strong>System模块</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004820607.png\" alt=\"image-20210619004820607\"></p>\n<p><strong>image-20210619004820607</strong></p>\n<p>在System模块中，读取磁道，重新回到setup模块执行，CPU进入保护模式，并初始化中断控制，那CPU是如何进入保护模式的呢？自然需要标志寄存器cr0.当<code>PE=1时启动保护模式，PG=1时自动分页</code>，CPU在进入保护模式后，有一个关键跳转，即jmpi 0, 8,这里设置cs=8是用来查询GDT表，即中断向量表。这里我们简单那描述一下GDT表的表项——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004835241.png\" alt=\"image-20210619004835241\"></p>\n<p><strong>image-20210619004835241</strong></p>\n<p>那么程序计数器PC跳转到了哪呢？那就是关键的System模块，</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004851277.png\" alt=\"image-20210619004851277\"></p>\n<p><strong>image-20210619004851277</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619004906587.png\" alt=\"image-20210619004906587\"></p>\n<p><strong>image-20210619004906587</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005014321.png\" alt=\"image-20210619005014321\"></p>\n<p><strong>image-20210619005014321</strong></p>\n<p>开局几张图，剩下全靠编，假装有”<strong>汇</strong>字”</p>\n<p>才疏学浅，这几张图以我的水准实在无法给出一个容易理解的答案，等什么时候经过时间沉淀突然悟了，再回来讲述这些汇编背后的故事………</p>\n</li>\n</ol>\n<h2 id=\"四、操作系统的接口\"><a href=\"#四、操作系统的接口\" class=\"headerlink\" title=\"四、操作系统的接口\"></a>四、操作系统的接口</h2><p>要学习操作系统的接口，我们必须先了解接口是什么，在日常生活中，我们使用插座，油门这种类型的物件，其实就是在使用接口。牛津词典是这样定义接口的：</p>\n<blockquote>\n<p>接口是连接两个东西，屏蔽细节，用于信号转换的</p>\n</blockquote>\n<p>那么什么是操作系统的接口呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005049553.png\" alt=\"image-20210619005049553\"></p>\n<p><strong>image-20210619005049553</strong></p>\n<p>可见，操作系统接口将上层软件和操作系统连接起来。表面上看用户可以直接与操作系统交互，然而操作系统接口是面对用户的吗？</p>\n<p>显然不是，我们通常使用计算机的方式有三种，分别是</p>\n<ul>\n<li><p>命令行</p>\n</li>\n<li><p>图形化界面</p>\n</li>\n<li><p>应用程序</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619005102257.png\" alt=\"image-20210619005102257\"></p>\n<p><strong>image-20210619005102257</strong></p>\n</li>\n</ul>\n<p>由此可以看出操作系统接口不是面向用户的，这三种方式都归于调用系统常用的C语言函数及普通函数(<strong>应用程序接口</strong>)来实现。</p>\n<p>到这里，我们可以给出操作系统接口一个相对贴近的定义了——</p>\n<blockquote>\n<p>操作系统接口：接口表现为调用，又由系统提供，因而称操作系统接口为系统调用</p>\n</blockquote>\n<p>既然交互的过程是通过函数来实现的，那通常会调用那些函数呢，IEEE组织针对系统调用制定了一个标准族，即<strong>POSIX</strong></p>\n<blockquote>\n<p><strong>可移植操作系统接口</strong>（英语：Portable Operating System Interface，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行的软件，而定义API的一系列互相关联的标准的总称</p>\n</blockquote>\n<ul>\n<li> 参考目录：</li>\n</ul>\n<ol>\n<li>哈工大李志军老师操作系统</li>\n<li>蓝桥实验楼</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n"},{"title":"虚拟内存","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T03:26:10.000Z","password":null,"summary":null,"_content":"\n我们在第三章的内存管理中常用的一个概念是虚拟内存，虚拟内存是用**于分离用户与物理层**，且实现物**理内存的扩展**的。\n\n但对于虚拟内存的**内在机理**，我们没有太多的谈及，只是把它当做一个**黑盒子**来使用，在这一章中我们将剖根问底，来揭开谜底。。。\n\n------\n\n## 1.请求调页和内存换入\n\n从用户的视角来看，一个进程是**独享**系统的全部内存的，然而我们知道**物理内存是有限**的，不可能让每个进程真的任意使用所有内存，那这种**内存很大的假象**是如何制造出来的呢？\n\n就是通过**虚拟内存**的引入，在**用户的视角**能看得到的内存地址是**逻辑地址，它是分段使用**的，而分的这些段又最终剥开揉碎成**一页一页的地址空间**。\n\n但仅有这些逻辑地址，也就是现有地址空间是不够的，数据最终是需要被存储在实实在在的存储空间中的，也就是**映射到物理内存**。\n\n但4G的虚拟内存映射1G的物理内存，听起来着实不怎么靠谱，怎么办呢？\n\n- [x] `只有在需要的时候才做映射`\n\n这就好比仓库与门店的关系，门店的**货柜是有限**的，当顾客要求一样东西时，就需要从仓库中取出来放到货架，这样看起来**商店总是不缺货**，但实际上这**归功于仓库**。\n\n这里的从仓库取东西到门店的动作就相当于**从磁盘上请求调页到内存**，那么什么时候要调页呢？显然是**缺页**的时候？\n\n嗯，再来一下灵魂叩问——**为什么会缺页**呢？\n\n用户程序中的地址是逻辑地址，逻辑地址经过地址翻译成为物理地址，逻辑地址需要映射到物理地址才能真正被使用，那假如映射失败呢？**映射失败**也就是说**物理内存中没有对应的地址**。\n\n这时就该请求调页了，从磁盘调页到物理地址，映射成功，继续执行。\n\n### 一个实际系统的请求调页\n\n请求调页时，就会执行缺页中断。那首先要获取缺页中断的**中断号**，而中断号是在**操作系统初始化**的时候设置的，这里我们直接给出：\n\n- [x] 操作系统初始化时设置中断向量表 **interrupt vector table** (**IVT**) ，它里面存储有很多表项，即中断向量，也就是中断处理程序的入口地址。\n\n![image-20201121190122738](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190122738.png)\n\n接下来跳转中断处理程序，首先对**错误码进行压栈**，并将**页的错误线性地址**存储在**寄存器cr2**中——\n\n![image-20201121190333570](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190333570.png)\n\n将状态保存后，跳转**申请物理内存的函数**——\n\n![image-20201121190506454](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190506454.png)\n\n最后**将请求的页加载到物理内存**中，**重新设置映射地址**——\n\n![image-20201121190556951](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190556951.png)\n\n## 2.内存换出\n\n为了保持货架上总有人们想要的商品，我们通常会将货柜中不常用的商品先撤到仓库中以腾出空间。\n\n- [x] 内存也是如此，有换入，就必然有换出。\n\n那怎样实现内存的换出呢？换出哪个对于系统是最有利的呢？\n\n直观的想法，首先应该是**先来先换出**，想法很朴实，但系统中的进程都是有**优先级**的。所以继续往后想——\n\n我们想让**不重要的换出**，那怎样体现不重要呢？直白的说，就是**很少用到**，这就衍生出了**MIN算法**，它的核心在于**换出这个序列中最远的将被使用的那个进程**。\n\n这个想法还是很nice的，但我们无法预知以后发生的事情，也就无法做出有效的预估。\n\n但这种想法是值得借鉴的，由这种想法进而衍生出了**LRU算法**，所谓LRU算法，就是选出**最近最少使用**的那个进程，然后换出。这里也应用了**程序局部性**的特点。\n\n### LRU的准确实现——时间戳\n\n假设存在一个**页序列ABCABDADBCB**，但只有**四个存储块**，这时需要选出**具有最小时间戳的页**。\n\n![image-20201121201707370](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121201707370.png)\n\n但页表ldt也是需要维护的，每更换一次时间戳，就要对页表进行更新，而页表是内存中的，访存次数过多实现代价未免过高。\n\n### LRU的准确实现——页码栈\n\n页码栈的实现代价同样很大，因而不作为实际应用使用，但很有必要了解它的思想——\n\n栈中只有三个页的内存空间，**最底层的空间**存放**最-近最少使用的页**，**最上层的空间**存放**当前使用的页**。\n\n因此在发生缺页时，将**最底层栈内的页弹出**，然后将其压入栈顶。\n\n![image-20201121202032441](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121202032441.png)\n\n一言以蔽之，LRU的准确实现在实际应用中代价太大，不可取。我们来看下实际应用中使用的近似实现：\n\n### LRU的近似实现——将时间和变成是和否\n\n记录时间和的系统开销太大，那我们能不能只维护一个标志位，也就是为使用页框的每一页设置一个**引用位**。\n\n这里我们暂且不考虑多少个页框，也就是多少个帧更为合适。而是着重描述它的运行机制**SCR**(再给一次机会算法)——\n\n我们用**循环队列**来表述**页框**，假如**加载一页**到页框中，**硬件**会自动**设置标志位R=1**，如果**发生缺页**，就**扫描这个循环队列**，如果**标志位R=1**，则将它**置为0**，表示**这个页最近没有被使用过**，如果标志位**R=0**,则**淘汰该页**，并**换入新的页**。\n\n![image-20201121215941114](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215941114.png)\n\n这样就完美了吗？假如很**少发生缺页**，那么指针就不需要置位，也就不**需要移动指针**，这样标志位**R的值会在0和1之间反复切换**，这样SCR算法就会退化为**FIFO**，而这本质上是因为**标志位R记录了太多历史信息**，所以我们需要**清除历史信息**，也就需要引入一个**跑得更快的指针**——\n\n![image-20201121215954545](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215954545.png)\n\n这样的模型更像是一个时钟，因而SCR算法又称**CLOCK算法**\n\n那么置换的策略有了，我们还需要解决一个问题，分配多少帧更合适呢？\n\n假如帧过多，那么就不存在**内存的高效利用**了，如果分的少，又会导致换入频繁，进程总在等待IO，CPU利用率下降，最终发生**颠簸现象**——\n\n![image-20201121215924180](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215924180.png)\n\n这里我们只是提出通过**工作集的算法**可以算出分配多少合适，而不再过多讨论。\n\n------\n\n> 山高路远，静水深流。\n\n\n\n","source":"_posts/虚拟内存.md","raw":"---\ntitle: 虚拟内存\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 11:26:10\npassword:\nsummary:\ntags: 操作系统\ncategories: 计算机基础\n---\n\n我们在第三章的内存管理中常用的一个概念是虚拟内存，虚拟内存是用**于分离用户与物理层**，且实现物**理内存的扩展**的。\n\n但对于虚拟内存的**内在机理**，我们没有太多的谈及，只是把它当做一个**黑盒子**来使用，在这一章中我们将剖根问底，来揭开谜底。。。\n\n------\n\n## 1.请求调页和内存换入\n\n从用户的视角来看，一个进程是**独享**系统的全部内存的，然而我们知道**物理内存是有限**的，不可能让每个进程真的任意使用所有内存，那这种**内存很大的假象**是如何制造出来的呢？\n\n就是通过**虚拟内存**的引入，在**用户的视角**能看得到的内存地址是**逻辑地址，它是分段使用**的，而分的这些段又最终剥开揉碎成**一页一页的地址空间**。\n\n但仅有这些逻辑地址，也就是现有地址空间是不够的，数据最终是需要被存储在实实在在的存储空间中的，也就是**映射到物理内存**。\n\n但4G的虚拟内存映射1G的物理内存，听起来着实不怎么靠谱，怎么办呢？\n\n- [x] `只有在需要的时候才做映射`\n\n这就好比仓库与门店的关系，门店的**货柜是有限**的，当顾客要求一样东西时，就需要从仓库中取出来放到货架，这样看起来**商店总是不缺货**，但实际上这**归功于仓库**。\n\n这里的从仓库取东西到门店的动作就相当于**从磁盘上请求调页到内存**，那么什么时候要调页呢？显然是**缺页**的时候？\n\n嗯，再来一下灵魂叩问——**为什么会缺页**呢？\n\n用户程序中的地址是逻辑地址，逻辑地址经过地址翻译成为物理地址，逻辑地址需要映射到物理地址才能真正被使用，那假如映射失败呢？**映射失败**也就是说**物理内存中没有对应的地址**。\n\n这时就该请求调页了，从磁盘调页到物理地址，映射成功，继续执行。\n\n### 一个实际系统的请求调页\n\n请求调页时，就会执行缺页中断。那首先要获取缺页中断的**中断号**，而中断号是在**操作系统初始化**的时候设置的，这里我们直接给出：\n\n- [x] 操作系统初始化时设置中断向量表 **interrupt vector table** (**IVT**) ，它里面存储有很多表项，即中断向量，也就是中断处理程序的入口地址。\n\n![image-20201121190122738](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190122738.png)\n\n接下来跳转中断处理程序，首先对**错误码进行压栈**，并将**页的错误线性地址**存储在**寄存器cr2**中——\n\n![image-20201121190333570](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190333570.png)\n\n将状态保存后，跳转**申请物理内存的函数**——\n\n![image-20201121190506454](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190506454.png)\n\n最后**将请求的页加载到物理内存**中，**重新设置映射地址**——\n\n![image-20201121190556951](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190556951.png)\n\n## 2.内存换出\n\n为了保持货架上总有人们想要的商品，我们通常会将货柜中不常用的商品先撤到仓库中以腾出空间。\n\n- [x] 内存也是如此，有换入，就必然有换出。\n\n那怎样实现内存的换出呢？换出哪个对于系统是最有利的呢？\n\n直观的想法，首先应该是**先来先换出**，想法很朴实，但系统中的进程都是有**优先级**的。所以继续往后想——\n\n我们想让**不重要的换出**，那怎样体现不重要呢？直白的说，就是**很少用到**，这就衍生出了**MIN算法**，它的核心在于**换出这个序列中最远的将被使用的那个进程**。\n\n这个想法还是很nice的，但我们无法预知以后发生的事情，也就无法做出有效的预估。\n\n但这种想法是值得借鉴的，由这种想法进而衍生出了**LRU算法**，所谓LRU算法，就是选出**最近最少使用**的那个进程，然后换出。这里也应用了**程序局部性**的特点。\n\n### LRU的准确实现——时间戳\n\n假设存在一个**页序列ABCABDADBCB**，但只有**四个存储块**，这时需要选出**具有最小时间戳的页**。\n\n![image-20201121201707370](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121201707370.png)\n\n但页表ldt也是需要维护的，每更换一次时间戳，就要对页表进行更新，而页表是内存中的，访存次数过多实现代价未免过高。\n\n### LRU的准确实现——页码栈\n\n页码栈的实现代价同样很大，因而不作为实际应用使用，但很有必要了解它的思想——\n\n栈中只有三个页的内存空间，**最底层的空间**存放**最-近最少使用的页**，**最上层的空间**存放**当前使用的页**。\n\n因此在发生缺页时，将**最底层栈内的页弹出**，然后将其压入栈顶。\n\n![image-20201121202032441](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121202032441.png)\n\n一言以蔽之，LRU的准确实现在实际应用中代价太大，不可取。我们来看下实际应用中使用的近似实现：\n\n### LRU的近似实现——将时间和变成是和否\n\n记录时间和的系统开销太大，那我们能不能只维护一个标志位，也就是为使用页框的每一页设置一个**引用位**。\n\n这里我们暂且不考虑多少个页框，也就是多少个帧更为合适。而是着重描述它的运行机制**SCR**(再给一次机会算法)——\n\n我们用**循环队列**来表述**页框**，假如**加载一页**到页框中，**硬件**会自动**设置标志位R=1**，如果**发生缺页**，就**扫描这个循环队列**，如果**标志位R=1**，则将它**置为0**，表示**这个页最近没有被使用过**，如果标志位**R=0**,则**淘汰该页**，并**换入新的页**。\n\n![image-20201121215941114](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215941114.png)\n\n这样就完美了吗？假如很**少发生缺页**，那么指针就不需要置位，也就不**需要移动指针**，这样标志位**R的值会在0和1之间反复切换**，这样SCR算法就会退化为**FIFO**，而这本质上是因为**标志位R记录了太多历史信息**，所以我们需要**清除历史信息**，也就需要引入一个**跑得更快的指针**——\n\n![image-20201121215954545](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215954545.png)\n\n这样的模型更像是一个时钟，因而SCR算法又称**CLOCK算法**\n\n那么置换的策略有了，我们还需要解决一个问题，分配多少帧更合适呢？\n\n假如帧过多，那么就不存在**内存的高效利用**了，如果分的少，又会导致换入频繁，进程总在等待IO，CPU利用率下降，最终发生**颠簸现象**——\n\n![image-20201121215924180](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215924180.png)\n\n这里我们只是提出通过**工作集的算法**可以算出分配多少合适，而不再过多讨论。\n\n------\n\n> 山高路远，静水深流。\n\n\n\n","slug":"虚拟内存","published":1,"updated":"2023-09-24T09:50:29.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7l3000kxjcc09yd5fhw","content":"<p>我们在第三章的内存管理中常用的一个概念是虚拟内存，虚拟内存是用<strong>于分离用户与物理层</strong>，且实现物<strong>理内存的扩展</strong>的。</p>\n<p>但对于虚拟内存的<strong>内在机理</strong>，我们没有太多的谈及，只是把它当做一个<strong>黑盒子</strong>来使用，在这一章中我们将剖根问底，来揭开谜底。。。</p>\n<hr>\n<h2 id=\"1-请求调页和内存换入\"><a href=\"#1-请求调页和内存换入\" class=\"headerlink\" title=\"1.请求调页和内存换入\"></a>1.请求调页和内存换入</h2><p>从用户的视角来看，一个进程是<strong>独享</strong>系统的全部内存的，然而我们知道<strong>物理内存是有限</strong>的，不可能让每个进程真的任意使用所有内存，那这种<strong>内存很大的假象</strong>是如何制造出来的呢？</p>\n<p>就是通过<strong>虚拟内存</strong>的引入，在<strong>用户的视角</strong>能看得到的内存地址是<strong>逻辑地址，它是分段使用</strong>的，而分的这些段又最终剥开揉碎成<strong>一页一页的地址空间</strong>。</p>\n<p>但仅有这些逻辑地址，也就是现有地址空间是不够的，数据最终是需要被存储在实实在在的存储空间中的，也就是<strong>映射到物理内存</strong>。</p>\n<p>但4G的虚拟内存映射1G的物理内存，听起来着实不怎么靠谱，怎么办呢？</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <code>只有在需要的时候才做映射</code></li>\n</ul>\n<p>这就好比仓库与门店的关系，门店的<strong>货柜是有限</strong>的，当顾客要求一样东西时，就需要从仓库中取出来放到货架，这样看起来<strong>商店总是不缺货</strong>，但实际上这<strong>归功于仓库</strong>。</p>\n<p>这里的从仓库取东西到门店的动作就相当于<strong>从磁盘上请求调页到内存</strong>，那么什么时候要调页呢？显然是<strong>缺页</strong>的时候？</p>\n<p>嗯，再来一下灵魂叩问——<strong>为什么会缺页</strong>呢？</p>\n<p>用户程序中的地址是逻辑地址，逻辑地址经过地址翻译成为物理地址，逻辑地址需要映射到物理地址才能真正被使用，那假如映射失败呢？<strong>映射失败</strong>也就是说<strong>物理内存中没有对应的地址</strong>。</p>\n<p>这时就该请求调页了，从磁盘调页到物理地址，映射成功，继续执行。</p>\n<h3 id=\"一个实际系统的请求调页\"><a href=\"#一个实际系统的请求调页\" class=\"headerlink\" title=\"一个实际系统的请求调页\"></a>一个实际系统的请求调页</h3><p>请求调页时，就会执行缺页中断。那首先要获取缺页中断的<strong>中断号</strong>，而中断号是在<strong>操作系统初始化</strong>的时候设置的，这里我们直接给出：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 操作系统初始化时设置中断向量表 <strong>interrupt vector table</strong> (<strong>IVT</strong>) ，它里面存储有很多表项，即中断向量，也就是中断处理程序的入口地址。</li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190122738.png\" alt=\"image-20201121190122738\"></p>\n<p>接下来跳转中断处理程序，首先对<strong>错误码进行压栈</strong>，并将<strong>页的错误线性地址</strong>存储在<strong>寄存器cr2</strong>中——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190333570.png\" alt=\"image-20201121190333570\"></p>\n<p>将状态保存后，跳转<strong>申请物理内存的函数</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190506454.png\" alt=\"image-20201121190506454\"></p>\n<p>最后<strong>将请求的页加载到物理内存</strong>中，<strong>重新设置映射地址</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190556951.png\" alt=\"image-20201121190556951\"></p>\n<h2 id=\"2-内存换出\"><a href=\"#2-内存换出\" class=\"headerlink\" title=\"2.内存换出\"></a>2.内存换出</h2><p>为了保持货架上总有人们想要的商品，我们通常会将货柜中不常用的商品先撤到仓库中以腾出空间。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 内存也是如此，有换入，就必然有换出。</li>\n</ul>\n<p>那怎样实现内存的换出呢？换出哪个对于系统是最有利的呢？</p>\n<p>直观的想法，首先应该是<strong>先来先换出</strong>，想法很朴实，但系统中的进程都是有<strong>优先级</strong>的。所以继续往后想——</p>\n<p>我们想让<strong>不重要的换出</strong>，那怎样体现不重要呢？直白的说，就是<strong>很少用到</strong>，这就衍生出了<strong>MIN算法</strong>，它的核心在于<strong>换出这个序列中最远的将被使用的那个进程</strong>。</p>\n<p>这个想法还是很nice的，但我们无法预知以后发生的事情，也就无法做出有效的预估。</p>\n<p>但这种想法是值得借鉴的，由这种想法进而衍生出了<strong>LRU算法</strong>，所谓LRU算法，就是选出<strong>最近最少使用</strong>的那个进程，然后换出。这里也应用了<strong>程序局部性</strong>的特点。</p>\n<h3 id=\"LRU的准确实现——时间戳\"><a href=\"#LRU的准确实现——时间戳\" class=\"headerlink\" title=\"LRU的准确实现——时间戳\"></a>LRU的准确实现——时间戳</h3><p>假设存在一个<strong>页序列ABCABDADBCB</strong>，但只有<strong>四个存储块</strong>，这时需要选出<strong>具有最小时间戳的页</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121201707370.png\" alt=\"image-20201121201707370\"></p>\n<p>但页表ldt也是需要维护的，每更换一次时间戳，就要对页表进行更新，而页表是内存中的，访存次数过多实现代价未免过高。</p>\n<h3 id=\"LRU的准确实现——页码栈\"><a href=\"#LRU的准确实现——页码栈\" class=\"headerlink\" title=\"LRU的准确实现——页码栈\"></a>LRU的准确实现——页码栈</h3><p>页码栈的实现代价同样很大，因而不作为实际应用使用，但很有必要了解它的思想——</p>\n<p>栈中只有三个页的内存空间，<strong>最底层的空间</strong>存放<strong>最-近最少使用的页</strong>，<strong>最上层的空间</strong>存放<strong>当前使用的页</strong>。</p>\n<p>因此在发生缺页时，将<strong>最底层栈内的页弹出</strong>，然后将其压入栈顶。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121202032441.png\" alt=\"image-20201121202032441\"></p>\n<p>一言以蔽之，LRU的准确实现在实际应用中代价太大，不可取。我们来看下实际应用中使用的近似实现：</p>\n<h3 id=\"LRU的近似实现——将时间和变成是和否\"><a href=\"#LRU的近似实现——将时间和变成是和否\" class=\"headerlink\" title=\"LRU的近似实现——将时间和变成是和否\"></a>LRU的近似实现——将时间和变成是和否</h3><p>记录时间和的系统开销太大，那我们能不能只维护一个标志位，也就是为使用页框的每一页设置一个<strong>引用位</strong>。</p>\n<p>这里我们暂且不考虑多少个页框，也就是多少个帧更为合适。而是着重描述它的运行机制<strong>SCR</strong>(再给一次机会算法)——</p>\n<p>我们用<strong>循环队列</strong>来表述<strong>页框</strong>，假如<strong>加载一页</strong>到页框中，<strong>硬件</strong>会自动<strong>设置标志位R=1</strong>，如果<strong>发生缺页</strong>，就<strong>扫描这个循环队列</strong>，如果<strong>标志位R=1</strong>，则将它<strong>置为0</strong>，表示<strong>这个页最近没有被使用过</strong>，如果标志位<strong>R=0</strong>,则<strong>淘汰该页</strong>，并<strong>换入新的页</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215941114.png\" alt=\"image-20201121215941114\"></p>\n<p>这样就完美了吗？假如很<strong>少发生缺页</strong>，那么指针就不需要置位，也就不<strong>需要移动指针</strong>，这样标志位<strong>R的值会在0和1之间反复切换</strong>，这样SCR算法就会退化为<strong>FIFO</strong>，而这本质上是因为<strong>标志位R记录了太多历史信息</strong>，所以我们需要<strong>清除历史信息</strong>，也就需要引入一个<strong>跑得更快的指针</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215954545.png\" alt=\"image-20201121215954545\"></p>\n<p>这样的模型更像是一个时钟，因而SCR算法又称<strong>CLOCK算法</strong></p>\n<p>那么置换的策略有了，我们还需要解决一个问题，分配多少帧更合适呢？</p>\n<p>假如帧过多，那么就不存在<strong>内存的高效利用</strong>了，如果分的少，又会导致换入频繁，进程总在等待IO，CPU利用率下降，最终发生<strong>颠簸现象</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215924180.png\" alt=\"image-20201121215924180\"></p>\n<p>这里我们只是提出通过<strong>工作集的算法</strong>可以算出分配多少合适，而不再过多讨论。</p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>我们在第三章的内存管理中常用的一个概念是虚拟内存，虚拟内存是用<strong>于分离用户与物理层</strong>，且实现物<strong>理内存的扩展</strong>的。</p>\n<p>但对于虚拟内存的<strong>内在机理</strong>，我们没有太多的谈及，只是把它当做一个<strong>黑盒子</strong>来使用，在这一章中我们将剖根问底，来揭开谜底。。。</p>\n<hr>\n<h2 id=\"1-请求调页和内存换入\"><a href=\"#1-请求调页和内存换入\" class=\"headerlink\" title=\"1.请求调页和内存换入\"></a>1.请求调页和内存换入</h2><p>从用户的视角来看，一个进程是<strong>独享</strong>系统的全部内存的，然而我们知道<strong>物理内存是有限</strong>的，不可能让每个进程真的任意使用所有内存，那这种<strong>内存很大的假象</strong>是如何制造出来的呢？</p>\n<p>就是通过<strong>虚拟内存</strong>的引入，在<strong>用户的视角</strong>能看得到的内存地址是<strong>逻辑地址，它是分段使用</strong>的，而分的这些段又最终剥开揉碎成<strong>一页一页的地址空间</strong>。</p>\n<p>但仅有这些逻辑地址，也就是现有地址空间是不够的，数据最终是需要被存储在实实在在的存储空间中的，也就是<strong>映射到物理内存</strong>。</p>\n<p>但4G的虚拟内存映射1G的物理内存，听起来着实不怎么靠谱，怎么办呢？</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <code>只有在需要的时候才做映射</code></li>\n</ul>\n<p>这就好比仓库与门店的关系，门店的<strong>货柜是有限</strong>的，当顾客要求一样东西时，就需要从仓库中取出来放到货架，这样看起来<strong>商店总是不缺货</strong>，但实际上这<strong>归功于仓库</strong>。</p>\n<p>这里的从仓库取东西到门店的动作就相当于<strong>从磁盘上请求调页到内存</strong>，那么什么时候要调页呢？显然是<strong>缺页</strong>的时候？</p>\n<p>嗯，再来一下灵魂叩问——<strong>为什么会缺页</strong>呢？</p>\n<p>用户程序中的地址是逻辑地址，逻辑地址经过地址翻译成为物理地址，逻辑地址需要映射到物理地址才能真正被使用，那假如映射失败呢？<strong>映射失败</strong>也就是说<strong>物理内存中没有对应的地址</strong>。</p>\n<p>这时就该请求调页了，从磁盘调页到物理地址，映射成功，继续执行。</p>\n<h3 id=\"一个实际系统的请求调页\"><a href=\"#一个实际系统的请求调页\" class=\"headerlink\" title=\"一个实际系统的请求调页\"></a>一个实际系统的请求调页</h3><p>请求调页时，就会执行缺页中断。那首先要获取缺页中断的<strong>中断号</strong>，而中断号是在<strong>操作系统初始化</strong>的时候设置的，这里我们直接给出：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 操作系统初始化时设置中断向量表 <strong>interrupt vector table</strong> (<strong>IVT</strong>) ，它里面存储有很多表项，即中断向量，也就是中断处理程序的入口地址。</li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190122738.png\" alt=\"image-20201121190122738\"></p>\n<p>接下来跳转中断处理程序，首先对<strong>错误码进行压栈</strong>，并将<strong>页的错误线性地址</strong>存储在<strong>寄存器cr2</strong>中——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190333570.png\" alt=\"image-20201121190333570\"></p>\n<p>将状态保存后，跳转<strong>申请物理内存的函数</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190506454.png\" alt=\"image-20201121190506454\"></p>\n<p>最后<strong>将请求的页加载到物理内存</strong>中，<strong>重新设置映射地址</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121190556951.png\" alt=\"image-20201121190556951\"></p>\n<h2 id=\"2-内存换出\"><a href=\"#2-内存换出\" class=\"headerlink\" title=\"2.内存换出\"></a>2.内存换出</h2><p>为了保持货架上总有人们想要的商品，我们通常会将货柜中不常用的商品先撤到仓库中以腾出空间。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 内存也是如此，有换入，就必然有换出。</li>\n</ul>\n<p>那怎样实现内存的换出呢？换出哪个对于系统是最有利的呢？</p>\n<p>直观的想法，首先应该是<strong>先来先换出</strong>，想法很朴实，但系统中的进程都是有<strong>优先级</strong>的。所以继续往后想——</p>\n<p>我们想让<strong>不重要的换出</strong>，那怎样体现不重要呢？直白的说，就是<strong>很少用到</strong>，这就衍生出了<strong>MIN算法</strong>，它的核心在于<strong>换出这个序列中最远的将被使用的那个进程</strong>。</p>\n<p>这个想法还是很nice的，但我们无法预知以后发生的事情，也就无法做出有效的预估。</p>\n<p>但这种想法是值得借鉴的，由这种想法进而衍生出了<strong>LRU算法</strong>，所谓LRU算法，就是选出<strong>最近最少使用</strong>的那个进程，然后换出。这里也应用了<strong>程序局部性</strong>的特点。</p>\n<h3 id=\"LRU的准确实现——时间戳\"><a href=\"#LRU的准确实现——时间戳\" class=\"headerlink\" title=\"LRU的准确实现——时间戳\"></a>LRU的准确实现——时间戳</h3><p>假设存在一个<strong>页序列ABCABDADBCB</strong>，但只有<strong>四个存储块</strong>，这时需要选出<strong>具有最小时间戳的页</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121201707370.png\" alt=\"image-20201121201707370\"></p>\n<p>但页表ldt也是需要维护的，每更换一次时间戳，就要对页表进行更新，而页表是内存中的，访存次数过多实现代价未免过高。</p>\n<h3 id=\"LRU的准确实现——页码栈\"><a href=\"#LRU的准确实现——页码栈\" class=\"headerlink\" title=\"LRU的准确实现——页码栈\"></a>LRU的准确实现——页码栈</h3><p>页码栈的实现代价同样很大，因而不作为实际应用使用，但很有必要了解它的思想——</p>\n<p>栈中只有三个页的内存空间，<strong>最底层的空间</strong>存放<strong>最-近最少使用的页</strong>，<strong>最上层的空间</strong>存放<strong>当前使用的页</strong>。</p>\n<p>因此在发生缺页时，将<strong>最底层栈内的页弹出</strong>，然后将其压入栈顶。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121202032441.png\" alt=\"image-20201121202032441\"></p>\n<p>一言以蔽之，LRU的准确实现在实际应用中代价太大，不可取。我们来看下实际应用中使用的近似实现：</p>\n<h3 id=\"LRU的近似实现——将时间和变成是和否\"><a href=\"#LRU的近似实现——将时间和变成是和否\" class=\"headerlink\" title=\"LRU的近似实现——将时间和变成是和否\"></a>LRU的近似实现——将时间和变成是和否</h3><p>记录时间和的系统开销太大，那我们能不能只维护一个标志位，也就是为使用页框的每一页设置一个<strong>引用位</strong>。</p>\n<p>这里我们暂且不考虑多少个页框，也就是多少个帧更为合适。而是着重描述它的运行机制<strong>SCR</strong>(再给一次机会算法)——</p>\n<p>我们用<strong>循环队列</strong>来表述<strong>页框</strong>，假如<strong>加载一页</strong>到页框中，<strong>硬件</strong>会自动<strong>设置标志位R=1</strong>，如果<strong>发生缺页</strong>，就<strong>扫描这个循环队列</strong>，如果<strong>标志位R=1</strong>，则将它<strong>置为0</strong>，表示<strong>这个页最近没有被使用过</strong>，如果标志位<strong>R=0</strong>,则<strong>淘汰该页</strong>，并<strong>换入新的页</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215941114.png\" alt=\"image-20201121215941114\"></p>\n<p>这样就完美了吗？假如很<strong>少发生缺页</strong>，那么指针就不需要置位，也就不<strong>需要移动指针</strong>，这样标志位<strong>R的值会在0和1之间反复切换</strong>，这样SCR算法就会退化为<strong>FIFO</strong>，而这本质上是因为<strong>标志位R记录了太多历史信息</strong>，所以我们需要<strong>清除历史信息</strong>，也就需要引入一个<strong>跑得更快的指针</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215954545.png\" alt=\"image-20201121215954545\"></p>\n<p>这样的模型更像是一个时钟，因而SCR算法又称<strong>CLOCK算法</strong></p>\n<p>那么置换的策略有了，我们还需要解决一个问题，分配多少帧更合适呢？</p>\n<p>假如帧过多，那么就不存在<strong>内存的高效利用</strong>了，如果分的少，又会导致换入频繁，进程总在等待IO，CPU利用率下降，最终发生<strong>颠簸现象</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201121215924180.png\" alt=\"image-20201121215924180\"></p>\n<p>这里我们只是提出通过<strong>工作集的算法</strong>可以算出分配多少合适，而不再过多讨论。</p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n"},{"title":"计算机网络概述","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T03:47:57.000Z","password":null,"summary":null,"_content":"\n## 前言\n\n终于要进入**正题**了。\n\n但当看到第一章居然是概述，小伙伴们可能会困惑，概述的内容值得这么大的篇章吗？起初我也抱着这样的心里，所以仓促的看了下第一章，就去看后面的重点内容了。但往后学，慢慢发现**所有的框架知识都是在概述建立的，还有那繁多却实用的术语**，所以呢，在写这篇文章之前，我又老老实实看了一遍这看似鸡肋的概述。\n\n其实呢，第一章的内容设置还是很**友好**的，在这一章中，我们首先就会从**网络的定义**出发，探寻**网络的框架结构**，深入**技术发展的征途**，最终自然的回归**分层模型**。\n\n如果通过第一章的学习能让我们建立起学习的纹路，那就不虚此行了。话不多说，出发咯——\n\n------\n\n## 1.1 什么是Internet\n\n网络是什么？这个是很宽泛的问题，我们将从两个维度来展开——\n\n### 从组成角度\n\n从数学的概念出发，网这种数据结构包含边和点。同样的，Internet包含**节点**和**通信链路**。而除此之外，一个网络还必须有**协议**的支持才能稳定的运行。\n\n`节点`：网络中的节点有两类，端节点和分组节点。端节点是指**主机及其上运行的应用程序**，而分组节点则是**路由器，交换机等网络交换设备**；\n\n`通信链路` ： 根据通信链路所在的位置分为**接入网链路**和**主干链路**。接入网链路是指从主机连接到互联网的链路，比如我们日常生活使用无线接入设备WIFI接入互联网就是接入网。而主干链路是指路由器之间的链路，它负责数据的传输和中转，通常通信链路使用的材质为**双绞线，光纤，电缆**等。\n\n那么如何衡量通信链路的传输速率呢，就需要引入**带宽**，带宽在通信和网络中的定义是有所区别的，在计算机网络中，带宽被这样定义：\n\n> 带宽，在计算机网络中用来表示网络的**通信线路传输数据的能力**。注意，这里是传输，而不是传播，带宽描述的是**发送数据的发送器的能力强弱**，而带宽越大，将数据注入这个链路所需要的时间就越少。而传播和发送器是没有关系的。它表示的是信号在信道中传输的速率。\n\n那协议又是什么东东呢？协议指在对等实体之间通信需要遵循的规则。通常我们会从一个协议的**语法**，**语义**，**时序**，**动作**方面来衡量一个协议。\n\n![image-20210707204758527](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204758527.png)\n\n### 从服务角度\n\n从服务的维度来看，Internet包括**分布式的应用程序**和**支撑分布式应用程序通信的基础设施**。\n\n------\n\n## 1.2 网络边缘\n\n网络边缘包含**计算机和其他接入网络的设备**，又因为他们处于边缘位置，故也称**端系统**。它的另一为人所知的称谓是**主机**，而网络边缘即是**主机+运行在主机上的应用程序**\n\n我们来看下面的网络图示——\n\n![image-20210707204813922](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204813922.png)\n\n在这个图中**，计算机，服务器，AP(无线访问设备)**都属于端系统的范畴。\n\n那这些端系统是如何介入网络的呢？很显然，通过通信链路，更具体的说，是通过**接入网**，接入网是**将端系统物理连接到边缘路由器**的链路。\n\n写到这，**不妨将知识映射到实际的应用**。我家是使用**电话线**来接入因特网的，学过通信原理的朋友都知道在信道中传输的信号必须是**数字信号**，也就是说，我们需要一个**调制解调器**来完成信号的转换，这就是我们常说的**猫(Modem)**。这样就可以保证使用计算机上网了。但如果要多个设备都接入网络，就需要我们常说的WIFI，具体的说，是**WIFI路由器**，WIFI路由器上有**很多以太网的网口**，这样就可以实现多设备的接入网络了，当然，是**共享带宽**哦。\n\n![image-20210707204826842](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png)\n\n而同样值得一提的是，使用电话线的接入网它的**上行和下行的速率是不一样的**，我们普遍的需求是下载的速度更快，而对上传的速率没有严格的要求，因此使用这种带宽分发策略更有利。\n\n接入网的方式自然不限于电话线，使用线缆反而是现在更通用的方式。\n\n![image-20210707204838947](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png)\n\n我们来描述一下这个过程——\n**首先计算机通过Modem,即DSL调制解调器完成信号的转化，连接线缆的设备共享线缆的接入网络，再通过CMTS(线缆调制解调终端系统)接入到ISP的路由器中。**\n\n我们描述了端系统是如何接入网络的，那端系统之上的**应用进程是如何通信的呢**？\n\n应用进程属于应用层，应用层的通信实现需要**通过传输层提供的接口调用传输层的服务**。当然，这只是一个概述，具体展开那就是第二章的故事了。\n\n换一个维度看，也就是从通信模式上说，应用进程之间的通信分为CS模式和P2P模式，我们常使用的WEB应用使用的就是CS架构，而迅雷使用的则是P2P模式，它们各有千秋，在后面章节中后提及~\n\n> 总而言之。网络边缘负责提供应用进程端到端的通信。\n\n------\n\n## 1.3 网络核心\n\n前面我们提及网络边缘通过接入网接入Internet，其实这种说法是不准确的，通过接入网接入的是网络核心，而网络核心指的是路由器的网状网络，所以说，网络核心其**本质是网络的网络**。\n\n从大的框架来看，**网络核心是为网络边缘服务的**，它负责将数据从一个应用进程通过网络核心这个黑盒子传输到另一个应用进程。\n\n那怎样实现传输呢？接根线直接连过去显然不合适，那是名副其实的互连，但着实不优雅。\n\n我们需要一种**中继的设备**，它需要知道数据从何而来，要去往何处，也要保证传输一定程度的稳定。在实际中，满足这样需求的设备就是**交换机。而使用网络链路和交换机传输数据有两种基本方法：**电路交换和分组交换。\n\n### 电路交换\n\n电路交换的思路是**为每一个呼叫预留一条专有的电路**。\n\n![image-20210707204900893](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204900893.png)\n\n从上图中可以看到，在两个交换机之间有四条链路，假如网络带宽是1Mbps,那每条链路的带宽都是250Kbps,发起通信以后以后，首先会建立一个专有的连接，在连接保持期间，它独享链路资源。这就好比两个人通过手机正在通话，第三方想接入的话会显示占线中。\n\n这种VIP的通信服务除了`专用带宽`以外，它也提供`缓存服务`。但同时它的缺点也很明显，接入的用户太少了。因特网的用户接入是有局部性和突发性的，一成不变的电路交换显然不能胜任。\n\n这里需要额外的给出一些**小贴士**：\n\n> 带宽可以认为是网络中的一种资源，而为了更充分的利用这种资源，通常将带宽分成片。这里可以类比CPU的时间片。通常的分片方式有时分，频分，码分，波分。\n>\n> ![image-20210707204915415](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204915415.png)\n\n### 分组交换\n\n分组交换传输数据的**粒度更小**，它是**基于分组**的传输，那首先要了解分组的定义，在端与端之间传输数据的单元是报文。报文中包含协议设计者需要的任何东西。而网络核心的设备处于网络层，因而源主机将报文分成一个个的分组，分组按照协议要求，封装特定的头部和实体部分，在网络中传输。\n\n为了量化传输的效率，我们通常将分组的长度记做L比特，而将链路的传输速率记做R比特/秒，即带宽为Rbps，那传输速率就为L/R。\n\n分组交换为了提高传输的效率并让传输变得稳定可控，采用**存储转发**的机制。即路由器先将接收到的分组存储起来，将分组中的某些信息取出，按照一定的路由算法得到路由表，再由路由表即可得到下一条的IP地址，最终将分组转发给下一个路由器。\n\n上面我们提及存储转发可以让传输稳定可用，但实际上，**存储转发只是一种尽力而为的机制**。\n\n![image-20210707204929034](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204929034.png)\n\n当`分组的到达速率>链路的输出速率`，分组就需要排队，当队列已满，即路由器的`缓存用完`时，分组就`会被抛弃`。\n\n从上图中可以看出，分组`没有时序的讲究`，分组共享链路的带宽资源。我们常将这种模式称为统计多路复用。\n\n### 网络核心的关键功能\n\n1. **路由**\n\n   即决定分组采用的源到目标的路径，传统的是使用**路由算法**得到下一条的地址，而现在效率更高，也更通用的方式是——`控制平面与数据平面`。第四章会着重聊到。\n\n2. 转发\n\n   即将分组从路由器的输入链路转移到输出链路。\n\n### 分组交换VS电路交换\n\n理论知识的掌握仅仅是定性，要想更透彻的了解区别，还需要定量分析，我们一起来看下面的小例子——\n\n> 假设链路的带宽是1Mbps,,每个用户活动时所需要的带宽为100kbps，且每个用户只有10%的时间是活动的，分析电路交换和分组交换模式下所能支撑的最大用户数量？\n\n- 电路交换： 显然可以支撑1M/100K=**10个**用户\n\n- 分组交换：假设有35个用户，按使用概率论的知识可以求得**链路不允许10个以上用户活动的概率为0.004**\n\n  ![image-20210707204942286](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204942286.png)\n\n  通俗的说，允许10个以上用户活动的概率就等于允许0个，1个。。。的**概率累加和**，而35个中可以允许1个用户活动的概率服从**伯努利实验，即二项分布**。\n\n  ![image-20210204122319342](http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210204122319342.png)\n\n  通过计算结果，很容易推断出分组交换在`用户容量`方面优于电路交换。\n\n------\n\n## 1.4 Internet结构与ISP\n\n这里我们不再回顾Internet的演变过程，下图直接给出最终的框架——\n\n![image-20210707204955995](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204955995.png)\n\n那如何来解释这张网络架构图呢？我们以**从边沿到核心的思路**说起：\n\n首先零散的端系统接入到`附近的ISP服务商`提供的区域网络，区域接入再通过很多路由器接入到去`global ISPS`,global ISPS通过互连IXP的方式接入到其他的global ISPS，这样一个网络框架就有了。但网络还需要实质的数据传输，这时候`ICP(内容分发网络，如谷歌)`就加入进去了，而为了节省成本，ICP通常会自己搭建更靠近用户的网络来向用户提供服务。\n\n为了更形象的展示错综复杂的网络，我们看下实际应用中的网络——\n\n![image-20210707205016410](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205016410.png)\n\n------\n\n## 1.5 分组延时,丢失和吞吐量\n\n又到了万恶的知识点环节，但朋友们大可放心，这些概念还是很好理解的——\n\n### 分组延时\n\n![image-20210707205026706](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205026706.png)\n\n分组延时有四种——\n\n- `节点处理延时`：检查**分组首部**以及决定将分组导向何处。\n\n- `排队延时`：在输出链路上**等待传输**的时间\n\n  在排队延时中我们引入**流量强度**的概念——\n  $$\n  流量强度=La/R\n  $$\n  a指的是分组到达队列的**平均速率**。\n\n  ![image-20210707205224266](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205224266.png)\n\n- `传输延时`：长度为L的分组在带宽为Rbps的链路上传输的时间为**L/R**.\n\n- `传播延时`：在**物理链路上的传播时间**。\n\n### 分组丢失\n\n当分组到达队列已满的路由器时，分组根据协议类型被**丢弃**或从上一个节点**重传**。\n\n### 吞吐量\n\n吞吐量指单位时间内从源端传输到目标端的数据量，它**取决于路径上最小的吞吐量**。\n\n------\n\n## 1.6 协议层次与服务模型\n\n在解决复杂问题时，将问题模块化，分层解决是一个很好的思路，我们先来看日常生活中称作航班的例子——\n\n![image-20210707205236557](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205236557.png)\n\n这个例子有什么特点呢？\n\n1. 在每一层都实现了**特定的功能**，比如购票，托运行李巴拉巴拉；\n2. 在使用上层服务时，必须依托下层提供的**服务**。简言之，总得先购票才能坐飞机吧，当然，像<猫和老鼠>中的莱昂纳多除外~\n3. 每一层都有特有的**规范**，比如按特定路线航行。\n\n在上面我们了服务，那怎样解释服务呢？\n\n`服务`：底层实体向上层实体提供他们之间的通信的能力。\n\n与服务会发生概念混淆的，是**原语**的概念，这里的原语区别于操作系统的原语，指的是使用服务的方式，说白了，就是**API**。有了服务，自然就有服务作用的对象——\n\n`服务访问点SAP`: 即下层提供的服务要通过**接口**来让上层调用。在传输层，SAP就是端口。\n\n我们将服务的粒度放小就是**数据单元DU**，下面的图会展示DU的结构——\n\n![image-20210707205247263](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205247263.png)\n\n也就是说，数据单元是由**实体+特定的协议头部**构成的。\n\n到这里，前置知识大抵就完了，我们直接上正菜——\n\n![image-20210707205300541](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205300541.png)\n\n换种描述方式——\n\n| 协议分层 | 数据单元 | 服务                       | 服务访问点 | 常用协议          | **关键词**                                            |\n| -------- | -------- | -------------------------- | ---------- | ----------------- | ----------------------------------------------------- |\n| 应用层   | 报文     | 网络应用                   |            | HTTP.DNS,SMTP,FTP |                                                       |\n| 传输层   | 报文段   | 主机之间的数据传输         | 端口       | TCP/UDP           | 拥塞控制，流量管理，可靠数据传输，面向连接/不面向连接 |\n| 网络层   | 分组     | 为数据包从源到目的选择路由 | IP地址     | IP                | 路由，转发                                            |\n| 链路层   | 数据帧   | 相邻网络节点间的数据传输   |            | PPP,802.11WIFI    | 不可靠                                                |\n| 物理层   | 字节     | 在线路上传送bit            |            |                   | 通信链路                                              |\n\n这时我们就可以解答实际中应用程序间的通信是如何实现的啦——\n\n![image-20210707205315024](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205315024.png)\n\n> 山高路远，静水深流","source":"_posts/计算机网络概述.md","raw":"---\ntitle: 计算机网络概述\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 11:47:57\npassword:\nsummary:\ntags: 计算机网络\ncategories: 计算机基础\n---\n\n## 前言\n\n终于要进入**正题**了。\n\n但当看到第一章居然是概述，小伙伴们可能会困惑，概述的内容值得这么大的篇章吗？起初我也抱着这样的心里，所以仓促的看了下第一章，就去看后面的重点内容了。但往后学，慢慢发现**所有的框架知识都是在概述建立的，还有那繁多却实用的术语**，所以呢，在写这篇文章之前，我又老老实实看了一遍这看似鸡肋的概述。\n\n其实呢，第一章的内容设置还是很**友好**的，在这一章中，我们首先就会从**网络的定义**出发，探寻**网络的框架结构**，深入**技术发展的征途**，最终自然的回归**分层模型**。\n\n如果通过第一章的学习能让我们建立起学习的纹路，那就不虚此行了。话不多说，出发咯——\n\n------\n\n## 1.1 什么是Internet\n\n网络是什么？这个是很宽泛的问题，我们将从两个维度来展开——\n\n### 从组成角度\n\n从数学的概念出发，网这种数据结构包含边和点。同样的，Internet包含**节点**和**通信链路**。而除此之外，一个网络还必须有**协议**的支持才能稳定的运行。\n\n`节点`：网络中的节点有两类，端节点和分组节点。端节点是指**主机及其上运行的应用程序**，而分组节点则是**路由器，交换机等网络交换设备**；\n\n`通信链路` ： 根据通信链路所在的位置分为**接入网链路**和**主干链路**。接入网链路是指从主机连接到互联网的链路，比如我们日常生活使用无线接入设备WIFI接入互联网就是接入网。而主干链路是指路由器之间的链路，它负责数据的传输和中转，通常通信链路使用的材质为**双绞线，光纤，电缆**等。\n\n那么如何衡量通信链路的传输速率呢，就需要引入**带宽**，带宽在通信和网络中的定义是有所区别的，在计算机网络中，带宽被这样定义：\n\n> 带宽，在计算机网络中用来表示网络的**通信线路传输数据的能力**。注意，这里是传输，而不是传播，带宽描述的是**发送数据的发送器的能力强弱**，而带宽越大，将数据注入这个链路所需要的时间就越少。而传播和发送器是没有关系的。它表示的是信号在信道中传输的速率。\n\n那协议又是什么东东呢？协议指在对等实体之间通信需要遵循的规则。通常我们会从一个协议的**语法**，**语义**，**时序**，**动作**方面来衡量一个协议。\n\n![image-20210707204758527](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204758527.png)\n\n### 从服务角度\n\n从服务的维度来看，Internet包括**分布式的应用程序**和**支撑分布式应用程序通信的基础设施**。\n\n------\n\n## 1.2 网络边缘\n\n网络边缘包含**计算机和其他接入网络的设备**，又因为他们处于边缘位置，故也称**端系统**。它的另一为人所知的称谓是**主机**，而网络边缘即是**主机+运行在主机上的应用程序**\n\n我们来看下面的网络图示——\n\n![image-20210707204813922](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204813922.png)\n\n在这个图中**，计算机，服务器，AP(无线访问设备)**都属于端系统的范畴。\n\n那这些端系统是如何介入网络的呢？很显然，通过通信链路，更具体的说，是通过**接入网**，接入网是**将端系统物理连接到边缘路由器**的链路。\n\n写到这，**不妨将知识映射到实际的应用**。我家是使用**电话线**来接入因特网的，学过通信原理的朋友都知道在信道中传输的信号必须是**数字信号**，也就是说，我们需要一个**调制解调器**来完成信号的转换，这就是我们常说的**猫(Modem)**。这样就可以保证使用计算机上网了。但如果要多个设备都接入网络，就需要我们常说的WIFI，具体的说，是**WIFI路由器**，WIFI路由器上有**很多以太网的网口**，这样就可以实现多设备的接入网络了，当然，是**共享带宽**哦。\n\n![image-20210707204826842](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png)\n\n而同样值得一提的是，使用电话线的接入网它的**上行和下行的速率是不一样的**，我们普遍的需求是下载的速度更快，而对上传的速率没有严格的要求，因此使用这种带宽分发策略更有利。\n\n接入网的方式自然不限于电话线，使用线缆反而是现在更通用的方式。\n\n![image-20210707204838947](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png)\n\n我们来描述一下这个过程——\n**首先计算机通过Modem,即DSL调制解调器完成信号的转化，连接线缆的设备共享线缆的接入网络，再通过CMTS(线缆调制解调终端系统)接入到ISP的路由器中。**\n\n我们描述了端系统是如何接入网络的，那端系统之上的**应用进程是如何通信的呢**？\n\n应用进程属于应用层，应用层的通信实现需要**通过传输层提供的接口调用传输层的服务**。当然，这只是一个概述，具体展开那就是第二章的故事了。\n\n换一个维度看，也就是从通信模式上说，应用进程之间的通信分为CS模式和P2P模式，我们常使用的WEB应用使用的就是CS架构，而迅雷使用的则是P2P模式，它们各有千秋，在后面章节中后提及~\n\n> 总而言之。网络边缘负责提供应用进程端到端的通信。\n\n------\n\n## 1.3 网络核心\n\n前面我们提及网络边缘通过接入网接入Internet，其实这种说法是不准确的，通过接入网接入的是网络核心，而网络核心指的是路由器的网状网络，所以说，网络核心其**本质是网络的网络**。\n\n从大的框架来看，**网络核心是为网络边缘服务的**，它负责将数据从一个应用进程通过网络核心这个黑盒子传输到另一个应用进程。\n\n那怎样实现传输呢？接根线直接连过去显然不合适，那是名副其实的互连，但着实不优雅。\n\n我们需要一种**中继的设备**，它需要知道数据从何而来，要去往何处，也要保证传输一定程度的稳定。在实际中，满足这样需求的设备就是**交换机。而使用网络链路和交换机传输数据有两种基本方法：**电路交换和分组交换。\n\n### 电路交换\n\n电路交换的思路是**为每一个呼叫预留一条专有的电路**。\n\n![image-20210707204900893](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204900893.png)\n\n从上图中可以看到，在两个交换机之间有四条链路，假如网络带宽是1Mbps,那每条链路的带宽都是250Kbps,发起通信以后以后，首先会建立一个专有的连接，在连接保持期间，它独享链路资源。这就好比两个人通过手机正在通话，第三方想接入的话会显示占线中。\n\n这种VIP的通信服务除了`专用带宽`以外，它也提供`缓存服务`。但同时它的缺点也很明显，接入的用户太少了。因特网的用户接入是有局部性和突发性的，一成不变的电路交换显然不能胜任。\n\n这里需要额外的给出一些**小贴士**：\n\n> 带宽可以认为是网络中的一种资源，而为了更充分的利用这种资源，通常将带宽分成片。这里可以类比CPU的时间片。通常的分片方式有时分，频分，码分，波分。\n>\n> ![image-20210707204915415](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204915415.png)\n\n### 分组交换\n\n分组交换传输数据的**粒度更小**，它是**基于分组**的传输，那首先要了解分组的定义，在端与端之间传输数据的单元是报文。报文中包含协议设计者需要的任何东西。而网络核心的设备处于网络层，因而源主机将报文分成一个个的分组，分组按照协议要求，封装特定的头部和实体部分，在网络中传输。\n\n为了量化传输的效率，我们通常将分组的长度记做L比特，而将链路的传输速率记做R比特/秒，即带宽为Rbps，那传输速率就为L/R。\n\n分组交换为了提高传输的效率并让传输变得稳定可控，采用**存储转发**的机制。即路由器先将接收到的分组存储起来，将分组中的某些信息取出，按照一定的路由算法得到路由表，再由路由表即可得到下一条的IP地址，最终将分组转发给下一个路由器。\n\n上面我们提及存储转发可以让传输稳定可用，但实际上，**存储转发只是一种尽力而为的机制**。\n\n![image-20210707204929034](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204929034.png)\n\n当`分组的到达速率>链路的输出速率`，分组就需要排队，当队列已满，即路由器的`缓存用完`时，分组就`会被抛弃`。\n\n从上图中可以看出，分组`没有时序的讲究`，分组共享链路的带宽资源。我们常将这种模式称为统计多路复用。\n\n### 网络核心的关键功能\n\n1. **路由**\n\n   即决定分组采用的源到目标的路径，传统的是使用**路由算法**得到下一条的地址，而现在效率更高，也更通用的方式是——`控制平面与数据平面`。第四章会着重聊到。\n\n2. 转发\n\n   即将分组从路由器的输入链路转移到输出链路。\n\n### 分组交换VS电路交换\n\n理论知识的掌握仅仅是定性，要想更透彻的了解区别，还需要定量分析，我们一起来看下面的小例子——\n\n> 假设链路的带宽是1Mbps,,每个用户活动时所需要的带宽为100kbps，且每个用户只有10%的时间是活动的，分析电路交换和分组交换模式下所能支撑的最大用户数量？\n\n- 电路交换： 显然可以支撑1M/100K=**10个**用户\n\n- 分组交换：假设有35个用户，按使用概率论的知识可以求得**链路不允许10个以上用户活动的概率为0.004**\n\n  ![image-20210707204942286](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204942286.png)\n\n  通俗的说，允许10个以上用户活动的概率就等于允许0个，1个。。。的**概率累加和**，而35个中可以允许1个用户活动的概率服从**伯努利实验，即二项分布**。\n\n  ![image-20210204122319342](http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210204122319342.png)\n\n  通过计算结果，很容易推断出分组交换在`用户容量`方面优于电路交换。\n\n------\n\n## 1.4 Internet结构与ISP\n\n这里我们不再回顾Internet的演变过程，下图直接给出最终的框架——\n\n![image-20210707204955995](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204955995.png)\n\n那如何来解释这张网络架构图呢？我们以**从边沿到核心的思路**说起：\n\n首先零散的端系统接入到`附近的ISP服务商`提供的区域网络，区域接入再通过很多路由器接入到去`global ISPS`,global ISPS通过互连IXP的方式接入到其他的global ISPS，这样一个网络框架就有了。但网络还需要实质的数据传输，这时候`ICP(内容分发网络，如谷歌)`就加入进去了，而为了节省成本，ICP通常会自己搭建更靠近用户的网络来向用户提供服务。\n\n为了更形象的展示错综复杂的网络，我们看下实际应用中的网络——\n\n![image-20210707205016410](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205016410.png)\n\n------\n\n## 1.5 分组延时,丢失和吞吐量\n\n又到了万恶的知识点环节，但朋友们大可放心，这些概念还是很好理解的——\n\n### 分组延时\n\n![image-20210707205026706](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205026706.png)\n\n分组延时有四种——\n\n- `节点处理延时`：检查**分组首部**以及决定将分组导向何处。\n\n- `排队延时`：在输出链路上**等待传输**的时间\n\n  在排队延时中我们引入**流量强度**的概念——\n  $$\n  流量强度=La/R\n  $$\n  a指的是分组到达队列的**平均速率**。\n\n  ![image-20210707205224266](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205224266.png)\n\n- `传输延时`：长度为L的分组在带宽为Rbps的链路上传输的时间为**L/R**.\n\n- `传播延时`：在**物理链路上的传播时间**。\n\n### 分组丢失\n\n当分组到达队列已满的路由器时，分组根据协议类型被**丢弃**或从上一个节点**重传**。\n\n### 吞吐量\n\n吞吐量指单位时间内从源端传输到目标端的数据量，它**取决于路径上最小的吞吐量**。\n\n------\n\n## 1.6 协议层次与服务模型\n\n在解决复杂问题时，将问题模块化，分层解决是一个很好的思路，我们先来看日常生活中称作航班的例子——\n\n![image-20210707205236557](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205236557.png)\n\n这个例子有什么特点呢？\n\n1. 在每一层都实现了**特定的功能**，比如购票，托运行李巴拉巴拉；\n2. 在使用上层服务时，必须依托下层提供的**服务**。简言之，总得先购票才能坐飞机吧，当然，像<猫和老鼠>中的莱昂纳多除外~\n3. 每一层都有特有的**规范**，比如按特定路线航行。\n\n在上面我们了服务，那怎样解释服务呢？\n\n`服务`：底层实体向上层实体提供他们之间的通信的能力。\n\n与服务会发生概念混淆的，是**原语**的概念，这里的原语区别于操作系统的原语，指的是使用服务的方式，说白了，就是**API**。有了服务，自然就有服务作用的对象——\n\n`服务访问点SAP`: 即下层提供的服务要通过**接口**来让上层调用。在传输层，SAP就是端口。\n\n我们将服务的粒度放小就是**数据单元DU**，下面的图会展示DU的结构——\n\n![image-20210707205247263](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205247263.png)\n\n也就是说，数据单元是由**实体+特定的协议头部**构成的。\n\n到这里，前置知识大抵就完了，我们直接上正菜——\n\n![image-20210707205300541](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205300541.png)\n\n换种描述方式——\n\n| 协议分层 | 数据单元 | 服务                       | 服务访问点 | 常用协议          | **关键词**                                            |\n| -------- | -------- | -------------------------- | ---------- | ----------------- | ----------------------------------------------------- |\n| 应用层   | 报文     | 网络应用                   |            | HTTP.DNS,SMTP,FTP |                                                       |\n| 传输层   | 报文段   | 主机之间的数据传输         | 端口       | TCP/UDP           | 拥塞控制，流量管理，可靠数据传输，面向连接/不面向连接 |\n| 网络层   | 分组     | 为数据包从源到目的选择路由 | IP地址     | IP                | 路由，转发                                            |\n| 链路层   | 数据帧   | 相邻网络节点间的数据传输   |            | PPP,802.11WIFI    | 不可靠                                                |\n| 物理层   | 字节     | 在线路上传送bit            |            |                   | 通信链路                                              |\n\n这时我们就可以解答实际中应用程序间的通信是如何实现的啦——\n\n![image-20210707205315024](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205315024.png)\n\n> 山高路远，静水深流","slug":"计算机网络概述","published":1,"updated":"2023-09-24T09:50:29.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7l4000pxjccbeho5cw6","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>终于要进入<strong>正题</strong>了。</p>\n<p>但当看到第一章居然是概述，小伙伴们可能会困惑，概述的内容值得这么大的篇章吗？起初我也抱着这样的心里，所以仓促的看了下第一章，就去看后面的重点内容了。但往后学，慢慢发现<strong>所有的框架知识都是在概述建立的，还有那繁多却实用的术语</strong>，所以呢，在写这篇文章之前，我又老老实实看了一遍这看似鸡肋的概述。</p>\n<p>其实呢，第一章的内容设置还是很<strong>友好</strong>的，在这一章中，我们首先就会从<strong>网络的定义</strong>出发，探寻<strong>网络的框架结构</strong>，深入<strong>技术发展的征途</strong>，最终自然的回归<strong>分层模型</strong>。</p>\n<p>如果通过第一章的学习能让我们建立起学习的纹路，那就不虚此行了。话不多说，出发咯——</p>\n<hr>\n<h2 id=\"1-1-什么是Internet\"><a href=\"#1-1-什么是Internet\" class=\"headerlink\" title=\"1.1 什么是Internet\"></a>1.1 什么是Internet</h2><p>网络是什么？这个是很宽泛的问题，我们将从两个维度来展开——</p>\n<h3 id=\"从组成角度\"><a href=\"#从组成角度\" class=\"headerlink\" title=\"从组成角度\"></a>从组成角度</h3><p>从数学的概念出发，网这种数据结构包含边和点。同样的，Internet包含<strong>节点</strong>和<strong>通信链路</strong>。而除此之外，一个网络还必须有<strong>协议</strong>的支持才能稳定的运行。</p>\n<p><code>节点</code>：网络中的节点有两类，端节点和分组节点。端节点是指<strong>主机及其上运行的应用程序</strong>，而分组节点则是<strong>路由器，交换机等网络交换设备</strong>；</p>\n<p><code>通信链路</code> ： 根据通信链路所在的位置分为<strong>接入网链路</strong>和<strong>主干链路</strong>。接入网链路是指从主机连接到互联网的链路，比如我们日常生活使用无线接入设备WIFI接入互联网就是接入网。而主干链路是指路由器之间的链路，它负责数据的传输和中转，通常通信链路使用的材质为<strong>双绞线，光纤，电缆</strong>等。</p>\n<p>那么如何衡量通信链路的传输速率呢，就需要引入<strong>带宽</strong>，带宽在通信和网络中的定义是有所区别的，在计算机网络中，带宽被这样定义：</p>\n<blockquote>\n<p>带宽，在计算机网络中用来表示网络的<strong>通信线路传输数据的能力</strong>。注意，这里是传输，而不是传播，带宽描述的是<strong>发送数据的发送器的能力强弱</strong>，而带宽越大，将数据注入这个链路所需要的时间就越少。而传播和发送器是没有关系的。它表示的是信号在信道中传输的速率。</p>\n</blockquote>\n<p>那协议又是什么东东呢？协议指在对等实体之间通信需要遵循的规则。通常我们会从一个协议的<strong>语法</strong>，<strong>语义</strong>，<strong>时序</strong>，<strong>动作</strong>方面来衡量一个协议。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204758527.png\" alt=\"image-20210707204758527\"></p>\n<h3 id=\"从服务角度\"><a href=\"#从服务角度\" class=\"headerlink\" title=\"从服务角度\"></a>从服务角度</h3><p>从服务的维度来看，Internet包括<strong>分布式的应用程序</strong>和<strong>支撑分布式应用程序通信的基础设施</strong>。</p>\n<hr>\n<h2 id=\"1-2-网络边缘\"><a href=\"#1-2-网络边缘\" class=\"headerlink\" title=\"1.2 网络边缘\"></a>1.2 网络边缘</h2><p>网络边缘包含<strong>计算机和其他接入网络的设备</strong>，又因为他们处于边缘位置，故也称<strong>端系统</strong>。它的另一为人所知的称谓是<strong>主机</strong>，而网络边缘即是<strong>主机+运行在主机上的应用程序</strong></p>\n<p>我们来看下面的网络图示——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204813922.png\" alt=\"image-20210707204813922\"></p>\n<p>在这个图中**，计算机，服务器，AP(无线访问设备)**都属于端系统的范畴。</p>\n<p>那这些端系统是如何介入网络的呢？很显然，通过通信链路，更具体的说，是通过<strong>接入网</strong>，接入网是<strong>将端系统物理连接到边缘路由器</strong>的链路。</p>\n<p>写到这，<strong>不妨将知识映射到实际的应用</strong>。我家是使用<strong>电话线</strong>来接入因特网的，学过通信原理的朋友都知道在信道中传输的信号必须是<strong>数字信号</strong>，也就是说，我们需要一个<strong>调制解调器</strong>来完成信号的转换，这就是我们常说的<strong>猫(Modem)<strong>。这样就可以保证使用计算机上网了。但如果要多个设备都接入网络，就需要我们常说的WIFI，具体的说，是</strong>WIFI路由器</strong>，WIFI路由器上有<strong>很多以太网的网口</strong>，这样就可以实现多设备的接入网络了，当然，是<strong>共享带宽</strong>哦。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png\" alt=\"image-20210707204826842\"></p>\n<p>而同样值得一提的是，使用电话线的接入网它的<strong>上行和下行的速率是不一样的</strong>，我们普遍的需求是下载的速度更快，而对上传的速率没有严格的要求，因此使用这种带宽分发策略更有利。</p>\n<p>接入网的方式自然不限于电话线，使用线缆反而是现在更通用的方式。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png\" alt=\"image-20210707204838947\"></p>\n<p>我们来描述一下这个过程——<br><strong>首先计算机通过Modem,即DSL调制解调器完成信号的转化，连接线缆的设备共享线缆的接入网络，再通过CMTS(线缆调制解调终端系统)接入到ISP的路由器中。</strong></p>\n<p>我们描述了端系统是如何接入网络的，那端系统之上的<strong>应用进程是如何通信的呢</strong>？</p>\n<p>应用进程属于应用层，应用层的通信实现需要<strong>通过传输层提供的接口调用传输层的服务</strong>。当然，这只是一个概述，具体展开那就是第二章的故事了。</p>\n<p>换一个维度看，也就是从通信模式上说，应用进程之间的通信分为CS模式和P2P模式，我们常使用的WEB应用使用的就是CS架构，而迅雷使用的则是P2P模式，它们各有千秋，在后面章节中后提及~</p>\n<blockquote>\n<p>总而言之。网络边缘负责提供应用进程端到端的通信。</p>\n</blockquote>\n<hr>\n<h2 id=\"1-3-网络核心\"><a href=\"#1-3-网络核心\" class=\"headerlink\" title=\"1.3 网络核心\"></a>1.3 网络核心</h2><p>前面我们提及网络边缘通过接入网接入Internet，其实这种说法是不准确的，通过接入网接入的是网络核心，而网络核心指的是路由器的网状网络，所以说，网络核心其<strong>本质是网络的网络</strong>。</p>\n<p>从大的框架来看，<strong>网络核心是为网络边缘服务的</strong>，它负责将数据从一个应用进程通过网络核心这个黑盒子传输到另一个应用进程。</p>\n<p>那怎样实现传输呢？接根线直接连过去显然不合适，那是名副其实的互连，但着实不优雅。</p>\n<p>我们需要一种<strong>中继的设备</strong>，它需要知道数据从何而来，要去往何处，也要保证传输一定程度的稳定。在实际中，满足这样需求的设备就是<strong>交换机。而使用网络链路和交换机传输数据有两种基本方法：</strong>电路交换和分组交换。</p>\n<h3 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h3><p>电路交换的思路是<strong>为每一个呼叫预留一条专有的电路</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204900893.png\" alt=\"image-20210707204900893\"></p>\n<p>从上图中可以看到，在两个交换机之间有四条链路，假如网络带宽是1Mbps,那每条链路的带宽都是250Kbps,发起通信以后以后，首先会建立一个专有的连接，在连接保持期间，它独享链路资源。这就好比两个人通过手机正在通话，第三方想接入的话会显示占线中。</p>\n<p>这种VIP的通信服务除了<code>专用带宽</code>以外，它也提供<code>缓存服务</code>。但同时它的缺点也很明显，接入的用户太少了。因特网的用户接入是有局部性和突发性的，一成不变的电路交换显然不能胜任。</p>\n<p>这里需要额外的给出一些<strong>小贴士</strong>：</p>\n<blockquote>\n<p>带宽可以认为是网络中的一种资源，而为了更充分的利用这种资源，通常将带宽分成片。这里可以类比CPU的时间片。通常的分片方式有时分，频分，码分，波分。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204915415.png\" alt=\"image-20210707204915415\"></p>\n</blockquote>\n<h3 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h3><p>分组交换传输数据的<strong>粒度更小</strong>，它是<strong>基于分组</strong>的传输，那首先要了解分组的定义，在端与端之间传输数据的单元是报文。报文中包含协议设计者需要的任何东西。而网络核心的设备处于网络层，因而源主机将报文分成一个个的分组，分组按照协议要求，封装特定的头部和实体部分，在网络中传输。</p>\n<p>为了量化传输的效率，我们通常将分组的长度记做L比特，而将链路的传输速率记做R比特/秒，即带宽为Rbps，那传输速率就为L/R。</p>\n<p>分组交换为了提高传输的效率并让传输变得稳定可控，采用<strong>存储转发</strong>的机制。即路由器先将接收到的分组存储起来，将分组中的某些信息取出，按照一定的路由算法得到路由表，再由路由表即可得到下一条的IP地址，最终将分组转发给下一个路由器。</p>\n<p>上面我们提及存储转发可以让传输稳定可用，但实际上，<strong>存储转发只是一种尽力而为的机制</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204929034.png\" alt=\"image-20210707204929034\"></p>\n<p>当<code>分组的到达速率&gt;链路的输出速率</code>，分组就需要排队，当队列已满，即路由器的<code>缓存用完</code>时，分组就<code>会被抛弃</code>。</p>\n<p>从上图中可以看出，分组<code>没有时序的讲究</code>，分组共享链路的带宽资源。我们常将这种模式称为统计多路复用。</p>\n<h3 id=\"网络核心的关键功能\"><a href=\"#网络核心的关键功能\" class=\"headerlink\" title=\"网络核心的关键功能\"></a>网络核心的关键功能</h3><ol>\n<li><p><strong>路由</strong></p>\n<p>即决定分组采用的源到目标的路径，传统的是使用<strong>路由算法</strong>得到下一条的地址，而现在效率更高，也更通用的方式是——<code>控制平面与数据平面</code>。第四章会着重聊到。</p>\n</li>\n<li><p>转发</p>\n<p>即将分组从路由器的输入链路转移到输出链路。</p>\n</li>\n</ol>\n<h3 id=\"分组交换VS电路交换\"><a href=\"#分组交换VS电路交换\" class=\"headerlink\" title=\"分组交换VS电路交换\"></a>分组交换VS电路交换</h3><p>理论知识的掌握仅仅是定性，要想更透彻的了解区别，还需要定量分析，我们一起来看下面的小例子——</p>\n<blockquote>\n<p>假设链路的带宽是1Mbps,,每个用户活动时所需要的带宽为100kbps，且每个用户只有10%的时间是活动的，分析电路交换和分组交换模式下所能支撑的最大用户数量？</p>\n</blockquote>\n<ul>\n<li><p>电路交换： 显然可以支撑1M/100K=<strong>10个</strong>用户</p>\n</li>\n<li><p>分组交换：假设有35个用户，按使用概率论的知识可以求得<strong>链路不允许10个以上用户活动的概率为0.004</strong></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204942286.png\" alt=\"image-20210707204942286\"></p>\n<p>通俗的说，允许10个以上用户活动的概率就等于允许0个，1个。。。的<strong>概率累加和</strong>，而35个中可以允许1个用户活动的概率服从<strong>伯努利实验，即二项分布</strong>。</p>\n<p><img src=\"http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210204122319342.png\" alt=\"image-20210204122319342\"></p>\n<p>通过计算结果，很容易推断出分组交换在<code>用户容量</code>方面优于电路交换。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"1-4-Internet结构与ISP\"><a href=\"#1-4-Internet结构与ISP\" class=\"headerlink\" title=\"1.4 Internet结构与ISP\"></a>1.4 Internet结构与ISP</h2><p>这里我们不再回顾Internet的演变过程，下图直接给出最终的框架——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204955995.png\" alt=\"image-20210707204955995\"></p>\n<p>那如何来解释这张网络架构图呢？我们以<strong>从边沿到核心的思路</strong>说起：</p>\n<p>首先零散的端系统接入到<code>附近的ISP服务商</code>提供的区域网络，区域接入再通过很多路由器接入到去<code>global ISPS</code>,global ISPS通过互连IXP的方式接入到其他的global ISPS，这样一个网络框架就有了。但网络还需要实质的数据传输，这时候<code>ICP(内容分发网络，如谷歌)</code>就加入进去了，而为了节省成本，ICP通常会自己搭建更靠近用户的网络来向用户提供服务。</p>\n<p>为了更形象的展示错综复杂的网络，我们看下实际应用中的网络——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205016410.png\" alt=\"image-20210707205016410\"></p>\n<hr>\n<h2 id=\"1-5-分组延时-丢失和吞吐量\"><a href=\"#1-5-分组延时-丢失和吞吐量\" class=\"headerlink\" title=\"1.5 分组延时,丢失和吞吐量\"></a>1.5 分组延时,丢失和吞吐量</h2><p>又到了万恶的知识点环节，但朋友们大可放心，这些概念还是很好理解的——</p>\n<h3 id=\"分组延时\"><a href=\"#分组延时\" class=\"headerlink\" title=\"分组延时\"></a>分组延时</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205026706.png\" alt=\"image-20210707205026706\"></p>\n<p>分组延时有四种——</p>\n<ul>\n<li><p><code>节点处理延时</code>：检查<strong>分组首部</strong>以及决定将分组导向何处。</p>\n</li>\n<li><p><code>排队延时</code>：在输出链路上<strong>等待传输</strong>的时间</p>\n<p>在排队延时中我们引入<strong>流量强度</strong>的概念——<br>$$<br>流量强度=La/R<br>$$<br>a指的是分组到达队列的<strong>平均速率</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205224266.png\" alt=\"image-20210707205224266\"></p>\n</li>\n<li><p><code>传输延时</code>：长度为L的分组在带宽为Rbps的链路上传输的时间为<strong>L/R</strong>.</p>\n</li>\n<li><p><code>传播延时</code>：在<strong>物理链路上的传播时间</strong>。</p>\n</li>\n</ul>\n<h3 id=\"分组丢失\"><a href=\"#分组丢失\" class=\"headerlink\" title=\"分组丢失\"></a>分组丢失</h3><p>当分组到达队列已满的路由器时，分组根据协议类型被<strong>丢弃</strong>或从上一个节点<strong>重传</strong>。</p>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>吞吐量指单位时间内从源端传输到目标端的数据量，它<strong>取决于路径上最小的吞吐量</strong>。</p>\n<hr>\n<h2 id=\"1-6-协议层次与服务模型\"><a href=\"#1-6-协议层次与服务模型\" class=\"headerlink\" title=\"1.6 协议层次与服务模型\"></a>1.6 协议层次与服务模型</h2><p>在解决复杂问题时，将问题模块化，分层解决是一个很好的思路，我们先来看日常生活中称作航班的例子——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205236557.png\" alt=\"image-20210707205236557\"></p>\n<p>这个例子有什么特点呢？</p>\n<ol>\n<li>在每一层都实现了<strong>特定的功能</strong>，比如购票，托运行李巴拉巴拉；</li>\n<li>在使用上层服务时，必须依托下层提供的<strong>服务</strong>。简言之，总得先购票才能坐飞机吧，当然，像&lt;猫和老鼠&gt;中的莱昂纳多除外~</li>\n<li>每一层都有特有的<strong>规范</strong>，比如按特定路线航行。</li>\n</ol>\n<p>在上面我们了服务，那怎样解释服务呢？</p>\n<p><code>服务</code>：底层实体向上层实体提供他们之间的通信的能力。</p>\n<p>与服务会发生概念混淆的，是<strong>原语</strong>的概念，这里的原语区别于操作系统的原语，指的是使用服务的方式，说白了，就是<strong>API</strong>。有了服务，自然就有服务作用的对象——</p>\n<p><code>服务访问点SAP</code>: 即下层提供的服务要通过<strong>接口</strong>来让上层调用。在传输层，SAP就是端口。</p>\n<p>我们将服务的粒度放小就是<strong>数据单元DU</strong>，下面的图会展示DU的结构——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205247263.png\" alt=\"image-20210707205247263\"></p>\n<p>也就是说，数据单元是由<strong>实体+特定的协议头部</strong>构成的。</p>\n<p>到这里，前置知识大抵就完了，我们直接上正菜——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205300541.png\" alt=\"image-20210707205300541\"></p>\n<p>换种描述方式——</p>\n<table>\n<thead>\n<tr>\n<th>协议分层</th>\n<th>数据单元</th>\n<th>服务</th>\n<th>服务访问点</th>\n<th>常用协议</th>\n<th><strong>关键词</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>应用层</td>\n<td>报文</td>\n<td>网络应用</td>\n<td></td>\n<td>HTTP.DNS,SMTP,FTP</td>\n<td></td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>报文段</td>\n<td>主机之间的数据传输</td>\n<td>端口</td>\n<td>TCP/UDP</td>\n<td>拥塞控制，流量管理，可靠数据传输，面向连接/不面向连接</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>分组</td>\n<td>为数据包从源到目的选择路由</td>\n<td>IP地址</td>\n<td>IP</td>\n<td>路由，转发</td>\n</tr>\n<tr>\n<td>链路层</td>\n<td>数据帧</td>\n<td>相邻网络节点间的数据传输</td>\n<td></td>\n<td>PPP,802.11WIFI</td>\n<td>不可靠</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>字节</td>\n<td>在线路上传送bit</td>\n<td></td>\n<td></td>\n<td>通信链路</td>\n</tr>\n</tbody></table>\n<p>这时我们就可以解答实际中应用程序间的通信是如何实现的啦——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205315024.png\" alt=\"image-20210707205315024\"></p>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>终于要进入<strong>正题</strong>了。</p>\n<p>但当看到第一章居然是概述，小伙伴们可能会困惑，概述的内容值得这么大的篇章吗？起初我也抱着这样的心里，所以仓促的看了下第一章，就去看后面的重点内容了。但往后学，慢慢发现<strong>所有的框架知识都是在概述建立的，还有那繁多却实用的术语</strong>，所以呢，在写这篇文章之前，我又老老实实看了一遍这看似鸡肋的概述。</p>\n<p>其实呢，第一章的内容设置还是很<strong>友好</strong>的，在这一章中，我们首先就会从<strong>网络的定义</strong>出发，探寻<strong>网络的框架结构</strong>，深入<strong>技术发展的征途</strong>，最终自然的回归<strong>分层模型</strong>。</p>\n<p>如果通过第一章的学习能让我们建立起学习的纹路，那就不虚此行了。话不多说，出发咯——</p>\n<hr>\n<h2 id=\"1-1-什么是Internet\"><a href=\"#1-1-什么是Internet\" class=\"headerlink\" title=\"1.1 什么是Internet\"></a>1.1 什么是Internet</h2><p>网络是什么？这个是很宽泛的问题，我们将从两个维度来展开——</p>\n<h3 id=\"从组成角度\"><a href=\"#从组成角度\" class=\"headerlink\" title=\"从组成角度\"></a>从组成角度</h3><p>从数学的概念出发，网这种数据结构包含边和点。同样的，Internet包含<strong>节点</strong>和<strong>通信链路</strong>。而除此之外，一个网络还必须有<strong>协议</strong>的支持才能稳定的运行。</p>\n<p><code>节点</code>：网络中的节点有两类，端节点和分组节点。端节点是指<strong>主机及其上运行的应用程序</strong>，而分组节点则是<strong>路由器，交换机等网络交换设备</strong>；</p>\n<p><code>通信链路</code> ： 根据通信链路所在的位置分为<strong>接入网链路</strong>和<strong>主干链路</strong>。接入网链路是指从主机连接到互联网的链路，比如我们日常生活使用无线接入设备WIFI接入互联网就是接入网。而主干链路是指路由器之间的链路，它负责数据的传输和中转，通常通信链路使用的材质为<strong>双绞线，光纤，电缆</strong>等。</p>\n<p>那么如何衡量通信链路的传输速率呢，就需要引入<strong>带宽</strong>，带宽在通信和网络中的定义是有所区别的，在计算机网络中，带宽被这样定义：</p>\n<blockquote>\n<p>带宽，在计算机网络中用来表示网络的<strong>通信线路传输数据的能力</strong>。注意，这里是传输，而不是传播，带宽描述的是<strong>发送数据的发送器的能力强弱</strong>，而带宽越大，将数据注入这个链路所需要的时间就越少。而传播和发送器是没有关系的。它表示的是信号在信道中传输的速率。</p>\n</blockquote>\n<p>那协议又是什么东东呢？协议指在对等实体之间通信需要遵循的规则。通常我们会从一个协议的<strong>语法</strong>，<strong>语义</strong>，<strong>时序</strong>，<strong>动作</strong>方面来衡量一个协议。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204758527.png\" alt=\"image-20210707204758527\"></p>\n<h3 id=\"从服务角度\"><a href=\"#从服务角度\" class=\"headerlink\" title=\"从服务角度\"></a>从服务角度</h3><p>从服务的维度来看，Internet包括<strong>分布式的应用程序</strong>和<strong>支撑分布式应用程序通信的基础设施</strong>。</p>\n<hr>\n<h2 id=\"1-2-网络边缘\"><a href=\"#1-2-网络边缘\" class=\"headerlink\" title=\"1.2 网络边缘\"></a>1.2 网络边缘</h2><p>网络边缘包含<strong>计算机和其他接入网络的设备</strong>，又因为他们处于边缘位置，故也称<strong>端系统</strong>。它的另一为人所知的称谓是<strong>主机</strong>，而网络边缘即是<strong>主机+运行在主机上的应用程序</strong></p>\n<p>我们来看下面的网络图示——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204813922.png\" alt=\"image-20210707204813922\"></p>\n<p>在这个图中**，计算机，服务器，AP(无线访问设备)**都属于端系统的范畴。</p>\n<p>那这些端系统是如何介入网络的呢？很显然，通过通信链路，更具体的说，是通过<strong>接入网</strong>，接入网是<strong>将端系统物理连接到边缘路由器</strong>的链路。</p>\n<p>写到这，<strong>不妨将知识映射到实际的应用</strong>。我家是使用<strong>电话线</strong>来接入因特网的，学过通信原理的朋友都知道在信道中传输的信号必须是<strong>数字信号</strong>，也就是说，我们需要一个<strong>调制解调器</strong>来完成信号的转换，这就是我们常说的<strong>猫(Modem)<strong>。这样就可以保证使用计算机上网了。但如果要多个设备都接入网络，就需要我们常说的WIFI，具体的说，是</strong>WIFI路由器</strong>，WIFI路由器上有<strong>很多以太网的网口</strong>，这样就可以实现多设备的接入网络了，当然，是<strong>共享带宽</strong>哦。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png\" alt=\"image-20210707204826842\"></p>\n<p>而同样值得一提的是，使用电话线的接入网它的<strong>上行和下行的速率是不一样的</strong>，我们普遍的需求是下载的速度更快，而对上传的速率没有严格的要求，因此使用这种带宽分发策略更有利。</p>\n<p>接入网的方式自然不限于电话线，使用线缆反而是现在更通用的方式。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204838947.png\" alt=\"image-20210707204838947\"></p>\n<p>我们来描述一下这个过程——<br><strong>首先计算机通过Modem,即DSL调制解调器完成信号的转化，连接线缆的设备共享线缆的接入网络，再通过CMTS(线缆调制解调终端系统)接入到ISP的路由器中。</strong></p>\n<p>我们描述了端系统是如何接入网络的，那端系统之上的<strong>应用进程是如何通信的呢</strong>？</p>\n<p>应用进程属于应用层，应用层的通信实现需要<strong>通过传输层提供的接口调用传输层的服务</strong>。当然，这只是一个概述，具体展开那就是第二章的故事了。</p>\n<p>换一个维度看，也就是从通信模式上说，应用进程之间的通信分为CS模式和P2P模式，我们常使用的WEB应用使用的就是CS架构，而迅雷使用的则是P2P模式，它们各有千秋，在后面章节中后提及~</p>\n<blockquote>\n<p>总而言之。网络边缘负责提供应用进程端到端的通信。</p>\n</blockquote>\n<hr>\n<h2 id=\"1-3-网络核心\"><a href=\"#1-3-网络核心\" class=\"headerlink\" title=\"1.3 网络核心\"></a>1.3 网络核心</h2><p>前面我们提及网络边缘通过接入网接入Internet，其实这种说法是不准确的，通过接入网接入的是网络核心，而网络核心指的是路由器的网状网络，所以说，网络核心其<strong>本质是网络的网络</strong>。</p>\n<p>从大的框架来看，<strong>网络核心是为网络边缘服务的</strong>，它负责将数据从一个应用进程通过网络核心这个黑盒子传输到另一个应用进程。</p>\n<p>那怎样实现传输呢？接根线直接连过去显然不合适，那是名副其实的互连，但着实不优雅。</p>\n<p>我们需要一种<strong>中继的设备</strong>，它需要知道数据从何而来，要去往何处，也要保证传输一定程度的稳定。在实际中，满足这样需求的设备就是<strong>交换机。而使用网络链路和交换机传输数据有两种基本方法：</strong>电路交换和分组交换。</p>\n<h3 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h3><p>电路交换的思路是<strong>为每一个呼叫预留一条专有的电路</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204900893.png\" alt=\"image-20210707204900893\"></p>\n<p>从上图中可以看到，在两个交换机之间有四条链路，假如网络带宽是1Mbps,那每条链路的带宽都是250Kbps,发起通信以后以后，首先会建立一个专有的连接，在连接保持期间，它独享链路资源。这就好比两个人通过手机正在通话，第三方想接入的话会显示占线中。</p>\n<p>这种VIP的通信服务除了<code>专用带宽</code>以外，它也提供<code>缓存服务</code>。但同时它的缺点也很明显，接入的用户太少了。因特网的用户接入是有局部性和突发性的，一成不变的电路交换显然不能胜任。</p>\n<p>这里需要额外的给出一些<strong>小贴士</strong>：</p>\n<blockquote>\n<p>带宽可以认为是网络中的一种资源，而为了更充分的利用这种资源，通常将带宽分成片。这里可以类比CPU的时间片。通常的分片方式有时分，频分，码分，波分。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204915415.png\" alt=\"image-20210707204915415\"></p>\n</blockquote>\n<h3 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h3><p>分组交换传输数据的<strong>粒度更小</strong>，它是<strong>基于分组</strong>的传输，那首先要了解分组的定义，在端与端之间传输数据的单元是报文。报文中包含协议设计者需要的任何东西。而网络核心的设备处于网络层，因而源主机将报文分成一个个的分组，分组按照协议要求，封装特定的头部和实体部分，在网络中传输。</p>\n<p>为了量化传输的效率，我们通常将分组的长度记做L比特，而将链路的传输速率记做R比特/秒，即带宽为Rbps，那传输速率就为L/R。</p>\n<p>分组交换为了提高传输的效率并让传输变得稳定可控，采用<strong>存储转发</strong>的机制。即路由器先将接收到的分组存储起来，将分组中的某些信息取出，按照一定的路由算法得到路由表，再由路由表即可得到下一条的IP地址，最终将分组转发给下一个路由器。</p>\n<p>上面我们提及存储转发可以让传输稳定可用，但实际上，<strong>存储转发只是一种尽力而为的机制</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204929034.png\" alt=\"image-20210707204929034\"></p>\n<p>当<code>分组的到达速率&gt;链路的输出速率</code>，分组就需要排队，当队列已满，即路由器的<code>缓存用完</code>时，分组就<code>会被抛弃</code>。</p>\n<p>从上图中可以看出，分组<code>没有时序的讲究</code>，分组共享链路的带宽资源。我们常将这种模式称为统计多路复用。</p>\n<h3 id=\"网络核心的关键功能\"><a href=\"#网络核心的关键功能\" class=\"headerlink\" title=\"网络核心的关键功能\"></a>网络核心的关键功能</h3><ol>\n<li><p><strong>路由</strong></p>\n<p>即决定分组采用的源到目标的路径，传统的是使用<strong>路由算法</strong>得到下一条的地址，而现在效率更高，也更通用的方式是——<code>控制平面与数据平面</code>。第四章会着重聊到。</p>\n</li>\n<li><p>转发</p>\n<p>即将分组从路由器的输入链路转移到输出链路。</p>\n</li>\n</ol>\n<h3 id=\"分组交换VS电路交换\"><a href=\"#分组交换VS电路交换\" class=\"headerlink\" title=\"分组交换VS电路交换\"></a>分组交换VS电路交换</h3><p>理论知识的掌握仅仅是定性，要想更透彻的了解区别，还需要定量分析，我们一起来看下面的小例子——</p>\n<blockquote>\n<p>假设链路的带宽是1Mbps,,每个用户活动时所需要的带宽为100kbps，且每个用户只有10%的时间是活动的，分析电路交换和分组交换模式下所能支撑的最大用户数量？</p>\n</blockquote>\n<ul>\n<li><p>电路交换： 显然可以支撑1M/100K=<strong>10个</strong>用户</p>\n</li>\n<li><p>分组交换：假设有35个用户，按使用概率论的知识可以求得<strong>链路不允许10个以上用户活动的概率为0.004</strong></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204942286.png\" alt=\"image-20210707204942286\"></p>\n<p>通俗的说，允许10个以上用户活动的概率就等于允许0个，1个。。。的<strong>概率累加和</strong>，而35个中可以允许1个用户活动的概率服从<strong>伯努利实验，即二项分布</strong>。</p>\n<p><img src=\"http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210204122319342.png\" alt=\"image-20210204122319342\"></p>\n<p>通过计算结果，很容易推断出分组交换在<code>用户容量</code>方面优于电路交换。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"1-4-Internet结构与ISP\"><a href=\"#1-4-Internet结构与ISP\" class=\"headerlink\" title=\"1.4 Internet结构与ISP\"></a>1.4 Internet结构与ISP</h2><p>这里我们不再回顾Internet的演变过程，下图直接给出最终的框架——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20210707204955995.png\" alt=\"image-20210707204955995\"></p>\n<p>那如何来解释这张网络架构图呢？我们以<strong>从边沿到核心的思路</strong>说起：</p>\n<p>首先零散的端系统接入到<code>附近的ISP服务商</code>提供的区域网络，区域接入再通过很多路由器接入到去<code>global ISPS</code>,global ISPS通过互连IXP的方式接入到其他的global ISPS，这样一个网络框架就有了。但网络还需要实质的数据传输，这时候<code>ICP(内容分发网络，如谷歌)</code>就加入进去了，而为了节省成本，ICP通常会自己搭建更靠近用户的网络来向用户提供服务。</p>\n<p>为了更形象的展示错综复杂的网络，我们看下实际应用中的网络——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205016410.png\" alt=\"image-20210707205016410\"></p>\n<hr>\n<h2 id=\"1-5-分组延时-丢失和吞吐量\"><a href=\"#1-5-分组延时-丢失和吞吐量\" class=\"headerlink\" title=\"1.5 分组延时,丢失和吞吐量\"></a>1.5 分组延时,丢失和吞吐量</h2><p>又到了万恶的知识点环节，但朋友们大可放心，这些概念还是很好理解的——</p>\n<h3 id=\"分组延时\"><a href=\"#分组延时\" class=\"headerlink\" title=\"分组延时\"></a>分组延时</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205026706.png\" alt=\"image-20210707205026706\"></p>\n<p>分组延时有四种——</p>\n<ul>\n<li><p><code>节点处理延时</code>：检查<strong>分组首部</strong>以及决定将分组导向何处。</p>\n</li>\n<li><p><code>排队延时</code>：在输出链路上<strong>等待传输</strong>的时间</p>\n<p>在排队延时中我们引入<strong>流量强度</strong>的概念——<br>$$<br>流量强度=La/R<br>$$<br>a指的是分组到达队列的<strong>平均速率</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205224266.png\" alt=\"image-20210707205224266\"></p>\n</li>\n<li><p><code>传输延时</code>：长度为L的分组在带宽为Rbps的链路上传输的时间为<strong>L/R</strong>.</p>\n</li>\n<li><p><code>传播延时</code>：在<strong>物理链路上的传播时间</strong>。</p>\n</li>\n</ul>\n<h3 id=\"分组丢失\"><a href=\"#分组丢失\" class=\"headerlink\" title=\"分组丢失\"></a>分组丢失</h3><p>当分组到达队列已满的路由器时，分组根据协议类型被<strong>丢弃</strong>或从上一个节点<strong>重传</strong>。</p>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>吞吐量指单位时间内从源端传输到目标端的数据量，它<strong>取决于路径上最小的吞吐量</strong>。</p>\n<hr>\n<h2 id=\"1-6-协议层次与服务模型\"><a href=\"#1-6-协议层次与服务模型\" class=\"headerlink\" title=\"1.6 协议层次与服务模型\"></a>1.6 协议层次与服务模型</h2><p>在解决复杂问题时，将问题模块化，分层解决是一个很好的思路，我们先来看日常生活中称作航班的例子——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205236557.png\" alt=\"image-20210707205236557\"></p>\n<p>这个例子有什么特点呢？</p>\n<ol>\n<li>在每一层都实现了<strong>特定的功能</strong>，比如购票，托运行李巴拉巴拉；</li>\n<li>在使用上层服务时，必须依托下层提供的<strong>服务</strong>。简言之，总得先购票才能坐飞机吧，当然，像&lt;猫和老鼠&gt;中的莱昂纳多除外~</li>\n<li>每一层都有特有的<strong>规范</strong>，比如按特定路线航行。</li>\n</ol>\n<p>在上面我们了服务，那怎样解释服务呢？</p>\n<p><code>服务</code>：底层实体向上层实体提供他们之间的通信的能力。</p>\n<p>与服务会发生概念混淆的，是<strong>原语</strong>的概念，这里的原语区别于操作系统的原语，指的是使用服务的方式，说白了，就是<strong>API</strong>。有了服务，自然就有服务作用的对象——</p>\n<p><code>服务访问点SAP</code>: 即下层提供的服务要通过<strong>接口</strong>来让上层调用。在传输层，SAP就是端口。</p>\n<p>我们将服务的粒度放小就是<strong>数据单元DU</strong>，下面的图会展示DU的结构——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205247263.png\" alt=\"image-20210707205247263\"></p>\n<p>也就是说，数据单元是由<strong>实体+特定的协议头部</strong>构成的。</p>\n<p>到这里，前置知识大抵就完了，我们直接上正菜——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205300541.png\" alt=\"image-20210707205300541\"></p>\n<p>换种描述方式——</p>\n<table>\n<thead>\n<tr>\n<th>协议分层</th>\n<th>数据单元</th>\n<th>服务</th>\n<th>服务访问点</th>\n<th>常用协议</th>\n<th><strong>关键词</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>应用层</td>\n<td>报文</td>\n<td>网络应用</td>\n<td></td>\n<td>HTTP.DNS,SMTP,FTP</td>\n<td></td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>报文段</td>\n<td>主机之间的数据传输</td>\n<td>端口</td>\n<td>TCP/UDP</td>\n<td>拥塞控制，流量管理，可靠数据传输，面向连接/不面向连接</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>分组</td>\n<td>为数据包从源到目的选择路由</td>\n<td>IP地址</td>\n<td>IP</td>\n<td>路由，转发</td>\n</tr>\n<tr>\n<td>链路层</td>\n<td>数据帧</td>\n<td>相邻网络节点间的数据传输</td>\n<td></td>\n<td>PPP,802.11WIFI</td>\n<td>不可靠</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>字节</td>\n<td>在线路上传送bit</td>\n<td></td>\n<td></td>\n<td>通信链路</td>\n</tr>\n</tbody></table>\n<p>这时我们就可以解答实际中应用程序间的通信是如何实现的啦——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205315024.png\" alt=\"image-20210707205315024\"></p>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"递归的基本思想","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T08:09:39.000Z","password":null,"summary":null,"_content":"\n## 从一个问题开始\n\n假设A的推荐人是B，B的推荐人是C，如何来查找A的最终推荐人呢？\n\n这里直接给出答案——\n\n```java\nlong findRootRerfererId(long actorId){\n    Long refererId = select referer_id from [table] where actor_id = actorId;\n    if(refererId == null)\n        return actorId;\n    return findRootRerfererId(refererId);\n}\n```\n\n## 递归概述\n\n递归是一种应用非常广泛的算法，亦可称作编程技巧。\n\n## 递归的引出\n\n递归顾名思义，包含递与归两个过程。我们用下面的例子来体会一下。\n\n假设你去电影院看电影，你想知道自己坐在第几排，所以你询问前排的人，但前排的人有相同的困惑，他又去问他的前排，直到第一排的人明确自己坐在第几排。然后每一排的人将结果告诉自己的后排，整个递归的过程就完成了。\n\n这个小例子中，第一排是终止条件，不断问前排的人是递归条件。无疑是很典型的递归问题，但面对递归问题更通常的反应是看了全会，写了全废。所以我们还要按部就班的学习递归的知识。。。\n\n## 递归的三个条件\n\n1. 一个问题的解可以分解为几个子问题的解\n2. 设个问题与分解后的问题除了问题规模不同外，求解思路完全相同\n3. 存在递归终止条件\n\n## 如何编写递归代码\n\n编写递归代码的核心无非就两个：**递归公式+终止条件**。我们通过下面的小例子来理解下——\n\n假设有n个台阶，每次你自己可以跨越1个台阶或者2个台阶。请问走这n个台阶共有多少种走法？\n\n我们会想到，可以按照第一步的走法将问题分解为两个子问题，也就是走一步之后的走法和走两步之后的走法，对应的递归公式就是\n$$\nf(n) = f(n-1)+f(n-2)\n$$\n再来确定终止条件，显然，当只有一个台阶时就没必要再递归了，也就是：\n$$\nf(1)=1\n$$\n将这个递归终止条件带入递归公式后，发现f(2)是无法确定的，所以终止条件还应该包含\n$$\nf(2)=2\n$$\n表示的含义是走两个台阶有两种走法。最后我们将其转换为代码实现——\n\n```java\nint f(int n){\n    if(n == 1)\n    return 1;\n    if(n == 2)\n        return 2;\n    return f(n-1)+f(n-2);\n}\n```\n\n站在巨人的肩膀——\n\n> 写递归代码的关键在于找到将大问题转化为小问题的关键，并且基于此写下递归公式，然后再推敲递归终止条件，最终将递归公式和递归条件转化为代码实现。\n\n## 递归代码要警惕堆栈溢出\n\n递归代码在简洁可读性强的同时，却也带来了堆栈溢出的隐患。\n\n之前提到过系统没调用一个函数，会将临时变量作为栈帧压栈，等到函数返回再弹栈。而递归代码因为调用的函数层数多，在函数调用时不断申请栈空间。从而导致空间复杂度不理想。\n\n那怎样避免呢？理想的方法是根据场景选择递归，如果递归层数不多，则限制递归层数，这时使用递归是合适的。\n\n## 递归代码要警惕重复计算\n\n在刚才走台阶的例子中，就不可避免的遇到了重复计算的问题，这样对问题的求解并没有障碍，但并不优雅，我们要使用哈比表这样的数据结构动态存储每个子问题的结果。\n\n## 一点思考\n\n在问题规模较大时，有什么比较好的调试方式——\n\n> - 打印日志发现递归值\n> - 结合条件断点进行调试\n\n------\n\n> 山高路远，静水深流","source":"_posts/递归的基本思想.md","raw":"---\ntitle: 递归的基本思想\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 16:09:39\npassword:\nsummary:\ntags: 递归\ncategories: 算法\n---\n\n## 从一个问题开始\n\n假设A的推荐人是B，B的推荐人是C，如何来查找A的最终推荐人呢？\n\n这里直接给出答案——\n\n```java\nlong findRootRerfererId(long actorId){\n    Long refererId = select referer_id from [table] where actor_id = actorId;\n    if(refererId == null)\n        return actorId;\n    return findRootRerfererId(refererId);\n}\n```\n\n## 递归概述\n\n递归是一种应用非常广泛的算法，亦可称作编程技巧。\n\n## 递归的引出\n\n递归顾名思义，包含递与归两个过程。我们用下面的例子来体会一下。\n\n假设你去电影院看电影，你想知道自己坐在第几排，所以你询问前排的人，但前排的人有相同的困惑，他又去问他的前排，直到第一排的人明确自己坐在第几排。然后每一排的人将结果告诉自己的后排，整个递归的过程就完成了。\n\n这个小例子中，第一排是终止条件，不断问前排的人是递归条件。无疑是很典型的递归问题，但面对递归问题更通常的反应是看了全会，写了全废。所以我们还要按部就班的学习递归的知识。。。\n\n## 递归的三个条件\n\n1. 一个问题的解可以分解为几个子问题的解\n2. 设个问题与分解后的问题除了问题规模不同外，求解思路完全相同\n3. 存在递归终止条件\n\n## 如何编写递归代码\n\n编写递归代码的核心无非就两个：**递归公式+终止条件**。我们通过下面的小例子来理解下——\n\n假设有n个台阶，每次你自己可以跨越1个台阶或者2个台阶。请问走这n个台阶共有多少种走法？\n\n我们会想到，可以按照第一步的走法将问题分解为两个子问题，也就是走一步之后的走法和走两步之后的走法，对应的递归公式就是\n$$\nf(n) = f(n-1)+f(n-2)\n$$\n再来确定终止条件，显然，当只有一个台阶时就没必要再递归了，也就是：\n$$\nf(1)=1\n$$\n将这个递归终止条件带入递归公式后，发现f(2)是无法确定的，所以终止条件还应该包含\n$$\nf(2)=2\n$$\n表示的含义是走两个台阶有两种走法。最后我们将其转换为代码实现——\n\n```java\nint f(int n){\n    if(n == 1)\n    return 1;\n    if(n == 2)\n        return 2;\n    return f(n-1)+f(n-2);\n}\n```\n\n站在巨人的肩膀——\n\n> 写递归代码的关键在于找到将大问题转化为小问题的关键，并且基于此写下递归公式，然后再推敲递归终止条件，最终将递归公式和递归条件转化为代码实现。\n\n## 递归代码要警惕堆栈溢出\n\n递归代码在简洁可读性强的同时，却也带来了堆栈溢出的隐患。\n\n之前提到过系统没调用一个函数，会将临时变量作为栈帧压栈，等到函数返回再弹栈。而递归代码因为调用的函数层数多，在函数调用时不断申请栈空间。从而导致空间复杂度不理想。\n\n那怎样避免呢？理想的方法是根据场景选择递归，如果递归层数不多，则限制递归层数，这时使用递归是合适的。\n\n## 递归代码要警惕重复计算\n\n在刚才走台阶的例子中，就不可避免的遇到了重复计算的问题，这样对问题的求解并没有障碍，但并不优雅，我们要使用哈比表这样的数据结构动态存储每个子问题的结果。\n\n## 一点思考\n\n在问题规模较大时，有什么比较好的调试方式——\n\n> - 打印日志发现递归值\n> - 结合条件断点进行调试\n\n------\n\n> 山高路远，静水深流","slug":"递归的基本思想","published":1,"updated":"2023-09-24T09:50:29.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7l4000qxjcc3b3o0vg6","content":"<h2 id=\"从一个问题开始\"><a href=\"#从一个问题开始\" class=\"headerlink\" title=\"从一个问题开始\"></a>从一个问题开始</h2><p>假设A的推荐人是B，B的推荐人是C，如何来查找A的最终推荐人呢？</p>\n<p>这里直接给出答案——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">long</span> <span class=\"token function\">findRootRerfererId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> actorId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">Long</span> refererId <span class=\"token operator\">=</span> select referer_id from <span class=\"token punctuation\">[</span>table<span class=\"token punctuation\">]</span> where actor_id <span class=\"token operator\">=</span> actorId<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>refererId <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> actorId<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">findRootRerfererId</span><span class=\"token punctuation\">(</span>refererId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"递归概述\"><a href=\"#递归概述\" class=\"headerlink\" title=\"递归概述\"></a>递归概述</h2><p>递归是一种应用非常广泛的算法，亦可称作编程技巧。</p>\n<h2 id=\"递归的引出\"><a href=\"#递归的引出\" class=\"headerlink\" title=\"递归的引出\"></a>递归的引出</h2><p>递归顾名思义，包含递与归两个过程。我们用下面的例子来体会一下。</p>\n<p>假设你去电影院看电影，你想知道自己坐在第几排，所以你询问前排的人，但前排的人有相同的困惑，他又去问他的前排，直到第一排的人明确自己坐在第几排。然后每一排的人将结果告诉自己的后排，整个递归的过程就完成了。</p>\n<p>这个小例子中，第一排是终止条件，不断问前排的人是递归条件。无疑是很典型的递归问题，但面对递归问题更通常的反应是看了全会，写了全废。所以我们还要按部就班的学习递归的知识。。。</p>\n<h2 id=\"递归的三个条件\"><a href=\"#递归的三个条件\" class=\"headerlink\" title=\"递归的三个条件\"></a>递归的三个条件</h2><ol>\n<li>一个问题的解可以分解为几个子问题的解</li>\n<li>设个问题与分解后的问题除了问题规模不同外，求解思路完全相同</li>\n<li>存在递归终止条件</li>\n</ol>\n<h2 id=\"如何编写递归代码\"><a href=\"#如何编写递归代码\" class=\"headerlink\" title=\"如何编写递归代码\"></a>如何编写递归代码</h2><p>编写递归代码的核心无非就两个：<strong>递归公式+终止条件</strong>。我们通过下面的小例子来理解下——</p>\n<p>假设有n个台阶，每次你自己可以跨越1个台阶或者2个台阶。请问走这n个台阶共有多少种走法？</p>\n<p>我们会想到，可以按照第一步的走法将问题分解为两个子问题，也就是走一步之后的走法和走两步之后的走法，对应的递归公式就是<br>$$<br>f(n) = f(n-1)+f(n-2)<br>$$<br>再来确定终止条件，显然，当只有一个台阶时就没必要再递归了，也就是：<br>$$<br>f(1)=1<br>$$<br>将这个递归终止条件带入递归公式后，发现f(2)是无法确定的，所以终止条件还应该包含<br>$$<br>f(2)=2<br>$$<br>表示的含义是走两个台阶有两种走法。最后我们将其转换为代码实现——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>站在巨人的肩膀——</p>\n<blockquote>\n<p>写递归代码的关键在于找到将大问题转化为小问题的关键，并且基于此写下递归公式，然后再推敲递归终止条件，最终将递归公式和递归条件转化为代码实现。</p>\n</blockquote>\n<h2 id=\"递归代码要警惕堆栈溢出\"><a href=\"#递归代码要警惕堆栈溢出\" class=\"headerlink\" title=\"递归代码要警惕堆栈溢出\"></a>递归代码要警惕堆栈溢出</h2><p>递归代码在简洁可读性强的同时，却也带来了堆栈溢出的隐患。</p>\n<p>之前提到过系统没调用一个函数，会将临时变量作为栈帧压栈，等到函数返回再弹栈。而递归代码因为调用的函数层数多，在函数调用时不断申请栈空间。从而导致空间复杂度不理想。</p>\n<p>那怎样避免呢？理想的方法是根据场景选择递归，如果递归层数不多，则限制递归层数，这时使用递归是合适的。</p>\n<h2 id=\"递归代码要警惕重复计算\"><a href=\"#递归代码要警惕重复计算\" class=\"headerlink\" title=\"递归代码要警惕重复计算\"></a>递归代码要警惕重复计算</h2><p>在刚才走台阶的例子中，就不可避免的遇到了重复计算的问题，这样对问题的求解并没有障碍，但并不优雅，我们要使用哈比表这样的数据结构动态存储每个子问题的结果。</p>\n<h2 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h2><p>在问题规模较大时，有什么比较好的调试方式——</p>\n<blockquote>\n<ul>\n<li>打印日志发现递归值</li>\n<li>结合条件断点进行调试</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"从一个问题开始\"><a href=\"#从一个问题开始\" class=\"headerlink\" title=\"从一个问题开始\"></a>从一个问题开始</h2><p>假设A的推荐人是B，B的推荐人是C，如何来查找A的最终推荐人呢？</p>\n<p>这里直接给出答案——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">long</span> <span class=\"token function\">findRootRerfererId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> actorId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">Long</span> refererId <span class=\"token operator\">=</span> select referer_id from <span class=\"token punctuation\">[</span>table<span class=\"token punctuation\">]</span> where actor_id <span class=\"token operator\">=</span> actorId<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>refererId <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> actorId<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">findRootRerfererId</span><span class=\"token punctuation\">(</span>refererId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"递归概述\"><a href=\"#递归概述\" class=\"headerlink\" title=\"递归概述\"></a>递归概述</h2><p>递归是一种应用非常广泛的算法，亦可称作编程技巧。</p>\n<h2 id=\"递归的引出\"><a href=\"#递归的引出\" class=\"headerlink\" title=\"递归的引出\"></a>递归的引出</h2><p>递归顾名思义，包含递与归两个过程。我们用下面的例子来体会一下。</p>\n<p>假设你去电影院看电影，你想知道自己坐在第几排，所以你询问前排的人，但前排的人有相同的困惑，他又去问他的前排，直到第一排的人明确自己坐在第几排。然后每一排的人将结果告诉自己的后排，整个递归的过程就完成了。</p>\n<p>这个小例子中，第一排是终止条件，不断问前排的人是递归条件。无疑是很典型的递归问题，但面对递归问题更通常的反应是看了全会，写了全废。所以我们还要按部就班的学习递归的知识。。。</p>\n<h2 id=\"递归的三个条件\"><a href=\"#递归的三个条件\" class=\"headerlink\" title=\"递归的三个条件\"></a>递归的三个条件</h2><ol>\n<li>一个问题的解可以分解为几个子问题的解</li>\n<li>设个问题与分解后的问题除了问题规模不同外，求解思路完全相同</li>\n<li>存在递归终止条件</li>\n</ol>\n<h2 id=\"如何编写递归代码\"><a href=\"#如何编写递归代码\" class=\"headerlink\" title=\"如何编写递归代码\"></a>如何编写递归代码</h2><p>编写递归代码的核心无非就两个：<strong>递归公式+终止条件</strong>。我们通过下面的小例子来理解下——</p>\n<p>假设有n个台阶，每次你自己可以跨越1个台阶或者2个台阶。请问走这n个台阶共有多少种走法？</p>\n<p>我们会想到，可以按照第一步的走法将问题分解为两个子问题，也就是走一步之后的走法和走两步之后的走法，对应的递归公式就是<br>$$<br>f(n) = f(n-1)+f(n-2)<br>$$<br>再来确定终止条件，显然，当只有一个台阶时就没必要再递归了，也就是：<br>$$<br>f(1)=1<br>$$<br>将这个递归终止条件带入递归公式后，发现f(2)是无法确定的，所以终止条件还应该包含<br>$$<br>f(2)=2<br>$$<br>表示的含义是走两个台阶有两种走法。最后我们将其转换为代码实现——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>站在巨人的肩膀——</p>\n<blockquote>\n<p>写递归代码的关键在于找到将大问题转化为小问题的关键，并且基于此写下递归公式，然后再推敲递归终止条件，最终将递归公式和递归条件转化为代码实现。</p>\n</blockquote>\n<h2 id=\"递归代码要警惕堆栈溢出\"><a href=\"#递归代码要警惕堆栈溢出\" class=\"headerlink\" title=\"递归代码要警惕堆栈溢出\"></a>递归代码要警惕堆栈溢出</h2><p>递归代码在简洁可读性强的同时，却也带来了堆栈溢出的隐患。</p>\n<p>之前提到过系统没调用一个函数，会将临时变量作为栈帧压栈，等到函数返回再弹栈。而递归代码因为调用的函数层数多，在函数调用时不断申请栈空间。从而导致空间复杂度不理想。</p>\n<p>那怎样避免呢？理想的方法是根据场景选择递归，如果递归层数不多，则限制递归层数，这时使用递归是合适的。</p>\n<h2 id=\"递归代码要警惕重复计算\"><a href=\"#递归代码要警惕重复计算\" class=\"headerlink\" title=\"递归代码要警惕重复计算\"></a>递归代码要警惕重复计算</h2><p>在刚才走台阶的例子中，就不可避免的遇到了重复计算的问题，这样对问题的求解并没有障碍，但并不优雅，我们要使用哈比表这样的数据结构动态存储每个子问题的结果。</p>\n<h2 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h2><p>在问题规模较大时，有什么比较好的调试方式——</p>\n<blockquote>\n<ul>\n<li>打印日志发现递归值</li>\n<li>结合条件断点进行调试</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"Mysql数据库系列——持续更新中","top":true,"cover":true,"toc":true,"mathjax":true,"date":"2021-07-12T08:24:45.000Z","password":null,"summary":null,"_content":"\n## 前言\n\n有一段时间我很困惑，如何在有限的时间内展开繁杂的内容，最终在评论区找到了答案：\n\n> 将每一小节的内容提炼成问题，通过回答这些问题来掌握知识，详略分明且高效！\n\n## 一.一条sql查询语句是如何执行的\n\n### 1.mysql的框架有哪些基本组件，各是什么功能？\n\n所有的故事，都从一张图开始：\n\n![image-20210604153409674](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604153409674.png)\n\n可以看到，mysql大致分为server层与存储引擎层：\n\n- `server层：`包含连接器，查询缓存，分析器，执行器等，涵盖了mysql的大多数的核心功能，以及所有的内置函数(日期，时间，数学，加密函数）,所有跨存储引擎的功能都在这一层实现，如存储过程，触发器，视图。\n- `存储引擎层：`它以插件式的架构方式负责数据的存储与提取，支持InnoDB,Memory,MyISAM等存储引擎，默认引擎是**InnoDB**.\n- 关系：**所有存储引擎共用一个server层**。\n\n### 2.server层包含哪些组件？它们各是什么作用？\n\n1. `连接器`：连接器负责和mysql服务器端**建立连接，获取权限，维持和管理连接**\n\n   ![image-20210604155808563](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604155808563.png)\n\n   在连接建立后，如果没有使用，就会进入sleep状态。\n\n   ![image-20210604160921192](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604160921192.png)\n\n   如果客户端太久没动作（**wait_timeout=8小时**），连接器就会将其自动断开。\n\n   当然，上面的情况是基于长连接的，而长连接正如我们在计网中了解的一样：**如果客户端持续有请求，则使用同一个连接**。长连接有效减少了频繁建立，销毁连接的成本，但也带来了一些问题：\n\n   - [x] mysql在执行过程中临时使用的内存是管理在连接对象中的，如果连接长期存在，会导致MYsql占用内存过多，最终导致OOM\n\n   而针对长连接占用内存过多的问题，通常有这样两种解决方式：\n\n   - **定期断开连接**\n   - MYSQL5.7以后，可以在每次执行比较大的操作后，执行**mysql_reset_connection**来重新初始化连接资源。\n\n2. `查询缓存`：\n\n   首先要明确的是：不建议使用功能缓存，原因如下：\n\n   我们在拿到一个查询请求后，首先会查询缓存，如果缓存中存在**以键值对形式存在的记录**，则直接从缓存中拿，也无须再执行后续环节，直接返回命中结果即可。如果缓存中不存在，则继续流程。\n\n   但如果我们拿到的是一个更新请求呢？那查询缓存不仅没用，还需要清空缓存，也就是我们常说的**缓存失效**，在一个更新语句频繁的系统中，要查询缓存有何用？\n\n   让人戏谑的是，在mysql8.0以后，查询缓存彻底成了过去式。\n\n3. `分析器`：\n\n   1. 词法分析：我们输入是由多个字符串和空格组成的一条sql语句，mysql需要识别里面的字符串分别是啥，如需要把字符串test识别为表test。\n   2. 语法分析：简言之，判断sql语句的语法是否正确。\n\n4. `优化器`：\n\n   哪些方面有优化空间呢？**join的连接顺序，索引**，所以优化器会决定选择哪一个。\n\n5. `执行器`：\n\n   在执行之前，首先查看是否具有执行权限，如果没有，返回错误。如果命中，则**在查询缓存返回结果的时候做权限验证**。\n\n   如果有权限，则执行器调用引擎提供的接口，调用API，完成操作。\n\n### 3.存储引擎层有什么作用？\n\n留个坑\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 二.一条sql更新语句是如何执行的？\n\n### 1.redo log的概念是什么？底层实现机制是怎样的？\n\n`redo-log`：即重做日志，它独属于InnoDB引擎，是一种物理日志，记录了在数据页上的操作，可以保证crash safe.\n\n`原理`：假如在执行更新语句后，直接将更新写回磁盘，就会影响即时体验。所以我们需要借鉴这样的思想：\n\n> 《孔乙已》中的酒店掌柜不会直接将还账记录写到**账本(磁盘)**中，而会将**还账(更新**,即做了什么)记录在**粉板(redo-log)**上，在空闲时，在全部写入账本中。\n\n`底层原理`：InnoDB的redo-log是固定大小的，如可以配置为一组4个文件，每个文件大小1GB，记录日志时使用**循环队列**的数据结构，当循环队列已满，会将最久的日志擦除(写入磁盘)，然后使用新的日志填充空间。\n\nredo-log并非直接持久化到磁盘，它会首先存储到`redo-log buffer`，接着存储到文件系统的`page cache`,最后才`持久化`到磁盘。\n\n### 2.什么是WAL（write ahead logging）机制，好处是什么？\n\n直白的说，就是`先写日志，再写入磁盘`，日志是被加载到内存中的，写入速度快，而写入磁盘是机械运动，写入速度非常慢。\n\n### 3.redo log是如何保证crash-safe的？\n\n所谓crash，指的`是数据库异常重启`的场景，显然，如果不使用redo-log机制，此时仅有负责归档(用于备份)的bin-log，数据的更新不会被刷新到磁盘中去。\n\n而redo-log机制负责物理更新刷新到磁盘中去，`不会出现物理与逻辑数据不一致`的状况。\n\n### 4.binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\n\n`bin-log`:即归档日志，由server层实现，记录数据库的逻辑操作，用于全量备份。当需要恢复数据时，可以取出某个时间段内的bin-log进行重放恢复。\n\n`底层原理`：bin-log区别于redo-log，它没有文件大小的限制，会追加写；\n\n每个线程都有自己的binlog cache,但是会共用一份binlog文件。\n\n持久化到磁盘分为两个阶段：首先将日志写到文件系统的**page cache**,此时并没有持久化到磁盘，所以速度比较快；接着**fsync**,即是将数据持久化到磁盘，一般认为只有fsync才占磁盘的**IOPS**。\n\n`crash-safe`:crash要解决的问题是逻辑数据与物理数据不一致的问题，也就是保证将内存中物理数据刷新到内存，但bin-log表示我做不到~\n\n### 5.对比redo-log和bin-log.\n\n|            | redo-log               | bin-log                                                      |\n| ---------- | ---------------------- | ------------------------------------------------------------ |\n| 文件大小   | 覆盖写                 | 追加写                                                       |\n| 层级       | server层               | InnoDB引擎                                                   |\n| 日志形式   | 物理日志               | 逻辑日志                                                     |\n| 作用       | 刷新到磁盘，物理一致性 | 归档，逻辑一致性                                             |\n| crash-safe | √                      | ×                                                            |\n| 实质       | 记录数据页做了什么操作 | statment模式：记录sql语句    row模式：记录更新前后的行，一般使用row模式 |\n\n### 6.一条sql更新语句是如何执行的？\n\n> update test set c=c+1 where id = 1\n\n1. 执行器先找引擎找ID=1的这一行，ID为主键，引擎使用B+树的主键索引找到这一行。如果该行在内存中，直接返回给执行器；否则，先从磁盘读取到内存中，再返回；\n2. 执行器执行得到新数据，调用引擎接口写入新的行记录；\n3. 引擎将这行记录更新到内存中，并将更新的操作记录写到redo-log中，redo-log进行prepare状态；\n4. 执行器生成bin-log，将bin-log写入磁盘；\n5. redo-log改为commit状态，更新完成。\n\n### 7.如果数据库误操作，如何将数据恢复？\n\n找到最近一次的全量备份，`从备份时间点开始`，将备份的bin-log依次取出，重放到误删时刻。\n\n### 8.什么是两阶段提交?如果不两阶段提交，会发生什么？\n\n即确定redo-log与bin-log提交时机，通过`两阶段提交来保证跨系统维持数据逻辑一致性`。如果没有两阶段提交，就好比读到了事务的脏数据。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 三.事务隔离：为什么你改了我还看不见\n\n### 1.事务的概念是什么？\n\n> 事务是对数据库中数据操作的`保证数据逻辑一致性的最小操作单元`。\n\n### 2.简述某一场景下，不同事务隔离级别的区别\n\n有这样的一个场景：\n\n![image-20210606161322663](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606161322663.png)\n\n在该场景下，不同事务隔离级别有不同的返回值：\n\n- `读未提交`：即在事务B没有提交的时候，它做的变更就可以被事务A看到。所以读到的值分别是1,2,2；\n\n- `读已提交`：即只有在事务A提交之后，它做的变更才能被事务A看到，所以读到的值为：1,1,2；\n- `可重复读`：即事务A执行期间读到的值和事务A开启时读到的值是一样的，所以读到的值是1,1,2；\n- `串行化`：即事务A，事务B对于同一行记录，会通过加读写锁的方式来限制另一个事务。所以读到的值是1,1,2.\n\n### 3.读已提交，可重复读是怎样通过视图构建实现的？\n\n首先了解下视图的概念：\n\n> 视图是对复杂sql语句的封装，可以认为是拷贝静态数据，对视图做的变更不会同步到数据库中。\n\n- `可重复读`：在该隔离级别下，数据库在事务启动时创建了一个视图，访问时以视图的逻辑结果为准，在**事务存在期间**都会使用这个视图。他为mysql的默认隔离级别；\n- `读未提交`：直接返回记录最新值，没有视图概念；\n- `读已提交`：视图在**sql语句开始执行时**创建。它为oracle的默认隔离级别。\n\n- [x] 注:配置方式：transaction-isolation=READ-COMMITED\n\n### 4.简要说明可重复读的使用场景\n\n在记账的时候很有用。\n\n### 5.事务隔离是怎样通过read-view实现的?\n\n之前我们提到，在事务隔离中，提供了`视图这种数据拷贝`的方式，而在事务隔离级别下，我们会读到不同的数据，这说明是存在多个视图的，也就是read-view。\n\n在MYSQL中，实际上每条记录在更新时都会记录一条`回滚操作`，通过回滚操作，可以得到上一个状态的值：\n\n![image-20210606163851669](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606163851669.png)\n\n也就是说，`同一个记录在数据库中是存在多个版本的`，当我们要读取数据时，要判断这个数据的版本对于当前事务是否可见，如果不可见，就通过`undo-log`计算得到上一个版本，直到找到正确版本为止。\n\n在不需要的时候，数据库系统会将回滚日志删除。\n\n### 6.并发版本控制的概念是什么？如何实现？\n\n`概念`：同一个数据行，在数据库中存在`多个版本号`，这个版本号可以理解为当前操作这行数据的`事务的ID`。\n\n`实现`：在进行并发操作时，会使用`该行的版本号与当前事务的版本号`进行比较，如果刚好等于，也就是说这行数据是由这个事务提交生成的。\n\n### 7.长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\n\n`概念`：需要执行很久的事务；\n\n`底层`：长事务意味着系统中有非常多的不能被删除的事务视图，这会导致大量的`空间占用`，而在mysql5.5之前，即便长事务被提交，`回滚段被清理，文件也不会变小`，另外长事务还`占用锁资源`，这时其他就会因锁等待重新建立连接，`mysql的连接被占用爆满`，导致拖垮整个库。\n\n`查询`：SELECT * FROM information_schema.INNODB_TRX\n\n`避免`：\n\n1. 设置autocommmit=1,即自动提交；\n2. 写脚本监控information_schema.INNODB_TRX的内容，发现长事务就kill掉它；\n3. 设置SQL语句所能执行的最大运行时间；\n4. 设置回滚表单独存放，便于回收表空间。\n5. 尽量去使用小事务。\n\n### 8.事务的启动方式有哪几种？\n\n- `begin:`\n- `start trasaction:`与begin效果一致；\n- `start trasaction with consistent snaps hot:`该语句执行后，会创建一致性视图，分配事务ID。\n\n### 9.commit work and chain的语法有什么作用？\n\n提交当前事务+开启下一个事务=begin+commit;\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 四.深入浅出索引上\n\n### 1.索引的概念是什么？\n\n**概念**：索引是一个相对抽象的数据结构，在书中，我们通常抽取`目录名与对应的页码号作为目录以快速定位数据`，在数据库系统中，索引就是以这样的作用存在的，它是数据库管理系统中一个`排序`的数据结构)，以`协助快速查询`、更新数据库表中数据。\n\n**类比**：操作系统中使用**inode**来唯一标识文件，在inode中，记录了各个`文件分别包含哪些磁盘块`，给定inode,就可以找到文件的所有块，在inode中，同样存储了文件属性的磁盘地址。\n\n### 2.简述索引模型之哈希表\n\n**概述**：哈希表是一种以`键值对`存储数据的结构，我们只需要输入待查找的key，就可以找到对应的value,哈希表的思路很简单，把值放在数组中，用一个`哈希函数把key换算成一个确定的位置`，然后将value放在数组的这个位置。\n\n**哈希冲突**：使用链表法解决；\n\n**示例**：![image-20210607202153949](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202153949.png)\n\n**特点**：只适用于`等值查询`，可以应用于NoSQL不能做`区间查询`。\n\n### 3.简述索引模型之有序数组\n\n**概述**：将元素按照一定的顺序排列，这里的顺序`不一定是严格自增`，而是按照某一属性从小到大排序。假如有一个按照身份证号排列的有序数组，我们要查询某一个身份证号的名字，通过`二分法`就可以找到。\n\n**示例**：![image-20210607202732018](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202732018.png)\n\n**特点**：对于`等值查找`和`范围查找`都较友好，查询的时间复杂度为`O(logN)`,但实际上有序数组并没有得到大量应用，这是因为在插入元素时需要大量的`数据搬移`，也因此有序数组被大量应用于`静态存储引擎`。\n\n### 4.简述索引模型之B+树\n\n**概述**：B+树是一种二叉搜索树，它的节点遵循严格的大小关系，`二叉搜索树的查询，更新的时间复杂度为O(logN)`,\n\n**示例**：![image-20210607203522696](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607203522696.png)\n\n**特点**：`B+树`即为InnoDB的引擎模型，但考虑到性能，更多被使用的实则是`多叉树`。\n\n### 5.为什么N叉树被广泛应用到数据库引擎中？\n\n我们先设想二叉树存储的场景：假如二叉树`树高20`，存储了100万行数据，`需要读取20个数据块(连续的存储空间)`，在机械硬盘时代，读取硬盘是龟速，而这样的龟速，居然要连续查询20次，那怎么提高查询的性能呢？\n\n减少树高，增加一个数据块中的数据，即`使用N叉树`。\n\n### 6.基于主键索引和普通索引的查询有什么区别？\n\n**前提**：在InnoDB中，`表是根据主键顺序以索引的形式存放`，这种存储方式被称为索引组织表。又因为索引是B+树的数据结构，即数据存储在B+树中，而`每一个索引在InnoDB里面对应一张表`。再进一步，则可以认为表是以多个B+树的形式存储的。\n\n**主键索引**：主键索引的叶子结点存储的是`整行数据`，也因此得名聚簇索引。\n\n**普通索引**：非主键索引的叶子结点存储的是`主键的值`，因此得名二级索引。\n\n**区别**：如果where条件需要走主键索引，则只需要搜索主键的B+树，如果where条件走的是普通索引，则就需要先查询普通索引的B+树，得到主键，再去查询普通索引，即`回表`\n\n### 7.简述维护B+树索引时的页分裂与页合并？\n\n- **页分裂**：在插入数据时，如果当前数据页已满，就会申请一个新的数据页，导致`空间利用率下降`；\n- **页合并**：如果因为删除数据，导致`利用率变低`，则页合并就成了可选的优化方式。\n\n### 8.哪些场景下应该使用自增主键，而哪些场景不应该\n\n`自增主键适合递增插入`的场景，这样追加数据时，就不需要数据搬移咯。所以**大多数的场景下，我们都会使用自增主键**。\n\n而在有业务逻辑的字段做主键时，数据成本就会变高啦。\n\n如果在`典型的KV场景下，就需要使用普通索引`。\n\n### 9.删除主键索引与普通索引有什么影响？\n\n删除，重建主键索引后，需要同时`修改普通索引对应的主键索引`，而删除，重建普通索引则让人省心不少。\n\n### 10.索引的优化\n\n1. **覆盖索引：**如果查询条件使用的是普通索引，或者联合索引的最左原则字段，查询结果是联合索引的字段或者主键，`不用回表操作，直接返回结果`，减少磁盘读写的次数，提高IO性能。\n2. **最左前缀：**联合索引的`最左N个字段`，也可以是字符串索引的前M个字符；\n3. **联合索引：**根据创建`联合索引`的顺序，`以最左原则进行where检索`，比如(age,name)以age=1或者age=1 and name='张三'可以使用索引，单以name=\"张三\"不会使用索引。考虑到存储空间的问题，还需要根据业务需求，将查找频繁的数据进行靠左创建索引。\n4. **索引下推：**like \"hello%\" and age>10检索，在mysql5.6之前，会对匹配的数据进行会回表查询，5.6版本以后，`会先过滤不合法的数据，再对合法的数据进行回表`，从而降低回表率，提升检索率。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 五.全局锁和表锁：给表加个字段怎么有那么多阻碍\n\n### 1.简述全局锁锁\n\n**概述**：对整个数据库实例加锁。\n**加锁方式**：`Flush tables with read lock(FTWRL)`，这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会`被阻塞`。\n**使用场景**：全库逻辑备份。\n**风险**：\n\t1.如果在`主库备份`，在备份期间不能更新，`业务停摆`\n\t2.如果在`从库备份`，备份期间不能执行主库同步的binlog，导致`主从延迟`\n\n### 2.InnoDB是如何实现全局备份的\n\n**mysqldump**：官方自带的逻辑备份工具mysqldump，当mysqldump使用参数`--single-transaction`的时候，会启动一个事务，确保拿到`一致性视图`。而由于`MVCC`的支持，这个过程中数据是可以正常更新的。\n\n一致性读是好，但是前提是引擎要支持这个隔离级别。\n\n## 3.如果要全库只读，为什么不使用set global readonly=true的方式？\n\n1.在有些系统中，`readonly的值会被用来做其他逻辑`，比如判断主备库。所以修改global变量的方式影响太大。\n2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会`导致整个库长时间处于不可写状态，风险较高`。\n\n## 4.表锁简述\n\n**概述**：mysql里面表锁有两种：表锁和MDL(元数据锁)，表锁不建议加，MDL会默认加上；\n\n**表锁**：![\t](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210608082421097.png)\n\n**MDL**：不需要显式使用，在访问的时候会自动加上，MDL包含`读锁和写锁`，`读锁之间不互斥`，可多线程共享，`写锁互斥`，来保证表结构变更时的安全性。\n\n**风险**：MDL直到事务提交才会被释放，因此为了防止MDL存在时间过长，从而MYSQL异常重启，应该避免长事务。\n\n### 5.如何安全地小表加一个字段\n\n1. 查询长事务，暂停或kill掉长事务；\n2. 在alter table语句中指定等待时间，避免阻塞。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 六.行锁功过：怎么减少行锁对性能的影响\n\n### 1.行锁的概述\n\n行锁即是对数据库的`行记录加锁`，在引擎层实现，仅`InnoDB`支持行锁。\n\n### 2.简述两阶段锁协议\n\n**概念**：在InnoDB事务中，行锁是在需要的时候加上的，但需要等待`事务提交才会释放`；\n\n**建议**：`如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁往后放`。\n\n### 3.简述死锁\n\n**概念**：当两个线程都在等待对方锁持有的资源时，就会产生死锁；\n\n**预防死锁**：\n\n1. 设置`超时参数`，默认为50s，这样显然交互不好，但如果设置过小，又会错将正常等待的线程当做死锁处理，因此**不建议使用这种方案**；\n\n2. `死锁检测`，发现死锁，马上`回滚`。这里可以`类比spring中的循环依赖`，都是需要查看自己所依赖的线程有没有被别人锁住。但这种方案仍有隐患，假设有100个线程并发修改，`都去查看自己依赖的线程有没有锁住，就必然需要大量的CPU资源`，这也是为什么即便很小的并发量，CPU占用率也可能很高的原因。\n\n   > 怎样解决由这种热点行更新导致的性能问题？\n\n   - 在`确认不会发生死锁的情况下，可关闭死锁检测`，但问题在于关掉死锁检测可能导致大量的超时，这是业务有损的；\n   - 控制并发度，具体地说，是在数据库服务端实现该逻辑，实现方式自然是`特定大小的等待队列`；\n   - 从设计上看，可以考虑将一行改成逻辑上的多行。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n## 番外\n\n### 1.mysql的服务器配置文件\n\n![image-20210607105513978](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607105513978.png)\n\n### 2.my.cnf/my.ini配置文件详解\n\nhttps://www.cnblogs.com/kuoAT/p/7080770.html\n\n### 3.mysql日志系统详解\n\nhttps://segmentfault.com/a/1190000023827696\n\n### 4.查看mysql下的几个日志\n\nhttps://blog.csdn.net/xuheng8600/article/details/79823875\n\n1. **慢查询日志**是记录了执行时间超过参数long_query_time(单位是秒)所设定值的SQL语句日志。\n\n   Note:慢查询日志对于我们发现性能有问题的SQL有很帮助，建议使用并经常分析；\n\n2. **查询日志**记录了clinet的所有的语句。\n\n   Note:由于log日志记录了数据库所有操作，对于访问频繁的系统，此种日志会造成性能影响，建议关闭。\n\n3. **错误日志**在Mysql数据库中很重要，它记录着mysqld启动和停止，以及服务器在运行过程中发生的任何错误的相关信息。\n\n4. **二进制日志**也通常被称为binlog,它记当着所有的DDL和DML，但不包括数据查询语句。\n\n## 面经集锦\n\n1. Explain的主要字段\n\n   ![image-20210613161115048](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613161115048.png)\n\n2. b+树相比B树的优点\n\n   ![image-20210613170513272](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613170513272.png)\n\n3. 可不可以切换索引为哈希索引？\n\n   ![image-20210613162722458](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613162722458.png)\n\n4. 场景题：高并发场景下数据库压力很大，怎么解决？\n\n   `使用索引，使用缓存，分库分表，消息队列`\n\n5. mysql分页查询优化\n\n   **一般查询会从第一条记录开始找起**\n\n   1. **子查询**：这种方式`先定位偏移位置的 id`，然后往后查询，这种方式适用于 id 递增的情况\n   2. **id限定**：可以使用 `id between and` 来查询\n\n   一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。\n\n6. mysql 联合索引使用 A>n and B=m 和 A=n and B=m 的区别\n\n   ![image-20210613165722760](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165722760.png)\n\n   ![image-20210613165652454](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165652454.png)\n\n7. MySQL的InnoDB和MyISAM区别\n\n   | 角度         | InnoDB   | MyISAM     |\n   | ------------ | -------- | ---------- |\n   | 事务         | 支持     | 不支持     |\n   | 外键         | 支持     | 不支持     |\n   | 索引         | 聚集索引 | 非聚集索引 |\n   | 表的具体行数 | 不保存   | 保存       |\n   | 锁的粒度     | 行锁     | 表锁       |\n\n8. 索引如何优化\n\n   发现索引走的不好：**慢查询**\n\n   1. 利用`覆盖索引`来进行查询操作，避免回表；\n   2. `explain中的字段type`：至少要达到range级别，要求是ref级别，如果为**consts**最好不过。\n   3. `联合索引最左前缀原则`。\n   4. union，in,or都能够命中索引，建议使用`in`.\n\n9. 简述乐观锁与悲观锁\n\n   **乐观锁**：拿数据时不会上锁，但在提交的时候会判断数据有没有被更新，通常使用版本号/时间戳来实现。\n\n   **悲观锁**：一开始就对商品加上锁（SELECT ... `FOR UPDATE`）\n\n10. 索引一定会命中吗？如何保证命中\n\n    不一定会命中，使用explain中的ref字段判断，force index,强制走某个索引\n\n    ```mysql\n    SELECT * FROM test01 FORCE INDEX(uk_index) WHERE NAME = '测试1' AND age=1 ;\n    ```\n\n11. mysql数据库为什么要使用N叉树\n\n    一个页就是一棵树B+树的节点，数据库I/O操作的最小单位是页，与数据库相关的内容都会存储在页的结构里。\n\n    在一棵B+树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间\n\n    同一层的节点之间，通过页的结构构成了一个双向链表\n\n    非叶子节点包括了多个索引行，每个索引行里存储索引键和指向下一层页面的指针\n\n    叶子节点为，存储了关键字和行记录，在节点内部(也就是页结构的内部)记录之间是一个单向的链表\n\n    ![img](https://img-blog.csdnimg.cn/20200404223041152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70#pic_center)\n\n12. 说一下你的项目里具体的一个表，有没有建索引，如何建的？\n\n    shop表，主键shopId（主键本身就是一种特殊的索引）,外键userId,shopCategoryId\n\n    **shopId bigint not null auto_invreament primary key**\n\n    在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键，除非高并发写入操作可能需要衡量自增主键\n\n13. innodb 索引文件的存储形式\n\n    思路：一个表——》多个B+树——》叶子节点(页结构，即多个磁盘块)+非叶子结点(页结构，即多个磁盘块)——》行数据+索引数据\n\n14. mysql主键是怎么自增的（其实是说底层的Auto-INC锁）\n\n    **自增长计数器**,**Auto-INC锁**,表锁\n\n------\n\n> 山高路远，静水深流","source":"_posts/Mysql数据库系列——持续更新中.md","raw":"---\ntitle: Mysql数据库系列——持续更新中\ntop: true\ncover: true\ntoc: true\nmathjax: true\ndate: 2021-07-12 16:24:45\npassword:\nsummary:\ncategories: 数据库\ntags: \n\t- Mysql\n\t- 极客时间\n---\n\n## 前言\n\n有一段时间我很困惑，如何在有限的时间内展开繁杂的内容，最终在评论区找到了答案：\n\n> 将每一小节的内容提炼成问题，通过回答这些问题来掌握知识，详略分明且高效！\n\n## 一.一条sql查询语句是如何执行的\n\n### 1.mysql的框架有哪些基本组件，各是什么功能？\n\n所有的故事，都从一张图开始：\n\n![image-20210604153409674](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604153409674.png)\n\n可以看到，mysql大致分为server层与存储引擎层：\n\n- `server层：`包含连接器，查询缓存，分析器，执行器等，涵盖了mysql的大多数的核心功能，以及所有的内置函数(日期，时间，数学，加密函数）,所有跨存储引擎的功能都在这一层实现，如存储过程，触发器，视图。\n- `存储引擎层：`它以插件式的架构方式负责数据的存储与提取，支持InnoDB,Memory,MyISAM等存储引擎，默认引擎是**InnoDB**.\n- 关系：**所有存储引擎共用一个server层**。\n\n### 2.server层包含哪些组件？它们各是什么作用？\n\n1. `连接器`：连接器负责和mysql服务器端**建立连接，获取权限，维持和管理连接**\n\n   ![image-20210604155808563](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604155808563.png)\n\n   在连接建立后，如果没有使用，就会进入sleep状态。\n\n   ![image-20210604160921192](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604160921192.png)\n\n   如果客户端太久没动作（**wait_timeout=8小时**），连接器就会将其自动断开。\n\n   当然，上面的情况是基于长连接的，而长连接正如我们在计网中了解的一样：**如果客户端持续有请求，则使用同一个连接**。长连接有效减少了频繁建立，销毁连接的成本，但也带来了一些问题：\n\n   - [x] mysql在执行过程中临时使用的内存是管理在连接对象中的，如果连接长期存在，会导致MYsql占用内存过多，最终导致OOM\n\n   而针对长连接占用内存过多的问题，通常有这样两种解决方式：\n\n   - **定期断开连接**\n   - MYSQL5.7以后，可以在每次执行比较大的操作后，执行**mysql_reset_connection**来重新初始化连接资源。\n\n2. `查询缓存`：\n\n   首先要明确的是：不建议使用功能缓存，原因如下：\n\n   我们在拿到一个查询请求后，首先会查询缓存，如果缓存中存在**以键值对形式存在的记录**，则直接从缓存中拿，也无须再执行后续环节，直接返回命中结果即可。如果缓存中不存在，则继续流程。\n\n   但如果我们拿到的是一个更新请求呢？那查询缓存不仅没用，还需要清空缓存，也就是我们常说的**缓存失效**，在一个更新语句频繁的系统中，要查询缓存有何用？\n\n   让人戏谑的是，在mysql8.0以后，查询缓存彻底成了过去式。\n\n3. `分析器`：\n\n   1. 词法分析：我们输入是由多个字符串和空格组成的一条sql语句，mysql需要识别里面的字符串分别是啥，如需要把字符串test识别为表test。\n   2. 语法分析：简言之，判断sql语句的语法是否正确。\n\n4. `优化器`：\n\n   哪些方面有优化空间呢？**join的连接顺序，索引**，所以优化器会决定选择哪一个。\n\n5. `执行器`：\n\n   在执行之前，首先查看是否具有执行权限，如果没有，返回错误。如果命中，则**在查询缓存返回结果的时候做权限验证**。\n\n   如果有权限，则执行器调用引擎提供的接口，调用API，完成操作。\n\n### 3.存储引擎层有什么作用？\n\n留个坑\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 二.一条sql更新语句是如何执行的？\n\n### 1.redo log的概念是什么？底层实现机制是怎样的？\n\n`redo-log`：即重做日志，它独属于InnoDB引擎，是一种物理日志，记录了在数据页上的操作，可以保证crash safe.\n\n`原理`：假如在执行更新语句后，直接将更新写回磁盘，就会影响即时体验。所以我们需要借鉴这样的思想：\n\n> 《孔乙已》中的酒店掌柜不会直接将还账记录写到**账本(磁盘)**中，而会将**还账(更新**,即做了什么)记录在**粉板(redo-log)**上，在空闲时，在全部写入账本中。\n\n`底层原理`：InnoDB的redo-log是固定大小的，如可以配置为一组4个文件，每个文件大小1GB，记录日志时使用**循环队列**的数据结构，当循环队列已满，会将最久的日志擦除(写入磁盘)，然后使用新的日志填充空间。\n\nredo-log并非直接持久化到磁盘，它会首先存储到`redo-log buffer`，接着存储到文件系统的`page cache`,最后才`持久化`到磁盘。\n\n### 2.什么是WAL（write ahead logging）机制，好处是什么？\n\n直白的说，就是`先写日志，再写入磁盘`，日志是被加载到内存中的，写入速度快，而写入磁盘是机械运动，写入速度非常慢。\n\n### 3.redo log是如何保证crash-safe的？\n\n所谓crash，指的`是数据库异常重启`的场景，显然，如果不使用redo-log机制，此时仅有负责归档(用于备份)的bin-log，数据的更新不会被刷新到磁盘中去。\n\n而redo-log机制负责物理更新刷新到磁盘中去，`不会出现物理与逻辑数据不一致`的状况。\n\n### 4.binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\n\n`bin-log`:即归档日志，由server层实现，记录数据库的逻辑操作，用于全量备份。当需要恢复数据时，可以取出某个时间段内的bin-log进行重放恢复。\n\n`底层原理`：bin-log区别于redo-log，它没有文件大小的限制，会追加写；\n\n每个线程都有自己的binlog cache,但是会共用一份binlog文件。\n\n持久化到磁盘分为两个阶段：首先将日志写到文件系统的**page cache**,此时并没有持久化到磁盘，所以速度比较快；接着**fsync**,即是将数据持久化到磁盘，一般认为只有fsync才占磁盘的**IOPS**。\n\n`crash-safe`:crash要解决的问题是逻辑数据与物理数据不一致的问题，也就是保证将内存中物理数据刷新到内存，但bin-log表示我做不到~\n\n### 5.对比redo-log和bin-log.\n\n|            | redo-log               | bin-log                                                      |\n| ---------- | ---------------------- | ------------------------------------------------------------ |\n| 文件大小   | 覆盖写                 | 追加写                                                       |\n| 层级       | server层               | InnoDB引擎                                                   |\n| 日志形式   | 物理日志               | 逻辑日志                                                     |\n| 作用       | 刷新到磁盘，物理一致性 | 归档，逻辑一致性                                             |\n| crash-safe | √                      | ×                                                            |\n| 实质       | 记录数据页做了什么操作 | statment模式：记录sql语句    row模式：记录更新前后的行，一般使用row模式 |\n\n### 6.一条sql更新语句是如何执行的？\n\n> update test set c=c+1 where id = 1\n\n1. 执行器先找引擎找ID=1的这一行，ID为主键，引擎使用B+树的主键索引找到这一行。如果该行在内存中，直接返回给执行器；否则，先从磁盘读取到内存中，再返回；\n2. 执行器执行得到新数据，调用引擎接口写入新的行记录；\n3. 引擎将这行记录更新到内存中，并将更新的操作记录写到redo-log中，redo-log进行prepare状态；\n4. 执行器生成bin-log，将bin-log写入磁盘；\n5. redo-log改为commit状态，更新完成。\n\n### 7.如果数据库误操作，如何将数据恢复？\n\n找到最近一次的全量备份，`从备份时间点开始`，将备份的bin-log依次取出，重放到误删时刻。\n\n### 8.什么是两阶段提交?如果不两阶段提交，会发生什么？\n\n即确定redo-log与bin-log提交时机，通过`两阶段提交来保证跨系统维持数据逻辑一致性`。如果没有两阶段提交，就好比读到了事务的脏数据。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 三.事务隔离：为什么你改了我还看不见\n\n### 1.事务的概念是什么？\n\n> 事务是对数据库中数据操作的`保证数据逻辑一致性的最小操作单元`。\n\n### 2.简述某一场景下，不同事务隔离级别的区别\n\n有这样的一个场景：\n\n![image-20210606161322663](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606161322663.png)\n\n在该场景下，不同事务隔离级别有不同的返回值：\n\n- `读未提交`：即在事务B没有提交的时候，它做的变更就可以被事务A看到。所以读到的值分别是1,2,2；\n\n- `读已提交`：即只有在事务A提交之后，它做的变更才能被事务A看到，所以读到的值为：1,1,2；\n- `可重复读`：即事务A执行期间读到的值和事务A开启时读到的值是一样的，所以读到的值是1,1,2；\n- `串行化`：即事务A，事务B对于同一行记录，会通过加读写锁的方式来限制另一个事务。所以读到的值是1,1,2.\n\n### 3.读已提交，可重复读是怎样通过视图构建实现的？\n\n首先了解下视图的概念：\n\n> 视图是对复杂sql语句的封装，可以认为是拷贝静态数据，对视图做的变更不会同步到数据库中。\n\n- `可重复读`：在该隔离级别下，数据库在事务启动时创建了一个视图，访问时以视图的逻辑结果为准，在**事务存在期间**都会使用这个视图。他为mysql的默认隔离级别；\n- `读未提交`：直接返回记录最新值，没有视图概念；\n- `读已提交`：视图在**sql语句开始执行时**创建。它为oracle的默认隔离级别。\n\n- [x] 注:配置方式：transaction-isolation=READ-COMMITED\n\n### 4.简要说明可重复读的使用场景\n\n在记账的时候很有用。\n\n### 5.事务隔离是怎样通过read-view实现的?\n\n之前我们提到，在事务隔离中，提供了`视图这种数据拷贝`的方式，而在事务隔离级别下，我们会读到不同的数据，这说明是存在多个视图的，也就是read-view。\n\n在MYSQL中，实际上每条记录在更新时都会记录一条`回滚操作`，通过回滚操作，可以得到上一个状态的值：\n\n![image-20210606163851669](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606163851669.png)\n\n也就是说，`同一个记录在数据库中是存在多个版本的`，当我们要读取数据时，要判断这个数据的版本对于当前事务是否可见，如果不可见，就通过`undo-log`计算得到上一个版本，直到找到正确版本为止。\n\n在不需要的时候，数据库系统会将回滚日志删除。\n\n### 6.并发版本控制的概念是什么？如何实现？\n\n`概念`：同一个数据行，在数据库中存在`多个版本号`，这个版本号可以理解为当前操作这行数据的`事务的ID`。\n\n`实现`：在进行并发操作时，会使用`该行的版本号与当前事务的版本号`进行比较，如果刚好等于，也就是说这行数据是由这个事务提交生成的。\n\n### 7.长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\n\n`概念`：需要执行很久的事务；\n\n`底层`：长事务意味着系统中有非常多的不能被删除的事务视图，这会导致大量的`空间占用`，而在mysql5.5之前，即便长事务被提交，`回滚段被清理，文件也不会变小`，另外长事务还`占用锁资源`，这时其他就会因锁等待重新建立连接，`mysql的连接被占用爆满`，导致拖垮整个库。\n\n`查询`：SELECT * FROM information_schema.INNODB_TRX\n\n`避免`：\n\n1. 设置autocommmit=1,即自动提交；\n2. 写脚本监控information_schema.INNODB_TRX的内容，发现长事务就kill掉它；\n3. 设置SQL语句所能执行的最大运行时间；\n4. 设置回滚表单独存放，便于回收表空间。\n5. 尽量去使用小事务。\n\n### 8.事务的启动方式有哪几种？\n\n- `begin:`\n- `start trasaction:`与begin效果一致；\n- `start trasaction with consistent snaps hot:`该语句执行后，会创建一致性视图，分配事务ID。\n\n### 9.commit work and chain的语法有什么作用？\n\n提交当前事务+开启下一个事务=begin+commit;\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 四.深入浅出索引上\n\n### 1.索引的概念是什么？\n\n**概念**：索引是一个相对抽象的数据结构，在书中，我们通常抽取`目录名与对应的页码号作为目录以快速定位数据`，在数据库系统中，索引就是以这样的作用存在的，它是数据库管理系统中一个`排序`的数据结构)，以`协助快速查询`、更新数据库表中数据。\n\n**类比**：操作系统中使用**inode**来唯一标识文件，在inode中，记录了各个`文件分别包含哪些磁盘块`，给定inode,就可以找到文件的所有块，在inode中，同样存储了文件属性的磁盘地址。\n\n### 2.简述索引模型之哈希表\n\n**概述**：哈希表是一种以`键值对`存储数据的结构，我们只需要输入待查找的key，就可以找到对应的value,哈希表的思路很简单，把值放在数组中，用一个`哈希函数把key换算成一个确定的位置`，然后将value放在数组的这个位置。\n\n**哈希冲突**：使用链表法解决；\n\n**示例**：![image-20210607202153949](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202153949.png)\n\n**特点**：只适用于`等值查询`，可以应用于NoSQL不能做`区间查询`。\n\n### 3.简述索引模型之有序数组\n\n**概述**：将元素按照一定的顺序排列，这里的顺序`不一定是严格自增`，而是按照某一属性从小到大排序。假如有一个按照身份证号排列的有序数组，我们要查询某一个身份证号的名字，通过`二分法`就可以找到。\n\n**示例**：![image-20210607202732018](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202732018.png)\n\n**特点**：对于`等值查找`和`范围查找`都较友好，查询的时间复杂度为`O(logN)`,但实际上有序数组并没有得到大量应用，这是因为在插入元素时需要大量的`数据搬移`，也因此有序数组被大量应用于`静态存储引擎`。\n\n### 4.简述索引模型之B+树\n\n**概述**：B+树是一种二叉搜索树，它的节点遵循严格的大小关系，`二叉搜索树的查询，更新的时间复杂度为O(logN)`,\n\n**示例**：![image-20210607203522696](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607203522696.png)\n\n**特点**：`B+树`即为InnoDB的引擎模型，但考虑到性能，更多被使用的实则是`多叉树`。\n\n### 5.为什么N叉树被广泛应用到数据库引擎中？\n\n我们先设想二叉树存储的场景：假如二叉树`树高20`，存储了100万行数据，`需要读取20个数据块(连续的存储空间)`，在机械硬盘时代，读取硬盘是龟速，而这样的龟速，居然要连续查询20次，那怎么提高查询的性能呢？\n\n减少树高，增加一个数据块中的数据，即`使用N叉树`。\n\n### 6.基于主键索引和普通索引的查询有什么区别？\n\n**前提**：在InnoDB中，`表是根据主键顺序以索引的形式存放`，这种存储方式被称为索引组织表。又因为索引是B+树的数据结构，即数据存储在B+树中，而`每一个索引在InnoDB里面对应一张表`。再进一步，则可以认为表是以多个B+树的形式存储的。\n\n**主键索引**：主键索引的叶子结点存储的是`整行数据`，也因此得名聚簇索引。\n\n**普通索引**：非主键索引的叶子结点存储的是`主键的值`，因此得名二级索引。\n\n**区别**：如果where条件需要走主键索引，则只需要搜索主键的B+树，如果where条件走的是普通索引，则就需要先查询普通索引的B+树，得到主键，再去查询普通索引，即`回表`\n\n### 7.简述维护B+树索引时的页分裂与页合并？\n\n- **页分裂**：在插入数据时，如果当前数据页已满，就会申请一个新的数据页，导致`空间利用率下降`；\n- **页合并**：如果因为删除数据，导致`利用率变低`，则页合并就成了可选的优化方式。\n\n### 8.哪些场景下应该使用自增主键，而哪些场景不应该\n\n`自增主键适合递增插入`的场景，这样追加数据时，就不需要数据搬移咯。所以**大多数的场景下，我们都会使用自增主键**。\n\n而在有业务逻辑的字段做主键时，数据成本就会变高啦。\n\n如果在`典型的KV场景下，就需要使用普通索引`。\n\n### 9.删除主键索引与普通索引有什么影响？\n\n删除，重建主键索引后，需要同时`修改普通索引对应的主键索引`，而删除，重建普通索引则让人省心不少。\n\n### 10.索引的优化\n\n1. **覆盖索引：**如果查询条件使用的是普通索引，或者联合索引的最左原则字段，查询结果是联合索引的字段或者主键，`不用回表操作，直接返回结果`，减少磁盘读写的次数，提高IO性能。\n2. **最左前缀：**联合索引的`最左N个字段`，也可以是字符串索引的前M个字符；\n3. **联合索引：**根据创建`联合索引`的顺序，`以最左原则进行where检索`，比如(age,name)以age=1或者age=1 and name='张三'可以使用索引，单以name=\"张三\"不会使用索引。考虑到存储空间的问题，还需要根据业务需求，将查找频繁的数据进行靠左创建索引。\n4. **索引下推：**like \"hello%\" and age>10检索，在mysql5.6之前，会对匹配的数据进行会回表查询，5.6版本以后，`会先过滤不合法的数据，再对合法的数据进行回表`，从而降低回表率，提升检索率。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 五.全局锁和表锁：给表加个字段怎么有那么多阻碍\n\n### 1.简述全局锁锁\n\n**概述**：对整个数据库实例加锁。\n**加锁方式**：`Flush tables with read lock(FTWRL)`，这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会`被阻塞`。\n**使用场景**：全库逻辑备份。\n**风险**：\n\t1.如果在`主库备份`，在备份期间不能更新，`业务停摆`\n\t2.如果在`从库备份`，备份期间不能执行主库同步的binlog，导致`主从延迟`\n\n### 2.InnoDB是如何实现全局备份的\n\n**mysqldump**：官方自带的逻辑备份工具mysqldump，当mysqldump使用参数`--single-transaction`的时候，会启动一个事务，确保拿到`一致性视图`。而由于`MVCC`的支持，这个过程中数据是可以正常更新的。\n\n一致性读是好，但是前提是引擎要支持这个隔离级别。\n\n## 3.如果要全库只读，为什么不使用set global readonly=true的方式？\n\n1.在有些系统中，`readonly的值会被用来做其他逻辑`，比如判断主备库。所以修改global变量的方式影响太大。\n2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会`导致整个库长时间处于不可写状态，风险较高`。\n\n## 4.表锁简述\n\n**概述**：mysql里面表锁有两种：表锁和MDL(元数据锁)，表锁不建议加，MDL会默认加上；\n\n**表锁**：![\t](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210608082421097.png)\n\n**MDL**：不需要显式使用，在访问的时候会自动加上，MDL包含`读锁和写锁`，`读锁之间不互斥`，可多线程共享，`写锁互斥`，来保证表结构变更时的安全性。\n\n**风险**：MDL直到事务提交才会被释放，因此为了防止MDL存在时间过长，从而MYSQL异常重启，应该避免长事务。\n\n### 5.如何安全地小表加一个字段\n\n1. 查询长事务，暂停或kill掉长事务；\n2. 在alter table语句中指定等待时间，避免阻塞。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 六.行锁功过：怎么减少行锁对性能的影响\n\n### 1.行锁的概述\n\n行锁即是对数据库的`行记录加锁`，在引擎层实现，仅`InnoDB`支持行锁。\n\n### 2.简述两阶段锁协议\n\n**概念**：在InnoDB事务中，行锁是在需要的时候加上的，但需要等待`事务提交才会释放`；\n\n**建议**：`如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁往后放`。\n\n### 3.简述死锁\n\n**概念**：当两个线程都在等待对方锁持有的资源时，就会产生死锁；\n\n**预防死锁**：\n\n1. 设置`超时参数`，默认为50s，这样显然交互不好，但如果设置过小，又会错将正常等待的线程当做死锁处理，因此**不建议使用这种方案**；\n\n2. `死锁检测`，发现死锁，马上`回滚`。这里可以`类比spring中的循环依赖`，都是需要查看自己所依赖的线程有没有被别人锁住。但这种方案仍有隐患，假设有100个线程并发修改，`都去查看自己依赖的线程有没有锁住，就必然需要大量的CPU资源`，这也是为什么即便很小的并发量，CPU占用率也可能很高的原因。\n\n   > 怎样解决由这种热点行更新导致的性能问题？\n\n   - 在`确认不会发生死锁的情况下，可关闭死锁检测`，但问题在于关掉死锁检测可能导致大量的超时，这是业务有损的；\n   - 控制并发度，具体地说，是在数据库服务端实现该逻辑，实现方式自然是`特定大小的等待队列`；\n   - 从设计上看，可以考虑将一行改成逻辑上的多行。\n\n------\n\n> 日拱一卒，功不唐捐。\n\n## 番外\n\n### 1.mysql的服务器配置文件\n\n![image-20210607105513978](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607105513978.png)\n\n### 2.my.cnf/my.ini配置文件详解\n\nhttps://www.cnblogs.com/kuoAT/p/7080770.html\n\n### 3.mysql日志系统详解\n\nhttps://segmentfault.com/a/1190000023827696\n\n### 4.查看mysql下的几个日志\n\nhttps://blog.csdn.net/xuheng8600/article/details/79823875\n\n1. **慢查询日志**是记录了执行时间超过参数long_query_time(单位是秒)所设定值的SQL语句日志。\n\n   Note:慢查询日志对于我们发现性能有问题的SQL有很帮助，建议使用并经常分析；\n\n2. **查询日志**记录了clinet的所有的语句。\n\n   Note:由于log日志记录了数据库所有操作，对于访问频繁的系统，此种日志会造成性能影响，建议关闭。\n\n3. **错误日志**在Mysql数据库中很重要，它记录着mysqld启动和停止，以及服务器在运行过程中发生的任何错误的相关信息。\n\n4. **二进制日志**也通常被称为binlog,它记当着所有的DDL和DML，但不包括数据查询语句。\n\n## 面经集锦\n\n1. Explain的主要字段\n\n   ![image-20210613161115048](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613161115048.png)\n\n2. b+树相比B树的优点\n\n   ![image-20210613170513272](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613170513272.png)\n\n3. 可不可以切换索引为哈希索引？\n\n   ![image-20210613162722458](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613162722458.png)\n\n4. 场景题：高并发场景下数据库压力很大，怎么解决？\n\n   `使用索引，使用缓存，分库分表，消息队列`\n\n5. mysql分页查询优化\n\n   **一般查询会从第一条记录开始找起**\n\n   1. **子查询**：这种方式`先定位偏移位置的 id`，然后往后查询，这种方式适用于 id 递增的情况\n   2. **id限定**：可以使用 `id between and` 来查询\n\n   一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。\n\n6. mysql 联合索引使用 A>n and B=m 和 A=n and B=m 的区别\n\n   ![image-20210613165722760](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165722760.png)\n\n   ![image-20210613165652454](C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165652454.png)\n\n7. MySQL的InnoDB和MyISAM区别\n\n   | 角度         | InnoDB   | MyISAM     |\n   | ------------ | -------- | ---------- |\n   | 事务         | 支持     | 不支持     |\n   | 外键         | 支持     | 不支持     |\n   | 索引         | 聚集索引 | 非聚集索引 |\n   | 表的具体行数 | 不保存   | 保存       |\n   | 锁的粒度     | 行锁     | 表锁       |\n\n8. 索引如何优化\n\n   发现索引走的不好：**慢查询**\n\n   1. 利用`覆盖索引`来进行查询操作，避免回表；\n   2. `explain中的字段type`：至少要达到range级别，要求是ref级别，如果为**consts**最好不过。\n   3. `联合索引最左前缀原则`。\n   4. union，in,or都能够命中索引，建议使用`in`.\n\n9. 简述乐观锁与悲观锁\n\n   **乐观锁**：拿数据时不会上锁，但在提交的时候会判断数据有没有被更新，通常使用版本号/时间戳来实现。\n\n   **悲观锁**：一开始就对商品加上锁（SELECT ... `FOR UPDATE`）\n\n10. 索引一定会命中吗？如何保证命中\n\n    不一定会命中，使用explain中的ref字段判断，force index,强制走某个索引\n\n    ```mysql\n    SELECT * FROM test01 FORCE INDEX(uk_index) WHERE NAME = '测试1' AND age=1 ;\n    ```\n\n11. mysql数据库为什么要使用N叉树\n\n    一个页就是一棵树B+树的节点，数据库I/O操作的最小单位是页，与数据库相关的内容都会存储在页的结构里。\n\n    在一棵B+树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间\n\n    同一层的节点之间，通过页的结构构成了一个双向链表\n\n    非叶子节点包括了多个索引行，每个索引行里存储索引键和指向下一层页面的指针\n\n    叶子节点为，存储了关键字和行记录，在节点内部(也就是页结构的内部)记录之间是一个单向的链表\n\n    ![img](https://img-blog.csdnimg.cn/20200404223041152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70#pic_center)\n\n12. 说一下你的项目里具体的一个表，有没有建索引，如何建的？\n\n    shop表，主键shopId（主键本身就是一种特殊的索引）,外键userId,shopCategoryId\n\n    **shopId bigint not null auto_invreament primary key**\n\n    在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键，除非高并发写入操作可能需要衡量自增主键\n\n13. innodb 索引文件的存储形式\n\n    思路：一个表——》多个B+树——》叶子节点(页结构，即多个磁盘块)+非叶子结点(页结构，即多个磁盘块)——》行数据+索引数据\n\n14. mysql主键是怎么自增的（其实是说底层的Auto-INC锁）\n\n    **自增长计数器**,**Auto-INC锁**,表锁\n\n------\n\n> 山高路远，静水深流","slug":"Mysql数据库系列——持续更新中","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7lw001rxjccf0ki4mc8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有一段时间我很困惑，如何在有限的时间内展开繁杂的内容，最终在评论区找到了答案：</p>\n<blockquote>\n<p>将每一小节的内容提炼成问题，通过回答这些问题来掌握知识，详略分明且高效！</p>\n</blockquote>\n<h2 id=\"一-一条sql查询语句是如何执行的\"><a href=\"#一-一条sql查询语句是如何执行的\" class=\"headerlink\" title=\"一.一条sql查询语句是如何执行的\"></a>一.一条sql查询语句是如何执行的</h2><h3 id=\"1-mysql的框架有哪些基本组件，各是什么功能？\"><a href=\"#1-mysql的框架有哪些基本组件，各是什么功能？\" class=\"headerlink\" title=\"1.mysql的框架有哪些基本组件，各是什么功能？\"></a>1.mysql的框架有哪些基本组件，各是什么功能？</h3><p>所有的故事，都从一张图开始：</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604153409674.png\" alt=\"image-20210604153409674\"></p>\n<p>可以看到，mysql大致分为server层与存储引擎层：</p>\n<ul>\n<li><code>server层：</code>包含连接器，查询缓存，分析器，执行器等，涵盖了mysql的大多数的核心功能，以及所有的内置函数(日期，时间，数学，加密函数）,所有跨存储引擎的功能都在这一层实现，如存储过程，触发器，视图。</li>\n<li><code>存储引擎层：</code>它以插件式的架构方式负责数据的存储与提取，支持InnoDB,Memory,MyISAM等存储引擎，默认引擎是<strong>InnoDB</strong>.</li>\n<li>关系：<strong>所有存储引擎共用一个server层</strong>。</li>\n</ul>\n<h3 id=\"2-server层包含哪些组件？它们各是什么作用？\"><a href=\"#2-server层包含哪些组件？它们各是什么作用？\" class=\"headerlink\" title=\"2.server层包含哪些组件？它们各是什么作用？\"></a>2.server层包含哪些组件？它们各是什么作用？</h3><ol>\n<li><p><code>连接器</code>：连接器负责和mysql服务器端<strong>建立连接，获取权限，维持和管理连接</strong></p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604155808563.png\" alt=\"image-20210604155808563\"></p>\n<p>在连接建立后，如果没有使用，就会进入sleep状态。</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604160921192.png\" alt=\"image-20210604160921192\"></p>\n<p>如果客户端太久没动作（<strong>wait_timeout=8小时</strong>），连接器就会将其自动断开。</p>\n<p>当然，上面的情况是基于长连接的，而长连接正如我们在计网中了解的一样：<strong>如果客户端持续有请求，则使用同一个连接</strong>。长连接有效减少了频繁建立，销毁连接的成本，但也带来了一些问题：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> mysql在执行过程中临时使用的内存是管理在连接对象中的，如果连接长期存在，会导致MYsql占用内存过多，最终导致OOM</li>\n</ul>\n<p>而针对长连接占用内存过多的问题，通常有这样两种解决方式：</p>\n<ul>\n<li><strong>定期断开连接</strong></li>\n<li>MYSQL5.7以后，可以在每次执行比较大的操作后，执行<strong>mysql_reset_connection</strong>来重新初始化连接资源。</li>\n</ul>\n</li>\n<li><p><code>查询缓存</code>：</p>\n<p>首先要明确的是：不建议使用功能缓存，原因如下：</p>\n<p>我们在拿到一个查询请求后，首先会查询缓存，如果缓存中存在<strong>以键值对形式存在的记录</strong>，则直接从缓存中拿，也无须再执行后续环节，直接返回命中结果即可。如果缓存中不存在，则继续流程。</p>\n<p>但如果我们拿到的是一个更新请求呢？那查询缓存不仅没用，还需要清空缓存，也就是我们常说的<strong>缓存失效</strong>，在一个更新语句频繁的系统中，要查询缓存有何用？</p>\n<p>让人戏谑的是，在mysql8.0以后，查询缓存彻底成了过去式。</p>\n</li>\n<li><p><code>分析器</code>：</p>\n<ol>\n<li>词法分析：我们输入是由多个字符串和空格组成的一条sql语句，mysql需要识别里面的字符串分别是啥，如需要把字符串test识别为表test。</li>\n<li>语法分析：简言之，判断sql语句的语法是否正确。</li>\n</ol>\n</li>\n<li><p><code>优化器</code>：</p>\n<p>哪些方面有优化空间呢？<strong>join的连接顺序，索引</strong>，所以优化器会决定选择哪一个。</p>\n</li>\n<li><p><code>执行器</code>：</p>\n<p>在执行之前，首先查看是否具有执行权限，如果没有，返回错误。如果命中，则<strong>在查询缓存返回结果的时候做权限验证</strong>。</p>\n<p>如果有权限，则执行器调用引擎提供的接口，调用API，完成操作。</p>\n</li>\n</ol>\n<h3 id=\"3-存储引擎层有什么作用？\"><a href=\"#3-存储引擎层有什么作用？\" class=\"headerlink\" title=\"3.存储引擎层有什么作用？\"></a>3.存储引擎层有什么作用？</h3><p>留个坑</p>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"二-一条sql更新语句是如何执行的？\"><a href=\"#二-一条sql更新语句是如何执行的？\" class=\"headerlink\" title=\"二.一条sql更新语句是如何执行的？\"></a>二.一条sql更新语句是如何执行的？</h2><h3 id=\"1-redo-log的概念是什么？底层实现机制是怎样的？\"><a href=\"#1-redo-log的概念是什么？底层实现机制是怎样的？\" class=\"headerlink\" title=\"1.redo log的概念是什么？底层实现机制是怎样的？\"></a>1.redo log的概念是什么？底层实现机制是怎样的？</h3><p><code>redo-log</code>：即重做日志，它独属于InnoDB引擎，是一种物理日志，记录了在数据页上的操作，可以保证crash safe.</p>\n<p><code>原理</code>：假如在执行更新语句后，直接将更新写回磁盘，就会影响即时体验。所以我们需要借鉴这样的思想：</p>\n<blockquote>\n<p>《孔乙已》中的酒店掌柜不会直接将还账记录写到<strong>账本(磁盘)<strong>中，而会将</strong>还账(更新</strong>,即做了什么)记录在**粉板(redo-log)**上，在空闲时，在全部写入账本中。</p>\n</blockquote>\n<p><code>底层原理</code>：InnoDB的redo-log是固定大小的，如可以配置为一组4个文件，每个文件大小1GB，记录日志时使用<strong>循环队列</strong>的数据结构，当循环队列已满，会将最久的日志擦除(写入磁盘)，然后使用新的日志填充空间。</p>\n<p>redo-log并非直接持久化到磁盘，它会首先存储到<code>redo-log buffer</code>，接着存储到文件系统的<code>page cache</code>,最后才<code>持久化</code>到磁盘。</p>\n<h3 id=\"2-什么是WAL（write-ahead-logging）机制，好处是什么？\"><a href=\"#2-什么是WAL（write-ahead-logging）机制，好处是什么？\" class=\"headerlink\" title=\"2.什么是WAL（write ahead logging）机制，好处是什么？\"></a>2.什么是WAL（write ahead logging）机制，好处是什么？</h3><p>直白的说，就是<code>先写日志，再写入磁盘</code>，日志是被加载到内存中的，写入速度快，而写入磁盘是机械运动，写入速度非常慢。</p>\n<h3 id=\"3-redo-log是如何保证crash-safe的？\"><a href=\"#3-redo-log是如何保证crash-safe的？\" class=\"headerlink\" title=\"3.redo log是如何保证crash-safe的？\"></a>3.redo log是如何保证crash-safe的？</h3><p>所谓crash，指的<code>是数据库异常重启</code>的场景，显然，如果不使用redo-log机制，此时仅有负责归档(用于备份)的bin-log，数据的更新不会被刷新到磁盘中去。</p>\n<p>而redo-log机制负责物理更新刷新到磁盘中去，<code>不会出现物理与逻辑数据不一致</code>的状况。</p>\n<h3 id=\"4-binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\"><a href=\"#4-binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\" class=\"headerlink\" title=\"4.binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\"></a>4.binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？</h3><p><code>bin-log</code>:即归档日志，由server层实现，记录数据库的逻辑操作，用于全量备份。当需要恢复数据时，可以取出某个时间段内的bin-log进行重放恢复。</p>\n<p><code>底层原理</code>：bin-log区别于redo-log，它没有文件大小的限制，会追加写；</p>\n<p>每个线程都有自己的binlog cache,但是会共用一份binlog文件。</p>\n<p>持久化到磁盘分为两个阶段：首先将日志写到文件系统的<strong>page cache</strong>,此时并没有持久化到磁盘，所以速度比较快；接着<strong>fsync</strong>,即是将数据持久化到磁盘，一般认为只有fsync才占磁盘的<strong>IOPS</strong>。</p>\n<p><code>crash-safe</code>:crash要解决的问题是逻辑数据与物理数据不一致的问题，也就是保证将内存中物理数据刷新到内存，但bin-log表示我做不到~</p>\n<h3 id=\"5-对比redo-log和bin-log\"><a href=\"#5-对比redo-log和bin-log\" class=\"headerlink\" title=\"5.对比redo-log和bin-log.\"></a>5.对比redo-log和bin-log.</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>redo-log</th>\n<th>bin-log</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文件大小</td>\n<td>覆盖写</td>\n<td>追加写</td>\n</tr>\n<tr>\n<td>层级</td>\n<td>server层</td>\n<td>InnoDB引擎</td>\n</tr>\n<tr>\n<td>日志形式</td>\n<td>物理日志</td>\n<td>逻辑日志</td>\n</tr>\n<tr>\n<td>作用</td>\n<td>刷新到磁盘，物理一致性</td>\n<td>归档，逻辑一致性</td>\n</tr>\n<tr>\n<td>crash-safe</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>实质</td>\n<td>记录数据页做了什么操作</td>\n<td>statment模式：记录sql语句    row模式：记录更新前后的行，一般使用row模式</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-一条sql更新语句是如何执行的？\"><a href=\"#6-一条sql更新语句是如何执行的？\" class=\"headerlink\" title=\"6.一条sql更新语句是如何执行的？\"></a>6.一条sql更新语句是如何执行的？</h3><blockquote>\n<p>update test set c=c+1 where id = 1</p>\n</blockquote>\n<ol>\n<li>执行器先找引擎找ID=1的这一行，ID为主键，引擎使用B+树的主键索引找到这一行。如果该行在内存中，直接返回给执行器；否则，先从磁盘读取到内存中，再返回；</li>\n<li>执行器执行得到新数据，调用引擎接口写入新的行记录；</li>\n<li>引擎将这行记录更新到内存中，并将更新的操作记录写到redo-log中，redo-log进行prepare状态；</li>\n<li>执行器生成bin-log，将bin-log写入磁盘；</li>\n<li>redo-log改为commit状态，更新完成。</li>\n</ol>\n<h3 id=\"7-如果数据库误操作，如何将数据恢复？\"><a href=\"#7-如果数据库误操作，如何将数据恢复？\" class=\"headerlink\" title=\"7.如果数据库误操作，如何将数据恢复？\"></a>7.如果数据库误操作，如何将数据恢复？</h3><p>找到最近一次的全量备份，<code>从备份时间点开始</code>，将备份的bin-log依次取出，重放到误删时刻。</p>\n<h3 id=\"8-什么是两阶段提交-如果不两阶段提交，会发生什么？\"><a href=\"#8-什么是两阶段提交-如果不两阶段提交，会发生什么？\" class=\"headerlink\" title=\"8.什么是两阶段提交?如果不两阶段提交，会发生什么？\"></a>8.什么是两阶段提交?如果不两阶段提交，会发生什么？</h3><p>即确定redo-log与bin-log提交时机，通过<code>两阶段提交来保证跨系统维持数据逻辑一致性</code>。如果没有两阶段提交，就好比读到了事务的脏数据。</p>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"三-事务隔离：为什么你改了我还看不见\"><a href=\"#三-事务隔离：为什么你改了我还看不见\" class=\"headerlink\" title=\"三.事务隔离：为什么你改了我还看不见\"></a>三.事务隔离：为什么你改了我还看不见</h2><h3 id=\"1-事务的概念是什么？\"><a href=\"#1-事务的概念是什么？\" class=\"headerlink\" title=\"1.事务的概念是什么？\"></a>1.事务的概念是什么？</h3><blockquote>\n<p>事务是对数据库中数据操作的<code>保证数据逻辑一致性的最小操作单元</code>。</p>\n</blockquote>\n<h3 id=\"2-简述某一场景下，不同事务隔离级别的区别\"><a href=\"#2-简述某一场景下，不同事务隔离级别的区别\" class=\"headerlink\" title=\"2.简述某一场景下，不同事务隔离级别的区别\"></a>2.简述某一场景下，不同事务隔离级别的区别</h3><p>有这样的一个场景：</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606161322663.png\" alt=\"image-20210606161322663\"></p>\n<p>在该场景下，不同事务隔离级别有不同的返回值：</p>\n<ul>\n<li><p><code>读未提交</code>：即在事务B没有提交的时候，它做的变更就可以被事务A看到。所以读到的值分别是1,2,2；</p>\n</li>\n<li><p><code>读已提交</code>：即只有在事务A提交之后，它做的变更才能被事务A看到，所以读到的值为：1,1,2；</p>\n</li>\n<li><p><code>可重复读</code>：即事务A执行期间读到的值和事务A开启时读到的值是一样的，所以读到的值是1,1,2；</p>\n</li>\n<li><p><code>串行化</code>：即事务A，事务B对于同一行记录，会通过加读写锁的方式来限制另一个事务。所以读到的值是1,1,2.</p>\n</li>\n</ul>\n<h3 id=\"3-读已提交，可重复读是怎样通过视图构建实现的？\"><a href=\"#3-读已提交，可重复读是怎样通过视图构建实现的？\" class=\"headerlink\" title=\"3.读已提交，可重复读是怎样通过视图构建实现的？\"></a>3.读已提交，可重复读是怎样通过视图构建实现的？</h3><p>首先了解下视图的概念：</p>\n<blockquote>\n<p>视图是对复杂sql语句的封装，可以认为是拷贝静态数据，对视图做的变更不会同步到数据库中。</p>\n</blockquote>\n<ul>\n<li><p><code>可重复读</code>：在该隔离级别下，数据库在事务启动时创建了一个视图，访问时以视图的逻辑结果为准，在<strong>事务存在期间</strong>都会使用这个视图。他为mysql的默认隔离级别；</p>\n</li>\n<li><p><code>读未提交</code>：直接返回记录最新值，没有视图概念；</p>\n</li>\n<li><p><code>读已提交</code>：视图在<strong>sql语句开始执行时</strong>创建。它为oracle的默认隔离级别。</p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\">  注:配置方式：transaction-isolation=READ-COMMITED</p>\n</li>\n</ul>\n<h3 id=\"4-简要说明可重复读的使用场景\"><a href=\"#4-简要说明可重复读的使用场景\" class=\"headerlink\" title=\"4.简要说明可重复读的使用场景\"></a>4.简要说明可重复读的使用场景</h3><p>在记账的时候很有用。</p>\n<h3 id=\"5-事务隔离是怎样通过read-view实现的\"><a href=\"#5-事务隔离是怎样通过read-view实现的\" class=\"headerlink\" title=\"5.事务隔离是怎样通过read-view实现的?\"></a>5.事务隔离是怎样通过read-view实现的?</h3><p>之前我们提到，在事务隔离中，提供了<code>视图这种数据拷贝</code>的方式，而在事务隔离级别下，我们会读到不同的数据，这说明是存在多个视图的，也就是read-view。</p>\n<p>在MYSQL中，实际上每条记录在更新时都会记录一条<code>回滚操作</code>，通过回滚操作，可以得到上一个状态的值：</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606163851669.png\" alt=\"image-20210606163851669\"></p>\n<p>也就是说，<code>同一个记录在数据库中是存在多个版本的</code>，当我们要读取数据时，要判断这个数据的版本对于当前事务是否可见，如果不可见，就通过<code>undo-log</code>计算得到上一个版本，直到找到正确版本为止。</p>\n<p>在不需要的时候，数据库系统会将回滚日志删除。</p>\n<h3 id=\"6-并发版本控制的概念是什么？如何实现？\"><a href=\"#6-并发版本控制的概念是什么？如何实现？\" class=\"headerlink\" title=\"6.并发版本控制的概念是什么？如何实现？\"></a>6.并发版本控制的概念是什么？如何实现？</h3><p><code>概念</code>：同一个数据行，在数据库中存在<code>多个版本号</code>，这个版本号可以理解为当前操作这行数据的<code>事务的ID</code>。</p>\n<p><code>实现</code>：在进行并发操作时，会使用<code>该行的版本号与当前事务的版本号</code>进行比较，如果刚好等于，也就是说这行数据是由这个事务提交生成的。</p>\n<h3 id=\"7-长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\"><a href=\"#7-长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\" class=\"headerlink\" title=\"7.长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\"></a>7.长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？</h3><p><code>概念</code>：需要执行很久的事务；</p>\n<p><code>底层</code>：长事务意味着系统中有非常多的不能被删除的事务视图，这会导致大量的<code>空间占用</code>，而在mysql5.5之前，即便长事务被提交，<code>回滚段被清理，文件也不会变小</code>，另外长事务还<code>占用锁资源</code>，这时其他就会因锁等待重新建立连接，<code>mysql的连接被占用爆满</code>，导致拖垮整个库。</p>\n<p><code>查询</code>：SELECT * FROM information_schema.INNODB_TRX</p>\n<p><code>避免</code>：</p>\n<ol>\n<li>设置autocommmit=1,即自动提交；</li>\n<li>写脚本监控information_schema.INNODB_TRX的内容，发现长事务就kill掉它；</li>\n<li>设置SQL语句所能执行的最大运行时间；</li>\n<li>设置回滚表单独存放，便于回收表空间。</li>\n<li>尽量去使用小事务。</li>\n</ol>\n<h3 id=\"8-事务的启动方式有哪几种？\"><a href=\"#8-事务的启动方式有哪几种？\" class=\"headerlink\" title=\"8.事务的启动方式有哪几种？\"></a>8.事务的启动方式有哪几种？</h3><ul>\n<li><code>begin:</code></li>\n<li><code>start trasaction:</code>与begin效果一致；</li>\n<li><code>start trasaction with consistent snaps hot:</code>该语句执行后，会创建一致性视图，分配事务ID。</li>\n</ul>\n<h3 id=\"9-commit-work-and-chain的语法有什么作用？\"><a href=\"#9-commit-work-and-chain的语法有什么作用？\" class=\"headerlink\" title=\"9.commit work and chain的语法有什么作用？\"></a>9.commit work and chain的语法有什么作用？</h3><p>提交当前事务+开启下一个事务=begin+commit;</p>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"四-深入浅出索引上\"><a href=\"#四-深入浅出索引上\" class=\"headerlink\" title=\"四.深入浅出索引上\"></a>四.深入浅出索引上</h2><h3 id=\"1-索引的概念是什么？\"><a href=\"#1-索引的概念是什么？\" class=\"headerlink\" title=\"1.索引的概念是什么？\"></a>1.索引的概念是什么？</h3><p><strong>概念</strong>：索引是一个相对抽象的数据结构，在书中，我们通常抽取<code>目录名与对应的页码号作为目录以快速定位数据</code>，在数据库系统中，索引就是以这样的作用存在的，它是数据库管理系统中一个<code>排序</code>的数据结构)，以<code>协助快速查询</code>、更新数据库表中数据。</p>\n<p><strong>类比</strong>：操作系统中使用<strong>inode</strong>来唯一标识文件，在inode中，记录了各个<code>文件分别包含哪些磁盘块</code>，给定inode,就可以找到文件的所有块，在inode中，同样存储了文件属性的磁盘地址。</p>\n<h3 id=\"2-简述索引模型之哈希表\"><a href=\"#2-简述索引模型之哈希表\" class=\"headerlink\" title=\"2.简述索引模型之哈希表\"></a>2.简述索引模型之哈希表</h3><p><strong>概述</strong>：哈希表是一种以<code>键值对</code>存储数据的结构，我们只需要输入待查找的key，就可以找到对应的value,哈希表的思路很简单，把值放在数组中，用一个<code>哈希函数把key换算成一个确定的位置</code>，然后将value放在数组的这个位置。</p>\n<p><strong>哈希冲突</strong>：使用链表法解决；</p>\n<p><strong>示例</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202153949.png\" alt=\"image-20210607202153949\"></p>\n<p><strong>特点</strong>：只适用于<code>等值查询</code>，可以应用于NoSQL不能做<code>区间查询</code>。</p>\n<h3 id=\"3-简述索引模型之有序数组\"><a href=\"#3-简述索引模型之有序数组\" class=\"headerlink\" title=\"3.简述索引模型之有序数组\"></a>3.简述索引模型之有序数组</h3><p><strong>概述</strong>：将元素按照一定的顺序排列，这里的顺序<code>不一定是严格自增</code>，而是按照某一属性从小到大排序。假如有一个按照身份证号排列的有序数组，我们要查询某一个身份证号的名字，通过<code>二分法</code>就可以找到。</p>\n<p><strong>示例</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202732018.png\" alt=\"image-20210607202732018\"></p>\n<p><strong>特点</strong>：对于<code>等值查找</code>和<code>范围查找</code>都较友好，查询的时间复杂度为<code>O(logN)</code>,但实际上有序数组并没有得到大量应用，这是因为在插入元素时需要大量的<code>数据搬移</code>，也因此有序数组被大量应用于<code>静态存储引擎</code>。</p>\n<h3 id=\"4-简述索引模型之B-树\"><a href=\"#4-简述索引模型之B-树\" class=\"headerlink\" title=\"4.简述索引模型之B+树\"></a>4.简述索引模型之B+树</h3><p><strong>概述</strong>：B+树是一种二叉搜索树，它的节点遵循严格的大小关系，<code>二叉搜索树的查询，更新的时间复杂度为O(logN)</code>,</p>\n<p><strong>示例</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607203522696.png\" alt=\"image-20210607203522696\"></p>\n<p><strong>特点</strong>：<code>B+树</code>即为InnoDB的引擎模型，但考虑到性能，更多被使用的实则是<code>多叉树</code>。</p>\n<h3 id=\"5-为什么N叉树被广泛应用到数据库引擎中？\"><a href=\"#5-为什么N叉树被广泛应用到数据库引擎中？\" class=\"headerlink\" title=\"5.为什么N叉树被广泛应用到数据库引擎中？\"></a>5.为什么N叉树被广泛应用到数据库引擎中？</h3><p>我们先设想二叉树存储的场景：假如二叉树<code>树高20</code>，存储了100万行数据，<code>需要读取20个数据块(连续的存储空间)</code>，在机械硬盘时代，读取硬盘是龟速，而这样的龟速，居然要连续查询20次，那怎么提高查询的性能呢？</p>\n<p>减少树高，增加一个数据块中的数据，即<code>使用N叉树</code>。</p>\n<h3 id=\"6-基于主键索引和普通索引的查询有什么区别？\"><a href=\"#6-基于主键索引和普通索引的查询有什么区别？\" class=\"headerlink\" title=\"6.基于主键索引和普通索引的查询有什么区别？\"></a>6.基于主键索引和普通索引的查询有什么区别？</h3><p><strong>前提</strong>：在InnoDB中，<code>表是根据主键顺序以索引的形式存放</code>，这种存储方式被称为索引组织表。又因为索引是B+树的数据结构，即数据存储在B+树中，而<code>每一个索引在InnoDB里面对应一张表</code>。再进一步，则可以认为表是以多个B+树的形式存储的。</p>\n<p><strong>主键索引</strong>：主键索引的叶子结点存储的是<code>整行数据</code>，也因此得名聚簇索引。</p>\n<p><strong>普通索引</strong>：非主键索引的叶子结点存储的是<code>主键的值</code>，因此得名二级索引。</p>\n<p><strong>区别</strong>：如果where条件需要走主键索引，则只需要搜索主键的B+树，如果where条件走的是普通索引，则就需要先查询普通索引的B+树，得到主键，再去查询普通索引，即<code>回表</code></p>\n<h3 id=\"7-简述维护B-树索引时的页分裂与页合并？\"><a href=\"#7-简述维护B-树索引时的页分裂与页合并？\" class=\"headerlink\" title=\"7.简述维护B+树索引时的页分裂与页合并？\"></a>7.简述维护B+树索引时的页分裂与页合并？</h3><ul>\n<li><strong>页分裂</strong>：在插入数据时，如果当前数据页已满，就会申请一个新的数据页，导致<code>空间利用率下降</code>；</li>\n<li><strong>页合并</strong>：如果因为删除数据，导致<code>利用率变低</code>，则页合并就成了可选的优化方式。</li>\n</ul>\n<h3 id=\"8-哪些场景下应该使用自增主键，而哪些场景不应该\"><a href=\"#8-哪些场景下应该使用自增主键，而哪些场景不应该\" class=\"headerlink\" title=\"8.哪些场景下应该使用自增主键，而哪些场景不应该\"></a>8.哪些场景下应该使用自增主键，而哪些场景不应该</h3><p><code>自增主键适合递增插入</code>的场景，这样追加数据时，就不需要数据搬移咯。所以<strong>大多数的场景下，我们都会使用自增主键</strong>。</p>\n<p>而在有业务逻辑的字段做主键时，数据成本就会变高啦。</p>\n<p>如果在<code>典型的KV场景下，就需要使用普通索引</code>。</p>\n<h3 id=\"9-删除主键索引与普通索引有什么影响？\"><a href=\"#9-删除主键索引与普通索引有什么影响？\" class=\"headerlink\" title=\"9.删除主键索引与普通索引有什么影响？\"></a>9.删除主键索引与普通索引有什么影响？</h3><p>删除，重建主键索引后，需要同时<code>修改普通索引对应的主键索引</code>，而删除，重建普通索引则让人省心不少。</p>\n<h3 id=\"10-索引的优化\"><a href=\"#10-索引的优化\" class=\"headerlink\" title=\"10.索引的优化\"></a>10.索引的优化</h3><ol>\n<li><strong>覆盖索引：</strong>如果查询条件使用的是普通索引，或者联合索引的最左原则字段，查询结果是联合索引的字段或者主键，<code>不用回表操作，直接返回结果</code>，减少磁盘读写的次数，提高IO性能。</li>\n<li><strong>最左前缀：</strong>联合索引的<code>最左N个字段</code>，也可以是字符串索引的前M个字符；</li>\n<li><strong>联合索引：</strong>根据创建<code>联合索引</code>的顺序，<code>以最左原则进行where检索</code>，比如(age,name)以age=1或者age=1 and name=’张三’可以使用索引，单以name=”张三”不会使用索引。考虑到存储空间的问题，还需要根据业务需求，将查找频繁的数据进行靠左创建索引。</li>\n<li><strong>索引下推：</strong>like “hello%” and age&gt;10检索，在mysql5.6之前，会对匹配的数据进行会回表查询，5.6版本以后，<code>会先过滤不合法的数据，再对合法的数据进行回表</code>，从而降低回表率，提升检索率。</li>\n</ol>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"五-全局锁和表锁：给表加个字段怎么有那么多阻碍\"><a href=\"#五-全局锁和表锁：给表加个字段怎么有那么多阻碍\" class=\"headerlink\" title=\"五.全局锁和表锁：给表加个字段怎么有那么多阻碍\"></a>五.全局锁和表锁：给表加个字段怎么有那么多阻碍</h2><h3 id=\"1-简述全局锁锁\"><a href=\"#1-简述全局锁锁\" class=\"headerlink\" title=\"1.简述全局锁锁\"></a>1.简述全局锁锁</h3><p><strong>概述</strong>：对整个数据库实例加锁。<br><strong>加锁方式</strong>：<code>Flush tables with read lock(FTWRL)</code>，这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会<code>被阻塞</code>。<br><strong>使用场景</strong>：全库逻辑备份。<br><strong>风险</strong>：<br>    1.如果在<code>主库备份</code>，在备份期间不能更新，<code>业务停摆</code><br>    2.如果在<code>从库备份</code>，备份期间不能执行主库同步的binlog，导致<code>主从延迟</code></p>\n<h3 id=\"2-InnoDB是如何实现全局备份的\"><a href=\"#2-InnoDB是如何实现全局备份的\" class=\"headerlink\" title=\"2.InnoDB是如何实现全局备份的\"></a>2.InnoDB是如何实现全局备份的</h3><p><strong>mysqldump</strong>：官方自带的逻辑备份工具mysqldump，当mysqldump使用参数<code>--single-transaction</code>的时候，会启动一个事务，确保拿到<code>一致性视图</code>。而由于<code>MVCC</code>的支持，这个过程中数据是可以正常更新的。</p>\n<p>一致性读是好，但是前提是引擎要支持这个隔离级别。</p>\n<h2 id=\"3-如果要全库只读，为什么不使用set-global-readonly-true的方式？\"><a href=\"#3-如果要全库只读，为什么不使用set-global-readonly-true的方式？\" class=\"headerlink\" title=\"3.如果要全库只读，为什么不使用set global readonly=true的方式？\"></a>3.如果要全库只读，为什么不使用set global readonly=true的方式？</h2><p>1.在有些系统中，<code>readonly的值会被用来做其他逻辑</code>，比如判断主备库。所以修改global变量的方式影响太大。<br>2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会<code>导致整个库长时间处于不可写状态，风险较高</code>。</p>\n<h2 id=\"4-表锁简述\"><a href=\"#4-表锁简述\" class=\"headerlink\" title=\"4.表锁简述\"></a>4.表锁简述</h2><p><strong>概述</strong>：mysql里面表锁有两种：表锁和MDL(元数据锁)，表锁不建议加，MDL会默认加上；</p>\n<p><strong>表锁</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210608082421097.png\" alt=\"    \"></p>\n<p><strong>MDL</strong>：不需要显式使用，在访问的时候会自动加上，MDL包含<code>读锁和写锁</code>，<code>读锁之间不互斥</code>，可多线程共享，<code>写锁互斥</code>，来保证表结构变更时的安全性。</p>\n<p><strong>风险</strong>：MDL直到事务提交才会被释放，因此为了防止MDL存在时间过长，从而MYSQL异常重启，应该避免长事务。</p>\n<h3 id=\"5-如何安全地小表加一个字段\"><a href=\"#5-如何安全地小表加一个字段\" class=\"headerlink\" title=\"5.如何安全地小表加一个字段\"></a>5.如何安全地小表加一个字段</h3><ol>\n<li>查询长事务，暂停或kill掉长事务；</li>\n<li>在alter table语句中指定等待时间，避免阻塞。</li>\n</ol>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"六-行锁功过：怎么减少行锁对性能的影响\"><a href=\"#六-行锁功过：怎么减少行锁对性能的影响\" class=\"headerlink\" title=\"六.行锁功过：怎么减少行锁对性能的影响\"></a>六.行锁功过：怎么减少行锁对性能的影响</h2><h3 id=\"1-行锁的概述\"><a href=\"#1-行锁的概述\" class=\"headerlink\" title=\"1.行锁的概述\"></a>1.行锁的概述</h3><p>行锁即是对数据库的<code>行记录加锁</code>，在引擎层实现，仅<code>InnoDB</code>支持行锁。</p>\n<h3 id=\"2-简述两阶段锁协议\"><a href=\"#2-简述两阶段锁协议\" class=\"headerlink\" title=\"2.简述两阶段锁协议\"></a>2.简述两阶段锁协议</h3><p><strong>概念</strong>：在InnoDB事务中，行锁是在需要的时候加上的，但需要等待<code>事务提交才会释放</code>；</p>\n<p><strong>建议</strong>：<code>如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁往后放</code>。</p>\n<h3 id=\"3-简述死锁\"><a href=\"#3-简述死锁\" class=\"headerlink\" title=\"3.简述死锁\"></a>3.简述死锁</h3><p><strong>概念</strong>：当两个线程都在等待对方锁持有的资源时，就会产生死锁；</p>\n<p><strong>预防死锁</strong>：</p>\n<ol>\n<li><p>设置<code>超时参数</code>，默认为50s，这样显然交互不好，但如果设置过小，又会错将正常等待的线程当做死锁处理，因此<strong>不建议使用这种方案</strong>；</p>\n</li>\n<li><p><code>死锁检测</code>，发现死锁，马上<code>回滚</code>。这里可以<code>类比spring中的循环依赖</code>，都是需要查看自己所依赖的线程有没有被别人锁住。但这种方案仍有隐患，假设有100个线程并发修改，<code>都去查看自己依赖的线程有没有锁住，就必然需要大量的CPU资源</code>，这也是为什么即便很小的并发量，CPU占用率也可能很高的原因。</p>\n<blockquote>\n<p>怎样解决由这种热点行更新导致的性能问题？</p>\n</blockquote>\n<ul>\n<li>在<code>确认不会发生死锁的情况下，可关闭死锁检测</code>，但问题在于关掉死锁检测可能导致大量的超时，这是业务有损的；</li>\n<li>控制并发度，具体地说，是在数据库服务端实现该逻辑，实现方式自然是<code>特定大小的等待队列</code>；</li>\n<li>从设计上看，可以考虑将一行改成逻辑上的多行。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<h2 id=\"番外\"><a href=\"#番外\" class=\"headerlink\" title=\"番外\"></a>番外</h2><h3 id=\"1-mysql的服务器配置文件\"><a href=\"#1-mysql的服务器配置文件\" class=\"headerlink\" title=\"1.mysql的服务器配置文件\"></a>1.mysql的服务器配置文件</h3><p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607105513978.png\" alt=\"image-20210607105513978\"></p>\n<h3 id=\"2-my-cnf-my-ini配置文件详解\"><a href=\"#2-my-cnf-my-ini配置文件详解\" class=\"headerlink\" title=\"2.my.cnf/my.ini配置文件详解\"></a>2.my.cnf/my.ini配置文件详解</h3><p><a href=\"https://www.cnblogs.com/kuoAT/p/7080770.html\">https://www.cnblogs.com/kuoAT/p/7080770.html</a></p>\n<h3 id=\"3-mysql日志系统详解\"><a href=\"#3-mysql日志系统详解\" class=\"headerlink\" title=\"3.mysql日志系统详解\"></a>3.mysql日志系统详解</h3><p><a href=\"https://segmentfault.com/a/1190000023827696\">https://segmentfault.com/a/1190000023827696</a></p>\n<h3 id=\"4-查看mysql下的几个日志\"><a href=\"#4-查看mysql下的几个日志\" class=\"headerlink\" title=\"4.查看mysql下的几个日志\"></a>4.查看mysql下的几个日志</h3><p><a href=\"https://blog.csdn.net/xuheng8600/article/details/79823875\">https://blog.csdn.net/xuheng8600/article/details/79823875</a></p>\n<ol>\n<li><p><strong>慢查询日志</strong>是记录了执行时间超过参数long_query_time(单位是秒)所设定值的SQL语句日志。</p>\n<p>Note:慢查询日志对于我们发现性能有问题的SQL有很帮助，建议使用并经常分析；</p>\n</li>\n<li><p><strong>查询日志</strong>记录了clinet的所有的语句。</p>\n<p>Note:由于log日志记录了数据库所有操作，对于访问频繁的系统，此种日志会造成性能影响，建议关闭。</p>\n</li>\n<li><p><strong>错误日志</strong>在Mysql数据库中很重要，它记录着mysqld启动和停止，以及服务器在运行过程中发生的任何错误的相关信息。</p>\n</li>\n<li><p><strong>二进制日志</strong>也通常被称为binlog,它记当着所有的DDL和DML，但不包括数据查询语句。</p>\n</li>\n</ol>\n<h2 id=\"面经集锦\"><a href=\"#面经集锦\" class=\"headerlink\" title=\"面经集锦\"></a>面经集锦</h2><ol>\n<li><p>Explain的主要字段</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613161115048.png\" alt=\"image-20210613161115048\"></p>\n</li>\n<li><p>b+树相比B树的优点</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613170513272.png\" alt=\"image-20210613170513272\"></p>\n</li>\n<li><p>可不可以切换索引为哈希索引？</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613162722458.png\" alt=\"image-20210613162722458\"></p>\n</li>\n<li><p>场景题：高并发场景下数据库压力很大，怎么解决？</p>\n<p><code>使用索引，使用缓存，分库分表，消息队列</code></p>\n</li>\n<li><p>mysql分页查询优化</p>\n<p><strong>一般查询会从第一条记录开始找起</strong></p>\n<ol>\n<li><strong>子查询</strong>：这种方式<code>先定位偏移位置的 id</code>，然后往后查询，这种方式适用于 id 递增的情况</li>\n<li><strong>id限定</strong>：可以使用 <code>id between and</code> 来查询</li>\n</ol>\n<p>一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。</p>\n</li>\n<li><p>mysql 联合索引使用 A&gt;n and B=m 和 A=n and B=m 的区别</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165722760.png\" alt=\"image-20210613165722760\"></p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165652454.png\" alt=\"image-20210613165652454\"></p>\n</li>\n<li><p>MySQL的InnoDB和MyISAM区别</p>\n<table>\n<thead>\n<tr>\n<th>角度</th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>事务</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>外键</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>索引</td>\n<td>聚集索引</td>\n<td>非聚集索引</td>\n</tr>\n<tr>\n<td>表的具体行数</td>\n<td>不保存</td>\n<td>保存</td>\n</tr>\n<tr>\n<td>锁的粒度</td>\n<td>行锁</td>\n<td>表锁</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>索引如何优化</p>\n<p>发现索引走的不好：<strong>慢查询</strong></p>\n<ol>\n<li>利用<code>覆盖索引</code>来进行查询操作，避免回表；</li>\n<li><code>explain中的字段type</code>：至少要达到range级别，要求是ref级别，如果为<strong>consts</strong>最好不过。</li>\n<li><code>联合索引最左前缀原则</code>。</li>\n<li>union，in,or都能够命中索引，建议使用<code>in</code>.</li>\n</ol>\n</li>\n<li><p>简述乐观锁与悲观锁</p>\n<p><strong>乐观锁</strong>：拿数据时不会上锁，但在提交的时候会判断数据有没有被更新，通常使用版本号/时间戳来实现。</p>\n<p><strong>悲观锁</strong>：一开始就对商品加上锁（SELECT … <code>FOR UPDATE</code>）</p>\n</li>\n<li><p>索引一定会命中吗？如何保证命中</p>\n<p>不一定会命中，使用explain中的ref字段判断，force index,强制走某个索引</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT * FROM test01 FORCE INDEX(uk_index) WHERE NAME &#x3D; &#39;测试1&#39; AND age&#x3D;1 ;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>mysql数据库为什么要使用N叉树</p>\n<p>一个页就是一棵树B+树的节点，数据库I/O操作的最小单位是页，与数据库相关的内容都会存储在页的结构里。</p>\n<p>在一棵B+树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间</p>\n<p>同一层的节点之间，通过页的结构构成了一个双向链表</p>\n<p>非叶子节点包括了多个索引行，每个索引行里存储索引键和指向下一层页面的指针</p>\n<p>叶子节点为，存储了关键字和行记录，在节点内部(也就是页结构的内部)记录之间是一个单向的链表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200404223041152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"img\"></p>\n</li>\n<li><p>说一下你的项目里具体的一个表，有没有建索引，如何建的？</p>\n<p>shop表，主键shopId（主键本身就是一种特殊的索引）,外键userId,shopCategoryId</p>\n<p><strong>shopId bigint not null auto_invreament primary key</strong></p>\n<p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键，除非高并发写入操作可能需要衡量自增主键</p>\n</li>\n<li><p>innodb 索引文件的存储形式</p>\n<p>思路：一个表——》多个B+树——》叶子节点(页结构，即多个磁盘块)+非叶子结点(页结构，即多个磁盘块)——》行数据+索引数据</p>\n</li>\n<li><p>mysql主键是怎么自增的（其实是说底层的Auto-INC锁）</p>\n<p><strong>自增长计数器</strong>,<strong>Auto-INC锁</strong>,表锁</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有一段时间我很困惑，如何在有限的时间内展开繁杂的内容，最终在评论区找到了答案：</p>\n<blockquote>\n<p>将每一小节的内容提炼成问题，通过回答这些问题来掌握知识，详略分明且高效！</p>\n</blockquote>\n<h2 id=\"一-一条sql查询语句是如何执行的\"><a href=\"#一-一条sql查询语句是如何执行的\" class=\"headerlink\" title=\"一.一条sql查询语句是如何执行的\"></a>一.一条sql查询语句是如何执行的</h2><h3 id=\"1-mysql的框架有哪些基本组件，各是什么功能？\"><a href=\"#1-mysql的框架有哪些基本组件，各是什么功能？\" class=\"headerlink\" title=\"1.mysql的框架有哪些基本组件，各是什么功能？\"></a>1.mysql的框架有哪些基本组件，各是什么功能？</h3><p>所有的故事，都从一张图开始：</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604153409674.png\" alt=\"image-20210604153409674\"></p>\n<p>可以看到，mysql大致分为server层与存储引擎层：</p>\n<ul>\n<li><code>server层：</code>包含连接器，查询缓存，分析器，执行器等，涵盖了mysql的大多数的核心功能，以及所有的内置函数(日期，时间，数学，加密函数）,所有跨存储引擎的功能都在这一层实现，如存储过程，触发器，视图。</li>\n<li><code>存储引擎层：</code>它以插件式的架构方式负责数据的存储与提取，支持InnoDB,Memory,MyISAM等存储引擎，默认引擎是<strong>InnoDB</strong>.</li>\n<li>关系：<strong>所有存储引擎共用一个server层</strong>。</li>\n</ul>\n<h3 id=\"2-server层包含哪些组件？它们各是什么作用？\"><a href=\"#2-server层包含哪些组件？它们各是什么作用？\" class=\"headerlink\" title=\"2.server层包含哪些组件？它们各是什么作用？\"></a>2.server层包含哪些组件？它们各是什么作用？</h3><ol>\n<li><p><code>连接器</code>：连接器负责和mysql服务器端<strong>建立连接，获取权限，维持和管理连接</strong></p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604155808563.png\" alt=\"image-20210604155808563\"></p>\n<p>在连接建立后，如果没有使用，就会进入sleep状态。</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210604160921192.png\" alt=\"image-20210604160921192\"></p>\n<p>如果客户端太久没动作（<strong>wait_timeout=8小时</strong>），连接器就会将其自动断开。</p>\n<p>当然，上面的情况是基于长连接的，而长连接正如我们在计网中了解的一样：<strong>如果客户端持续有请求，则使用同一个连接</strong>。长连接有效减少了频繁建立，销毁连接的成本，但也带来了一些问题：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> mysql在执行过程中临时使用的内存是管理在连接对象中的，如果连接长期存在，会导致MYsql占用内存过多，最终导致OOM</li>\n</ul>\n<p>而针对长连接占用内存过多的问题，通常有这样两种解决方式：</p>\n<ul>\n<li><strong>定期断开连接</strong></li>\n<li>MYSQL5.7以后，可以在每次执行比较大的操作后，执行<strong>mysql_reset_connection</strong>来重新初始化连接资源。</li>\n</ul>\n</li>\n<li><p><code>查询缓存</code>：</p>\n<p>首先要明确的是：不建议使用功能缓存，原因如下：</p>\n<p>我们在拿到一个查询请求后，首先会查询缓存，如果缓存中存在<strong>以键值对形式存在的记录</strong>，则直接从缓存中拿，也无须再执行后续环节，直接返回命中结果即可。如果缓存中不存在，则继续流程。</p>\n<p>但如果我们拿到的是一个更新请求呢？那查询缓存不仅没用，还需要清空缓存，也就是我们常说的<strong>缓存失效</strong>，在一个更新语句频繁的系统中，要查询缓存有何用？</p>\n<p>让人戏谑的是，在mysql8.0以后，查询缓存彻底成了过去式。</p>\n</li>\n<li><p><code>分析器</code>：</p>\n<ol>\n<li>词法分析：我们输入是由多个字符串和空格组成的一条sql语句，mysql需要识别里面的字符串分别是啥，如需要把字符串test识别为表test。</li>\n<li>语法分析：简言之，判断sql语句的语法是否正确。</li>\n</ol>\n</li>\n<li><p><code>优化器</code>：</p>\n<p>哪些方面有优化空间呢？<strong>join的连接顺序，索引</strong>，所以优化器会决定选择哪一个。</p>\n</li>\n<li><p><code>执行器</code>：</p>\n<p>在执行之前，首先查看是否具有执行权限，如果没有，返回错误。如果命中，则<strong>在查询缓存返回结果的时候做权限验证</strong>。</p>\n<p>如果有权限，则执行器调用引擎提供的接口，调用API，完成操作。</p>\n</li>\n</ol>\n<h3 id=\"3-存储引擎层有什么作用？\"><a href=\"#3-存储引擎层有什么作用？\" class=\"headerlink\" title=\"3.存储引擎层有什么作用？\"></a>3.存储引擎层有什么作用？</h3><p>留个坑</p>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"二-一条sql更新语句是如何执行的？\"><a href=\"#二-一条sql更新语句是如何执行的？\" class=\"headerlink\" title=\"二.一条sql更新语句是如何执行的？\"></a>二.一条sql更新语句是如何执行的？</h2><h3 id=\"1-redo-log的概念是什么？底层实现机制是怎样的？\"><a href=\"#1-redo-log的概念是什么？底层实现机制是怎样的？\" class=\"headerlink\" title=\"1.redo log的概念是什么？底层实现机制是怎样的？\"></a>1.redo log的概念是什么？底层实现机制是怎样的？</h3><p><code>redo-log</code>：即重做日志，它独属于InnoDB引擎，是一种物理日志，记录了在数据页上的操作，可以保证crash safe.</p>\n<p><code>原理</code>：假如在执行更新语句后，直接将更新写回磁盘，就会影响即时体验。所以我们需要借鉴这样的思想：</p>\n<blockquote>\n<p>《孔乙已》中的酒店掌柜不会直接将还账记录写到<strong>账本(磁盘)<strong>中，而会将</strong>还账(更新</strong>,即做了什么)记录在**粉板(redo-log)**上，在空闲时，在全部写入账本中。</p>\n</blockquote>\n<p><code>底层原理</code>：InnoDB的redo-log是固定大小的，如可以配置为一组4个文件，每个文件大小1GB，记录日志时使用<strong>循环队列</strong>的数据结构，当循环队列已满，会将最久的日志擦除(写入磁盘)，然后使用新的日志填充空间。</p>\n<p>redo-log并非直接持久化到磁盘，它会首先存储到<code>redo-log buffer</code>，接着存储到文件系统的<code>page cache</code>,最后才<code>持久化</code>到磁盘。</p>\n<h3 id=\"2-什么是WAL（write-ahead-logging）机制，好处是什么？\"><a href=\"#2-什么是WAL（write-ahead-logging）机制，好处是什么？\" class=\"headerlink\" title=\"2.什么是WAL（write ahead logging）机制，好处是什么？\"></a>2.什么是WAL（write ahead logging）机制，好处是什么？</h3><p>直白的说，就是<code>先写日志，再写入磁盘</code>，日志是被加载到内存中的，写入速度快，而写入磁盘是机械运动，写入速度非常慢。</p>\n<h3 id=\"3-redo-log是如何保证crash-safe的？\"><a href=\"#3-redo-log是如何保证crash-safe的？\" class=\"headerlink\" title=\"3.redo log是如何保证crash-safe的？\"></a>3.redo log是如何保证crash-safe的？</h3><p>所谓crash，指的<code>是数据库异常重启</code>的场景，显然，如果不使用redo-log机制，此时仅有负责归档(用于备份)的bin-log，数据的更新不会被刷新到磁盘中去。</p>\n<p>而redo-log机制负责物理更新刷新到磁盘中去，<code>不会出现物理与逻辑数据不一致</code>的状况。</p>\n<h3 id=\"4-binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\"><a href=\"#4-binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\" class=\"headerlink\" title=\"4.binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？\"></a>4.binlog如何理解，它的底层实现机制是怎样的，它可以保证crash-safe吗？</h3><p><code>bin-log</code>:即归档日志，由server层实现，记录数据库的逻辑操作，用于全量备份。当需要恢复数据时，可以取出某个时间段内的bin-log进行重放恢复。</p>\n<p><code>底层原理</code>：bin-log区别于redo-log，它没有文件大小的限制，会追加写；</p>\n<p>每个线程都有自己的binlog cache,但是会共用一份binlog文件。</p>\n<p>持久化到磁盘分为两个阶段：首先将日志写到文件系统的<strong>page cache</strong>,此时并没有持久化到磁盘，所以速度比较快；接着<strong>fsync</strong>,即是将数据持久化到磁盘，一般认为只有fsync才占磁盘的<strong>IOPS</strong>。</p>\n<p><code>crash-safe</code>:crash要解决的问题是逻辑数据与物理数据不一致的问题，也就是保证将内存中物理数据刷新到内存，但bin-log表示我做不到~</p>\n<h3 id=\"5-对比redo-log和bin-log\"><a href=\"#5-对比redo-log和bin-log\" class=\"headerlink\" title=\"5.对比redo-log和bin-log.\"></a>5.对比redo-log和bin-log.</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>redo-log</th>\n<th>bin-log</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文件大小</td>\n<td>覆盖写</td>\n<td>追加写</td>\n</tr>\n<tr>\n<td>层级</td>\n<td>server层</td>\n<td>InnoDB引擎</td>\n</tr>\n<tr>\n<td>日志形式</td>\n<td>物理日志</td>\n<td>逻辑日志</td>\n</tr>\n<tr>\n<td>作用</td>\n<td>刷新到磁盘，物理一致性</td>\n<td>归档，逻辑一致性</td>\n</tr>\n<tr>\n<td>crash-safe</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>实质</td>\n<td>记录数据页做了什么操作</td>\n<td>statment模式：记录sql语句    row模式：记录更新前后的行，一般使用row模式</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-一条sql更新语句是如何执行的？\"><a href=\"#6-一条sql更新语句是如何执行的？\" class=\"headerlink\" title=\"6.一条sql更新语句是如何执行的？\"></a>6.一条sql更新语句是如何执行的？</h3><blockquote>\n<p>update test set c=c+1 where id = 1</p>\n</blockquote>\n<ol>\n<li>执行器先找引擎找ID=1的这一行，ID为主键，引擎使用B+树的主键索引找到这一行。如果该行在内存中，直接返回给执行器；否则，先从磁盘读取到内存中，再返回；</li>\n<li>执行器执行得到新数据，调用引擎接口写入新的行记录；</li>\n<li>引擎将这行记录更新到内存中，并将更新的操作记录写到redo-log中，redo-log进行prepare状态；</li>\n<li>执行器生成bin-log，将bin-log写入磁盘；</li>\n<li>redo-log改为commit状态，更新完成。</li>\n</ol>\n<h3 id=\"7-如果数据库误操作，如何将数据恢复？\"><a href=\"#7-如果数据库误操作，如何将数据恢复？\" class=\"headerlink\" title=\"7.如果数据库误操作，如何将数据恢复？\"></a>7.如果数据库误操作，如何将数据恢复？</h3><p>找到最近一次的全量备份，<code>从备份时间点开始</code>，将备份的bin-log依次取出，重放到误删时刻。</p>\n<h3 id=\"8-什么是两阶段提交-如果不两阶段提交，会发生什么？\"><a href=\"#8-什么是两阶段提交-如果不两阶段提交，会发生什么？\" class=\"headerlink\" title=\"8.什么是两阶段提交?如果不两阶段提交，会发生什么？\"></a>8.什么是两阶段提交?如果不两阶段提交，会发生什么？</h3><p>即确定redo-log与bin-log提交时机，通过<code>两阶段提交来保证跨系统维持数据逻辑一致性</code>。如果没有两阶段提交，就好比读到了事务的脏数据。</p>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"三-事务隔离：为什么你改了我还看不见\"><a href=\"#三-事务隔离：为什么你改了我还看不见\" class=\"headerlink\" title=\"三.事务隔离：为什么你改了我还看不见\"></a>三.事务隔离：为什么你改了我还看不见</h2><h3 id=\"1-事务的概念是什么？\"><a href=\"#1-事务的概念是什么？\" class=\"headerlink\" title=\"1.事务的概念是什么？\"></a>1.事务的概念是什么？</h3><blockquote>\n<p>事务是对数据库中数据操作的<code>保证数据逻辑一致性的最小操作单元</code>。</p>\n</blockquote>\n<h3 id=\"2-简述某一场景下，不同事务隔离级别的区别\"><a href=\"#2-简述某一场景下，不同事务隔离级别的区别\" class=\"headerlink\" title=\"2.简述某一场景下，不同事务隔离级别的区别\"></a>2.简述某一场景下，不同事务隔离级别的区别</h3><p>有这样的一个场景：</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606161322663.png\" alt=\"image-20210606161322663\"></p>\n<p>在该场景下，不同事务隔离级别有不同的返回值：</p>\n<ul>\n<li><p><code>读未提交</code>：即在事务B没有提交的时候，它做的变更就可以被事务A看到。所以读到的值分别是1,2,2；</p>\n</li>\n<li><p><code>读已提交</code>：即只有在事务A提交之后，它做的变更才能被事务A看到，所以读到的值为：1,1,2；</p>\n</li>\n<li><p><code>可重复读</code>：即事务A执行期间读到的值和事务A开启时读到的值是一样的，所以读到的值是1,1,2；</p>\n</li>\n<li><p><code>串行化</code>：即事务A，事务B对于同一行记录，会通过加读写锁的方式来限制另一个事务。所以读到的值是1,1,2.</p>\n</li>\n</ul>\n<h3 id=\"3-读已提交，可重复读是怎样通过视图构建实现的？\"><a href=\"#3-读已提交，可重复读是怎样通过视图构建实现的？\" class=\"headerlink\" title=\"3.读已提交，可重复读是怎样通过视图构建实现的？\"></a>3.读已提交，可重复读是怎样通过视图构建实现的？</h3><p>首先了解下视图的概念：</p>\n<blockquote>\n<p>视图是对复杂sql语句的封装，可以认为是拷贝静态数据，对视图做的变更不会同步到数据库中。</p>\n</blockquote>\n<ul>\n<li><p><code>可重复读</code>：在该隔离级别下，数据库在事务启动时创建了一个视图，访问时以视图的逻辑结果为准，在<strong>事务存在期间</strong>都会使用这个视图。他为mysql的默认隔离级别；</p>\n</li>\n<li><p><code>读未提交</code>：直接返回记录最新值，没有视图概念；</p>\n</li>\n<li><p><code>读已提交</code>：视图在<strong>sql语句开始执行时</strong>创建。它为oracle的默认隔离级别。</p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\">  注:配置方式：transaction-isolation=READ-COMMITED</p>\n</li>\n</ul>\n<h3 id=\"4-简要说明可重复读的使用场景\"><a href=\"#4-简要说明可重复读的使用场景\" class=\"headerlink\" title=\"4.简要说明可重复读的使用场景\"></a>4.简要说明可重复读的使用场景</h3><p>在记账的时候很有用。</p>\n<h3 id=\"5-事务隔离是怎样通过read-view实现的\"><a href=\"#5-事务隔离是怎样通过read-view实现的\" class=\"headerlink\" title=\"5.事务隔离是怎样通过read-view实现的?\"></a>5.事务隔离是怎样通过read-view实现的?</h3><p>之前我们提到，在事务隔离中，提供了<code>视图这种数据拷贝</code>的方式，而在事务隔离级别下，我们会读到不同的数据，这说明是存在多个视图的，也就是read-view。</p>\n<p>在MYSQL中，实际上每条记录在更新时都会记录一条<code>回滚操作</code>，通过回滚操作，可以得到上一个状态的值：</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210606163851669.png\" alt=\"image-20210606163851669\"></p>\n<p>也就是说，<code>同一个记录在数据库中是存在多个版本的</code>，当我们要读取数据时，要判断这个数据的版本对于当前事务是否可见，如果不可见，就通过<code>undo-log</code>计算得到上一个版本，直到找到正确版本为止。</p>\n<p>在不需要的时候，数据库系统会将回滚日志删除。</p>\n<h3 id=\"6-并发版本控制的概念是什么？如何实现？\"><a href=\"#6-并发版本控制的概念是什么？如何实现？\" class=\"headerlink\" title=\"6.并发版本控制的概念是什么？如何实现？\"></a>6.并发版本控制的概念是什么？如何实现？</h3><p><code>概念</code>：同一个数据行，在数据库中存在<code>多个版本号</code>，这个版本号可以理解为当前操作这行数据的<code>事务的ID</code>。</p>\n<p><code>实现</code>：在进行并发操作时，会使用<code>该行的版本号与当前事务的版本号</code>进行比较，如果刚好等于，也就是说这行数据是由这个事务提交生成的。</p>\n<h3 id=\"7-长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\"><a href=\"#7-长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\" class=\"headerlink\" title=\"7.长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？\"></a>7.长事务是什么？使用长事务会拖垮整个库？如何查询各个表中的长事务，那应该如何避免使用长事务？</h3><p><code>概念</code>：需要执行很久的事务；</p>\n<p><code>底层</code>：长事务意味着系统中有非常多的不能被删除的事务视图，这会导致大量的<code>空间占用</code>，而在mysql5.5之前，即便长事务被提交，<code>回滚段被清理，文件也不会变小</code>，另外长事务还<code>占用锁资源</code>，这时其他就会因锁等待重新建立连接，<code>mysql的连接被占用爆满</code>，导致拖垮整个库。</p>\n<p><code>查询</code>：SELECT * FROM information_schema.INNODB_TRX</p>\n<p><code>避免</code>：</p>\n<ol>\n<li>设置autocommmit=1,即自动提交；</li>\n<li>写脚本监控information_schema.INNODB_TRX的内容，发现长事务就kill掉它；</li>\n<li>设置SQL语句所能执行的最大运行时间；</li>\n<li>设置回滚表单独存放，便于回收表空间。</li>\n<li>尽量去使用小事务。</li>\n</ol>\n<h3 id=\"8-事务的启动方式有哪几种？\"><a href=\"#8-事务的启动方式有哪几种？\" class=\"headerlink\" title=\"8.事务的启动方式有哪几种？\"></a>8.事务的启动方式有哪几种？</h3><ul>\n<li><code>begin:</code></li>\n<li><code>start trasaction:</code>与begin效果一致；</li>\n<li><code>start trasaction with consistent snaps hot:</code>该语句执行后，会创建一致性视图，分配事务ID。</li>\n</ul>\n<h3 id=\"9-commit-work-and-chain的语法有什么作用？\"><a href=\"#9-commit-work-and-chain的语法有什么作用？\" class=\"headerlink\" title=\"9.commit work and chain的语法有什么作用？\"></a>9.commit work and chain的语法有什么作用？</h3><p>提交当前事务+开启下一个事务=begin+commit;</p>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"四-深入浅出索引上\"><a href=\"#四-深入浅出索引上\" class=\"headerlink\" title=\"四.深入浅出索引上\"></a>四.深入浅出索引上</h2><h3 id=\"1-索引的概念是什么？\"><a href=\"#1-索引的概念是什么？\" class=\"headerlink\" title=\"1.索引的概念是什么？\"></a>1.索引的概念是什么？</h3><p><strong>概念</strong>：索引是一个相对抽象的数据结构，在书中，我们通常抽取<code>目录名与对应的页码号作为目录以快速定位数据</code>，在数据库系统中，索引就是以这样的作用存在的，它是数据库管理系统中一个<code>排序</code>的数据结构)，以<code>协助快速查询</code>、更新数据库表中数据。</p>\n<p><strong>类比</strong>：操作系统中使用<strong>inode</strong>来唯一标识文件，在inode中，记录了各个<code>文件分别包含哪些磁盘块</code>，给定inode,就可以找到文件的所有块，在inode中，同样存储了文件属性的磁盘地址。</p>\n<h3 id=\"2-简述索引模型之哈希表\"><a href=\"#2-简述索引模型之哈希表\" class=\"headerlink\" title=\"2.简述索引模型之哈希表\"></a>2.简述索引模型之哈希表</h3><p><strong>概述</strong>：哈希表是一种以<code>键值对</code>存储数据的结构，我们只需要输入待查找的key，就可以找到对应的value,哈希表的思路很简单，把值放在数组中，用一个<code>哈希函数把key换算成一个确定的位置</code>，然后将value放在数组的这个位置。</p>\n<p><strong>哈希冲突</strong>：使用链表法解决；</p>\n<p><strong>示例</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202153949.png\" alt=\"image-20210607202153949\"></p>\n<p><strong>特点</strong>：只适用于<code>等值查询</code>，可以应用于NoSQL不能做<code>区间查询</code>。</p>\n<h3 id=\"3-简述索引模型之有序数组\"><a href=\"#3-简述索引模型之有序数组\" class=\"headerlink\" title=\"3.简述索引模型之有序数组\"></a>3.简述索引模型之有序数组</h3><p><strong>概述</strong>：将元素按照一定的顺序排列，这里的顺序<code>不一定是严格自增</code>，而是按照某一属性从小到大排序。假如有一个按照身份证号排列的有序数组，我们要查询某一个身份证号的名字，通过<code>二分法</code>就可以找到。</p>\n<p><strong>示例</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607202732018.png\" alt=\"image-20210607202732018\"></p>\n<p><strong>特点</strong>：对于<code>等值查找</code>和<code>范围查找</code>都较友好，查询的时间复杂度为<code>O(logN)</code>,但实际上有序数组并没有得到大量应用，这是因为在插入元素时需要大量的<code>数据搬移</code>，也因此有序数组被大量应用于<code>静态存储引擎</code>。</p>\n<h3 id=\"4-简述索引模型之B-树\"><a href=\"#4-简述索引模型之B-树\" class=\"headerlink\" title=\"4.简述索引模型之B+树\"></a>4.简述索引模型之B+树</h3><p><strong>概述</strong>：B+树是一种二叉搜索树，它的节点遵循严格的大小关系，<code>二叉搜索树的查询，更新的时间复杂度为O(logN)</code>,</p>\n<p><strong>示例</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607203522696.png\" alt=\"image-20210607203522696\"></p>\n<p><strong>特点</strong>：<code>B+树</code>即为InnoDB的引擎模型，但考虑到性能，更多被使用的实则是<code>多叉树</code>。</p>\n<h3 id=\"5-为什么N叉树被广泛应用到数据库引擎中？\"><a href=\"#5-为什么N叉树被广泛应用到数据库引擎中？\" class=\"headerlink\" title=\"5.为什么N叉树被广泛应用到数据库引擎中？\"></a>5.为什么N叉树被广泛应用到数据库引擎中？</h3><p>我们先设想二叉树存储的场景：假如二叉树<code>树高20</code>，存储了100万行数据，<code>需要读取20个数据块(连续的存储空间)</code>，在机械硬盘时代，读取硬盘是龟速，而这样的龟速，居然要连续查询20次，那怎么提高查询的性能呢？</p>\n<p>减少树高，增加一个数据块中的数据，即<code>使用N叉树</code>。</p>\n<h3 id=\"6-基于主键索引和普通索引的查询有什么区别？\"><a href=\"#6-基于主键索引和普通索引的查询有什么区别？\" class=\"headerlink\" title=\"6.基于主键索引和普通索引的查询有什么区别？\"></a>6.基于主键索引和普通索引的查询有什么区别？</h3><p><strong>前提</strong>：在InnoDB中，<code>表是根据主键顺序以索引的形式存放</code>，这种存储方式被称为索引组织表。又因为索引是B+树的数据结构，即数据存储在B+树中，而<code>每一个索引在InnoDB里面对应一张表</code>。再进一步，则可以认为表是以多个B+树的形式存储的。</p>\n<p><strong>主键索引</strong>：主键索引的叶子结点存储的是<code>整行数据</code>，也因此得名聚簇索引。</p>\n<p><strong>普通索引</strong>：非主键索引的叶子结点存储的是<code>主键的值</code>，因此得名二级索引。</p>\n<p><strong>区别</strong>：如果where条件需要走主键索引，则只需要搜索主键的B+树，如果where条件走的是普通索引，则就需要先查询普通索引的B+树，得到主键，再去查询普通索引，即<code>回表</code></p>\n<h3 id=\"7-简述维护B-树索引时的页分裂与页合并？\"><a href=\"#7-简述维护B-树索引时的页分裂与页合并？\" class=\"headerlink\" title=\"7.简述维护B+树索引时的页分裂与页合并？\"></a>7.简述维护B+树索引时的页分裂与页合并？</h3><ul>\n<li><strong>页分裂</strong>：在插入数据时，如果当前数据页已满，就会申请一个新的数据页，导致<code>空间利用率下降</code>；</li>\n<li><strong>页合并</strong>：如果因为删除数据，导致<code>利用率变低</code>，则页合并就成了可选的优化方式。</li>\n</ul>\n<h3 id=\"8-哪些场景下应该使用自增主键，而哪些场景不应该\"><a href=\"#8-哪些场景下应该使用自增主键，而哪些场景不应该\" class=\"headerlink\" title=\"8.哪些场景下应该使用自增主键，而哪些场景不应该\"></a>8.哪些场景下应该使用自增主键，而哪些场景不应该</h3><p><code>自增主键适合递增插入</code>的场景，这样追加数据时，就不需要数据搬移咯。所以<strong>大多数的场景下，我们都会使用自增主键</strong>。</p>\n<p>而在有业务逻辑的字段做主键时，数据成本就会变高啦。</p>\n<p>如果在<code>典型的KV场景下，就需要使用普通索引</code>。</p>\n<h3 id=\"9-删除主键索引与普通索引有什么影响？\"><a href=\"#9-删除主键索引与普通索引有什么影响？\" class=\"headerlink\" title=\"9.删除主键索引与普通索引有什么影响？\"></a>9.删除主键索引与普通索引有什么影响？</h3><p>删除，重建主键索引后，需要同时<code>修改普通索引对应的主键索引</code>，而删除，重建普通索引则让人省心不少。</p>\n<h3 id=\"10-索引的优化\"><a href=\"#10-索引的优化\" class=\"headerlink\" title=\"10.索引的优化\"></a>10.索引的优化</h3><ol>\n<li><strong>覆盖索引：</strong>如果查询条件使用的是普通索引，或者联合索引的最左原则字段，查询结果是联合索引的字段或者主键，<code>不用回表操作，直接返回结果</code>，减少磁盘读写的次数，提高IO性能。</li>\n<li><strong>最左前缀：</strong>联合索引的<code>最左N个字段</code>，也可以是字符串索引的前M个字符；</li>\n<li><strong>联合索引：</strong>根据创建<code>联合索引</code>的顺序，<code>以最左原则进行where检索</code>，比如(age,name)以age=1或者age=1 and name=’张三’可以使用索引，单以name=”张三”不会使用索引。考虑到存储空间的问题，还需要根据业务需求，将查找频繁的数据进行靠左创建索引。</li>\n<li><strong>索引下推：</strong>like “hello%” and age&gt;10检索，在mysql5.6之前，会对匹配的数据进行会回表查询，5.6版本以后，<code>会先过滤不合法的数据，再对合法的数据进行回表</code>，从而降低回表率，提升检索率。</li>\n</ol>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"五-全局锁和表锁：给表加个字段怎么有那么多阻碍\"><a href=\"#五-全局锁和表锁：给表加个字段怎么有那么多阻碍\" class=\"headerlink\" title=\"五.全局锁和表锁：给表加个字段怎么有那么多阻碍\"></a>五.全局锁和表锁：给表加个字段怎么有那么多阻碍</h2><h3 id=\"1-简述全局锁锁\"><a href=\"#1-简述全局锁锁\" class=\"headerlink\" title=\"1.简述全局锁锁\"></a>1.简述全局锁锁</h3><p><strong>概述</strong>：对整个数据库实例加锁。<br><strong>加锁方式</strong>：<code>Flush tables with read lock(FTWRL)</code>，这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会<code>被阻塞</code>。<br><strong>使用场景</strong>：全库逻辑备份。<br><strong>风险</strong>：<br>    1.如果在<code>主库备份</code>，在备份期间不能更新，<code>业务停摆</code><br>    2.如果在<code>从库备份</code>，备份期间不能执行主库同步的binlog，导致<code>主从延迟</code></p>\n<h3 id=\"2-InnoDB是如何实现全局备份的\"><a href=\"#2-InnoDB是如何实现全局备份的\" class=\"headerlink\" title=\"2.InnoDB是如何实现全局备份的\"></a>2.InnoDB是如何实现全局备份的</h3><p><strong>mysqldump</strong>：官方自带的逻辑备份工具mysqldump，当mysqldump使用参数<code>--single-transaction</code>的时候，会启动一个事务，确保拿到<code>一致性视图</code>。而由于<code>MVCC</code>的支持，这个过程中数据是可以正常更新的。</p>\n<p>一致性读是好，但是前提是引擎要支持这个隔离级别。</p>\n<h2 id=\"3-如果要全库只读，为什么不使用set-global-readonly-true的方式？\"><a href=\"#3-如果要全库只读，为什么不使用set-global-readonly-true的方式？\" class=\"headerlink\" title=\"3.如果要全库只读，为什么不使用set global readonly=true的方式？\"></a>3.如果要全库只读，为什么不使用set global readonly=true的方式？</h2><p>1.在有些系统中，<code>readonly的值会被用来做其他逻辑</code>，比如判断主备库。所以修改global变量的方式影响太大。<br>2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会<code>导致整个库长时间处于不可写状态，风险较高</code>。</p>\n<h2 id=\"4-表锁简述\"><a href=\"#4-表锁简述\" class=\"headerlink\" title=\"4.表锁简述\"></a>4.表锁简述</h2><p><strong>概述</strong>：mysql里面表锁有两种：表锁和MDL(元数据锁)，表锁不建议加，MDL会默认加上；</p>\n<p><strong>表锁</strong>：<img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210608082421097.png\" alt=\"    \"></p>\n<p><strong>MDL</strong>：不需要显式使用，在访问的时候会自动加上，MDL包含<code>读锁和写锁</code>，<code>读锁之间不互斥</code>，可多线程共享，<code>写锁互斥</code>，来保证表结构变更时的安全性。</p>\n<p><strong>风险</strong>：MDL直到事务提交才会被释放，因此为了防止MDL存在时间过长，从而MYSQL异常重启，应该避免长事务。</p>\n<h3 id=\"5-如何安全地小表加一个字段\"><a href=\"#5-如何安全地小表加一个字段\" class=\"headerlink\" title=\"5.如何安全地小表加一个字段\"></a>5.如何安全地小表加一个字段</h3><ol>\n<li>查询长事务，暂停或kill掉长事务；</li>\n<li>在alter table语句中指定等待时间，避免阻塞。</li>\n</ol>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"六-行锁功过：怎么减少行锁对性能的影响\"><a href=\"#六-行锁功过：怎么减少行锁对性能的影响\" class=\"headerlink\" title=\"六.行锁功过：怎么减少行锁对性能的影响\"></a>六.行锁功过：怎么减少行锁对性能的影响</h2><h3 id=\"1-行锁的概述\"><a href=\"#1-行锁的概述\" class=\"headerlink\" title=\"1.行锁的概述\"></a>1.行锁的概述</h3><p>行锁即是对数据库的<code>行记录加锁</code>，在引擎层实现，仅<code>InnoDB</code>支持行锁。</p>\n<h3 id=\"2-简述两阶段锁协议\"><a href=\"#2-简述两阶段锁协议\" class=\"headerlink\" title=\"2.简述两阶段锁协议\"></a>2.简述两阶段锁协议</h3><p><strong>概念</strong>：在InnoDB事务中，行锁是在需要的时候加上的，但需要等待<code>事务提交才会释放</code>；</p>\n<p><strong>建议</strong>：<code>如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁往后放</code>。</p>\n<h3 id=\"3-简述死锁\"><a href=\"#3-简述死锁\" class=\"headerlink\" title=\"3.简述死锁\"></a>3.简述死锁</h3><p><strong>概念</strong>：当两个线程都在等待对方锁持有的资源时，就会产生死锁；</p>\n<p><strong>预防死锁</strong>：</p>\n<ol>\n<li><p>设置<code>超时参数</code>，默认为50s，这样显然交互不好，但如果设置过小，又会错将正常等待的线程当做死锁处理，因此<strong>不建议使用这种方案</strong>；</p>\n</li>\n<li><p><code>死锁检测</code>，发现死锁，马上<code>回滚</code>。这里可以<code>类比spring中的循环依赖</code>，都是需要查看自己所依赖的线程有没有被别人锁住。但这种方案仍有隐患，假设有100个线程并发修改，<code>都去查看自己依赖的线程有没有锁住，就必然需要大量的CPU资源</code>，这也是为什么即便很小的并发量，CPU占用率也可能很高的原因。</p>\n<blockquote>\n<p>怎样解决由这种热点行更新导致的性能问题？</p>\n</blockquote>\n<ul>\n<li>在<code>确认不会发生死锁的情况下，可关闭死锁检测</code>，但问题在于关掉死锁检测可能导致大量的超时，这是业务有损的；</li>\n<li>控制并发度，具体地说，是在数据库服务端实现该逻辑，实现方式自然是<code>特定大小的等待队列</code>；</li>\n<li>从设计上看，可以考虑将一行改成逻辑上的多行。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<h2 id=\"番外\"><a href=\"#番外\" class=\"headerlink\" title=\"番外\"></a>番外</h2><h3 id=\"1-mysql的服务器配置文件\"><a href=\"#1-mysql的服务器配置文件\" class=\"headerlink\" title=\"1.mysql的服务器配置文件\"></a>1.mysql的服务器配置文件</h3><p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210607105513978.png\" alt=\"image-20210607105513978\"></p>\n<h3 id=\"2-my-cnf-my-ini配置文件详解\"><a href=\"#2-my-cnf-my-ini配置文件详解\" class=\"headerlink\" title=\"2.my.cnf/my.ini配置文件详解\"></a>2.my.cnf/my.ini配置文件详解</h3><p><a href=\"https://www.cnblogs.com/kuoAT/p/7080770.html\">https://www.cnblogs.com/kuoAT/p/7080770.html</a></p>\n<h3 id=\"3-mysql日志系统详解\"><a href=\"#3-mysql日志系统详解\" class=\"headerlink\" title=\"3.mysql日志系统详解\"></a>3.mysql日志系统详解</h3><p><a href=\"https://segmentfault.com/a/1190000023827696\">https://segmentfault.com/a/1190000023827696</a></p>\n<h3 id=\"4-查看mysql下的几个日志\"><a href=\"#4-查看mysql下的几个日志\" class=\"headerlink\" title=\"4.查看mysql下的几个日志\"></a>4.查看mysql下的几个日志</h3><p><a href=\"https://blog.csdn.net/xuheng8600/article/details/79823875\">https://blog.csdn.net/xuheng8600/article/details/79823875</a></p>\n<ol>\n<li><p><strong>慢查询日志</strong>是记录了执行时间超过参数long_query_time(单位是秒)所设定值的SQL语句日志。</p>\n<p>Note:慢查询日志对于我们发现性能有问题的SQL有很帮助，建议使用并经常分析；</p>\n</li>\n<li><p><strong>查询日志</strong>记录了clinet的所有的语句。</p>\n<p>Note:由于log日志记录了数据库所有操作，对于访问频繁的系统，此种日志会造成性能影响，建议关闭。</p>\n</li>\n<li><p><strong>错误日志</strong>在Mysql数据库中很重要，它记录着mysqld启动和停止，以及服务器在运行过程中发生的任何错误的相关信息。</p>\n</li>\n<li><p><strong>二进制日志</strong>也通常被称为binlog,它记当着所有的DDL和DML，但不包括数据查询语句。</p>\n</li>\n</ol>\n<h2 id=\"面经集锦\"><a href=\"#面经集锦\" class=\"headerlink\" title=\"面经集锦\"></a>面经集锦</h2><ol>\n<li><p>Explain的主要字段</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613161115048.png\" alt=\"image-20210613161115048\"></p>\n</li>\n<li><p>b+树相比B树的优点</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613170513272.png\" alt=\"image-20210613170513272\"></p>\n</li>\n<li><p>可不可以切换索引为哈希索引？</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613162722458.png\" alt=\"image-20210613162722458\"></p>\n</li>\n<li><p>场景题：高并发场景下数据库压力很大，怎么解决？</p>\n<p><code>使用索引，使用缓存，分库分表，消息队列</code></p>\n</li>\n<li><p>mysql分页查询优化</p>\n<p><strong>一般查询会从第一条记录开始找起</strong></p>\n<ol>\n<li><strong>子查询</strong>：这种方式<code>先定位偏移位置的 id</code>，然后往后查询，这种方式适用于 id 递增的情况</li>\n<li><strong>id限定</strong>：可以使用 <code>id between and</code> 来查询</li>\n</ol>\n<p>一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。</p>\n</li>\n<li><p>mysql 联合索引使用 A&gt;n and B=m 和 A=n and B=m 的区别</p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165722760.png\" alt=\"image-20210613165722760\"></p>\n<p><img src=\"C:/Users/zyz/AppData/Roaming/Typora/typora-user-images/image-20210613165652454.png\" alt=\"image-20210613165652454\"></p>\n</li>\n<li><p>MySQL的InnoDB和MyISAM区别</p>\n<table>\n<thead>\n<tr>\n<th>角度</th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>事务</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>外键</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>索引</td>\n<td>聚集索引</td>\n<td>非聚集索引</td>\n</tr>\n<tr>\n<td>表的具体行数</td>\n<td>不保存</td>\n<td>保存</td>\n</tr>\n<tr>\n<td>锁的粒度</td>\n<td>行锁</td>\n<td>表锁</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>索引如何优化</p>\n<p>发现索引走的不好：<strong>慢查询</strong></p>\n<ol>\n<li>利用<code>覆盖索引</code>来进行查询操作，避免回表；</li>\n<li><code>explain中的字段type</code>：至少要达到range级别，要求是ref级别，如果为<strong>consts</strong>最好不过。</li>\n<li><code>联合索引最左前缀原则</code>。</li>\n<li>union，in,or都能够命中索引，建议使用<code>in</code>.</li>\n</ol>\n</li>\n<li><p>简述乐观锁与悲观锁</p>\n<p><strong>乐观锁</strong>：拿数据时不会上锁，但在提交的时候会判断数据有没有被更新，通常使用版本号/时间戳来实现。</p>\n<p><strong>悲观锁</strong>：一开始就对商品加上锁（SELECT … <code>FOR UPDATE</code>）</p>\n</li>\n<li><p>索引一定会命中吗？如何保证命中</p>\n<p>不一定会命中，使用explain中的ref字段判断，force index,强制走某个索引</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT * FROM test01 FORCE INDEX(uk_index) WHERE NAME &#x3D; &#39;测试1&#39; AND age&#x3D;1 ;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>mysql数据库为什么要使用N叉树</p>\n<p>一个页就是一棵树B+树的节点，数据库I/O操作的最小单位是页，与数据库相关的内容都会存储在页的结构里。</p>\n<p>在一棵B+树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间</p>\n<p>同一层的节点之间，通过页的结构构成了一个双向链表</p>\n<p>非叶子节点包括了多个索引行，每个索引行里存储索引键和指向下一层页面的指针</p>\n<p>叶子节点为，存储了关键字和行记录，在节点内部(也就是页结构的内部)记录之间是一个单向的链表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200404223041152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"img\"></p>\n</li>\n<li><p>说一下你的项目里具体的一个表，有没有建索引，如何建的？</p>\n<p>shop表，主键shopId（主键本身就是一种特殊的索引）,外键userId,shopCategoryId</p>\n<p><strong>shopId bigint not null auto_invreament primary key</strong></p>\n<p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键，除非高并发写入操作可能需要衡量自增主键</p>\n</li>\n<li><p>innodb 索引文件的存储形式</p>\n<p>思路：一个表——》多个B+树——》叶子节点(页结构，即多个磁盘块)+非叶子结点(页结构，即多个磁盘块)——》行数据+索引数据</p>\n</li>\n<li><p>mysql主键是怎么自增的（其实是说底层的Auto-INC锁）</p>\n<p><strong>自增长计数器</strong>,<strong>Auto-INC锁</strong>,表锁</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"四种基本的数据结构","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T08:05:33.000Z","password":null,"summary":null,"_content":"\n> 在具体的算法题解之前，我会先简要的描述一些知识点，这些知识点都是基于数据结构与算法专栏的总结，对于详细的推理不再涉及，仅当做笔记使用。\n\n# 我们所熟识的数组\n\n## 1.1 从一个问题开始\n\n为什么大部分编程语言中，数组要从0开始编号，而不是从1开始？\n\n从数组存储的内存模型来看，数组的下标实际上指的是内存地址的偏移，假设用a表示数组的首地址，将数组元素的类型所占字节数计为type_size，那么**a[k]表示的含义就是存储在内存空间k*typesize+base_addr处的元素**，如果从1开始编号的，公式就变成了这样——\n$$\n(k-1)*typesize+base_addr\n$$\n也就是说，每次随机访问数组元素时多了一个减法操作，CPU多了一次减法指令的执行。\n\n## 1.2 数组概述\n\n**数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据**。\n\n数组的特性之一就是数组支持**随机访问**，根据下标随机访问的时间复杂度是O(1).而不基于下标访问数组元素最优的方式是二分查找，平均时间复杂度为O(logn).\n\n## 1.3 低效的插入与删除\n\n由于数组使用的是连续的内存空间，所以其在插入和删除元素时实际上需要两步：\n\n1. 进行**数据的搬移**\n2. 实际的**数据操作**\n\n因为涉及到元素的搬移，因此他们的**平均时间复杂度**是O(N),相对链表只操作指针就可以完成插入和删除来说，低效得多。\n\n## 1.4 令人头疼的数组越界问题\n\n数组在初始化时必须要指定数组的长度，但在使用时，并**没有机制约束操作数组长度以外的元素**，这就导致了越界问题，在java中，当处理的数组越界时，会抛出**java.lang.ArrayIndexOutOfBoundsException**异常，而在C语言中，就比较头疼了，需要自己时刻谨慎以防止数组越界。\n\n## 1.5 容器可以代替数组吗？\n\n容器ArrayList在数组的基础上封装了**增删改查及动态扩容**的操作，简化了开发流程。但同时也多了限制，即容器中**只能存储对象**，这就需要基本数据类型的装箱与拆箱，**降低了性能**。那什么情况下建议使用数组呢——\n\n> 1. 如果考虑性能，则使用数组\n> 2. 若数组大小事先已知且涉及到的数组操作非常简单，可以使用数组\n> 3. 对于底层的开发，如网络框架，性能优化，选择数组\n\n## 1.7 小练习\n\n如何理解JVM中标记清除垃圾回收算法的思想？\n\n我们知道删除数组元素是非常耗费性能的，如果涉及到多次删除，就需要多次搬移元素。这时可以先记录下已经删除的元素，但并不搬移数据，当数组没有更多的存储空间时，再触发真正的数据搬移。\n\n而关于jvm标记清除算法的详情，就请移步https://segmentfault.com/a/1190000037685570\n\n# 二.链表知识大派送\n\n------\n\n## 摘要\n\n确认过眼神，是熟悉的链表环节。从内存模型的角度来看，众多的数据结构都是在数组和链表的基础上衍生的。\n\n在链表的学习小节中，我们首先从一个通用的解决方案出发，接着谈及几种链表的基本结构，常用操作，以及不同结构的链表是怎样自然递进的。最后还将对数组与链表做一对比。话不多说，让我们启程吧——\n\n## 2.1 从一个问题开始\n\n我们知道，在操作系统中，为了解决从硬盘读取和从内存读写的速度不匹配问题，常常引入缓存这一概念。缓存家族可谓人丁兴旺，寄存器，浏览器缓存，数据库缓存大行其道。那缓存实现的机制是什么呢？\n\n那就是LRU缓存淘汰算法，在后期推出的操作系统系列博文中，你将对其有深入的了解。这里我们只讨论，如何**使用链表实现LRU缓存淘汰算法**，对此，王争老师的思路这样的——\n\n> 我们维护一个有序的单链表，越靠近链表尾部的节点是越早之前被插入的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历单链表。\n>\n> 假如这个元素之前被缓存在链表中，则将该元素从原来的位置删除，然后插入到链表的头部\n>\n> 如果该数据没有在缓存链表中，又可以分为两种情况：\n>\n> 1. 如果缓存未满，则将此节点直接插入到链表的头部\n> 2. 如果缓存已满，则将链表尾部的元素删除，再将该数据插入到链表的头部。\n>\n> 此外，还可以通过**散列表降低访问元素的时间复杂度**优化这个方案。\n\n## 2.2 五花八门的链表结构\n\n首先对链表下一个定义：\n\n> 区别于数组使用连续的内存空间，**链表通过指针将离散的内存块串联在一起。**\n\n定义中的内存块即是链表的节点，为了将所有节点串起来，每个节点**存储数据**以外，还需要**记录下一个节点的地址，也就是后继指针next。**\n\n常用的链表有三种，其中最简单常用的是单链表——\n\n### 2.2.1 单链表\n\n![image-20210707230130075](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230130075.png)\n\n我们习惯将第一个节点称为头结点，将最后一个节点称为尾结点，值得注意的是，尾结点不再指向一个地址，而指向null。\n\n与数组一样，链表也支持数据的查找，插入和删除。\n\n在插入，删除新元素时，只需要考虑相邻节点的指针改变——\n\n![image-20210707230140227](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230140227.png)\n\n在链表中查找元素是不方便的，必须顺序遍历链表，它的时间复杂度为O(n).\n\n### 2.2.2 循环链表\n\n循环链表是特殊的单链表，它与单链表的区别就在于尾结点。循环链表的尾结点指针指向的是头结点。那么这么结构适用于什么场景呢？\n\n它可以用来高效的解决**环结构的链表**，比如著名的**约瑟夫环**问题。\n\n在实际应用中，被更多使用的要属双向链表，我们来看下它特定的结构得以应用于什么场景呢。。。\n\n### 2.2.3 双向链表\n\n双向链表在单链表的基础上增加了前驱节点prev，这样双向链表就可以实现反向遍历，对于找特定节点的前驱节点的时间复杂为O(1)。双向链表降低了遍历链表时的复杂度，但同时也带来了内存的损耗。是一种使用空间换时间的策略\n\n### 2.2.4 双向链表高效在哪呢\n\n我们知道，删除链表元素的场景分为两类：\n\n1. 删除值等于给定值的节点\n2. 删除给定指针指向的节点\n\n对于第一种情况，没有捷径可走，只能去逐个遍历节点元素。而对于第二个节点，双向链表增加了通过前驱指针找给定节点的遍历，因此高效的多。同样的，插入一个节点时，使用双向链表也提供了更多的可能。\n\n既然双向链表这么牛，那实际应用场景中有没有双向链表的大展身手呢，那就是LinkedHashMap,这种高效的集合底层即是使用了这种数据结构。\n\n看到这，很多朋友会问，既然双向链表的效率这么高，那再给他加上循环链表的特点岂不是如虎添翼，的确如此，我们来看究极版——\n![image-20210707230151299](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230151299.png)\n\n## 2.3 链表VS数组性能大比拼\n\n这里不再俗套的给出很多理论，而是通过具体的应用场景来考虑数组与链表性能——\n\nCPU缓存应该哪种数据结构呢？CPU管理的是连续的内存空间，使用链表简直天然地不友好，所以使用数组。而对于一个插入删除更频繁的系统来说，使用数组则更众望所归。其实抛开场景说数据结构就是耍流氓，在之前的定义中，我们就提及，数据结构是用于特定场景的。\n\n## 2.4 如何轻松的写出正确的链表代码\n\n链表的代码因为涉及到指针的操作，往往空想起来比较绕，要想高效地写出链表代码，我们还需要一些技巧——\n\n1. **理解指针或者引用的含义**\n\n   将某个变量赋给指针，实际上就是将这个变量的地址赋值给指针，引用同样如是。\n\n2. **警惕指针丢失和内存泄漏**\n\n   链表的操作往往是有序的，此外，在删除元素时，一定要手动释放内存空间(C语言).\n\n3. **利用哨兵简化实现难度**\n\n   对原生的单链表删除尾结点和插入第一个节点时，需要做特殊处理。这种边界条件能不能简化成通用的情况呢？\n\n   当然可以，我们使用哨兵机制来实现，即在第一个节点之前加入head节点，head节点不存储数据，它指向链表的第一个节点。这里需要注意区分head节点和第一个节点，他们的定义是不同的！\n\n4. **重点留意边界条件**\n\n   常见的边界处理条件有那么几个\n\n   1. **如果链表为空，代码是否能正常运行**\n   2. **如果链表只包含一个节点时，代码是否能正常工作**\n   3. **如果链表只包含两个节点时，代码是否能正常工作**\n   4. **代码逻辑在处理头结点和尾结点时，代码是否能正常工作。**\n\n5. **举例画图，辅助思考**\n\n   非常有必要，脑子不是那么靠谱的时候，就需要动手啦。\n\n6. **多写多练，没有捷径**\n\n------\n\n# 三.更进一步——关于栈\n\n## 3.1 从一个问题开始\n\n我们在浏览网站时都会用到前进和后退的功能，那这种功能是如何实现的你知道吗？\n\n没错，就是使用这节我们会讲到的栈，针对这个需求，假设将我们浏览的网页按照先后顺序存储在一个数组中，我们根据下标，即可实现前进和后退，但这里有一个致命的BUG，那就是它无法按我们的需求去删减一些存储在数组中的网页，也正因此我们需要引入栈。\n\n假设我们依次访问了三个网页A,B,C，那栈的情况是这样的——\n\n![image-20210707230201483](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230201483.png)\n\n这时，我们想回退到a页面了，就需要出栈c,b到栈Y中——\n![image-20210707230229659](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230229659.png)\n\n然后，我们再去访问页面d:就会入栈X，如果我们再想访问页面b,c就不行了，栈Y会清空栈中的内容\n\n## 3.2 为什么要学习栈\n\n栈是一种操作受限的线性表，从功能上来说，数组异或链表都可以实现栈。但是数组或是链表都暴露了太多的接口，这就需要我们非常注意邻界条件。\n\n而特定的数据结构是对特定情境的抽象，对于某些场景来说，用栈就很合适了。\n\n当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特点时，我们就应该首选使用栈。\n\n## 3.3 怎样学习栈？\n\n### 实现一个栈\n\n可以查看我的另一篇关于**队列和栈基础应用的博文**：\n\n### 支持动态扩容的顺序栈\n\n我们先来分析下入栈和出栈的时间复杂度，出栈时，时间复杂度为O(1)没有悬念，而入栈时假如还有空间，那时间复杂度自然也是O(1)，但当栈满的时候入栈，就需要扩容，这里的时间复杂度用均摊时间复杂度理解仍为O(1).\n\n既然，我们需要扩容这种机制，而栈本身又可以使用数组实现。不妨用栈来继承一个可以实现动态扩容的集合。\n\n实际上，java就是这样做的——\n\n![image-20210707230239639](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230239639.png)\n\n当需要扩容时，会将数组大小扩展为原来的2倍：\n\n![image-20210707230251442](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230251442.png)\n\n### 栈的应用\n\n栈在函数调用，括号匹配，表达式运算方面有广泛的应用，我们一一来看——\n\n`函数调用` ：\n\n> 我们知道，操作系统给给每个线程分配了一个独立的内存空间，这块内存被组织为栈这种结构。用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈\n\n`表达式运算`\n\n> 编译器实则就是使用两个栈来实现的。其中一个是保存操作数的栈，另一个是保存运算符的栈。当我们从左到右遍历表达式，当遇到数据，我们直接压入操作数栈。\n>\n> 当遇到运算符时，首先与运算符栈的栈顶运算符进行比较，如果比栈顶运算符的优先级低或者相等，则从运算符栈取出栈顶元素，然后从操作数栈取两个元素进行运算，并将运算结果压入操作数栈，继续比较。来看下王争老师的举例——\n>\n> ![image-20210707230302756](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230302756.png)\n\n`括号匹配`\n\n> 这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。\n> 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。\n\n### 面试常考的练习题集锦\n\n1. 有效的括号\n\n   待更新\n\n2. 最小栈\n\n   待更新\n\n3. 用栈实现队列\n\n   待更新\n\n4. 比较含退格的栈\n\n   待更新\n\n5. 基本计算器\n\n   待更新\n\n------\n\n# 四. 队列\n\n## 4.1 从一个问题开始\n\n当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池会如何处理这个请求，是拒绝请求还是排队请求？各种处理策略又是怎样实现的呢？\n\n> 一般有两种解决策略，一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队。那排队的队列是如何实现的呢——\n>\n> 我们知道，队列有基于数组和链表的实现方式。基于链表的实现方式，可以实现一个支持无限排队的无界队列，但对用户体验来说，着实不怎么友好。\n>\n> 基于数组实现的有界队列，队列的大小有限，当超过队列大小时，请求会被拒绝，这种方式对响应时间敏感的系统来说，相对比较合理。但设置一个合理的队列大小也非常有讲究，需要按照具体应用场景设计。\n\n## 4.2 概述\n\n队列是一种操作受限的线性表，对比栈，它同样支持入队和出队。操作时，**队头指针指向队头元素，队尾指针指向队尾元素的下一个内存空间。**\n\n## 4.3 五花八门的队列\n\n### 顺序队列的实现\n\n参考博文：https://blog.csdn.net/qq_48573752/article/details/113776915\n\n通过小例子来理解顺序队列的基础操作——\n\n![image-20210707230319078](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230319078.png)\n\n但是我们发现，当tail==n的时候，队列中还有空闲的空间，但却不能执行入队操作，这时要怎么办呢？\n\n数据搬移，也就是当tail==n时触发一次整体的数据搬移，这样的话，入队的时间复杂度就不再是O(1)，因为会涉及到数据的搬移，我们来看下新的入队操作：\n\n```java\npublic boolean enqueue(int item){\n    //无法执行入队操作\n    if(tail == n){\n        //空间已满\n        if(head == 0)\n            return false;\n        for(int i=0;i<tail-head;i++){\n\t\t   items[i] = items[head+i];\n        }\n        tail -= head;\n        head = 0;  \n    }\n    item[n++] = item;\n    return true;\n}\n```\n\n这样的入队操作无疑更严谨了一些。但这样还是太麻烦了些，有没有什么办法可以不进行数据搬移就可以入队呢，那就要看循环队列了。\n\n### 循环队列\n\n在循环队列中，应该注意的核心问题就是队列满的判别条件，我们画张图理解下——\n\n![image-20210707230332406](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230332406.png)\n\n再结合代码看下:\n\n参见博文：https://blog.csdn.net/qq_48573752/article/details/113776915\n\n### 并发队列与阻塞队列\n\n上面的队列都是我们耳闻能详的知识，而实际工程中应用更多的实则是并发队列与阻塞队列。\n\n> 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是**在队列为空的时候，从队头取数据会被阻塞**。因为此时还没有数据可取，直到队列中有了数据才能返回；**如果队列已经满了，那么插入数据的操作就会被阻塞**，直到队列中有空闲位置后再插入数据，然后再返回。\n>\n> **线程安全的队列我们叫作并发队列**。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上**加锁**，但是**锁粒度大并发度会比较低**，同一时刻仅允许一个存或者取操作。实际上，**基于数组的循环队列，利用 CAS 原子操作**，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。\n\n## 4.4  一点思考\n\n`Q`：如何实现无锁的并发队列？\n\n`A`：可以使用**数组+CAS机制**。在入队之前，获取tail位置，入队时比较tail是否发生了变化。如果否，允许入队。反之，入队失败。相应的，出队则是参照head的位置。\n\n------\n\n> 山高路远，静水深流","source":"_posts/四种基本的数据结构.md","raw":"---\ntitle: 四种基本的数据结构\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 16:05:33\npassword:\nsummary:\ncategories: 数据结构与算法\ntags: \n\t- 数据结构\n\t- 极客时间\n---\n\n> 在具体的算法题解之前，我会先简要的描述一些知识点，这些知识点都是基于数据结构与算法专栏的总结，对于详细的推理不再涉及，仅当做笔记使用。\n\n# 我们所熟识的数组\n\n## 1.1 从一个问题开始\n\n为什么大部分编程语言中，数组要从0开始编号，而不是从1开始？\n\n从数组存储的内存模型来看，数组的下标实际上指的是内存地址的偏移，假设用a表示数组的首地址，将数组元素的类型所占字节数计为type_size，那么**a[k]表示的含义就是存储在内存空间k*typesize+base_addr处的元素**，如果从1开始编号的，公式就变成了这样——\n$$\n(k-1)*typesize+base_addr\n$$\n也就是说，每次随机访问数组元素时多了一个减法操作，CPU多了一次减法指令的执行。\n\n## 1.2 数组概述\n\n**数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据**。\n\n数组的特性之一就是数组支持**随机访问**，根据下标随机访问的时间复杂度是O(1).而不基于下标访问数组元素最优的方式是二分查找，平均时间复杂度为O(logn).\n\n## 1.3 低效的插入与删除\n\n由于数组使用的是连续的内存空间，所以其在插入和删除元素时实际上需要两步：\n\n1. 进行**数据的搬移**\n2. 实际的**数据操作**\n\n因为涉及到元素的搬移，因此他们的**平均时间复杂度**是O(N),相对链表只操作指针就可以完成插入和删除来说，低效得多。\n\n## 1.4 令人头疼的数组越界问题\n\n数组在初始化时必须要指定数组的长度，但在使用时，并**没有机制约束操作数组长度以外的元素**，这就导致了越界问题，在java中，当处理的数组越界时，会抛出**java.lang.ArrayIndexOutOfBoundsException**异常，而在C语言中，就比较头疼了，需要自己时刻谨慎以防止数组越界。\n\n## 1.5 容器可以代替数组吗？\n\n容器ArrayList在数组的基础上封装了**增删改查及动态扩容**的操作，简化了开发流程。但同时也多了限制，即容器中**只能存储对象**，这就需要基本数据类型的装箱与拆箱，**降低了性能**。那什么情况下建议使用数组呢——\n\n> 1. 如果考虑性能，则使用数组\n> 2. 若数组大小事先已知且涉及到的数组操作非常简单，可以使用数组\n> 3. 对于底层的开发，如网络框架，性能优化，选择数组\n\n## 1.7 小练习\n\n如何理解JVM中标记清除垃圾回收算法的思想？\n\n我们知道删除数组元素是非常耗费性能的，如果涉及到多次删除，就需要多次搬移元素。这时可以先记录下已经删除的元素，但并不搬移数据，当数组没有更多的存储空间时，再触发真正的数据搬移。\n\n而关于jvm标记清除算法的详情，就请移步https://segmentfault.com/a/1190000037685570\n\n# 二.链表知识大派送\n\n------\n\n## 摘要\n\n确认过眼神，是熟悉的链表环节。从内存模型的角度来看，众多的数据结构都是在数组和链表的基础上衍生的。\n\n在链表的学习小节中，我们首先从一个通用的解决方案出发，接着谈及几种链表的基本结构，常用操作，以及不同结构的链表是怎样自然递进的。最后还将对数组与链表做一对比。话不多说，让我们启程吧——\n\n## 2.1 从一个问题开始\n\n我们知道，在操作系统中，为了解决从硬盘读取和从内存读写的速度不匹配问题，常常引入缓存这一概念。缓存家族可谓人丁兴旺，寄存器，浏览器缓存，数据库缓存大行其道。那缓存实现的机制是什么呢？\n\n那就是LRU缓存淘汰算法，在后期推出的操作系统系列博文中，你将对其有深入的了解。这里我们只讨论，如何**使用链表实现LRU缓存淘汰算法**，对此，王争老师的思路这样的——\n\n> 我们维护一个有序的单链表，越靠近链表尾部的节点是越早之前被插入的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历单链表。\n>\n> 假如这个元素之前被缓存在链表中，则将该元素从原来的位置删除，然后插入到链表的头部\n>\n> 如果该数据没有在缓存链表中，又可以分为两种情况：\n>\n> 1. 如果缓存未满，则将此节点直接插入到链表的头部\n> 2. 如果缓存已满，则将链表尾部的元素删除，再将该数据插入到链表的头部。\n>\n> 此外，还可以通过**散列表降低访问元素的时间复杂度**优化这个方案。\n\n## 2.2 五花八门的链表结构\n\n首先对链表下一个定义：\n\n> 区别于数组使用连续的内存空间，**链表通过指针将离散的内存块串联在一起。**\n\n定义中的内存块即是链表的节点，为了将所有节点串起来，每个节点**存储数据**以外，还需要**记录下一个节点的地址，也就是后继指针next。**\n\n常用的链表有三种，其中最简单常用的是单链表——\n\n### 2.2.1 单链表\n\n![image-20210707230130075](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230130075.png)\n\n我们习惯将第一个节点称为头结点，将最后一个节点称为尾结点，值得注意的是，尾结点不再指向一个地址，而指向null。\n\n与数组一样，链表也支持数据的查找，插入和删除。\n\n在插入，删除新元素时，只需要考虑相邻节点的指针改变——\n\n![image-20210707230140227](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230140227.png)\n\n在链表中查找元素是不方便的，必须顺序遍历链表，它的时间复杂度为O(n).\n\n### 2.2.2 循环链表\n\n循环链表是特殊的单链表，它与单链表的区别就在于尾结点。循环链表的尾结点指针指向的是头结点。那么这么结构适用于什么场景呢？\n\n它可以用来高效的解决**环结构的链表**，比如著名的**约瑟夫环**问题。\n\n在实际应用中，被更多使用的要属双向链表，我们来看下它特定的结构得以应用于什么场景呢。。。\n\n### 2.2.3 双向链表\n\n双向链表在单链表的基础上增加了前驱节点prev，这样双向链表就可以实现反向遍历，对于找特定节点的前驱节点的时间复杂为O(1)。双向链表降低了遍历链表时的复杂度，但同时也带来了内存的损耗。是一种使用空间换时间的策略\n\n### 2.2.4 双向链表高效在哪呢\n\n我们知道，删除链表元素的场景分为两类：\n\n1. 删除值等于给定值的节点\n2. 删除给定指针指向的节点\n\n对于第一种情况，没有捷径可走，只能去逐个遍历节点元素。而对于第二个节点，双向链表增加了通过前驱指针找给定节点的遍历，因此高效的多。同样的，插入一个节点时，使用双向链表也提供了更多的可能。\n\n既然双向链表这么牛，那实际应用场景中有没有双向链表的大展身手呢，那就是LinkedHashMap,这种高效的集合底层即是使用了这种数据结构。\n\n看到这，很多朋友会问，既然双向链表的效率这么高，那再给他加上循环链表的特点岂不是如虎添翼，的确如此，我们来看究极版——\n![image-20210707230151299](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230151299.png)\n\n## 2.3 链表VS数组性能大比拼\n\n这里不再俗套的给出很多理论，而是通过具体的应用场景来考虑数组与链表性能——\n\nCPU缓存应该哪种数据结构呢？CPU管理的是连续的内存空间，使用链表简直天然地不友好，所以使用数组。而对于一个插入删除更频繁的系统来说，使用数组则更众望所归。其实抛开场景说数据结构就是耍流氓，在之前的定义中，我们就提及，数据结构是用于特定场景的。\n\n## 2.4 如何轻松的写出正确的链表代码\n\n链表的代码因为涉及到指针的操作，往往空想起来比较绕，要想高效地写出链表代码，我们还需要一些技巧——\n\n1. **理解指针或者引用的含义**\n\n   将某个变量赋给指针，实际上就是将这个变量的地址赋值给指针，引用同样如是。\n\n2. **警惕指针丢失和内存泄漏**\n\n   链表的操作往往是有序的，此外，在删除元素时，一定要手动释放内存空间(C语言).\n\n3. **利用哨兵简化实现难度**\n\n   对原生的单链表删除尾结点和插入第一个节点时，需要做特殊处理。这种边界条件能不能简化成通用的情况呢？\n\n   当然可以，我们使用哨兵机制来实现，即在第一个节点之前加入head节点，head节点不存储数据，它指向链表的第一个节点。这里需要注意区分head节点和第一个节点，他们的定义是不同的！\n\n4. **重点留意边界条件**\n\n   常见的边界处理条件有那么几个\n\n   1. **如果链表为空，代码是否能正常运行**\n   2. **如果链表只包含一个节点时，代码是否能正常工作**\n   3. **如果链表只包含两个节点时，代码是否能正常工作**\n   4. **代码逻辑在处理头结点和尾结点时，代码是否能正常工作。**\n\n5. **举例画图，辅助思考**\n\n   非常有必要，脑子不是那么靠谱的时候，就需要动手啦。\n\n6. **多写多练，没有捷径**\n\n------\n\n# 三.更进一步——关于栈\n\n## 3.1 从一个问题开始\n\n我们在浏览网站时都会用到前进和后退的功能，那这种功能是如何实现的你知道吗？\n\n没错，就是使用这节我们会讲到的栈，针对这个需求，假设将我们浏览的网页按照先后顺序存储在一个数组中，我们根据下标，即可实现前进和后退，但这里有一个致命的BUG，那就是它无法按我们的需求去删减一些存储在数组中的网页，也正因此我们需要引入栈。\n\n假设我们依次访问了三个网页A,B,C，那栈的情况是这样的——\n\n![image-20210707230201483](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230201483.png)\n\n这时，我们想回退到a页面了，就需要出栈c,b到栈Y中——\n![image-20210707230229659](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230229659.png)\n\n然后，我们再去访问页面d:就会入栈X，如果我们再想访问页面b,c就不行了，栈Y会清空栈中的内容\n\n## 3.2 为什么要学习栈\n\n栈是一种操作受限的线性表，从功能上来说，数组异或链表都可以实现栈。但是数组或是链表都暴露了太多的接口，这就需要我们非常注意邻界条件。\n\n而特定的数据结构是对特定情境的抽象，对于某些场景来说，用栈就很合适了。\n\n当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特点时，我们就应该首选使用栈。\n\n## 3.3 怎样学习栈？\n\n### 实现一个栈\n\n可以查看我的另一篇关于**队列和栈基础应用的博文**：\n\n### 支持动态扩容的顺序栈\n\n我们先来分析下入栈和出栈的时间复杂度，出栈时，时间复杂度为O(1)没有悬念，而入栈时假如还有空间，那时间复杂度自然也是O(1)，但当栈满的时候入栈，就需要扩容，这里的时间复杂度用均摊时间复杂度理解仍为O(1).\n\n既然，我们需要扩容这种机制，而栈本身又可以使用数组实现。不妨用栈来继承一个可以实现动态扩容的集合。\n\n实际上，java就是这样做的——\n\n![image-20210707230239639](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230239639.png)\n\n当需要扩容时，会将数组大小扩展为原来的2倍：\n\n![image-20210707230251442](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230251442.png)\n\n### 栈的应用\n\n栈在函数调用，括号匹配，表达式运算方面有广泛的应用，我们一一来看——\n\n`函数调用` ：\n\n> 我们知道，操作系统给给每个线程分配了一个独立的内存空间，这块内存被组织为栈这种结构。用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈\n\n`表达式运算`\n\n> 编译器实则就是使用两个栈来实现的。其中一个是保存操作数的栈，另一个是保存运算符的栈。当我们从左到右遍历表达式，当遇到数据，我们直接压入操作数栈。\n>\n> 当遇到运算符时，首先与运算符栈的栈顶运算符进行比较，如果比栈顶运算符的优先级低或者相等，则从运算符栈取出栈顶元素，然后从操作数栈取两个元素进行运算，并将运算结果压入操作数栈，继续比较。来看下王争老师的举例——\n>\n> ![image-20210707230302756](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230302756.png)\n\n`括号匹配`\n\n> 这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。\n> 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。\n\n### 面试常考的练习题集锦\n\n1. 有效的括号\n\n   待更新\n\n2. 最小栈\n\n   待更新\n\n3. 用栈实现队列\n\n   待更新\n\n4. 比较含退格的栈\n\n   待更新\n\n5. 基本计算器\n\n   待更新\n\n------\n\n# 四. 队列\n\n## 4.1 从一个问题开始\n\n当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池会如何处理这个请求，是拒绝请求还是排队请求？各种处理策略又是怎样实现的呢？\n\n> 一般有两种解决策略，一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队。那排队的队列是如何实现的呢——\n>\n> 我们知道，队列有基于数组和链表的实现方式。基于链表的实现方式，可以实现一个支持无限排队的无界队列，但对用户体验来说，着实不怎么友好。\n>\n> 基于数组实现的有界队列，队列的大小有限，当超过队列大小时，请求会被拒绝，这种方式对响应时间敏感的系统来说，相对比较合理。但设置一个合理的队列大小也非常有讲究，需要按照具体应用场景设计。\n\n## 4.2 概述\n\n队列是一种操作受限的线性表，对比栈，它同样支持入队和出队。操作时，**队头指针指向队头元素，队尾指针指向队尾元素的下一个内存空间。**\n\n## 4.3 五花八门的队列\n\n### 顺序队列的实现\n\n参考博文：https://blog.csdn.net/qq_48573752/article/details/113776915\n\n通过小例子来理解顺序队列的基础操作——\n\n![image-20210707230319078](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230319078.png)\n\n但是我们发现，当tail==n的时候，队列中还有空闲的空间，但却不能执行入队操作，这时要怎么办呢？\n\n数据搬移，也就是当tail==n时触发一次整体的数据搬移，这样的话，入队的时间复杂度就不再是O(1)，因为会涉及到数据的搬移，我们来看下新的入队操作：\n\n```java\npublic boolean enqueue(int item){\n    //无法执行入队操作\n    if(tail == n){\n        //空间已满\n        if(head == 0)\n            return false;\n        for(int i=0;i<tail-head;i++){\n\t\t   items[i] = items[head+i];\n        }\n        tail -= head;\n        head = 0;  \n    }\n    item[n++] = item;\n    return true;\n}\n```\n\n这样的入队操作无疑更严谨了一些。但这样还是太麻烦了些，有没有什么办法可以不进行数据搬移就可以入队呢，那就要看循环队列了。\n\n### 循环队列\n\n在循环队列中，应该注意的核心问题就是队列满的判别条件，我们画张图理解下——\n\n![image-20210707230332406](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230332406.png)\n\n再结合代码看下:\n\n参见博文：https://blog.csdn.net/qq_48573752/article/details/113776915\n\n### 并发队列与阻塞队列\n\n上面的队列都是我们耳闻能详的知识，而实际工程中应用更多的实则是并发队列与阻塞队列。\n\n> 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是**在队列为空的时候，从队头取数据会被阻塞**。因为此时还没有数据可取，直到队列中有了数据才能返回；**如果队列已经满了，那么插入数据的操作就会被阻塞**，直到队列中有空闲位置后再插入数据，然后再返回。\n>\n> **线程安全的队列我们叫作并发队列**。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上**加锁**，但是**锁粒度大并发度会比较低**，同一时刻仅允许一个存或者取操作。实际上，**基于数组的循环队列，利用 CAS 原子操作**，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。\n\n## 4.4  一点思考\n\n`Q`：如何实现无锁的并发队列？\n\n`A`：可以使用**数组+CAS机制**。在入队之前，获取tail位置，入队时比较tail是否发生了变化。如果否，允许入队。反之，入队失败。相应的，出队则是参照head的位置。\n\n------\n\n> 山高路远，静水深流","slug":"四种基本的数据结构","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7lz001sxjccfvg23dfi","content":"<blockquote>\n<p>在具体的算法题解之前，我会先简要的描述一些知识点，这些知识点都是基于数据结构与算法专栏的总结，对于详细的推理不再涉及，仅当做笔记使用。</p>\n</blockquote>\n<h1 id=\"我们所熟识的数组\"><a href=\"#我们所熟识的数组\" class=\"headerlink\" title=\"我们所熟识的数组\"></a>我们所熟识的数组</h1><h2 id=\"1-1-从一个问题开始\"><a href=\"#1-1-从一个问题开始\" class=\"headerlink\" title=\"1.1 从一个问题开始\"></a>1.1 从一个问题开始</h2><p>为什么大部分编程语言中，数组要从0开始编号，而不是从1开始？</p>\n<p>从数组存储的内存模型来看，数组的下标实际上指的是内存地址的偏移，假设用a表示数组的首地址，将数组元素的类型所占字节数计为type_size，那么<strong>a[k]表示的含义就是存储在内存空间k*typesize+base_addr处的元素</strong>，如果从1开始编号的，公式就变成了这样——<br>$$<br>(k-1)*typesize+base_addr<br>$$<br>也就是说，每次随机访问数组元素时多了一个减法操作，CPU多了一次减法指令的执行。</p>\n<h2 id=\"1-2-数组概述\"><a href=\"#1-2-数组概述\" class=\"headerlink\" title=\"1.2 数组概述\"></a>1.2 数组概述</h2><p><strong>数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据</strong>。</p>\n<p>数组的特性之一就是数组支持<strong>随机访问</strong>，根据下标随机访问的时间复杂度是O(1).而不基于下标访问数组元素最优的方式是二分查找，平均时间复杂度为O(logn).</p>\n<h2 id=\"1-3-低效的插入与删除\"><a href=\"#1-3-低效的插入与删除\" class=\"headerlink\" title=\"1.3 低效的插入与删除\"></a>1.3 低效的插入与删除</h2><p>由于数组使用的是连续的内存空间，所以其在插入和删除元素时实际上需要两步：</p>\n<ol>\n<li>进行<strong>数据的搬移</strong></li>\n<li>实际的<strong>数据操作</strong></li>\n</ol>\n<p>因为涉及到元素的搬移，因此他们的<strong>平均时间复杂度</strong>是O(N),相对链表只操作指针就可以完成插入和删除来说，低效得多。</p>\n<h2 id=\"1-4-令人头疼的数组越界问题\"><a href=\"#1-4-令人头疼的数组越界问题\" class=\"headerlink\" title=\"1.4 令人头疼的数组越界问题\"></a>1.4 令人头疼的数组越界问题</h2><p>数组在初始化时必须要指定数组的长度，但在使用时，并<strong>没有机制约束操作数组长度以外的元素</strong>，这就导致了越界问题，在java中，当处理的数组越界时，会抛出<strong>java.lang.ArrayIndexOutOfBoundsException</strong>异常，而在C语言中，就比较头疼了，需要自己时刻谨慎以防止数组越界。</p>\n<h2 id=\"1-5-容器可以代替数组吗？\"><a href=\"#1-5-容器可以代替数组吗？\" class=\"headerlink\" title=\"1.5 容器可以代替数组吗？\"></a>1.5 容器可以代替数组吗？</h2><p>容器ArrayList在数组的基础上封装了<strong>增删改查及动态扩容</strong>的操作，简化了开发流程。但同时也多了限制，即容器中<strong>只能存储对象</strong>，这就需要基本数据类型的装箱与拆箱，<strong>降低了性能</strong>。那什么情况下建议使用数组呢——</p>\n<blockquote>\n<ol>\n<li>如果考虑性能，则使用数组</li>\n<li>若数组大小事先已知且涉及到的数组操作非常简单，可以使用数组</li>\n<li>对于底层的开发，如网络框架，性能优化，选择数组</li>\n</ol>\n</blockquote>\n<h2 id=\"1-7-小练习\"><a href=\"#1-7-小练习\" class=\"headerlink\" title=\"1.7 小练习\"></a>1.7 小练习</h2><p>如何理解JVM中标记清除垃圾回收算法的思想？</p>\n<p>我们知道删除数组元素是非常耗费性能的，如果涉及到多次删除，就需要多次搬移元素。这时可以先记录下已经删除的元素，但并不搬移数据，当数组没有更多的存储空间时，再触发真正的数据搬移。</p>\n<p>而关于jvm标记清除算法的详情，就请移步<a href=\"https://segmentfault.com/a/1190000037685570\">https://segmentfault.com/a/1190000037685570</a></p>\n<h1 id=\"二-链表知识大派送\"><a href=\"#二-链表知识大派送\" class=\"headerlink\" title=\"二.链表知识大派送\"></a>二.链表知识大派送</h1><hr>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>确认过眼神，是熟悉的链表环节。从内存模型的角度来看，众多的数据结构都是在数组和链表的基础上衍生的。</p>\n<p>在链表的学习小节中，我们首先从一个通用的解决方案出发，接着谈及几种链表的基本结构，常用操作，以及不同结构的链表是怎样自然递进的。最后还将对数组与链表做一对比。话不多说，让我们启程吧——</p>\n<h2 id=\"2-1-从一个问题开始\"><a href=\"#2-1-从一个问题开始\" class=\"headerlink\" title=\"2.1 从一个问题开始\"></a>2.1 从一个问题开始</h2><p>我们知道，在操作系统中，为了解决从硬盘读取和从内存读写的速度不匹配问题，常常引入缓存这一概念。缓存家族可谓人丁兴旺，寄存器，浏览器缓存，数据库缓存大行其道。那缓存实现的机制是什么呢？</p>\n<p>那就是LRU缓存淘汰算法，在后期推出的操作系统系列博文中，你将对其有深入的了解。这里我们只讨论，如何<strong>使用链表实现LRU缓存淘汰算法</strong>，对此，王争老师的思路这样的——</p>\n<blockquote>\n<p>我们维护一个有序的单链表，越靠近链表尾部的节点是越早之前被插入的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历单链表。</p>\n<p>假如这个元素之前被缓存在链表中，则将该元素从原来的位置删除，然后插入到链表的头部</p>\n<p>如果该数据没有在缓存链表中，又可以分为两种情况：</p>\n<ol>\n<li>如果缓存未满，则将此节点直接插入到链表的头部</li>\n<li>如果缓存已满，则将链表尾部的元素删除，再将该数据插入到链表的头部。</li>\n</ol>\n<p>此外，还可以通过<strong>散列表降低访问元素的时间复杂度</strong>优化这个方案。</p>\n</blockquote>\n<h2 id=\"2-2-五花八门的链表结构\"><a href=\"#2-2-五花八门的链表结构\" class=\"headerlink\" title=\"2.2 五花八门的链表结构\"></a>2.2 五花八门的链表结构</h2><p>首先对链表下一个定义：</p>\n<blockquote>\n<p>区别于数组使用连续的内存空间，<strong>链表通过指针将离散的内存块串联在一起。</strong></p>\n</blockquote>\n<p>定义中的内存块即是链表的节点，为了将所有节点串起来，每个节点<strong>存储数据</strong>以外，还需要<strong>记录下一个节点的地址，也就是后继指针next。</strong></p>\n<p>常用的链表有三种，其中最简单常用的是单链表——</p>\n<h3 id=\"2-2-1-单链表\"><a href=\"#2-2-1-单链表\" class=\"headerlink\" title=\"2.2.1 单链表\"></a>2.2.1 单链表</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230130075.png\" alt=\"image-20210707230130075\"></p>\n<p>我们习惯将第一个节点称为头结点，将最后一个节点称为尾结点，值得注意的是，尾结点不再指向一个地址，而指向null。</p>\n<p>与数组一样，链表也支持数据的查找，插入和删除。</p>\n<p>在插入，删除新元素时，只需要考虑相邻节点的指针改变——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230140227.png\" alt=\"image-20210707230140227\"></p>\n<p>在链表中查找元素是不方便的，必须顺序遍历链表，它的时间复杂度为O(n).</p>\n<h3 id=\"2-2-2-循环链表\"><a href=\"#2-2-2-循环链表\" class=\"headerlink\" title=\"2.2.2 循环链表\"></a>2.2.2 循环链表</h3><p>循环链表是特殊的单链表，它与单链表的区别就在于尾结点。循环链表的尾结点指针指向的是头结点。那么这么结构适用于什么场景呢？</p>\n<p>它可以用来高效的解决<strong>环结构的链表</strong>，比如著名的<strong>约瑟夫环</strong>问题。</p>\n<p>在实际应用中，被更多使用的要属双向链表，我们来看下它特定的结构得以应用于什么场景呢。。。</p>\n<h3 id=\"2-2-3-双向链表\"><a href=\"#2-2-3-双向链表\" class=\"headerlink\" title=\"2.2.3 双向链表\"></a>2.2.3 双向链表</h3><p>双向链表在单链表的基础上增加了前驱节点prev，这样双向链表就可以实现反向遍历，对于找特定节点的前驱节点的时间复杂为O(1)。双向链表降低了遍历链表时的复杂度，但同时也带来了内存的损耗。是一种使用空间换时间的策略</p>\n<h3 id=\"2-2-4-双向链表高效在哪呢\"><a href=\"#2-2-4-双向链表高效在哪呢\" class=\"headerlink\" title=\"2.2.4 双向链表高效在哪呢\"></a>2.2.4 双向链表高效在哪呢</h3><p>我们知道，删除链表元素的场景分为两类：</p>\n<ol>\n<li>删除值等于给定值的节点</li>\n<li>删除给定指针指向的节点</li>\n</ol>\n<p>对于第一种情况，没有捷径可走，只能去逐个遍历节点元素。而对于第二个节点，双向链表增加了通过前驱指针找给定节点的遍历，因此高效的多。同样的，插入一个节点时，使用双向链表也提供了更多的可能。</p>\n<p>既然双向链表这么牛，那实际应用场景中有没有双向链表的大展身手呢，那就是LinkedHashMap,这种高效的集合底层即是使用了这种数据结构。</p>\n<p>看到这，很多朋友会问，既然双向链表的效率这么高，那再给他加上循环链表的特点岂不是如虎添翼，的确如此，我们来看究极版——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230151299.png\" alt=\"image-20210707230151299\"></p>\n<h2 id=\"2-3-链表VS数组性能大比拼\"><a href=\"#2-3-链表VS数组性能大比拼\" class=\"headerlink\" title=\"2.3 链表VS数组性能大比拼\"></a>2.3 链表VS数组性能大比拼</h2><p>这里不再俗套的给出很多理论，而是通过具体的应用场景来考虑数组与链表性能——</p>\n<p>CPU缓存应该哪种数据结构呢？CPU管理的是连续的内存空间，使用链表简直天然地不友好，所以使用数组。而对于一个插入删除更频繁的系统来说，使用数组则更众望所归。其实抛开场景说数据结构就是耍流氓，在之前的定义中，我们就提及，数据结构是用于特定场景的。</p>\n<h2 id=\"2-4-如何轻松的写出正确的链表代码\"><a href=\"#2-4-如何轻松的写出正确的链表代码\" class=\"headerlink\" title=\"2.4 如何轻松的写出正确的链表代码\"></a>2.4 如何轻松的写出正确的链表代码</h2><p>链表的代码因为涉及到指针的操作，往往空想起来比较绕，要想高效地写出链表代码，我们还需要一些技巧——</p>\n<ol>\n<li><p><strong>理解指针或者引用的含义</strong></p>\n<p>将某个变量赋给指针，实际上就是将这个变量的地址赋值给指针，引用同样如是。</p>\n</li>\n<li><p><strong>警惕指针丢失和内存泄漏</strong></p>\n<p>链表的操作往往是有序的，此外，在删除元素时，一定要手动释放内存空间(C语言).</p>\n</li>\n<li><p><strong>利用哨兵简化实现难度</strong></p>\n<p>对原生的单链表删除尾结点和插入第一个节点时，需要做特殊处理。这种边界条件能不能简化成通用的情况呢？</p>\n<p>当然可以，我们使用哨兵机制来实现，即在第一个节点之前加入head节点，head节点不存储数据，它指向链表的第一个节点。这里需要注意区分head节点和第一个节点，他们的定义是不同的！</p>\n</li>\n<li><p><strong>重点留意边界条件</strong></p>\n<p>常见的边界处理条件有那么几个</p>\n<ol>\n<li><strong>如果链表为空，代码是否能正常运行</strong></li>\n<li><strong>如果链表只包含一个节点时，代码是否能正常工作</strong></li>\n<li><strong>如果链表只包含两个节点时，代码是否能正常工作</strong></li>\n<li><strong>代码逻辑在处理头结点和尾结点时，代码是否能正常工作。</strong></li>\n</ol>\n</li>\n<li><p><strong>举例画图，辅助思考</strong></p>\n<p>非常有必要，脑子不是那么靠谱的时候，就需要动手啦。</p>\n</li>\n<li><p><strong>多写多练，没有捷径</strong></p>\n</li>\n</ol>\n<hr>\n<h1 id=\"三-更进一步——关于栈\"><a href=\"#三-更进一步——关于栈\" class=\"headerlink\" title=\"三.更进一步——关于栈\"></a>三.更进一步——关于栈</h1><h2 id=\"3-1-从一个问题开始\"><a href=\"#3-1-从一个问题开始\" class=\"headerlink\" title=\"3.1 从一个问题开始\"></a>3.1 从一个问题开始</h2><p>我们在浏览网站时都会用到前进和后退的功能，那这种功能是如何实现的你知道吗？</p>\n<p>没错，就是使用这节我们会讲到的栈，针对这个需求，假设将我们浏览的网页按照先后顺序存储在一个数组中，我们根据下标，即可实现前进和后退，但这里有一个致命的BUG，那就是它无法按我们的需求去删减一些存储在数组中的网页，也正因此我们需要引入栈。</p>\n<p>假设我们依次访问了三个网页A,B,C，那栈的情况是这样的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230201483.png\" alt=\"image-20210707230201483\"></p>\n<p>这时，我们想回退到a页面了，就需要出栈c,b到栈Y中——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230229659.png\" alt=\"image-20210707230229659\"></p>\n<p>然后，我们再去访问页面d:就会入栈X，如果我们再想访问页面b,c就不行了，栈Y会清空栈中的内容</p>\n<h2 id=\"3-2-为什么要学习栈\"><a href=\"#3-2-为什么要学习栈\" class=\"headerlink\" title=\"3.2 为什么要学习栈\"></a>3.2 为什么要学习栈</h2><p>栈是一种操作受限的线性表，从功能上来说，数组异或链表都可以实现栈。但是数组或是链表都暴露了太多的接口，这就需要我们非常注意邻界条件。</p>\n<p>而特定的数据结构是对特定情境的抽象，对于某些场景来说，用栈就很合适了。</p>\n<p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特点时，我们就应该首选使用栈。</p>\n<h2 id=\"3-3-怎样学习栈？\"><a href=\"#3-3-怎样学习栈？\" class=\"headerlink\" title=\"3.3 怎样学习栈？\"></a>3.3 怎样学习栈？</h2><h3 id=\"实现一个栈\"><a href=\"#实现一个栈\" class=\"headerlink\" title=\"实现一个栈\"></a>实现一个栈</h3><p>可以查看我的另一篇关于<strong>队列和栈基础应用的博文</strong>：</p>\n<h3 id=\"支持动态扩容的顺序栈\"><a href=\"#支持动态扩容的顺序栈\" class=\"headerlink\" title=\"支持动态扩容的顺序栈\"></a>支持动态扩容的顺序栈</h3><p>我们先来分析下入栈和出栈的时间复杂度，出栈时，时间复杂度为O(1)没有悬念，而入栈时假如还有空间，那时间复杂度自然也是O(1)，但当栈满的时候入栈，就需要扩容，这里的时间复杂度用均摊时间复杂度理解仍为O(1).</p>\n<p>既然，我们需要扩容这种机制，而栈本身又可以使用数组实现。不妨用栈来继承一个可以实现动态扩容的集合。</p>\n<p>实际上，java就是这样做的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230239639.png\" alt=\"image-20210707230239639\"></p>\n<p>当需要扩容时，会将数组大小扩展为原来的2倍：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230251442.png\" alt=\"image-20210707230251442\"></p>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><p>栈在函数调用，括号匹配，表达式运算方面有广泛的应用，我们一一来看——</p>\n<p><code>函数调用</code> ：</p>\n<blockquote>\n<p>我们知道，操作系统给给每个线程分配了一个独立的内存空间，这块内存被组织为栈这种结构。用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈</p>\n</blockquote>\n<p><code>表达式运算</code></p>\n<blockquote>\n<p>编译器实则就是使用两个栈来实现的。其中一个是保存操作数的栈，另一个是保存运算符的栈。当我们从左到右遍历表达式，当遇到数据，我们直接压入操作数栈。</p>\n<p>当遇到运算符时，首先与运算符栈的栈顶运算符进行比较，如果比栈顶运算符的优先级低或者相等，则从运算符栈取出栈顶元素，然后从操作数栈取两个元素进行运算，并将运算结果压入操作数栈，继续比较。来看下王争老师的举例——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230302756.png\" alt=\"image-20210707230302756\"></p>\n</blockquote>\n<p><code>括号匹配</code></p>\n<blockquote>\n<p>这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>\n</blockquote>\n<h3 id=\"面试常考的练习题集锦\"><a href=\"#面试常考的练习题集锦\" class=\"headerlink\" title=\"面试常考的练习题集锦\"></a>面试常考的练习题集锦</h3><ol>\n<li><p>有效的括号</p>\n<p>待更新</p>\n</li>\n<li><p>最小栈</p>\n<p>待更新</p>\n</li>\n<li><p>用栈实现队列</p>\n<p>待更新</p>\n</li>\n<li><p>比较含退格的栈</p>\n<p>待更新</p>\n</li>\n<li><p>基本计算器</p>\n<p>待更新</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"四-队列\"><a href=\"#四-队列\" class=\"headerlink\" title=\"四. 队列\"></a>四. 队列</h1><h2 id=\"4-1-从一个问题开始\"><a href=\"#4-1-从一个问题开始\" class=\"headerlink\" title=\"4.1 从一个问题开始\"></a>4.1 从一个问题开始</h2><p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池会如何处理这个请求，是拒绝请求还是排队请求？各种处理策略又是怎样实现的呢？</p>\n<blockquote>\n<p>一般有两种解决策略，一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队。那排队的队列是如何实现的呢——</p>\n<p>我们知道，队列有基于数组和链表的实现方式。基于链表的实现方式，可以实现一个支持无限排队的无界队列，但对用户体验来说，着实不怎么友好。</p>\n<p>基于数组实现的有界队列，队列的大小有限，当超过队列大小时，请求会被拒绝，这种方式对响应时间敏感的系统来说，相对比较合理。但设置一个合理的队列大小也非常有讲究，需要按照具体应用场景设计。</p>\n</blockquote>\n<h2 id=\"4-2-概述\"><a href=\"#4-2-概述\" class=\"headerlink\" title=\"4.2 概述\"></a>4.2 概述</h2><p>队列是一种操作受限的线性表，对比栈，它同样支持入队和出队。操作时，<strong>队头指针指向队头元素，队尾指针指向队尾元素的下一个内存空间。</strong></p>\n<h2 id=\"4-3-五花八门的队列\"><a href=\"#4-3-五花八门的队列\" class=\"headerlink\" title=\"4.3 五花八门的队列\"></a>4.3 五花八门的队列</h2><h3 id=\"顺序队列的实现\"><a href=\"#顺序队列的实现\" class=\"headerlink\" title=\"顺序队列的实现\"></a>顺序队列的实现</h3><p>参考博文：<a href=\"https://blog.csdn.net/qq_48573752/article/details/113776915\">https://blog.csdn.net/qq_48573752/article/details/113776915</a></p>\n<p>通过小例子来理解顺序队列的基础操作——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230319078.png\" alt=\"image-20210707230319078\"></p>\n<p>但是我们发现，当tail==n的时候，队列中还有空闲的空间，但却不能执行入队操作，这时要怎么办呢？</p>\n<p>数据搬移，也就是当tail==n时触发一次整体的数据搬移，这样的话，入队的时间复杂度就不再是O(1)，因为会涉及到数据的搬移，我们来看下新的入队操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//无法执行入队操作</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tail <span class=\"token operator\">==</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//空间已满</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>tail<span class=\"token operator\">-</span>head<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\t   items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> items<span class=\"token punctuation\">[</span>head<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        tail <span class=\"token operator\">-=</span> head<span class=\"token punctuation\">;</span>\n        head <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">&#125;</span>\n    item<span class=\"token punctuation\">[</span>n<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> item<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样的入队操作无疑更严谨了一些。但这样还是太麻烦了些，有没有什么办法可以不进行数据搬移就可以入队呢，那就要看循环队列了。</p>\n<h3 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h3><p>在循环队列中，应该注意的核心问题就是队列满的判别条件，我们画张图理解下——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230332406.png\" alt=\"image-20210707230332406\"></p>\n<p>再结合代码看下:</p>\n<p>参见博文：<a href=\"https://blog.csdn.net/qq_48573752/article/details/113776915\">https://blog.csdn.net/qq_48573752/article/details/113776915</a></p>\n<h3 id=\"并发队列与阻塞队列\"><a href=\"#并发队列与阻塞队列\" class=\"headerlink\" title=\"并发队列与阻塞队列\"></a>并发队列与阻塞队列</h3><p>上面的队列都是我们耳闻能详的知识，而实际工程中应用更多的实则是并发队列与阻塞队列。</p>\n<blockquote>\n<p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是<strong>在队列为空的时候，从队头取数据会被阻塞</strong>。因为此时还没有数据可取，直到队列中有了数据才能返回；<strong>如果队列已经满了，那么插入数据的操作就会被阻塞</strong>，直到队列中有空闲位置后再插入数据，然后再返回。</p>\n<p><strong>线程安全的队列我们叫作并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上<strong>加锁</strong>，但是<strong>锁粒度大并发度会比较低</strong>，同一时刻仅允许一个存或者取操作。实际上，<strong>基于数组的循环队列，利用 CAS 原子操作</strong>，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>\n</blockquote>\n<h2 id=\"4-4-一点思考\"><a href=\"#4-4-一点思考\" class=\"headerlink\" title=\"4.4  一点思考\"></a>4.4  一点思考</h2><p><code>Q</code>：如何实现无锁的并发队列？</p>\n<p><code>A</code>：可以使用<strong>数组+CAS机制</strong>。在入队之前，获取tail位置，入队时比较tail是否发生了变化。如果否，允许入队。反之，入队失败。相应的，出队则是参照head的位置。</p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在具体的算法题解之前，我会先简要的描述一些知识点，这些知识点都是基于数据结构与算法专栏的总结，对于详细的推理不再涉及，仅当做笔记使用。</p>\n</blockquote>\n<h1 id=\"我们所熟识的数组\"><a href=\"#我们所熟识的数组\" class=\"headerlink\" title=\"我们所熟识的数组\"></a>我们所熟识的数组</h1><h2 id=\"1-1-从一个问题开始\"><a href=\"#1-1-从一个问题开始\" class=\"headerlink\" title=\"1.1 从一个问题开始\"></a>1.1 从一个问题开始</h2><p>为什么大部分编程语言中，数组要从0开始编号，而不是从1开始？</p>\n<p>从数组存储的内存模型来看，数组的下标实际上指的是内存地址的偏移，假设用a表示数组的首地址，将数组元素的类型所占字节数计为type_size，那么<strong>a[k]表示的含义就是存储在内存空间k*typesize+base_addr处的元素</strong>，如果从1开始编号的，公式就变成了这样——<br>$$<br>(k-1)*typesize+base_addr<br>$$<br>也就是说，每次随机访问数组元素时多了一个减法操作，CPU多了一次减法指令的执行。</p>\n<h2 id=\"1-2-数组概述\"><a href=\"#1-2-数组概述\" class=\"headerlink\" title=\"1.2 数组概述\"></a>1.2 数组概述</h2><p><strong>数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据</strong>。</p>\n<p>数组的特性之一就是数组支持<strong>随机访问</strong>，根据下标随机访问的时间复杂度是O(1).而不基于下标访问数组元素最优的方式是二分查找，平均时间复杂度为O(logn).</p>\n<h2 id=\"1-3-低效的插入与删除\"><a href=\"#1-3-低效的插入与删除\" class=\"headerlink\" title=\"1.3 低效的插入与删除\"></a>1.3 低效的插入与删除</h2><p>由于数组使用的是连续的内存空间，所以其在插入和删除元素时实际上需要两步：</p>\n<ol>\n<li>进行<strong>数据的搬移</strong></li>\n<li>实际的<strong>数据操作</strong></li>\n</ol>\n<p>因为涉及到元素的搬移，因此他们的<strong>平均时间复杂度</strong>是O(N),相对链表只操作指针就可以完成插入和删除来说，低效得多。</p>\n<h2 id=\"1-4-令人头疼的数组越界问题\"><a href=\"#1-4-令人头疼的数组越界问题\" class=\"headerlink\" title=\"1.4 令人头疼的数组越界问题\"></a>1.4 令人头疼的数组越界问题</h2><p>数组在初始化时必须要指定数组的长度，但在使用时，并<strong>没有机制约束操作数组长度以外的元素</strong>，这就导致了越界问题，在java中，当处理的数组越界时，会抛出<strong>java.lang.ArrayIndexOutOfBoundsException</strong>异常，而在C语言中，就比较头疼了，需要自己时刻谨慎以防止数组越界。</p>\n<h2 id=\"1-5-容器可以代替数组吗？\"><a href=\"#1-5-容器可以代替数组吗？\" class=\"headerlink\" title=\"1.5 容器可以代替数组吗？\"></a>1.5 容器可以代替数组吗？</h2><p>容器ArrayList在数组的基础上封装了<strong>增删改查及动态扩容</strong>的操作，简化了开发流程。但同时也多了限制，即容器中<strong>只能存储对象</strong>，这就需要基本数据类型的装箱与拆箱，<strong>降低了性能</strong>。那什么情况下建议使用数组呢——</p>\n<blockquote>\n<ol>\n<li>如果考虑性能，则使用数组</li>\n<li>若数组大小事先已知且涉及到的数组操作非常简单，可以使用数组</li>\n<li>对于底层的开发，如网络框架，性能优化，选择数组</li>\n</ol>\n</blockquote>\n<h2 id=\"1-7-小练习\"><a href=\"#1-7-小练习\" class=\"headerlink\" title=\"1.7 小练习\"></a>1.7 小练习</h2><p>如何理解JVM中标记清除垃圾回收算法的思想？</p>\n<p>我们知道删除数组元素是非常耗费性能的，如果涉及到多次删除，就需要多次搬移元素。这时可以先记录下已经删除的元素，但并不搬移数据，当数组没有更多的存储空间时，再触发真正的数据搬移。</p>\n<p>而关于jvm标记清除算法的详情，就请移步<a href=\"https://segmentfault.com/a/1190000037685570\">https://segmentfault.com/a/1190000037685570</a></p>\n<h1 id=\"二-链表知识大派送\"><a href=\"#二-链表知识大派送\" class=\"headerlink\" title=\"二.链表知识大派送\"></a>二.链表知识大派送</h1><hr>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>确认过眼神，是熟悉的链表环节。从内存模型的角度来看，众多的数据结构都是在数组和链表的基础上衍生的。</p>\n<p>在链表的学习小节中，我们首先从一个通用的解决方案出发，接着谈及几种链表的基本结构，常用操作，以及不同结构的链表是怎样自然递进的。最后还将对数组与链表做一对比。话不多说，让我们启程吧——</p>\n<h2 id=\"2-1-从一个问题开始\"><a href=\"#2-1-从一个问题开始\" class=\"headerlink\" title=\"2.1 从一个问题开始\"></a>2.1 从一个问题开始</h2><p>我们知道，在操作系统中，为了解决从硬盘读取和从内存读写的速度不匹配问题，常常引入缓存这一概念。缓存家族可谓人丁兴旺，寄存器，浏览器缓存，数据库缓存大行其道。那缓存实现的机制是什么呢？</p>\n<p>那就是LRU缓存淘汰算法，在后期推出的操作系统系列博文中，你将对其有深入的了解。这里我们只讨论，如何<strong>使用链表实现LRU缓存淘汰算法</strong>，对此，王争老师的思路这样的——</p>\n<blockquote>\n<p>我们维护一个有序的单链表，越靠近链表尾部的节点是越早之前被插入的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历单链表。</p>\n<p>假如这个元素之前被缓存在链表中，则将该元素从原来的位置删除，然后插入到链表的头部</p>\n<p>如果该数据没有在缓存链表中，又可以分为两种情况：</p>\n<ol>\n<li>如果缓存未满，则将此节点直接插入到链表的头部</li>\n<li>如果缓存已满，则将链表尾部的元素删除，再将该数据插入到链表的头部。</li>\n</ol>\n<p>此外，还可以通过<strong>散列表降低访问元素的时间复杂度</strong>优化这个方案。</p>\n</blockquote>\n<h2 id=\"2-2-五花八门的链表结构\"><a href=\"#2-2-五花八门的链表结构\" class=\"headerlink\" title=\"2.2 五花八门的链表结构\"></a>2.2 五花八门的链表结构</h2><p>首先对链表下一个定义：</p>\n<blockquote>\n<p>区别于数组使用连续的内存空间，<strong>链表通过指针将离散的内存块串联在一起。</strong></p>\n</blockquote>\n<p>定义中的内存块即是链表的节点，为了将所有节点串起来，每个节点<strong>存储数据</strong>以外，还需要<strong>记录下一个节点的地址，也就是后继指针next。</strong></p>\n<p>常用的链表有三种，其中最简单常用的是单链表——</p>\n<h3 id=\"2-2-1-单链表\"><a href=\"#2-2-1-单链表\" class=\"headerlink\" title=\"2.2.1 单链表\"></a>2.2.1 单链表</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230130075.png\" alt=\"image-20210707230130075\"></p>\n<p>我们习惯将第一个节点称为头结点，将最后一个节点称为尾结点，值得注意的是，尾结点不再指向一个地址，而指向null。</p>\n<p>与数组一样，链表也支持数据的查找，插入和删除。</p>\n<p>在插入，删除新元素时，只需要考虑相邻节点的指针改变——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230140227.png\" alt=\"image-20210707230140227\"></p>\n<p>在链表中查找元素是不方便的，必须顺序遍历链表，它的时间复杂度为O(n).</p>\n<h3 id=\"2-2-2-循环链表\"><a href=\"#2-2-2-循环链表\" class=\"headerlink\" title=\"2.2.2 循环链表\"></a>2.2.2 循环链表</h3><p>循环链表是特殊的单链表，它与单链表的区别就在于尾结点。循环链表的尾结点指针指向的是头结点。那么这么结构适用于什么场景呢？</p>\n<p>它可以用来高效的解决<strong>环结构的链表</strong>，比如著名的<strong>约瑟夫环</strong>问题。</p>\n<p>在实际应用中，被更多使用的要属双向链表，我们来看下它特定的结构得以应用于什么场景呢。。。</p>\n<h3 id=\"2-2-3-双向链表\"><a href=\"#2-2-3-双向链表\" class=\"headerlink\" title=\"2.2.3 双向链表\"></a>2.2.3 双向链表</h3><p>双向链表在单链表的基础上增加了前驱节点prev，这样双向链表就可以实现反向遍历，对于找特定节点的前驱节点的时间复杂为O(1)。双向链表降低了遍历链表时的复杂度，但同时也带来了内存的损耗。是一种使用空间换时间的策略</p>\n<h3 id=\"2-2-4-双向链表高效在哪呢\"><a href=\"#2-2-4-双向链表高效在哪呢\" class=\"headerlink\" title=\"2.2.4 双向链表高效在哪呢\"></a>2.2.4 双向链表高效在哪呢</h3><p>我们知道，删除链表元素的场景分为两类：</p>\n<ol>\n<li>删除值等于给定值的节点</li>\n<li>删除给定指针指向的节点</li>\n</ol>\n<p>对于第一种情况，没有捷径可走，只能去逐个遍历节点元素。而对于第二个节点，双向链表增加了通过前驱指针找给定节点的遍历，因此高效的多。同样的，插入一个节点时，使用双向链表也提供了更多的可能。</p>\n<p>既然双向链表这么牛，那实际应用场景中有没有双向链表的大展身手呢，那就是LinkedHashMap,这种高效的集合底层即是使用了这种数据结构。</p>\n<p>看到这，很多朋友会问，既然双向链表的效率这么高，那再给他加上循环链表的特点岂不是如虎添翼，的确如此，我们来看究极版——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230151299.png\" alt=\"image-20210707230151299\"></p>\n<h2 id=\"2-3-链表VS数组性能大比拼\"><a href=\"#2-3-链表VS数组性能大比拼\" class=\"headerlink\" title=\"2.3 链表VS数组性能大比拼\"></a>2.3 链表VS数组性能大比拼</h2><p>这里不再俗套的给出很多理论，而是通过具体的应用场景来考虑数组与链表性能——</p>\n<p>CPU缓存应该哪种数据结构呢？CPU管理的是连续的内存空间，使用链表简直天然地不友好，所以使用数组。而对于一个插入删除更频繁的系统来说，使用数组则更众望所归。其实抛开场景说数据结构就是耍流氓，在之前的定义中，我们就提及，数据结构是用于特定场景的。</p>\n<h2 id=\"2-4-如何轻松的写出正确的链表代码\"><a href=\"#2-4-如何轻松的写出正确的链表代码\" class=\"headerlink\" title=\"2.4 如何轻松的写出正确的链表代码\"></a>2.4 如何轻松的写出正确的链表代码</h2><p>链表的代码因为涉及到指针的操作，往往空想起来比较绕，要想高效地写出链表代码，我们还需要一些技巧——</p>\n<ol>\n<li><p><strong>理解指针或者引用的含义</strong></p>\n<p>将某个变量赋给指针，实际上就是将这个变量的地址赋值给指针，引用同样如是。</p>\n</li>\n<li><p><strong>警惕指针丢失和内存泄漏</strong></p>\n<p>链表的操作往往是有序的，此外，在删除元素时，一定要手动释放内存空间(C语言).</p>\n</li>\n<li><p><strong>利用哨兵简化实现难度</strong></p>\n<p>对原生的单链表删除尾结点和插入第一个节点时，需要做特殊处理。这种边界条件能不能简化成通用的情况呢？</p>\n<p>当然可以，我们使用哨兵机制来实现，即在第一个节点之前加入head节点，head节点不存储数据，它指向链表的第一个节点。这里需要注意区分head节点和第一个节点，他们的定义是不同的！</p>\n</li>\n<li><p><strong>重点留意边界条件</strong></p>\n<p>常见的边界处理条件有那么几个</p>\n<ol>\n<li><strong>如果链表为空，代码是否能正常运行</strong></li>\n<li><strong>如果链表只包含一个节点时，代码是否能正常工作</strong></li>\n<li><strong>如果链表只包含两个节点时，代码是否能正常工作</strong></li>\n<li><strong>代码逻辑在处理头结点和尾结点时，代码是否能正常工作。</strong></li>\n</ol>\n</li>\n<li><p><strong>举例画图，辅助思考</strong></p>\n<p>非常有必要，脑子不是那么靠谱的时候，就需要动手啦。</p>\n</li>\n<li><p><strong>多写多练，没有捷径</strong></p>\n</li>\n</ol>\n<hr>\n<h1 id=\"三-更进一步——关于栈\"><a href=\"#三-更进一步——关于栈\" class=\"headerlink\" title=\"三.更进一步——关于栈\"></a>三.更进一步——关于栈</h1><h2 id=\"3-1-从一个问题开始\"><a href=\"#3-1-从一个问题开始\" class=\"headerlink\" title=\"3.1 从一个问题开始\"></a>3.1 从一个问题开始</h2><p>我们在浏览网站时都会用到前进和后退的功能，那这种功能是如何实现的你知道吗？</p>\n<p>没错，就是使用这节我们会讲到的栈，针对这个需求，假设将我们浏览的网页按照先后顺序存储在一个数组中，我们根据下标，即可实现前进和后退，但这里有一个致命的BUG，那就是它无法按我们的需求去删减一些存储在数组中的网页，也正因此我们需要引入栈。</p>\n<p>假设我们依次访问了三个网页A,B,C，那栈的情况是这样的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230201483.png\" alt=\"image-20210707230201483\"></p>\n<p>这时，我们想回退到a页面了，就需要出栈c,b到栈Y中——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230229659.png\" alt=\"image-20210707230229659\"></p>\n<p>然后，我们再去访问页面d:就会入栈X，如果我们再想访问页面b,c就不行了，栈Y会清空栈中的内容</p>\n<h2 id=\"3-2-为什么要学习栈\"><a href=\"#3-2-为什么要学习栈\" class=\"headerlink\" title=\"3.2 为什么要学习栈\"></a>3.2 为什么要学习栈</h2><p>栈是一种操作受限的线性表，从功能上来说，数组异或链表都可以实现栈。但是数组或是链表都暴露了太多的接口，这就需要我们非常注意邻界条件。</p>\n<p>而特定的数据结构是对特定情境的抽象，对于某些场景来说，用栈就很合适了。</p>\n<p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出，先进后出的特点时，我们就应该首选使用栈。</p>\n<h2 id=\"3-3-怎样学习栈？\"><a href=\"#3-3-怎样学习栈？\" class=\"headerlink\" title=\"3.3 怎样学习栈？\"></a>3.3 怎样学习栈？</h2><h3 id=\"实现一个栈\"><a href=\"#实现一个栈\" class=\"headerlink\" title=\"实现一个栈\"></a>实现一个栈</h3><p>可以查看我的另一篇关于<strong>队列和栈基础应用的博文</strong>：</p>\n<h3 id=\"支持动态扩容的顺序栈\"><a href=\"#支持动态扩容的顺序栈\" class=\"headerlink\" title=\"支持动态扩容的顺序栈\"></a>支持动态扩容的顺序栈</h3><p>我们先来分析下入栈和出栈的时间复杂度，出栈时，时间复杂度为O(1)没有悬念，而入栈时假如还有空间，那时间复杂度自然也是O(1)，但当栈满的时候入栈，就需要扩容，这里的时间复杂度用均摊时间复杂度理解仍为O(1).</p>\n<p>既然，我们需要扩容这种机制，而栈本身又可以使用数组实现。不妨用栈来继承一个可以实现动态扩容的集合。</p>\n<p>实际上，java就是这样做的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230239639.png\" alt=\"image-20210707230239639\"></p>\n<p>当需要扩容时，会将数组大小扩展为原来的2倍：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230251442.png\" alt=\"image-20210707230251442\"></p>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><p>栈在函数调用，括号匹配，表达式运算方面有广泛的应用，我们一一来看——</p>\n<p><code>函数调用</code> ：</p>\n<blockquote>\n<p>我们知道，操作系统给给每个线程分配了一个独立的内存空间，这块内存被组织为栈这种结构。用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈</p>\n</blockquote>\n<p><code>表达式运算</code></p>\n<blockquote>\n<p>编译器实则就是使用两个栈来实现的。其中一个是保存操作数的栈，另一个是保存运算符的栈。当我们从左到右遍历表达式，当遇到数据，我们直接压入操作数栈。</p>\n<p>当遇到运算符时，首先与运算符栈的栈顶运算符进行比较，如果比栈顶运算符的优先级低或者相等，则从运算符栈取出栈顶元素，然后从操作数栈取两个元素进行运算，并将运算结果压入操作数栈，继续比较。来看下王争老师的举例——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230302756.png\" alt=\"image-20210707230302756\"></p>\n</blockquote>\n<p><code>括号匹配</code></p>\n<blockquote>\n<p>这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>\n</blockquote>\n<h3 id=\"面试常考的练习题集锦\"><a href=\"#面试常考的练习题集锦\" class=\"headerlink\" title=\"面试常考的练习题集锦\"></a>面试常考的练习题集锦</h3><ol>\n<li><p>有效的括号</p>\n<p>待更新</p>\n</li>\n<li><p>最小栈</p>\n<p>待更新</p>\n</li>\n<li><p>用栈实现队列</p>\n<p>待更新</p>\n</li>\n<li><p>比较含退格的栈</p>\n<p>待更新</p>\n</li>\n<li><p>基本计算器</p>\n<p>待更新</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"四-队列\"><a href=\"#四-队列\" class=\"headerlink\" title=\"四. 队列\"></a>四. 队列</h1><h2 id=\"4-1-从一个问题开始\"><a href=\"#4-1-从一个问题开始\" class=\"headerlink\" title=\"4.1 从一个问题开始\"></a>4.1 从一个问题开始</h2><p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池会如何处理这个请求，是拒绝请求还是排队请求？各种处理策略又是怎样实现的呢？</p>\n<blockquote>\n<p>一般有两种解决策略，一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队。那排队的队列是如何实现的呢——</p>\n<p>我们知道，队列有基于数组和链表的实现方式。基于链表的实现方式，可以实现一个支持无限排队的无界队列，但对用户体验来说，着实不怎么友好。</p>\n<p>基于数组实现的有界队列，队列的大小有限，当超过队列大小时，请求会被拒绝，这种方式对响应时间敏感的系统来说，相对比较合理。但设置一个合理的队列大小也非常有讲究，需要按照具体应用场景设计。</p>\n</blockquote>\n<h2 id=\"4-2-概述\"><a href=\"#4-2-概述\" class=\"headerlink\" title=\"4.2 概述\"></a>4.2 概述</h2><p>队列是一种操作受限的线性表，对比栈，它同样支持入队和出队。操作时，<strong>队头指针指向队头元素，队尾指针指向队尾元素的下一个内存空间。</strong></p>\n<h2 id=\"4-3-五花八门的队列\"><a href=\"#4-3-五花八门的队列\" class=\"headerlink\" title=\"4.3 五花八门的队列\"></a>4.3 五花八门的队列</h2><h3 id=\"顺序队列的实现\"><a href=\"#顺序队列的实现\" class=\"headerlink\" title=\"顺序队列的实现\"></a>顺序队列的实现</h3><p>参考博文：<a href=\"https://blog.csdn.net/qq_48573752/article/details/113776915\">https://blog.csdn.net/qq_48573752/article/details/113776915</a></p>\n<p>通过小例子来理解顺序队列的基础操作——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230319078.png\" alt=\"image-20210707230319078\"></p>\n<p>但是我们发现，当tail==n的时候，队列中还有空闲的空间，但却不能执行入队操作，这时要怎么办呢？</p>\n<p>数据搬移，也就是当tail==n时触发一次整体的数据搬移，这样的话，入队的时间复杂度就不再是O(1)，因为会涉及到数据的搬移，我们来看下新的入队操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//无法执行入队操作</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tail <span class=\"token operator\">==</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//空间已满</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>tail<span class=\"token operator\">-</span>head<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\t   items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> items<span class=\"token punctuation\">[</span>head<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        tail <span class=\"token operator\">-=</span> head<span class=\"token punctuation\">;</span>\n        head <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">&#125;</span>\n    item<span class=\"token punctuation\">[</span>n<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> item<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样的入队操作无疑更严谨了一些。但这样还是太麻烦了些，有没有什么办法可以不进行数据搬移就可以入队呢，那就要看循环队列了。</p>\n<h3 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h3><p>在循环队列中，应该注意的核心问题就是队列满的判别条件，我们画张图理解下——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230332406.png\" alt=\"image-20210707230332406\"></p>\n<p>再结合代码看下:</p>\n<p>参见博文：<a href=\"https://blog.csdn.net/qq_48573752/article/details/113776915\">https://blog.csdn.net/qq_48573752/article/details/113776915</a></p>\n<h3 id=\"并发队列与阻塞队列\"><a href=\"#并发队列与阻塞队列\" class=\"headerlink\" title=\"并发队列与阻塞队列\"></a>并发队列与阻塞队列</h3><p>上面的队列都是我们耳闻能详的知识，而实际工程中应用更多的实则是并发队列与阻塞队列。</p>\n<blockquote>\n<p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是<strong>在队列为空的时候，从队头取数据会被阻塞</strong>。因为此时还没有数据可取，直到队列中有了数据才能返回；<strong>如果队列已经满了，那么插入数据的操作就会被阻塞</strong>，直到队列中有空闲位置后再插入数据，然后再返回。</p>\n<p><strong>线程安全的队列我们叫作并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上<strong>加锁</strong>，但是<strong>锁粒度大并发度会比较低</strong>，同一时刻仅允许一个存或者取操作。实际上，<strong>基于数组的循环队列，利用 CAS 原子操作</strong>，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>\n</blockquote>\n<h2 id=\"4-4-一点思考\"><a href=\"#4-4-一点思考\" class=\"headerlink\" title=\"4.4  一点思考\"></a>4.4  一点思考</h2><p><code>Q</code>：如何实现无锁的并发队列？</p>\n<p><code>A</code>：可以使用<strong>数组+CAS机制</strong>。在入队之前，获取tail位置，入队时比较tail是否发生了变化。如果否，允许入队。反之，入队失败。相应的，出队则是参照head的位置。</p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"数据结构常见的八大排序图文详解","top":false,"cover":true,"toc":true,"mathjax":true,"date":"2021-07-12T07:51:13.000Z","password":null,"summary":null,"_content":"\n#  摘要\n\n算法如果按照模块分，`排序算法绝对算得上割据一方的存在`。我们无可避免地会想，对一组数据进行排序让你玩得这么花，有这个必要吗？我想被要求手写快排的人至少是认为有的~\n\n就如同以前历史老师所说的那般：学习历史学的不是历史本身，而是`历史背后的故事`。\n\n而排序算法背后，`分治思想，二分思想，优化，时空复杂度`都是需要我们去探寻的故事，而不同的排序算法在相同场景下的性能大相径庭，到底选谁呢？有没有什么衡量依据呢？人们更常用的是哪种呢？故事的大幕就此拉开——\n\n>注：文章中的图均来自于极客时间数据结构与算法专栏。文章初衷是作为笔记使用，所以缺乏详细推导，仅用于回顾知识点。\n\n------\n\n# 一、排序上——冒泡,插入,选择排序\n\n## 1.1 从一个问题开始\n\n`Q`：插入排序和冒泡排序的时间复杂度都为O(n2),但为什么人们更倾向于选择插入排序呢？\n\n`A`：**插入排序和冒泡排序的时间复杂度都为O(n2),且他们都是稳定的原地排序算法，但他们的性能区别在于比较次数和交换次数。**\n\n冒泡排序不管怎么优化，它的交换次数，也就是`移动元素次数`都是固定值，即原始数据的`逆序度`。插入排序同样如是。\n\n但从代码实现上来说，冒泡排序需要`三次赋值`，而插入排序只需要`一次赋值`。也就是说冒泡排序的数据交换比插入排序的数据交换更复杂，我们来具象的看一下——\n\n```java\n//冒泡排序中的交换操作\nif(a[j]>a[j+1]){\n    int tmp = a[j];\n    a[j] = a[j+1];\n    a[j+1] = tmp;\n    flag = true;\n}\n\n//插入排序中的交换操作\nif(a[j] > value){\n\ta[j+1] = a[j];\n}else{\n\tbreak;\n}\n```\n\n## 1.2 如何分析一个排序算法\n\n### 1.2.1 排序算法的执行效率\n\n#### 最好情况，最坏情况，平均情况时间复杂度\n\n在之前的学习中，我们只需要粗略的比较时间复杂度，那为什么在排序时，又需要引入这些具体的参数呢?\n\n1. 有些排序算法有区分的必要；\n2. 对于要排序的数据，**有序度**是截然不同的。\n\n#### 时间复杂度的系数，常数和低阶\n\n同样的困惑，但这个要好解答的多，无非是**数据规模小的情况**下，这些参数本身就可以表达一种**趋势**。\n\n#### 比较次数和交换次数\n\n排序算法有两类，一类基于排序，一类不基于排序。在分析基于排序的算法中，**数据交换就意味着数据搬移，是要耗费性能的**，所以有必要区分。\n\n### 1.2.2 排序算法的内存消耗\n\n为了描述内存消耗，我们引入**原地排序**的概念，所谓原地排序，就是指**空间复杂度为O(1)**。\n\n### 1.2.3 排序算法的稳定性\n\n稳定性的大致意思是在新的需求被引入后，原本系统能够维持相对稳定。而在这里，排序算法的稳定性指的是，**如果待排序的序列中存在值相等的元素，经过排序以后，相等元素之间的原有的先后顺序不变。**\n\n但是业务中的排序，往往不是对单纯的整数进行排序，而是一组`对象`，我们需要根据对象的`某个KEY`进行排序。来看一个小例子——\n\n> 假如说，我们需要给电商交易系统中的订单排序。订单有两个属性，一个是下单时间，一个是订单金额。如果我们现在有10万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照订单时间排序，对于这样的需求，我们要怎么做？\n>\n> 很明显，先入为主的一种方式是，首先根据订单金额进行排序，在对订单金额相同的区间按照时间排序。\n>\n> 很自然没错，但在每个小区间要交换元素的次数太多了，有没有性能更高的方法呢？\n>\n> **我们需要选择一种稳定的排序算法，也就是先对订单按照时间进行排序，再使用稳定排序算法按照金额进行排序，这样的话，我们就能确保金额相同的两个对象，在排序后的前后顺序不变。**\n\n## 1.3 冒泡排序\n\n### 1.3.1 冒泡排序概述\n\n冒泡排序比较相邻的两个元素，如果不满足大小关系，则互换位置，一次冒泡会让至少一个元素移动到它应该在的位置。重复n次即可完成排序。\n\n下面我们来看具体的例子：对一组数据4,5,6,3,2,1从小到大进行排序。\n\n那么第一次冒泡的过程是这样的——\n\n![image-20210214151417841](https://img-blog.csdnimg.cn/img_convert/e47dbf3b0ff8dea0e83d65e1a17fe4fe.png)\n\n这样重复n次即可完成冒泡排序。但这样的排序方式是可以优化的，因为在某次冒泡后，整个数据已经是有序的了，就不需要再排序。所以我们`需要一个标志量来标识有序的状态`，下面是优化后的代码——\n\n```java\n /**\n     * 冒泡排序\n     */\n    public void bubbleSort(int[] a,int n){\n        if(n <= 1)\n            return;\n        //比较n-1趟\n        for(int i=0;i<n-1;i++){\n            boolean flag = false;\n            for(int j=0;i<n-i-1;j++){\n                if(a[j] > a[j+1]){\n                    int tmp = a[j];\n                    a[j] = a[j+1];\n                    a[j+1] = tmp;\n                    //表明有数据交换\n                    flag = true;\n                }\n            }\n            //如果没有数据交换，则退出\n            if(!flag)\n                break;;\n        }\n    }\n```\n\n### 1.3.2 冒泡排序的分析\n\n1. `原地排序算法:`冒泡的过程只涉及相邻两个元素的交换操作，只需要常量级的临时空间，所以空间复杂度为O(1),即原地排序算法。\n\n2. `稳定的排序算法:`在比较时，相等的元素不需要交换位置，所以是稳定的排序算法\n\n3. `时间复杂度均为O(n2):`最好情况即是整个数据都是有序的，只需要进行一次冒泡就ok了，即最好时间复杂度为O(N)。同理，最坏情况下的时间复杂度为O(N2)。\n\n   那平均时间复杂度如何计算呢?按部就班的说，应该计算**期望**，但规模大的数据，计算期望是非常麻烦的，为了更好地描述平均时间复杂度，我们这里引入**有序度**的概念。\n\n   > **有序度是数组中具有有序关系的元素对的个数**。用数学表达式表示就是——\n   > $$\n   > a[i]>a[j],i>j\n   > $$\n\n   同理，假如有6个元素，那这组数据的满序度就是6*(6-1)/2,应用到更宽泛的范围，满序度可以表示为——\n   $$\n   n*(n-1)/2\n   $$\n   自然，我们也可以得到逆序度的概念：`逆序度=满序度-有序度`。\n\n   我们现在再来描述平均时间复杂度。最坏情况下，有序度为0，需要进行n*(n-1)/2次交换。最好情况下，有序度为n，不需要进行交换，则平均时间复杂度为\n   $$\n   n*   (n-1)/4\n   $$\n\n## 1.4 插入排序\n\n### 1.4.1 插入排序概述\n\n插入排序是借助区分**已排序区间和未排序区间**的思路来展开描述的。\n\n- [x] 插入算法的**核心**是**取未排序区间中的元素，将其插入到已排序区间的合适位置，并保证已排序区间数据一致有序。**\n\n如下图所示，要排序的数据为**4,5,6,1,3,2**——\n\n![image-20210214155307987](https://img-blog.csdnimg.cn/img_convert/c080151ce91820fc9a8697ee4e70d98e.png)\n\n插入排序同冒泡排序，包含元素的比较进而元素的移动两种操作，那我们如何描述需要移动元素多少次呢？\n\n这里直接给出概念，`移动次数就等于逆序度`。当然，也容易理解，移动完成后逆序度为0，那么移动次数自然等于逆序度。\n\n来看下插入排序的代码——\n\n```java\n/**\n     * 插入排序\n     */\n    public void insertionSort(int[] a,int n){\n        if(n == 1)\n            return;\n        //需要将未排序区间的n-1个元素放置到已排序区间合适的位置\n        for(int i=1;i<n;i++){\n            //记录要排序的值\n            int value = a[i];\n            int j = i-1;\n            //已排序区间\n            for(;j>=0;j--){\n                if(a[j] > value){\n                    a[j+1] = a[j];\n                }else{\n                    break;\n                }\n            }\n            //插入数据\n            a[j+1] = value;\n        }\n    }\n```\n\n### 1.4.2 插入排序分析\n\n- `原地排序算法：`比较数据交换元素时只需要常数级的空间，即空间复杂度为O(1);\n- `稳定的排序算法`：  当遇到相同元素时，**只需要将未排序数据中的元素插入到已排序相同元素的后面即可**，因此也是稳定的排序算法。\n- `时间复杂度：`最好时间复杂度为**O(N)**,最坏情况下，时间复杂度为**O(N2)**.在分析平均时间复杂度时，可以看做是将n-1个数据分别插入到有序的数组中去，一次这样的过程时间复杂度为O(N),那么整个过程的平均时间复杂度就为**O(N2)**\n\n## 1.5 选择排序\n\n### 1.5.1 选择排序概述\n\n选择排序的**思路类似于插入排序**，同样基于**已排序区间和未排序区间**的思路。不同的是，选择排序依次找出**未排序区间中的最小元素**，**将其与未排序区间的第一个元素互换位置,排好序的部分作为已排序区间。**\n\n我们来看下面的小例子——\n\n![image-20210214182637560](https://img-blog.csdnimg.cn/img_convert/cfffb76ec8fbe3678179f5d397b4047c.png)\n再来看下具体的代码实现——\n\n```java\n/**\n* 选择排序\n*/\n    public void selectSort(int[] a,int n){\n        if(n == 0)\n            return;\n        //每一趟最小值的初始值\n        for(int i=0;i<n-1;i++){\n            int min = a[i];\n            //标志位\n            boolean isSwap = false;\n            //记录最小值的下标\n            int index = i;\n            int j = i+1;\n            for(;j<n;j++){\n                //存在比最小值更小的值\n                if(min > a[j]){\n                    min = a[j];\n                    //记录新的最小值的下标\n                    index = j;\n                    isSwap = true;\n                }\n            }\n            //该趟中存在需要互换位置的元素\n            if(isSwap){\n                a[index] = a[i];\n                a[i] = min;\n            }\n        }\n    }\n```\n\n### 1.5.2 选择排序分析\n\n- `原地排序算法：`代码执行时只需要常数级的空间，即空间复杂度为O(1).\n- `不稳定的算法：`交换位置导致有可能颠倒相同值的相对位置，所以是不稳定的排序算法。\n- `时间复杂度分析：`最好，最坏，平均时间复杂度均为O(N2).\n\n------\n\n# 二、排序下\n\n## 摘要\n\n在排序上中提及到了冒泡排序，选择排序，插入排序。这三种排序是因为时间复杂度较高，所以**适用于规模小**的数据排序，因为y = x 2曲线的数据规模较小时增长趋势并不快。但在实际项目开发中，动辄上万的数据排序，我们应该怎样处理呢？这就涉及到**时间复杂度相对较小的快速排序与归并排序**，这两种排序都是使用**分治的编程思想**，理解起来相对困难一点，但在面试时，出于他们性能折中又适用范围广的特点，因此成为**面试的宠儿**。好啦，接下来进入正题——\n\n## 2.1 从一个问题开始\n\n`如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？`\n\n乍看上去，不管是快排还是归并排序，他们的时间复杂度都是O(NlogN),但使用分区技巧的快速排序**在合并之前就已经是一个有序的数据集了。**\n\n假设原始的数据集是这样的：`4,2,5,12,3`,要找到第3大的元素4.\n\n我们将数据已分区点为界分为三个区间，如果K等于分区点，则直接返回即可，假设不等于，我们就去**递归的分治的另外两个区间，直到区间缩小为1.**\n\n来计算下时间复杂度：首先遍历数据集找到分区点，时间复杂度为O(n),第二次只需要分治一半的元素，也就是时间复杂度为O(n/2).递推得到第n次分治需要的时间复杂度为O(n/2的n-1次方)，最后一次不需要分治，时间复杂度为O(1)，把这些时间复杂度加起来，构成一个等比数列的求和，**求和结果为2n-1**,也就是时间复杂度为O(n).\n\n## 2.2 归并排序\n\n### 2.2.1 概述\n\n归并排序是用**分治**的思想，将大问题分成小问题，小问题解决了，大问题自然也就解决了。\n\n归并排序时，首先执行**递**，将数组从中间分成两部分，对这两部分**分别进行分治，直到区间为1为止**。然后是**归**的过程，**依次排序合并每个小区间成大区间，直到得到排好序的数据集**。\n\n这样说总归是不形象的，我们来看下图解——\n\n![image-20210215112204718](https://img-blog.csdnimg.cn/img_convert/a0c1aaa677cec70cea2934481234173b.png)\n\n### 2.2.2 代码实现\n\n有了大致的思路，我们来使用递归实现归并排序，既然是递归问题，那就先找递归终止条件和递归公式咯——\n\n- `递归终止条件`：\n  $$\n  merge_sort(p...r) = merge(merge_sort(p,q),merge_sort(q+1,r))\n  $$\n\n- `递归公式`：\n  $$\n  p>=r\n  $$\n\n我们再将其转化为代码——\n\n```java\n /**\n     * 归并排序\n     */\n    public static int[] mergeSort(int[] a,int n){\n        mergeSort_s(a,0,n-1);\n        return a;\n    }\n\n    private static void mergeSort_s(int[] a, int from, int to) {\n        //递归终止条件\n        if(from >= to)\n            return;\n        //得到该区间的中间位置\n        int mid = (from+to)/2 ;\n        //分治递归\n        mergeSort_s(a, from, mid);\n        mergeSort_s(a, mid + 1, to);\n        merge(a,from,mid,to);\n    }\n\n    /**\n     * 合并两个有序数组并返回\n     * @param a\n     * @param from\n     * @param mid\n     * @param to\n     * @return\n     */\n    private static void merge(int[] a, int from, int mid, int to) {\n        //申请一个临时数组来存储合并结果\n        int[] tmp = new int[to-from+1];\n        //合并\n        int i = from,j = mid+1,k = 0;\n        while(i<=mid && j<=to){\n            if(a[i] <= a[j])\n                tmp[k++] = a[i++];\n            else{\n                tmp[k++] = a[j++];\n            }\n        }\n        //下面这句的思路好厉害！\n        int start = i;\n        int end = mid ;\n        //右边还有剩余元素\n        if(j <= to){\n            start = j;\n            end = to;\n        }\n        //拷贝剩余元素到tmp中\n        while(start <= end){\n            tmp[k++] = a[start++];\n        }\n        //拷贝临时数组到a中\n        for(i=0;i<=to-from;i++){\n            a[from+i] = tmp[i];\n        }\n    }\n}\n```\n\n这里加点私货，在写归并排序代码的时候，犯了一个从来没有去主动意识的致命错误，这个错误就是在某些场景下，else要不要写？我们先分析一段代码——\n\n```java\npublic static void main(String[] args) {\n        int res = 0;\n        if (res == 0) {\n            res = 1;\n        }\n        res = -1;\n        System.out.println(res);\n}\n```\n\n这是一段很简洁的代码，小伙伴们认为会输出什么呢？\n\n我以前有些完整的if与else的习惯，今天犯懒了，索性没有写else，因为我认为if之后部分的第一行就是else的代码，但是真的是这样吗？\n\n`这里我没有写else，系统会认为else不执行任何事情，而不是默认执行if语句块后的第一行代码。`\n\n那么怎样的编程习惯更值得提倡呢？\n\n先给出结论，**if和else要写就写成对！**，因为这样对测试人员友好一些，另外检测bug也容易检测出来，我们再延伸一下，什么情况下用if，什么情况下用if else.\n\n> - if用于逻辑追加\n> - if else用于逻辑分支\n\n另外，针对硬件的设计，我们可以给出一个小技巧：为真的条件写在前面。\n\n这是因为现代CPU并不会做逻辑判断，而是顺序执行，假如发现不满足条件，则会回滚并执行下一条语句。所以在写if,else的前提下尽可能将为真的条件写在前面。\n\n### 2.2.3 性能分析\n\n- `稳定的排序算法：`归并排序的稳定与否取决于合并的方式，在合并时针对相同元素，不改变他们的相对位置即可。所以归并排序是稳定的排序算法。\n\n- `时间复杂度分析`：这里先给出一个结论：**不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。**归并排序的时间复杂度包括子问题的时间复杂度与合并代码的时间复杂度**加和**。假设包括b和c两个子问题，则：\n  $$\n  T(a)=T(b)+T(c)+K\n  $$\n  这里的K指的是合并的时间复杂度，即为O(N).又因为两个子问题的时间复杂度都为O(N/2),则归并排序的时间复杂度为：\n  $$\n  T(1) = C\\\\\n  \n  T(n) = 2*T(N/2)+N n>1\n  $$\n  我们求解后可以得到——\n  $$\n  T(n) = 2*T(n/2) + n\\\\\n     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n\\\\\n     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n\\\\\n     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n\\\\\n     ......\\\\\n     = 2^k * T(n/2^k) + k * n\\\\\n     ......\n  $$\n  **当T(n/2^k) = T(1)时，即k = log2N，将其带入上式，可以得到，T(n)=Cn+nlogn,即归并排序的时间复杂度为O(nlogn).**\n\n- `不是原地排序算法`:归并排序用到递归的思想，所以自然不会是原地排序算法。那它的空间复杂度是什么呢?\n\n  > 在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。\n\n## 2.3 快速排序\n\n### 2.3.1 概述\n\nJava1.8源码中Arrays.sort()排序函数使用快速排序算法。\n\n![image-20210707230458288](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230458288.png)\n\n快速排序是用**递归与分治**，将数据集按照**某个分区点**分为**比分区点小的区间**和**比分区间大的区间**，然后在区间内再**递归**这项操作**直到区间内只有一个元素为止**。\n\n既然是递归，我们同样写出**递归终止条件**和**递推公式**——\n$$\n递推公式：\nquick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)\n\\\\\n终止条件：\np >= r\n$$\n到这，我们只需要选出适合的分区点即可，通常将**区间内的最后一个元素**作为分区点，然后将比分区点小的元素放到一个数组中，把比分区点大的元素放到一个数组中。\n\n思路完全合理，但并不优雅，因为这意味着需要额外的空间。那怎样才能不申请额外空间呢？这里我们借助选择排序的思路，即核心是**交换元素**。\n\n那归并与快排有什么区别呢？归并排序的处理过程是自下往上的，而快排则是自上往下的。\n\n我们通过图解来认识排序的过程——\n\n![image-20210215195133829](https://img-blog.csdnimg.cn/img_convert/158c9e4dc48b12dfdbfb1ea6fe8e785c.png)\n\n### 2.3.2 代码实现\n\n```java\n/**\n     * 快速排序\n     */\n    public static void quickSort(int[] a,int n){\n        quickSort_c(a,0,n-1);\n    }\n\n    private static void quickSort_c(int[] a, int from, int to) {\n        if(from >= to)\n            return;\n        int p = partition(a,from,to);\n        quickSort_c(a,from,p-1);\n        quickSort_c(a,p+1,to);\n    }\n    /**\n     * 分区函数\n     */\n    private static int partition(int[] a, int from, int to) {\n        //将最后一个元素作为分区点\n        int pivot = a[to];\n        int i = from;\n        for(int j=from;j<to;j++){\n            //小于分界点，则使用交换的方式将元素放到已排序区间\n            if(a[j] < pivot){\n                int tmp = a[i];\n                a[i] = a[j];\n                a[j] = tmp;\n                //\n                ++i;\n            }\n        }\n        int tmp = a[to];\n        a[to] = a[i];\n        a[i] = tmp;\n        return i;\n    }\n```\n\n### 2.3.3 性能分析\n\n这里不再推到具体过程，直接给出结论——\n\n- [x] `归并排序是一种不稳定的原地排序算法，它大部分情况下的时间复杂度为O(nlogn),只有个别情况下才会退化为O(n2)`\n\n------\n\n# 三.、线性排序分析总结\n\n## 3.1 前言\n\n在已经学习了五种基于比较的排序算法的基础上，我们仍要继续学习**三种特定场景下更优的不基于比较的排序算法**，那我们肯定会困惑，为什么不基于比较的算法在某些场景下性能更优呢，换句话说，基于比较的算法有什么不能逾越的天花板呢？\n\n这就需要引入CBA理论：`任何基于比较的排序算法的性能天花板就是O(nlogn)`.我们来探究一下这个结论是如何得出的——\n\n> - [x] 来自：https://yfsyfs.github.io/2019/05/25/CBA%E7%90%86%E8%AE%BA-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%9E%81%E9%99%90%E6%98%AFO-nlogn/\n>\n> 原因很简单, n个元素的全排列是`n!.` 而最终排序的结果只是其中一种（一棵含有n!个叶子节点的`二叉树`）. 每次比较, 我们可以砍掉一半的元素. 所以比较的次数就是树的高度.而此树的高度是\n> $$\n> \\log_2n!\n> $$\n> 由分析数学中的`Stirling公式`便知.速度不可能突破NlogN.\n\n既然是基因限制，那我们就有必要另辟蹊径，学习一下**时间复杂度为O(N)**的线性排序咯。\n\n## 3.2 桶排序\n\n### 3.2.1 概述\n\n这三种排序方式都会用到桶，而桶排序的核心思想是将`要排序的数据发到几个有序的桶里，每个桶里的数据再单独进行排序，排完序后再将每个桶中的数据按照顺序依次取出，组成的序列就是有序的了。`\n\n按照它的核心思想，我们来拆解一下桶排序的实现过程：\n\n1. 显然，桶的个数是首先应该被确定的，如果你再完后看的话，就会发现三种线性排序核心的区别就是`桶的大小粒度不同`，也就是每个桶中放的数据个数不同，就拿桶排序来说，它适用**外部排序**，也就是磁盘空间很充足，但内存不足,这就需要将磁盘中的文件分批地放入内存.\n\n   桶排序的桶的大小一般会预设好。所以桶的个数就等于数据的范围除以桶的大小。\n\n2. 接着就需要将数据按照`映射函数的规则`放置到对应的桶中。具体实现无非就是按大小分类到相应的桶下标。\n\n3. 然后自然就是排序啦，排序选用**java封装的快排方法**还是很舒适的，最后将排序后的桶元素放置到原数组即可。\n\n#### 复杂度分析\n\n- `时间复杂度`：假设有n个数据，分成m个桶，那每个桶中就有数据k=n/m个，每个桶中使用快排，时间复杂度为O(klogk),代入后可以得到O(n/mlog(n/m)),那总体的时间复杂度就是\n  $$\n  O(nlog(n/m))\n  $$\n  当**桶的个数趋近与数据量**时，桶排序的时间复杂度就可看做O(N).\n\n- `空间复杂度`：在将源数据分配到对应的桶时需要申请额外的空间，所以N个数据就需要额外申请N个空间，也就是空间复杂度为O(N).\n\n#### 总结\n\n> 桶排序堆排序数据的要求很苛刻，首先，要排序的数据需要`很容易就能划分成m个桶`，并且，桶和桶之间之间有着`天然的大小关系`。其次，数据在每个桶中的`分布是比较均匀`的，如果将数据都划分到同一个桶中，就会退化为O(nlogn)的排序算法啦。\n\n### 3.2.2 趣味图解\n\n![image-20210707230520254](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230520254.png)\n\n### 3.2.3 代码演示\n\n```java\npackage com.practice.sort;\n\nimport java.util.Arrays;\n\n/**\n *桶排序\n */\npublic class BucketSort {\n    public static void main(String[] args) {\n        int[] arry = {1,4,2,6,3,5,3,rry,2);\n        for (int value:arry};\n        arry = sort(arry) {\n            System.out.print(value+\" \");\n        }\n    }\n\n    private static int[] sort(int[] sourceArr,int bucketSize){\n        //首先拷贝数据,防止源数据因为没有备份而乱序\n        int[] arr = Arrays.copyOf(sourceArr, sourceArr.length);\n        return BucketSort(arr,5);\n    }\n\n    private static int[] BucketSort(int[] arr,int bucketSize){\n        //根据最小值，最大值确定分多少个桶\n        int max = arr[0];\n        int min = arr[0];\n        for (int data:arr) {\n            if(data > max){\n                max = data;\n            }else if(data < min){\n                min = data;\n            }\n        }\n        //确定桶数的原则\n        int bucketCount = (int)Math.floor((max-min)/bucketSize)+1;\n        //声明桶的标号\n        int[][] buckets = new int[bucketCount][0];\n        //通过映射函数将数据放到桶中\n        for(int i=0;i<arr.length;i++){\n            //确定数据对应的桶下标\n            int index = (int)Math.floor(arr[i]-min)/bucketSize;\n            //扩充二维数组对应行的列\n            buckets[index] = arrAppand(buckets[index], arr[i]);\n        }\n        int arryIndex = 0;\n        //为每个桶排序\n        for (int[] bucket:buckets) {\n            //特判\n            if(bucket.length <= 0)\n                continue;\n            Arrays.sort(bucket);\n            for (int value:bucket) {\n                arr[arryIndex++] = value;\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * 动态扩容,并保存数据\n     */\n    private static int[] arrAppand(int[] arr,int value){\n        arr = Arrays.copyOf(arr, arr.length + 1);\n        arr[arr.length-1] = value;\n        return arr;\n    }\n}\n```\n\n## 3.3 计数排序\n\n### 3.3.1 概述\n\n计数排序可以看做是桶排序的一种特殊情况，当要排序的数据所处的范围并不大时，我们将按数据最大值作为痛的个数，这样就省却了桶内排序的时间。\n\n我们同样聊聊来计数排序的实现：\n\n1. 类似于桶排序，计数排序同样首先确定桶的个数，这个就不再赘述。\n\n2. 然后，我们需要将源数据分配到对应的桶中，显然，如果分配到了对应的桶中，排序就已经完成了。那如何分配呢？\n\n   这个环节就是计数排序的核心啦——\n\n   假设有一组数据A[8]:2,5,3,0,2,3,0,3,我们首先遍历一遍数据，得到对应数据的个数C[6]——\n\n   ![image-20210707230533740](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230533740.png)\n\n   再对数据做顺序求和：\n\n   ![image-20210707230544186](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230544186.png)\n\n   也就是说C[i]里面存储的是小于等于I的数据个数。\n\n   最后的最后，最容易蒙圈的一步——\n\n   `逆序遍历数组，然后在数组C中找到与其相同的下标，然后通过下标对应的元素确定排序后数据的下标，再将个数减1。`\n\n   ![image-20210707230600134](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230600134.png)\n\n   王争老师的图绝了，非常有用！！！\n\n#### 复杂度分析\n\n- `时间复杂度：`计数的量级最大，但也不过于O(N).\n- `空间复杂度：`只需要额外申请一个计数数组，即计数的桶，则空间复杂度为O(N).\n\n#### 总结\n\n> 计数排序只能用在`数据范围不大的场景`中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给`非负整数`排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。\n\n### 3.3.2 趣味图解\n\n![img](https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif)\n\n### 3.3.3 代码演示\n\n```java\npackage com.practice.sort;\n\n/**\n * 计数排序\n */\npublic class CountingSort {\n    public static void main(String[] args) {\n        int[] arry = {1,5,2,4,3};\n        countSort(arry,arry.length);\n        for (int value:arry) {\n            System.out.print(value+\" \");\n        }\n    }\n\n    private static void countSort(int[] arry,int n){\n        //特判\n        if(n <= 1)\n            return ;\n        //计数排序的特征：值的范围小，将最大值作为桶的个数\n        int max = arry[0];\n        for(int i=0;i<n;i++){\n            if(arry[i] > max){\n                max = arry[i];\n            }\n        }\n        int bucketCount = max+1;\n        //声明并初始化桶\n        int[] buckets = new int[bucketCount];\n        for(int j=0;j<buckets.length;j++){\n            buckets[j] = 0;\n        }\n        //计数\n        for (int value:arry) {\n            ++buckets[value];\n        }\n        //累加\n        for(int k=1;k<buckets.length;k++){\n            buckets[k] += buckets[k-1];\n        }\n        //声明用于存储结果的tmp\n        int[] tmp = new int[arry.length];\n        //猎杀时刻~\n        for(int m=n-1;m>=0;m--){\n            int index = buckets[arry[m]]-1;\n            tmp[index] = arry[m];\n            buckets[arry[m]]--;\n        }\n        for(int i=0;i<n;i++){\n            arry[i] = tmp[i];\n        }\n    }\n}\n```\n\n## 3.4 基数排序\n\n### 3.4.1 概述\n\n> 基数排序要求数据可以划分成高低位，位之间有递进关系，比较两个数，我们只需要比较高位，高位相同再去比较低位，而且每一位的数据范围不能太大，因为基数排序需要借助桶排序或者计数排序来完成每一位的排序。\n\n还是熟悉的配方，我们来复现一下实现的过程——\n\n1. 首先根据数据中的**最大值位数**确定**桶的个数**。\n\n2. 接着**按位逆序排序**，我们这里只考虑通过最后一位对数据的划分：\n\n   通过取余运算得到的余数即为`桶对应的下标`，这里将数据分配到桶可以使用`二维数组`实现，最后将桶中的元素按序放回数组，准备下一位的比较。\n\n### 3.4.2 趣味图解\n\n![img](https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif)\n\n### 3.4.3 代码演示\n\n```java\npackage com.practice.sort;\n\nimport java.util.Arrays;\n\n/**\n * 基数排序\n */\npublic class RadixSort {\n    public static void main(String[] args) {\n        int[] arry = {2,5,24,12,30,50,0};\n        radixSort(arry,arry.length);\n        for (int value:arry) {\n            System.out.print(value+\" \");\n        }\n    }\n\n    private static void radixSort(int[] arry,int n){\n        //确定桶的个数\n        int max = arry[0];\n        for(int i=1;i<arry.length;i++){\n            if(max < arry[i]){\n                max = arry[i];\n            }\n        }\n        //得到它的位数\n        int bitCount = getBitCount(max);\n        //按位逆序排序,首先声明除数和余数\n        int mod = 10;\n        int dev = 1;\n        //bitcount趟比较\n        for(int j=0;j<bitCount;j++,mod*=10,dev*=10){\n            //声明临时数组\n            int[][] tmp = new int[mod * 2][0];\n            //将数据按照当前位放置到对应的桶中\n            for(int k=0;k<arry.length;k++){\n                //最好手绘验证一下\n                int bucket = (arry[k]%mod)/dev+mod;\n                tmp[bucket] = arryAppand(tmp[bucket],arry[k]);\n            }\n            //分别遍历每个桶中的元素，并将它们按序再放回数组中\n            int pos = 0;\n            for (int[] bucket:tmp) {\n                for(int value:bucket){\n                    arry[pos++] = value;\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组扩容并保存\n     * @param arry\n     * @param value\n     * @return\n     */\n    private static int[] arryAppand(int[] arry, int value) {\n        arry = Arrays.copyOf(arry, arry.length + 1);\n        arry[arry.length-1] = value;\n        return arry;\n    }\n\n    /**\n     * 获取整数位数\n     * @param value\n     * @return\n     */\n    private static int getBitCount(int value){\n        if(value == 0)\n            return 1;\n        int count = 0;\n        while(value > 0){\n            value /=10;\n            count++;\n        }\n        return count;\n    }\n\n}\n\n```\n\n------\n\n> 日拱一卒，功不唐捐。","source":"_posts/数据结构常见的八大排序图文详解.md","raw":"---\ntitle: 数据结构常见的八大排序图文详解\ntop: false\ncover: true\ntoc: true\nmathjax: true\ndate: 2021-07-12 15:51:13\npassword:\nsummary:\ncategories: 数据结构与算法\ntags: \n\t- 排序算法 \n\t- java\n---\n\n#  摘要\n\n算法如果按照模块分，`排序算法绝对算得上割据一方的存在`。我们无可避免地会想，对一组数据进行排序让你玩得这么花，有这个必要吗？我想被要求手写快排的人至少是认为有的~\n\n就如同以前历史老师所说的那般：学习历史学的不是历史本身，而是`历史背后的故事`。\n\n而排序算法背后，`分治思想，二分思想，优化，时空复杂度`都是需要我们去探寻的故事，而不同的排序算法在相同场景下的性能大相径庭，到底选谁呢？有没有什么衡量依据呢？人们更常用的是哪种呢？故事的大幕就此拉开——\n\n>注：文章中的图均来自于极客时间数据结构与算法专栏。文章初衷是作为笔记使用，所以缺乏详细推导，仅用于回顾知识点。\n\n------\n\n# 一、排序上——冒泡,插入,选择排序\n\n## 1.1 从一个问题开始\n\n`Q`：插入排序和冒泡排序的时间复杂度都为O(n2),但为什么人们更倾向于选择插入排序呢？\n\n`A`：**插入排序和冒泡排序的时间复杂度都为O(n2),且他们都是稳定的原地排序算法，但他们的性能区别在于比较次数和交换次数。**\n\n冒泡排序不管怎么优化，它的交换次数，也就是`移动元素次数`都是固定值，即原始数据的`逆序度`。插入排序同样如是。\n\n但从代码实现上来说，冒泡排序需要`三次赋值`，而插入排序只需要`一次赋值`。也就是说冒泡排序的数据交换比插入排序的数据交换更复杂，我们来具象的看一下——\n\n```java\n//冒泡排序中的交换操作\nif(a[j]>a[j+1]){\n    int tmp = a[j];\n    a[j] = a[j+1];\n    a[j+1] = tmp;\n    flag = true;\n}\n\n//插入排序中的交换操作\nif(a[j] > value){\n\ta[j+1] = a[j];\n}else{\n\tbreak;\n}\n```\n\n## 1.2 如何分析一个排序算法\n\n### 1.2.1 排序算法的执行效率\n\n#### 最好情况，最坏情况，平均情况时间复杂度\n\n在之前的学习中，我们只需要粗略的比较时间复杂度，那为什么在排序时，又需要引入这些具体的参数呢?\n\n1. 有些排序算法有区分的必要；\n2. 对于要排序的数据，**有序度**是截然不同的。\n\n#### 时间复杂度的系数，常数和低阶\n\n同样的困惑，但这个要好解答的多，无非是**数据规模小的情况**下，这些参数本身就可以表达一种**趋势**。\n\n#### 比较次数和交换次数\n\n排序算法有两类，一类基于排序，一类不基于排序。在分析基于排序的算法中，**数据交换就意味着数据搬移，是要耗费性能的**，所以有必要区分。\n\n### 1.2.2 排序算法的内存消耗\n\n为了描述内存消耗，我们引入**原地排序**的概念，所谓原地排序，就是指**空间复杂度为O(1)**。\n\n### 1.2.3 排序算法的稳定性\n\n稳定性的大致意思是在新的需求被引入后，原本系统能够维持相对稳定。而在这里，排序算法的稳定性指的是，**如果待排序的序列中存在值相等的元素，经过排序以后，相等元素之间的原有的先后顺序不变。**\n\n但是业务中的排序，往往不是对单纯的整数进行排序，而是一组`对象`，我们需要根据对象的`某个KEY`进行排序。来看一个小例子——\n\n> 假如说，我们需要给电商交易系统中的订单排序。订单有两个属性，一个是下单时间，一个是订单金额。如果我们现在有10万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照订单时间排序，对于这样的需求，我们要怎么做？\n>\n> 很明显，先入为主的一种方式是，首先根据订单金额进行排序，在对订单金额相同的区间按照时间排序。\n>\n> 很自然没错，但在每个小区间要交换元素的次数太多了，有没有性能更高的方法呢？\n>\n> **我们需要选择一种稳定的排序算法，也就是先对订单按照时间进行排序，再使用稳定排序算法按照金额进行排序，这样的话，我们就能确保金额相同的两个对象，在排序后的前后顺序不变。**\n\n## 1.3 冒泡排序\n\n### 1.3.1 冒泡排序概述\n\n冒泡排序比较相邻的两个元素，如果不满足大小关系，则互换位置，一次冒泡会让至少一个元素移动到它应该在的位置。重复n次即可完成排序。\n\n下面我们来看具体的例子：对一组数据4,5,6,3,2,1从小到大进行排序。\n\n那么第一次冒泡的过程是这样的——\n\n![image-20210214151417841](https://img-blog.csdnimg.cn/img_convert/e47dbf3b0ff8dea0e83d65e1a17fe4fe.png)\n\n这样重复n次即可完成冒泡排序。但这样的排序方式是可以优化的，因为在某次冒泡后，整个数据已经是有序的了，就不需要再排序。所以我们`需要一个标志量来标识有序的状态`，下面是优化后的代码——\n\n```java\n /**\n     * 冒泡排序\n     */\n    public void bubbleSort(int[] a,int n){\n        if(n <= 1)\n            return;\n        //比较n-1趟\n        for(int i=0;i<n-1;i++){\n            boolean flag = false;\n            for(int j=0;i<n-i-1;j++){\n                if(a[j] > a[j+1]){\n                    int tmp = a[j];\n                    a[j] = a[j+1];\n                    a[j+1] = tmp;\n                    //表明有数据交换\n                    flag = true;\n                }\n            }\n            //如果没有数据交换，则退出\n            if(!flag)\n                break;;\n        }\n    }\n```\n\n### 1.3.2 冒泡排序的分析\n\n1. `原地排序算法:`冒泡的过程只涉及相邻两个元素的交换操作，只需要常量级的临时空间，所以空间复杂度为O(1),即原地排序算法。\n\n2. `稳定的排序算法:`在比较时，相等的元素不需要交换位置，所以是稳定的排序算法\n\n3. `时间复杂度均为O(n2):`最好情况即是整个数据都是有序的，只需要进行一次冒泡就ok了，即最好时间复杂度为O(N)。同理，最坏情况下的时间复杂度为O(N2)。\n\n   那平均时间复杂度如何计算呢?按部就班的说，应该计算**期望**，但规模大的数据，计算期望是非常麻烦的，为了更好地描述平均时间复杂度，我们这里引入**有序度**的概念。\n\n   > **有序度是数组中具有有序关系的元素对的个数**。用数学表达式表示就是——\n   > $$\n   > a[i]>a[j],i>j\n   > $$\n\n   同理，假如有6个元素，那这组数据的满序度就是6*(6-1)/2,应用到更宽泛的范围，满序度可以表示为——\n   $$\n   n*(n-1)/2\n   $$\n   自然，我们也可以得到逆序度的概念：`逆序度=满序度-有序度`。\n\n   我们现在再来描述平均时间复杂度。最坏情况下，有序度为0，需要进行n*(n-1)/2次交换。最好情况下，有序度为n，不需要进行交换，则平均时间复杂度为\n   $$\n   n*   (n-1)/4\n   $$\n\n## 1.4 插入排序\n\n### 1.4.1 插入排序概述\n\n插入排序是借助区分**已排序区间和未排序区间**的思路来展开描述的。\n\n- [x] 插入算法的**核心**是**取未排序区间中的元素，将其插入到已排序区间的合适位置，并保证已排序区间数据一致有序。**\n\n如下图所示，要排序的数据为**4,5,6,1,3,2**——\n\n![image-20210214155307987](https://img-blog.csdnimg.cn/img_convert/c080151ce91820fc9a8697ee4e70d98e.png)\n\n插入排序同冒泡排序，包含元素的比较进而元素的移动两种操作，那我们如何描述需要移动元素多少次呢？\n\n这里直接给出概念，`移动次数就等于逆序度`。当然，也容易理解，移动完成后逆序度为0，那么移动次数自然等于逆序度。\n\n来看下插入排序的代码——\n\n```java\n/**\n     * 插入排序\n     */\n    public void insertionSort(int[] a,int n){\n        if(n == 1)\n            return;\n        //需要将未排序区间的n-1个元素放置到已排序区间合适的位置\n        for(int i=1;i<n;i++){\n            //记录要排序的值\n            int value = a[i];\n            int j = i-1;\n            //已排序区间\n            for(;j>=0;j--){\n                if(a[j] > value){\n                    a[j+1] = a[j];\n                }else{\n                    break;\n                }\n            }\n            //插入数据\n            a[j+1] = value;\n        }\n    }\n```\n\n### 1.4.2 插入排序分析\n\n- `原地排序算法：`比较数据交换元素时只需要常数级的空间，即空间复杂度为O(1);\n- `稳定的排序算法`：  当遇到相同元素时，**只需要将未排序数据中的元素插入到已排序相同元素的后面即可**，因此也是稳定的排序算法。\n- `时间复杂度：`最好时间复杂度为**O(N)**,最坏情况下，时间复杂度为**O(N2)**.在分析平均时间复杂度时，可以看做是将n-1个数据分别插入到有序的数组中去，一次这样的过程时间复杂度为O(N),那么整个过程的平均时间复杂度就为**O(N2)**\n\n## 1.5 选择排序\n\n### 1.5.1 选择排序概述\n\n选择排序的**思路类似于插入排序**，同样基于**已排序区间和未排序区间**的思路。不同的是，选择排序依次找出**未排序区间中的最小元素**，**将其与未排序区间的第一个元素互换位置,排好序的部分作为已排序区间。**\n\n我们来看下面的小例子——\n\n![image-20210214182637560](https://img-blog.csdnimg.cn/img_convert/cfffb76ec8fbe3678179f5d397b4047c.png)\n再来看下具体的代码实现——\n\n```java\n/**\n* 选择排序\n*/\n    public void selectSort(int[] a,int n){\n        if(n == 0)\n            return;\n        //每一趟最小值的初始值\n        for(int i=0;i<n-1;i++){\n            int min = a[i];\n            //标志位\n            boolean isSwap = false;\n            //记录最小值的下标\n            int index = i;\n            int j = i+1;\n            for(;j<n;j++){\n                //存在比最小值更小的值\n                if(min > a[j]){\n                    min = a[j];\n                    //记录新的最小值的下标\n                    index = j;\n                    isSwap = true;\n                }\n            }\n            //该趟中存在需要互换位置的元素\n            if(isSwap){\n                a[index] = a[i];\n                a[i] = min;\n            }\n        }\n    }\n```\n\n### 1.5.2 选择排序分析\n\n- `原地排序算法：`代码执行时只需要常数级的空间，即空间复杂度为O(1).\n- `不稳定的算法：`交换位置导致有可能颠倒相同值的相对位置，所以是不稳定的排序算法。\n- `时间复杂度分析：`最好，最坏，平均时间复杂度均为O(N2).\n\n------\n\n# 二、排序下\n\n## 摘要\n\n在排序上中提及到了冒泡排序，选择排序，插入排序。这三种排序是因为时间复杂度较高，所以**适用于规模小**的数据排序，因为y = x 2曲线的数据规模较小时增长趋势并不快。但在实际项目开发中，动辄上万的数据排序，我们应该怎样处理呢？这就涉及到**时间复杂度相对较小的快速排序与归并排序**，这两种排序都是使用**分治的编程思想**，理解起来相对困难一点，但在面试时，出于他们性能折中又适用范围广的特点，因此成为**面试的宠儿**。好啦，接下来进入正题——\n\n## 2.1 从一个问题开始\n\n`如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？`\n\n乍看上去，不管是快排还是归并排序，他们的时间复杂度都是O(NlogN),但使用分区技巧的快速排序**在合并之前就已经是一个有序的数据集了。**\n\n假设原始的数据集是这样的：`4,2,5,12,3`,要找到第3大的元素4.\n\n我们将数据已分区点为界分为三个区间，如果K等于分区点，则直接返回即可，假设不等于，我们就去**递归的分治的另外两个区间，直到区间缩小为1.**\n\n来计算下时间复杂度：首先遍历数据集找到分区点，时间复杂度为O(n),第二次只需要分治一半的元素，也就是时间复杂度为O(n/2).递推得到第n次分治需要的时间复杂度为O(n/2的n-1次方)，最后一次不需要分治，时间复杂度为O(1)，把这些时间复杂度加起来，构成一个等比数列的求和，**求和结果为2n-1**,也就是时间复杂度为O(n).\n\n## 2.2 归并排序\n\n### 2.2.1 概述\n\n归并排序是用**分治**的思想，将大问题分成小问题，小问题解决了，大问题自然也就解决了。\n\n归并排序时，首先执行**递**，将数组从中间分成两部分，对这两部分**分别进行分治，直到区间为1为止**。然后是**归**的过程，**依次排序合并每个小区间成大区间，直到得到排好序的数据集**。\n\n这样说总归是不形象的，我们来看下图解——\n\n![image-20210215112204718](https://img-blog.csdnimg.cn/img_convert/a0c1aaa677cec70cea2934481234173b.png)\n\n### 2.2.2 代码实现\n\n有了大致的思路，我们来使用递归实现归并排序，既然是递归问题，那就先找递归终止条件和递归公式咯——\n\n- `递归终止条件`：\n  $$\n  merge_sort(p...r) = merge(merge_sort(p,q),merge_sort(q+1,r))\n  $$\n\n- `递归公式`：\n  $$\n  p>=r\n  $$\n\n我们再将其转化为代码——\n\n```java\n /**\n     * 归并排序\n     */\n    public static int[] mergeSort(int[] a,int n){\n        mergeSort_s(a,0,n-1);\n        return a;\n    }\n\n    private static void mergeSort_s(int[] a, int from, int to) {\n        //递归终止条件\n        if(from >= to)\n            return;\n        //得到该区间的中间位置\n        int mid = (from+to)/2 ;\n        //分治递归\n        mergeSort_s(a, from, mid);\n        mergeSort_s(a, mid + 1, to);\n        merge(a,from,mid,to);\n    }\n\n    /**\n     * 合并两个有序数组并返回\n     * @param a\n     * @param from\n     * @param mid\n     * @param to\n     * @return\n     */\n    private static void merge(int[] a, int from, int mid, int to) {\n        //申请一个临时数组来存储合并结果\n        int[] tmp = new int[to-from+1];\n        //合并\n        int i = from,j = mid+1,k = 0;\n        while(i<=mid && j<=to){\n            if(a[i] <= a[j])\n                tmp[k++] = a[i++];\n            else{\n                tmp[k++] = a[j++];\n            }\n        }\n        //下面这句的思路好厉害！\n        int start = i;\n        int end = mid ;\n        //右边还有剩余元素\n        if(j <= to){\n            start = j;\n            end = to;\n        }\n        //拷贝剩余元素到tmp中\n        while(start <= end){\n            tmp[k++] = a[start++];\n        }\n        //拷贝临时数组到a中\n        for(i=0;i<=to-from;i++){\n            a[from+i] = tmp[i];\n        }\n    }\n}\n```\n\n这里加点私货，在写归并排序代码的时候，犯了一个从来没有去主动意识的致命错误，这个错误就是在某些场景下，else要不要写？我们先分析一段代码——\n\n```java\npublic static void main(String[] args) {\n        int res = 0;\n        if (res == 0) {\n            res = 1;\n        }\n        res = -1;\n        System.out.println(res);\n}\n```\n\n这是一段很简洁的代码，小伙伴们认为会输出什么呢？\n\n我以前有些完整的if与else的习惯，今天犯懒了，索性没有写else，因为我认为if之后部分的第一行就是else的代码，但是真的是这样吗？\n\n`这里我没有写else，系统会认为else不执行任何事情，而不是默认执行if语句块后的第一行代码。`\n\n那么怎样的编程习惯更值得提倡呢？\n\n先给出结论，**if和else要写就写成对！**，因为这样对测试人员友好一些，另外检测bug也容易检测出来，我们再延伸一下，什么情况下用if，什么情况下用if else.\n\n> - if用于逻辑追加\n> - if else用于逻辑分支\n\n另外，针对硬件的设计，我们可以给出一个小技巧：为真的条件写在前面。\n\n这是因为现代CPU并不会做逻辑判断，而是顺序执行，假如发现不满足条件，则会回滚并执行下一条语句。所以在写if,else的前提下尽可能将为真的条件写在前面。\n\n### 2.2.3 性能分析\n\n- `稳定的排序算法：`归并排序的稳定与否取决于合并的方式，在合并时针对相同元素，不改变他们的相对位置即可。所以归并排序是稳定的排序算法。\n\n- `时间复杂度分析`：这里先给出一个结论：**不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。**归并排序的时间复杂度包括子问题的时间复杂度与合并代码的时间复杂度**加和**。假设包括b和c两个子问题，则：\n  $$\n  T(a)=T(b)+T(c)+K\n  $$\n  这里的K指的是合并的时间复杂度，即为O(N).又因为两个子问题的时间复杂度都为O(N/2),则归并排序的时间复杂度为：\n  $$\n  T(1) = C\\\\\n  \n  T(n) = 2*T(N/2)+N n>1\n  $$\n  我们求解后可以得到——\n  $$\n  T(n) = 2*T(n/2) + n\\\\\n     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n\\\\\n     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n\\\\\n     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n\\\\\n     ......\\\\\n     = 2^k * T(n/2^k) + k * n\\\\\n     ......\n  $$\n  **当T(n/2^k) = T(1)时，即k = log2N，将其带入上式，可以得到，T(n)=Cn+nlogn,即归并排序的时间复杂度为O(nlogn).**\n\n- `不是原地排序算法`:归并排序用到递归的思想，所以自然不会是原地排序算法。那它的空间复杂度是什么呢?\n\n  > 在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。\n\n## 2.3 快速排序\n\n### 2.3.1 概述\n\nJava1.8源码中Arrays.sort()排序函数使用快速排序算法。\n\n![image-20210707230458288](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230458288.png)\n\n快速排序是用**递归与分治**，将数据集按照**某个分区点**分为**比分区点小的区间**和**比分区间大的区间**，然后在区间内再**递归**这项操作**直到区间内只有一个元素为止**。\n\n既然是递归，我们同样写出**递归终止条件**和**递推公式**——\n$$\n递推公式：\nquick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)\n\\\\\n终止条件：\np >= r\n$$\n到这，我们只需要选出适合的分区点即可，通常将**区间内的最后一个元素**作为分区点，然后将比分区点小的元素放到一个数组中，把比分区点大的元素放到一个数组中。\n\n思路完全合理，但并不优雅，因为这意味着需要额外的空间。那怎样才能不申请额外空间呢？这里我们借助选择排序的思路，即核心是**交换元素**。\n\n那归并与快排有什么区别呢？归并排序的处理过程是自下往上的，而快排则是自上往下的。\n\n我们通过图解来认识排序的过程——\n\n![image-20210215195133829](https://img-blog.csdnimg.cn/img_convert/158c9e4dc48b12dfdbfb1ea6fe8e785c.png)\n\n### 2.3.2 代码实现\n\n```java\n/**\n     * 快速排序\n     */\n    public static void quickSort(int[] a,int n){\n        quickSort_c(a,0,n-1);\n    }\n\n    private static void quickSort_c(int[] a, int from, int to) {\n        if(from >= to)\n            return;\n        int p = partition(a,from,to);\n        quickSort_c(a,from,p-1);\n        quickSort_c(a,p+1,to);\n    }\n    /**\n     * 分区函数\n     */\n    private static int partition(int[] a, int from, int to) {\n        //将最后一个元素作为分区点\n        int pivot = a[to];\n        int i = from;\n        for(int j=from;j<to;j++){\n            //小于分界点，则使用交换的方式将元素放到已排序区间\n            if(a[j] < pivot){\n                int tmp = a[i];\n                a[i] = a[j];\n                a[j] = tmp;\n                //\n                ++i;\n            }\n        }\n        int tmp = a[to];\n        a[to] = a[i];\n        a[i] = tmp;\n        return i;\n    }\n```\n\n### 2.3.3 性能分析\n\n这里不再推到具体过程，直接给出结论——\n\n- [x] `归并排序是一种不稳定的原地排序算法，它大部分情况下的时间复杂度为O(nlogn),只有个别情况下才会退化为O(n2)`\n\n------\n\n# 三.、线性排序分析总结\n\n## 3.1 前言\n\n在已经学习了五种基于比较的排序算法的基础上，我们仍要继续学习**三种特定场景下更优的不基于比较的排序算法**，那我们肯定会困惑，为什么不基于比较的算法在某些场景下性能更优呢，换句话说，基于比较的算法有什么不能逾越的天花板呢？\n\n这就需要引入CBA理论：`任何基于比较的排序算法的性能天花板就是O(nlogn)`.我们来探究一下这个结论是如何得出的——\n\n> - [x] 来自：https://yfsyfs.github.io/2019/05/25/CBA%E7%90%86%E8%AE%BA-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%9E%81%E9%99%90%E6%98%AFO-nlogn/\n>\n> 原因很简单, n个元素的全排列是`n!.` 而最终排序的结果只是其中一种（一棵含有n!个叶子节点的`二叉树`）. 每次比较, 我们可以砍掉一半的元素. 所以比较的次数就是树的高度.而此树的高度是\n> $$\n> \\log_2n!\n> $$\n> 由分析数学中的`Stirling公式`便知.速度不可能突破NlogN.\n\n既然是基因限制，那我们就有必要另辟蹊径，学习一下**时间复杂度为O(N)**的线性排序咯。\n\n## 3.2 桶排序\n\n### 3.2.1 概述\n\n这三种排序方式都会用到桶，而桶排序的核心思想是将`要排序的数据发到几个有序的桶里，每个桶里的数据再单独进行排序，排完序后再将每个桶中的数据按照顺序依次取出，组成的序列就是有序的了。`\n\n按照它的核心思想，我们来拆解一下桶排序的实现过程：\n\n1. 显然，桶的个数是首先应该被确定的，如果你再完后看的话，就会发现三种线性排序核心的区别就是`桶的大小粒度不同`，也就是每个桶中放的数据个数不同，就拿桶排序来说，它适用**外部排序**，也就是磁盘空间很充足，但内存不足,这就需要将磁盘中的文件分批地放入内存.\n\n   桶排序的桶的大小一般会预设好。所以桶的个数就等于数据的范围除以桶的大小。\n\n2. 接着就需要将数据按照`映射函数的规则`放置到对应的桶中。具体实现无非就是按大小分类到相应的桶下标。\n\n3. 然后自然就是排序啦，排序选用**java封装的快排方法**还是很舒适的，最后将排序后的桶元素放置到原数组即可。\n\n#### 复杂度分析\n\n- `时间复杂度`：假设有n个数据，分成m个桶，那每个桶中就有数据k=n/m个，每个桶中使用快排，时间复杂度为O(klogk),代入后可以得到O(n/mlog(n/m)),那总体的时间复杂度就是\n  $$\n  O(nlog(n/m))\n  $$\n  当**桶的个数趋近与数据量**时，桶排序的时间复杂度就可看做O(N).\n\n- `空间复杂度`：在将源数据分配到对应的桶时需要申请额外的空间，所以N个数据就需要额外申请N个空间，也就是空间复杂度为O(N).\n\n#### 总结\n\n> 桶排序堆排序数据的要求很苛刻，首先，要排序的数据需要`很容易就能划分成m个桶`，并且，桶和桶之间之间有着`天然的大小关系`。其次，数据在每个桶中的`分布是比较均匀`的，如果将数据都划分到同一个桶中，就会退化为O(nlogn)的排序算法啦。\n\n### 3.2.2 趣味图解\n\n![image-20210707230520254](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230520254.png)\n\n### 3.2.3 代码演示\n\n```java\npackage com.practice.sort;\n\nimport java.util.Arrays;\n\n/**\n *桶排序\n */\npublic class BucketSort {\n    public static void main(String[] args) {\n        int[] arry = {1,4,2,6,3,5,3,rry,2);\n        for (int value:arry};\n        arry = sort(arry) {\n            System.out.print(value+\" \");\n        }\n    }\n\n    private static int[] sort(int[] sourceArr,int bucketSize){\n        //首先拷贝数据,防止源数据因为没有备份而乱序\n        int[] arr = Arrays.copyOf(sourceArr, sourceArr.length);\n        return BucketSort(arr,5);\n    }\n\n    private static int[] BucketSort(int[] arr,int bucketSize){\n        //根据最小值，最大值确定分多少个桶\n        int max = arr[0];\n        int min = arr[0];\n        for (int data:arr) {\n            if(data > max){\n                max = data;\n            }else if(data < min){\n                min = data;\n            }\n        }\n        //确定桶数的原则\n        int bucketCount = (int)Math.floor((max-min)/bucketSize)+1;\n        //声明桶的标号\n        int[][] buckets = new int[bucketCount][0];\n        //通过映射函数将数据放到桶中\n        for(int i=0;i<arr.length;i++){\n            //确定数据对应的桶下标\n            int index = (int)Math.floor(arr[i]-min)/bucketSize;\n            //扩充二维数组对应行的列\n            buckets[index] = arrAppand(buckets[index], arr[i]);\n        }\n        int arryIndex = 0;\n        //为每个桶排序\n        for (int[] bucket:buckets) {\n            //特判\n            if(bucket.length <= 0)\n                continue;\n            Arrays.sort(bucket);\n            for (int value:bucket) {\n                arr[arryIndex++] = value;\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * 动态扩容,并保存数据\n     */\n    private static int[] arrAppand(int[] arr,int value){\n        arr = Arrays.copyOf(arr, arr.length + 1);\n        arr[arr.length-1] = value;\n        return arr;\n    }\n}\n```\n\n## 3.3 计数排序\n\n### 3.3.1 概述\n\n计数排序可以看做是桶排序的一种特殊情况，当要排序的数据所处的范围并不大时，我们将按数据最大值作为痛的个数，这样就省却了桶内排序的时间。\n\n我们同样聊聊来计数排序的实现：\n\n1. 类似于桶排序，计数排序同样首先确定桶的个数，这个就不再赘述。\n\n2. 然后，我们需要将源数据分配到对应的桶中，显然，如果分配到了对应的桶中，排序就已经完成了。那如何分配呢？\n\n   这个环节就是计数排序的核心啦——\n\n   假设有一组数据A[8]:2,5,3,0,2,3,0,3,我们首先遍历一遍数据，得到对应数据的个数C[6]——\n\n   ![image-20210707230533740](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230533740.png)\n\n   再对数据做顺序求和：\n\n   ![image-20210707230544186](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230544186.png)\n\n   也就是说C[i]里面存储的是小于等于I的数据个数。\n\n   最后的最后，最容易蒙圈的一步——\n\n   `逆序遍历数组，然后在数组C中找到与其相同的下标，然后通过下标对应的元素确定排序后数据的下标，再将个数减1。`\n\n   ![image-20210707230600134](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230600134.png)\n\n   王争老师的图绝了，非常有用！！！\n\n#### 复杂度分析\n\n- `时间复杂度：`计数的量级最大，但也不过于O(N).\n- `空间复杂度：`只需要额外申请一个计数数组，即计数的桶，则空间复杂度为O(N).\n\n#### 总结\n\n> 计数排序只能用在`数据范围不大的场景`中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给`非负整数`排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。\n\n### 3.3.2 趣味图解\n\n![img](https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif)\n\n### 3.3.3 代码演示\n\n```java\npackage com.practice.sort;\n\n/**\n * 计数排序\n */\npublic class CountingSort {\n    public static void main(String[] args) {\n        int[] arry = {1,5,2,4,3};\n        countSort(arry,arry.length);\n        for (int value:arry) {\n            System.out.print(value+\" \");\n        }\n    }\n\n    private static void countSort(int[] arry,int n){\n        //特判\n        if(n <= 1)\n            return ;\n        //计数排序的特征：值的范围小，将最大值作为桶的个数\n        int max = arry[0];\n        for(int i=0;i<n;i++){\n            if(arry[i] > max){\n                max = arry[i];\n            }\n        }\n        int bucketCount = max+1;\n        //声明并初始化桶\n        int[] buckets = new int[bucketCount];\n        for(int j=0;j<buckets.length;j++){\n            buckets[j] = 0;\n        }\n        //计数\n        for (int value:arry) {\n            ++buckets[value];\n        }\n        //累加\n        for(int k=1;k<buckets.length;k++){\n            buckets[k] += buckets[k-1];\n        }\n        //声明用于存储结果的tmp\n        int[] tmp = new int[arry.length];\n        //猎杀时刻~\n        for(int m=n-1;m>=0;m--){\n            int index = buckets[arry[m]]-1;\n            tmp[index] = arry[m];\n            buckets[arry[m]]--;\n        }\n        for(int i=0;i<n;i++){\n            arry[i] = tmp[i];\n        }\n    }\n}\n```\n\n## 3.4 基数排序\n\n### 3.4.1 概述\n\n> 基数排序要求数据可以划分成高低位，位之间有递进关系，比较两个数，我们只需要比较高位，高位相同再去比较低位，而且每一位的数据范围不能太大，因为基数排序需要借助桶排序或者计数排序来完成每一位的排序。\n\n还是熟悉的配方，我们来复现一下实现的过程——\n\n1. 首先根据数据中的**最大值位数**确定**桶的个数**。\n\n2. 接着**按位逆序排序**，我们这里只考虑通过最后一位对数据的划分：\n\n   通过取余运算得到的余数即为`桶对应的下标`，这里将数据分配到桶可以使用`二维数组`实现，最后将桶中的元素按序放回数组，准备下一位的比较。\n\n### 3.4.2 趣味图解\n\n![img](https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif)\n\n### 3.4.3 代码演示\n\n```java\npackage com.practice.sort;\n\nimport java.util.Arrays;\n\n/**\n * 基数排序\n */\npublic class RadixSort {\n    public static void main(String[] args) {\n        int[] arry = {2,5,24,12,30,50,0};\n        radixSort(arry,arry.length);\n        for (int value:arry) {\n            System.out.print(value+\" \");\n        }\n    }\n\n    private static void radixSort(int[] arry,int n){\n        //确定桶的个数\n        int max = arry[0];\n        for(int i=1;i<arry.length;i++){\n            if(max < arry[i]){\n                max = arry[i];\n            }\n        }\n        //得到它的位数\n        int bitCount = getBitCount(max);\n        //按位逆序排序,首先声明除数和余数\n        int mod = 10;\n        int dev = 1;\n        //bitcount趟比较\n        for(int j=0;j<bitCount;j++,mod*=10,dev*=10){\n            //声明临时数组\n            int[][] tmp = new int[mod * 2][0];\n            //将数据按照当前位放置到对应的桶中\n            for(int k=0;k<arry.length;k++){\n                //最好手绘验证一下\n                int bucket = (arry[k]%mod)/dev+mod;\n                tmp[bucket] = arryAppand(tmp[bucket],arry[k]);\n            }\n            //分别遍历每个桶中的元素，并将它们按序再放回数组中\n            int pos = 0;\n            for (int[] bucket:tmp) {\n                for(int value:bucket){\n                    arry[pos++] = value;\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组扩容并保存\n     * @param arry\n     * @param value\n     * @return\n     */\n    private static int[] arryAppand(int[] arry, int value) {\n        arry = Arrays.copyOf(arry, arry.length + 1);\n        arry[arry.length-1] = value;\n        return arry;\n    }\n\n    /**\n     * 获取整数位数\n     * @param value\n     * @return\n     */\n    private static int getBitCount(int value){\n        if(value == 0)\n            return 1;\n        int count = 0;\n        while(value > 0){\n            value /=10;\n            count++;\n        }\n        return count;\n    }\n\n}\n\n```\n\n------\n\n> 日拱一卒，功不唐捐。","slug":"数据结构常见的八大排序图文详解","published":1,"updated":"2023-09-24T09:50:29.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7m0001vxjcc6h9v7zgv","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>算法如果按照模块分，<code>排序算法绝对算得上割据一方的存在</code>。我们无可避免地会想，对一组数据进行排序让你玩得这么花，有这个必要吗？我想被要求手写快排的人至少是认为有的~</p>\n<p>就如同以前历史老师所说的那般：学习历史学的不是历史本身，而是<code>历史背后的故事</code>。</p>\n<p>而排序算法背后，<code>分治思想，二分思想，优化，时空复杂度</code>都是需要我们去探寻的故事，而不同的排序算法在相同场景下的性能大相径庭，到底选谁呢？有没有什么衡量依据呢？人们更常用的是哪种呢？故事的大幕就此拉开——</p>\n<blockquote>\n<p>注：文章中的图均来自于极客时间数据结构与算法专栏。文章初衷是作为笔记使用，所以缺乏详细推导，仅用于回顾知识点。</p>\n</blockquote>\n<hr>\n<h1 id=\"一、排序上——冒泡-插入-选择排序\"><a href=\"#一、排序上——冒泡-插入-选择排序\" class=\"headerlink\" title=\"一、排序上——冒泡,插入,选择排序\"></a>一、排序上——冒泡,插入,选择排序</h1><h2 id=\"1-1-从一个问题开始\"><a href=\"#1-1-从一个问题开始\" class=\"headerlink\" title=\"1.1 从一个问题开始\"></a>1.1 从一个问题开始</h2><p><code>Q</code>：插入排序和冒泡排序的时间复杂度都为O(n2),但为什么人们更倾向于选择插入排序呢？</p>\n<p><code>A</code>：<strong>插入排序和冒泡排序的时间复杂度都为O(n2),且他们都是稳定的原地排序算法，但他们的性能区别在于比较次数和交换次数。</strong></p>\n<p>冒泡排序不管怎么优化，它的交换次数，也就是<code>移动元素次数</code>都是固定值，即原始数据的<code>逆序度</code>。插入排序同样如是。</p>\n<p>但从代码实现上来说，冒泡排序需要<code>三次赋值</code>，而插入排序只需要<code>一次赋值</code>。也就是说冒泡排序的数据交换比插入排序的数据交换更复杂，我们来具象的看一下——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//冒泡排序中的交换操作</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n    flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//插入排序中的交换操作</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\ta<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"1-2-如何分析一个排序算法\"><a href=\"#1-2-如何分析一个排序算法\" class=\"headerlink\" title=\"1.2 如何分析一个排序算法\"></a>1.2 如何分析一个排序算法</h2><h3 id=\"1-2-1-排序算法的执行效率\"><a href=\"#1-2-1-排序算法的执行效率\" class=\"headerlink\" title=\"1.2.1 排序算法的执行效率\"></a>1.2.1 排序算法的执行效率</h3><h4 id=\"最好情况，最坏情况，平均情况时间复杂度\"><a href=\"#最好情况，最坏情况，平均情况时间复杂度\" class=\"headerlink\" title=\"最好情况，最坏情况，平均情况时间复杂度\"></a>最好情况，最坏情况，平均情况时间复杂度</h4><p>在之前的学习中，我们只需要粗略的比较时间复杂度，那为什么在排序时，又需要引入这些具体的参数呢?</p>\n<ol>\n<li>有些排序算法有区分的必要；</li>\n<li>对于要排序的数据，<strong>有序度</strong>是截然不同的。</li>\n</ol>\n<h4 id=\"时间复杂度的系数，常数和低阶\"><a href=\"#时间复杂度的系数，常数和低阶\" class=\"headerlink\" title=\"时间复杂度的系数，常数和低阶\"></a>时间复杂度的系数，常数和低阶</h4><p>同样的困惑，但这个要好解答的多，无非是<strong>数据规模小的情况</strong>下，这些参数本身就可以表达一种<strong>趋势</strong>。</p>\n<h4 id=\"比较次数和交换次数\"><a href=\"#比较次数和交换次数\" class=\"headerlink\" title=\"比较次数和交换次数\"></a>比较次数和交换次数</h4><p>排序算法有两类，一类基于排序，一类不基于排序。在分析基于排序的算法中，<strong>数据交换就意味着数据搬移，是要耗费性能的</strong>，所以有必要区分。</p>\n<h3 id=\"1-2-2-排序算法的内存消耗\"><a href=\"#1-2-2-排序算法的内存消耗\" class=\"headerlink\" title=\"1.2.2 排序算法的内存消耗\"></a>1.2.2 排序算法的内存消耗</h3><p>为了描述内存消耗，我们引入<strong>原地排序</strong>的概念，所谓原地排序，就是指**空间复杂度为O(1)**。</p>\n<h3 id=\"1-2-3-排序算法的稳定性\"><a href=\"#1-2-3-排序算法的稳定性\" class=\"headerlink\" title=\"1.2.3 排序算法的稳定性\"></a>1.2.3 排序算法的稳定性</h3><p>稳定性的大致意思是在新的需求被引入后，原本系统能够维持相对稳定。而在这里，排序算法的稳定性指的是，<strong>如果待排序的序列中存在值相等的元素，经过排序以后，相等元素之间的原有的先后顺序不变。</strong></p>\n<p>但是业务中的排序，往往不是对单纯的整数进行排序，而是一组<code>对象</code>，我们需要根据对象的<code>某个KEY</code>进行排序。来看一个小例子——</p>\n<blockquote>\n<p>假如说，我们需要给电商交易系统中的订单排序。订单有两个属性，一个是下单时间，一个是订单金额。如果我们现在有10万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照订单时间排序，对于这样的需求，我们要怎么做？</p>\n<p>很明显，先入为主的一种方式是，首先根据订单金额进行排序，在对订单金额相同的区间按照时间排序。</p>\n<p>很自然没错，但在每个小区间要交换元素的次数太多了，有没有性能更高的方法呢？</p>\n<p><strong>我们需要选择一种稳定的排序算法，也就是先对订单按照时间进行排序，再使用稳定排序算法按照金额进行排序，这样的话，我们就能确保金额相同的两个对象，在排序后的前后顺序不变。</strong></p>\n</blockquote>\n<h2 id=\"1-3-冒泡排序\"><a href=\"#1-3-冒泡排序\" class=\"headerlink\" title=\"1.3 冒泡排序\"></a>1.3 冒泡排序</h2><h3 id=\"1-3-1-冒泡排序概述\"><a href=\"#1-3-1-冒泡排序概述\" class=\"headerlink\" title=\"1.3.1 冒泡排序概述\"></a>1.3.1 冒泡排序概述</h3><p>冒泡排序比较相邻的两个元素，如果不满足大小关系，则互换位置，一次冒泡会让至少一个元素移动到它应该在的位置。重复n次即可完成排序。</p>\n<p>下面我们来看具体的例子：对一组数据4,5,6,3,2,1从小到大进行排序。</p>\n<p>那么第一次冒泡的过程是这样的——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e47dbf3b0ff8dea0e83d65e1a17fe4fe.png\" alt=\"image-20210214151417841\"></p>\n<p>这样重复n次即可完成冒泡排序。但这样的排序方式是可以优化的，因为在某次冒泡后，整个数据已经是有序的了，就不需要再排序。所以我们<code>需要一个标志量来标识有序的状态</code>，下面是优化后的代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n    * 冒泡排序\n    */</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n           <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//比较n-1趟</span>\n       <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n           <span class=\"token keyword\">boolean</span> flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n           <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">-</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n               <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                   <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                   a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                   a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n                   <span class=\"token comment\">//表明有数据交换</span>\n                   flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">&#125;</span>\n           <span class=\"token punctuation\">&#125;</span>\n           <span class=\"token comment\">//如果没有数据交换，则退出</span>\n           <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flag<span class=\"token punctuation\">)</span>\n               <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-3-2-冒泡排序的分析\"><a href=\"#1-3-2-冒泡排序的分析\" class=\"headerlink\" title=\"1.3.2 冒泡排序的分析\"></a>1.3.2 冒泡排序的分析</h3><ol>\n<li><p><code>原地排序算法:</code>冒泡的过程只涉及相邻两个元素的交换操作，只需要常量级的临时空间，所以空间复杂度为O(1),即原地排序算法。</p>\n</li>\n<li><p><code>稳定的排序算法:</code>在比较时，相等的元素不需要交换位置，所以是稳定的排序算法</p>\n</li>\n<li><p><code>时间复杂度均为O(n2):</code>最好情况即是整个数据都是有序的，只需要进行一次冒泡就ok了，即最好时间复杂度为O(N)。同理，最坏情况下的时间复杂度为O(N2)。</p>\n<p>那平均时间复杂度如何计算呢?按部就班的说，应该计算<strong>期望</strong>，但规模大的数据，计算期望是非常麻烦的，为了更好地描述平均时间复杂度，我们这里引入<strong>有序度</strong>的概念。</p>\n<blockquote>\n<p><strong>有序度是数组中具有有序关系的元素对的个数</strong>。用数学表达式表示就是——<br>$$<br>a[i]&gt;a[j],i&gt;j<br>$$</p>\n</blockquote>\n<p>同理，假如有6个元素，那这组数据的满序度就是6*(6-1)/2,应用到更宽泛的范围，满序度可以表示为——<br>$$<br>n*(n-1)/2<br>$$<br>自然，我们也可以得到逆序度的概念：<code>逆序度=满序度-有序度</code>。</p>\n<p>我们现在再来描述平均时间复杂度。最坏情况下，有序度为0，需要进行n*(n-1)/2次交换。最好情况下，有序度为n，不需要进行交换，则平均时间复杂度为<br>$$<br>n*   (n-1)/4<br>$$</p>\n</li>\n</ol>\n<h2 id=\"1-4-插入排序\"><a href=\"#1-4-插入排序\" class=\"headerlink\" title=\"1.4 插入排序\"></a>1.4 插入排序</h2><h3 id=\"1-4-1-插入排序概述\"><a href=\"#1-4-1-插入排序概述\" class=\"headerlink\" title=\"1.4.1 插入排序概述\"></a>1.4.1 插入排序概述</h3><p>插入排序是借助区分<strong>已排序区间和未排序区间</strong>的思路来展开描述的。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 插入算法的<strong>核心</strong>是<strong>取未排序区间中的元素，将其插入到已排序区间的合适位置，并保证已排序区间数据一致有序。</strong></li>\n</ul>\n<p>如下图所示，要排序的数据为<strong>4,5,6,1,3,2</strong>——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c080151ce91820fc9a8697ee4e70d98e.png\" alt=\"image-20210214155307987\"></p>\n<p>插入排序同冒泡排序，包含元素的比较进而元素的移动两种操作，那我们如何描述需要移动元素多少次呢？</p>\n<p>这里直接给出概念，<code>移动次数就等于逆序度</code>。当然，也容易理解，移动完成后逆序度为0，那么移动次数自然等于逆序度。</p>\n<p>来看下插入排序的代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n     * 插入排序\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//需要将未排序区间的n-1个元素放置到已排序区间合适的位置</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//记录要排序的值</span>\n            <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//已排序区间</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">//插入数据</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-4-2-插入排序分析\"><a href=\"#1-4-2-插入排序分析\" class=\"headerlink\" title=\"1.4.2 插入排序分析\"></a>1.4.2 插入排序分析</h3><ul>\n<li><code>原地排序算法：</code>比较数据交换元素时只需要常数级的空间，即空间复杂度为O(1);</li>\n<li><code>稳定的排序算法</code>：  当遇到相同元素时，<strong>只需要将未排序数据中的元素插入到已排序相同元素的后面即可</strong>，因此也是稳定的排序算法。</li>\n<li><code>时间复杂度：</code>最好时间复杂度为<strong>O(N)</strong>,最坏情况下，时间复杂度为<strong>O(N2)</strong>.在分析平均时间复杂度时，可以看做是将n-1个数据分别插入到有序的数组中去，一次这样的过程时间复杂度为O(N),那么整个过程的平均时间复杂度就为<strong>O(N2)</strong></li>\n</ul>\n<h2 id=\"1-5-选择排序\"><a href=\"#1-5-选择排序\" class=\"headerlink\" title=\"1.5 选择排序\"></a>1.5 选择排序</h2><h3 id=\"1-5-1-选择排序概述\"><a href=\"#1-5-1-选择排序概述\" class=\"headerlink\" title=\"1.5.1 选择排序概述\"></a>1.5.1 选择排序概述</h3><p>选择排序的<strong>思路类似于插入排序</strong>，同样基于<strong>已排序区间和未排序区间</strong>的思路。不同的是，选择排序依次找出<strong>未排序区间中的最小元素</strong>，<strong>将其与未排序区间的第一个元素互换位置,排好序的部分作为已排序区间。</strong></p>\n<p>我们来看下面的小例子——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/cfffb76ec8fbe3678179f5d397b4047c.png\" alt=\"image-20210214182637560\"><br>再来看下具体的代码实现——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n* 选择排序\n*/</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">selectSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//每一趟最小值的初始值</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//标志位</span>\n            <span class=\"token keyword\">boolean</span> isSwap <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//记录最小值的下标</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">//存在比最小值更小的值</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>min <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    min <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">//记录新的最小值的下标</span>\n                    index <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n                    isSwap <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">//该趟中存在需要互换位置的元素</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>isSwap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> min<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-5-2-选择排序分析\"><a href=\"#1-5-2-选择排序分析\" class=\"headerlink\" title=\"1.5.2 选择排序分析\"></a>1.5.2 选择排序分析</h3><ul>\n<li><code>原地排序算法：</code>代码执行时只需要常数级的空间，即空间复杂度为O(1).</li>\n<li><code>不稳定的算法：</code>交换位置导致有可能颠倒相同值的相对位置，所以是不稳定的排序算法。</li>\n<li><code>时间复杂度分析：</code>最好，最坏，平均时间复杂度均为O(N2).</li>\n</ul>\n<hr>\n<h1 id=\"二、排序下\"><a href=\"#二、排序下\" class=\"headerlink\" title=\"二、排序下\"></a>二、排序下</h1><h2 id=\"摘要-1\"><a href=\"#摘要-1\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在排序上中提及到了冒泡排序，选择排序，插入排序。这三种排序是因为时间复杂度较高，所以<strong>适用于规模小</strong>的数据排序，因为y = x 2曲线的数据规模较小时增长趋势并不快。但在实际项目开发中，动辄上万的数据排序，我们应该怎样处理呢？这就涉及到<strong>时间复杂度相对较小的快速排序与归并排序</strong>，这两种排序都是使用<strong>分治的编程思想</strong>，理解起来相对困难一点，但在面试时，出于他们性能折中又适用范围广的特点，因此成为<strong>面试的宠儿</strong>。好啦，接下来进入正题——</p>\n<h2 id=\"2-1-从一个问题开始\"><a href=\"#2-1-从一个问题开始\" class=\"headerlink\" title=\"2.1 从一个问题开始\"></a>2.1 从一个问题开始</h2><p><code>如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？</code></p>\n<p>乍看上去，不管是快排还是归并排序，他们的时间复杂度都是O(NlogN),但使用分区技巧的快速排序<strong>在合并之前就已经是一个有序的数据集了。</strong></p>\n<p>假设原始的数据集是这样的：<code>4,2,5,12,3</code>,要找到第3大的元素4.</p>\n<p>我们将数据已分区点为界分为三个区间，如果K等于分区点，则直接返回即可，假设不等于，我们就去<strong>递归的分治的另外两个区间，直到区间缩小为1.</strong></p>\n<p>来计算下时间复杂度：首先遍历数据集找到分区点，时间复杂度为O(n),第二次只需要分治一半的元素，也就是时间复杂度为O(n/2).递推得到第n次分治需要的时间复杂度为O(n/2的n-1次方)，最后一次不需要分治，时间复杂度为O(1)，把这些时间复杂度加起来，构成一个等比数列的求和，<strong>求和结果为2n-1</strong>,也就是时间复杂度为O(n).</p>\n<h2 id=\"2-2-归并排序\"><a href=\"#2-2-归并排序\" class=\"headerlink\" title=\"2.2 归并排序\"></a>2.2 归并排序</h2><h3 id=\"2-2-1-概述\"><a href=\"#2-2-1-概述\" class=\"headerlink\" title=\"2.2.1 概述\"></a>2.2.1 概述</h3><p>归并排序是用<strong>分治</strong>的思想，将大问题分成小问题，小问题解决了，大问题自然也就解决了。</p>\n<p>归并排序时，首先执行<strong>递</strong>，将数组从中间分成两部分，对这两部分<strong>分别进行分治，直到区间为1为止</strong>。然后是<strong>归</strong>的过程，<strong>依次排序合并每个小区间成大区间，直到得到排好序的数据集</strong>。</p>\n<p>这样说总归是不形象的，我们来看下图解——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/a0c1aaa677cec70cea2934481234173b.png\" alt=\"image-20210215112204718\"></p>\n<h3 id=\"2-2-2-代码实现\"><a href=\"#2-2-2-代码实现\" class=\"headerlink\" title=\"2.2.2 代码实现\"></a>2.2.2 代码实现</h3><p>有了大致的思路，我们来使用递归实现归并排序，既然是递归问题，那就先找递归终止条件和递归公式咯——</p>\n<ul>\n<li><p><code>递归终止条件</code>：<br>$$<br>merge_sort(p…r) = merge(merge_sort(p,q),merge_sort(q+1,r))<br>$$</p>\n</li>\n<li><p><code>递归公式</code>：<br>$$<br>p&gt;=r<br>$$</p>\n</li>\n</ul>\n<p>我们再将其转化为代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> <span class=\"token comment\">/**\n     * 归并排序\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//递归终止条件</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>from <span class=\"token operator\">>=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//得到该区间的中间位置</span>\n        <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>from<span class=\"token operator\">+</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//分治递归</span>\n        <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> from<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>from<span class=\"token punctuation\">,</span>mid<span class=\"token punctuation\">,</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 合并两个有序数组并返回\n     * @param a\n     * @param from\n     * @param mid\n     * @param to\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> mid<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//申请一个临时数组来存储合并结果</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>from<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//合并</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> from<span class=\"token punctuation\">,</span>j <span class=\"token operator\">=</span> mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;=</span>mid <span class=\"token operator\">&amp;&amp;</span> j<span class=\"token operator\">&lt;=</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//下面这句的思路好厉害！</span>\n        <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> mid <span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//右边还有剩余元素</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            start <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n            end <span class=\"token operator\">=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//拷贝剩余元素到tmp中</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>start<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//拷贝临时数组到a中</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>from<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            a<span class=\"token punctuation\">[</span>from<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里加点私货，在写归并排序代码的时候，犯了一个从来没有去主动意识的致命错误，这个错误就是在某些场景下，else要不要写？我们先分析一段代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        res <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是一段很简洁的代码，小伙伴们认为会输出什么呢？</p>\n<p>我以前有些完整的if与else的习惯，今天犯懒了，索性没有写else，因为我认为if之后部分的第一行就是else的代码，但是真的是这样吗？</p>\n<p><code>这里我没有写else，系统会认为else不执行任何事情，而不是默认执行if语句块后的第一行代码。</code></p>\n<p>那么怎样的编程习惯更值得提倡呢？</p>\n<p>先给出结论，<strong>if和else要写就写成对！</strong>，因为这样对测试人员友好一些，另外检测bug也容易检测出来，我们再延伸一下，什么情况下用if，什么情况下用if else.</p>\n<blockquote>\n<ul>\n<li>if用于逻辑追加</li>\n<li>if else用于逻辑分支</li>\n</ul>\n</blockquote>\n<p>另外，针对硬件的设计，我们可以给出一个小技巧：为真的条件写在前面。</p>\n<p>这是因为现代CPU并不会做逻辑判断，而是顺序执行，假如发现不满足条件，则会回滚并执行下一条语句。所以在写if,else的前提下尽可能将为真的条件写在前面。</p>\n<h3 id=\"2-2-3-性能分析\"><a href=\"#2-2-3-性能分析\" class=\"headerlink\" title=\"2.2.3 性能分析\"></a>2.2.3 性能分析</h3><ul>\n<li><p><code>稳定的排序算法：</code>归并排序的稳定与否取决于合并的方式，在合并时针对相同元素，不改变他们的相对位置即可。所以归并排序是稳定的排序算法。</p>\n</li>\n<li><p><code>时间复杂度分析</code>：这里先给出一个结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong>归并排序的时间复杂度包括子问题的时间复杂度与合并代码的时间复杂度<strong>加和</strong>。假设包括b和c两个子问题，则：<br>$$<br>T(a)=T(b)+T(c)+K<br>$$<br>这里的K指的是合并的时间复杂度，即为O(N).又因为两个子问题的时间复杂度都为O(N/2),则归并排序的时间复杂度为：<br>$$<br>T(1) = C\\</p>\n<p>T(n) = 2<em>T(N/2)+N n&gt;1<br>$$<br>我们求解后可以得到——<br>$$<br>T(n) = 2</em>T(n/2) + n\\<br>   = 2*(2<em>T(n/4) + n/2) + n = 4</em>T(n/4) + 2<em>n\\<br>   = 4</em>(2<em>T(n/8) + n/4) + 2</em>n = 8<em>T(n/8) + 3</em>n\\<br>   = 8*(2<em>T(n/16) + n/8) + 3</em>n = 16<em>T(n/16) + 4</em>n\\<br>   ……\\<br>   = 2^k * T(n/2^k) + k * n\\<br>   ……<br>$$<br><strong>当T(n/2^k) = T(1)时，即k = log2N，将其带入上式，可以得到，T(n)=Cn+nlogn,即归并排序的时间复杂度为O(nlogn).</strong></p>\n</li>\n<li><p><code>不是原地排序算法</code>:归并排序用到递归的思想，所以自然不会是原地排序算法。那它的空间复杂度是什么呢?</p>\n<blockquote>\n<p>在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"2-3-快速排序\"><a href=\"#2-3-快速排序\" class=\"headerlink\" title=\"2.3 快速排序\"></a>2.3 快速排序</h2><h3 id=\"2-3-1-概述\"><a href=\"#2-3-1-概述\" class=\"headerlink\" title=\"2.3.1 概述\"></a>2.3.1 概述</h3><p>Java1.8源码中Arrays.sort()排序函数使用快速排序算法。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230458288.png\" alt=\"image-20210707230458288\"></p>\n<p>快速排序是用<strong>递归与分治</strong>，将数据集按照<strong>某个分区点</strong>分为<strong>比分区点小的区间</strong>和<strong>比分区间大的区间</strong>，然后在区间内再<strong>递归</strong>这项操作<strong>直到区间内只有一个元素为止</strong>。</p>\n<p>既然是递归，我们同样写出<strong>递归终止条件</strong>和<strong>递推公式</strong>——<br>$$<br>递推公式：<br>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)<br>\\<br>终止条件：<br>p &gt;= r<br>$$<br>到这，我们只需要选出适合的分区点即可，通常将<strong>区间内的最后一个元素</strong>作为分区点，然后将比分区点小的元素放到一个数组中，把比分区点大的元素放到一个数组中。</p>\n<p>思路完全合理，但并不优雅，因为这意味着需要额外的空间。那怎样才能不申请额外空间呢？这里我们借助选择排序的思路，即核心是<strong>交换元素</strong>。</p>\n<p>那归并与快排有什么区别呢？归并排序的处理过程是自下往上的，而快排则是自上往下的。</p>\n<p>我们通过图解来认识排序的过程——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/158c9e4dc48b12dfdbfb1ea6fe8e785c.png\" alt=\"image-20210215195133829\"></p>\n<h3 id=\"2-3-2-代码实现\"><a href=\"#2-3-2-代码实现\" class=\"headerlink\" title=\"2.3.2 代码实现\"></a>2.3.2 代码实现</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n     * 快速排序\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>from <span class=\"token operator\">>=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>from<span class=\"token punctuation\">,</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>from<span class=\"token punctuation\">,</span>p<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>p<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">/**\n     * 分区函数\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//将最后一个元素作为分区点</span>\n        <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> from<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span>from<span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//小于分界点，则使用交换的方式将元素放到已排序区间</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">//</span>\n                <span class=\"token operator\">++</span>i<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a<span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-3-3-性能分析\"><a href=\"#2-3-3-性能分析\" class=\"headerlink\" title=\"2.3.3 性能分析\"></a>2.3.3 性能分析</h3><p>这里不再推到具体过程，直接给出结论——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <code>归并排序是一种不稳定的原地排序算法，它大部分情况下的时间复杂度为O(nlogn),只有个别情况下才会退化为O(n2)</code></li>\n</ul>\n<hr>\n<h1 id=\"三-、线性排序分析总结\"><a href=\"#三-、线性排序分析总结\" class=\"headerlink\" title=\"三.、线性排序分析总结\"></a>三.、线性排序分析总结</h1><h2 id=\"3-1-前言\"><a href=\"#3-1-前言\" class=\"headerlink\" title=\"3.1 前言\"></a>3.1 前言</h2><p>在已经学习了五种基于比较的排序算法的基础上，我们仍要继续学习<strong>三种特定场景下更优的不基于比较的排序算法</strong>，那我们肯定会困惑，为什么不基于比较的算法在某些场景下性能更优呢，换句话说，基于比较的算法有什么不能逾越的天花板呢？</p>\n<p>这就需要引入CBA理论：<code>任何基于比较的排序算法的性能天花板就是O(nlogn)</code>.我们来探究一下这个结论是如何得出的——</p>\n<blockquote>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 来自：<a href=\"https://yfsyfs.github.io/2019/05/25/CBA%E7%90%86%E8%AE%BA-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%9E%81%E9%99%90%E6%98%AFO-nlogn/\">https://yfsyfs.github.io/2019/05/25/CBA%E7%90%86%E8%AE%BA-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%9E%81%E9%99%90%E6%98%AFO-nlogn/</a></li>\n</ul>\n<p>原因很简单, n个元素的全排列是<code>n!.</code> 而最终排序的结果只是其中一种（一棵含有n!个叶子节点的<code>二叉树</code>）. 每次比较, 我们可以砍掉一半的元素. 所以比较的次数就是树的高度.而此树的高度是<br>$$<br>\\log_2n!<br>$$<br>由分析数学中的<code>Stirling公式</code>便知.速度不可能突破NlogN.</p>\n</blockquote>\n<p>既然是基因限制，那我们就有必要另辟蹊径，学习一下**时间复杂度为O(N)**的线性排序咯。</p>\n<h2 id=\"3-2-桶排序\"><a href=\"#3-2-桶排序\" class=\"headerlink\" title=\"3.2 桶排序\"></a>3.2 桶排序</h2><h3 id=\"3-2-1-概述\"><a href=\"#3-2-1-概述\" class=\"headerlink\" title=\"3.2.1 概述\"></a>3.2.1 概述</h3><p>这三种排序方式都会用到桶，而桶排序的核心思想是将<code>要排序的数据发到几个有序的桶里，每个桶里的数据再单独进行排序，排完序后再将每个桶中的数据按照顺序依次取出，组成的序列就是有序的了。</code></p>\n<p>按照它的核心思想，我们来拆解一下桶排序的实现过程：</p>\n<ol>\n<li><p>显然，桶的个数是首先应该被确定的，如果你再完后看的话，就会发现三种线性排序核心的区别就是<code>桶的大小粒度不同</code>，也就是每个桶中放的数据个数不同，就拿桶排序来说，它适用<strong>外部排序</strong>，也就是磁盘空间很充足，但内存不足,这就需要将磁盘中的文件分批地放入内存.</p>\n<p>桶排序的桶的大小一般会预设好。所以桶的个数就等于数据的范围除以桶的大小。</p>\n</li>\n<li><p>接着就需要将数据按照<code>映射函数的规则</code>放置到对应的桶中。具体实现无非就是按大小分类到相应的桶下标。</p>\n</li>\n<li><p>然后自然就是排序啦，排序选用<strong>java封装的快排方法</strong>还是很舒适的，最后将排序后的桶元素放置到原数组即可。</p>\n</li>\n</ol>\n<h4 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li><p><code>时间复杂度</code>：假设有n个数据，分成m个桶，那每个桶中就有数据k=n/m个，每个桶中使用快排，时间复杂度为O(klogk),代入后可以得到O(n/mlog(n/m)),那总体的时间复杂度就是<br>$$<br>O(nlog(n/m))<br>$$<br>当<strong>桶的个数趋近与数据量</strong>时，桶排序的时间复杂度就可看做O(N).</p>\n</li>\n<li><p><code>空间复杂度</code>：在将源数据分配到对应的桶时需要申请额外的空间，所以N个数据就需要额外申请N个空间，也就是空间复杂度为O(N).</p>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>桶排序堆排序数据的要求很苛刻，首先，要排序的数据需要<code>很容易就能划分成m个桶</code>，并且，桶和桶之间之间有着<code>天然的大小关系</code>。其次，数据在每个桶中的<code>分布是比较均匀</code>的，如果将数据都划分到同一个桶中，就会退化为O(nlogn)的排序算法啦。</p>\n</blockquote>\n<h3 id=\"3-2-2-趣味图解\"><a href=\"#3-2-2-趣味图解\" class=\"headerlink\" title=\"3.2.2 趣味图解\"></a>3.2.2 趣味图解</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230520254.png\" alt=\"image-20210707230520254\"></p>\n<h3 id=\"3-2-3-代码演示\"><a href=\"#3-2-3-代码演示\" class=\"headerlink\" title=\"3.2.3 代码演示\"></a>3.2.3 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>practice<span class=\"token punctuation\">.</span>sort</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n *桶排序\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BucketSort</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>rry<span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        arry <span class=\"token operator\">=</span> <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> sourceArr<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> bucketSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//首先拷贝数据,防止源数据因为没有备份而乱序</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>sourceArr<span class=\"token punctuation\">,</span> sourceArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">BucketSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\">BucketSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> bucketSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//根据最小值，最大值确定分多少个桶</span>\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> data<span class=\"token operator\">:</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                max <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">&lt;</span> min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                min <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//确定桶数的原则</span>\n        <span class=\"token keyword\">int</span> bucketCount <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>max<span class=\"token operator\">-</span>min<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>bucketSize<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明桶的标号</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buckets <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>bucketCount<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//通过映射函数将数据放到桶中</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//确定数据对应的桶下标</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>min<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>bucketSize<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//扩充二维数组对应行的列</span>\n            buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">arrAppand</span><span class=\"token punctuation\">(</span>buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">int</span> arryIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//为每个桶排序</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bucket<span class=\"token operator\">:</span>buckets<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//特判</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>bucket<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                arr<span class=\"token punctuation\">[</span>arryIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 动态扩容,并保存数据\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">arrAppand</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        arr <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        arr<span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3-3-计数排序\"><a href=\"#3-3-计数排序\" class=\"headerlink\" title=\"3.3 计数排序\"></a>3.3 计数排序</h2><h3 id=\"3-3-1-概述\"><a href=\"#3-3-1-概述\" class=\"headerlink\" title=\"3.3.1 概述\"></a>3.3.1 概述</h3><p>计数排序可以看做是桶排序的一种特殊情况，当要排序的数据所处的范围并不大时，我们将按数据最大值作为痛的个数，这样就省却了桶内排序的时间。</p>\n<p>我们同样聊聊来计数排序的实现：</p>\n<ol>\n<li><p>类似于桶排序，计数排序同样首先确定桶的个数，这个就不再赘述。</p>\n</li>\n<li><p>然后，我们需要将源数据分配到对应的桶中，显然，如果分配到了对应的桶中，排序就已经完成了。那如何分配呢？</p>\n<p>这个环节就是计数排序的核心啦——</p>\n<p>假设有一组数据A[8]:2,5,3,0,2,3,0,3,我们首先遍历一遍数据，得到对应数据的个数C[6]——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230533740.png\" alt=\"image-20210707230533740\"></p>\n<p>再对数据做顺序求和：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230544186.png\" alt=\"image-20210707230544186\"></p>\n<p>也就是说C[i]里面存储的是小于等于I的数据个数。</p>\n<p>最后的最后，最容易蒙圈的一步——</p>\n<p><code>逆序遍历数组，然后在数组C中找到与其相同的下标，然后通过下标对应的元素确定排序后数据的下标，再将个数减1。</code></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230600134.png\" alt=\"image-20210707230600134\"></p>\n<p>王争老师的图绝了，非常有用！！！</p>\n</li>\n</ol>\n<h4 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li><code>时间复杂度：</code>计数的量级最大，但也不过于O(N).</li>\n<li><code>空间复杂度：</code>只需要额外申请一个计数数组，即计数的桶，则空间复杂度为O(N).</li>\n</ul>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>计数排序只能用在<code>数据范围不大的场景</code>中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给<code>非负整数</code>排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>\n</blockquote>\n<h3 id=\"3-3-2-趣味图解\"><a href=\"#3-3-2-趣味图解\" class=\"headerlink\" title=\"3.3.2 趣味图解\"></a>3.3.2 趣味图解</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif\" alt=\"img\"></p>\n<h3 id=\"3-3-3-代码演示\"><a href=\"#3-3-3-代码演示\" class=\"headerlink\" title=\"3.3.3 代码演示\"></a>3.3.3 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>practice<span class=\"token punctuation\">.</span>sort</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 计数排序\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CountingSort</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">countSort</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">,</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">countSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//特判</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//计数排序的特征：值的范围小，将最大值作为桶的个数</span>\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">int</span> bucketCount <span class=\"token operator\">=</span> max<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明并初始化桶</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buckets <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>bucketCount<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>buckets<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            buckets<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//计数</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token operator\">++</span>buckets<span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//累加</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">&lt;</span>buckets<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            buckets<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> buckets<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//声明用于存储结果的tmp</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//猎杀时刻~</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m<span class=\"token operator\">=</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>m<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>m<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> buckets<span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            tmp<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            buckets<span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3-4-基数排序\"><a href=\"#3-4-基数排序\" class=\"headerlink\" title=\"3.4 基数排序\"></a>3.4 基数排序</h2><h3 id=\"3-4-1-概述\"><a href=\"#3-4-1-概述\" class=\"headerlink\" title=\"3.4.1 概述\"></a>3.4.1 概述</h3><blockquote>\n<p>基数排序要求数据可以划分成高低位，位之间有递进关系，比较两个数，我们只需要比较高位，高位相同再去比较低位，而且每一位的数据范围不能太大，因为基数排序需要借助桶排序或者计数排序来完成每一位的排序。</p>\n</blockquote>\n<p>还是熟悉的配方，我们来复现一下实现的过程——</p>\n<ol>\n<li><p>首先根据数据中的<strong>最大值位数</strong>确定<strong>桶的个数</strong>。</p>\n</li>\n<li><p>接着<strong>按位逆序排序</strong>，我们这里只考虑通过最后一位对数据的划分：</p>\n<p>通过取余运算得到的余数即为<code>桶对应的下标</code>，这里将数据分配到桶可以使用<code>二维数组</code>实现，最后将桶中的元素按序放回数组，准备下一位的比较。</p>\n</li>\n</ol>\n<h3 id=\"3-4-2-趣味图解\"><a href=\"#3-4-2-趣味图解\" class=\"headerlink\" title=\"3.4.2 趣味图解\"></a>3.4.2 趣味图解</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif\" alt=\"img\"></p>\n<h3 id=\"3-4-3-代码演示\"><a href=\"#3-4-3-代码演示\" class=\"headerlink\" title=\"3.4.3 代码演示\"></a>3.4.3 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>practice<span class=\"token punctuation\">.</span>sort</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 基数排序\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RadixSort</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">,</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//确定桶的个数</span>\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>max <span class=\"token operator\">&lt;</span> arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//得到它的位数</span>\n        <span class=\"token keyword\">int</span> bitCount <span class=\"token operator\">=</span> <span class=\"token function\">getBitCount</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//按位逆序排序,首先声明除数和余数</span>\n        <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> dev <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//bitcount趟比较</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>bitCount<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span>mod<span class=\"token operator\">*=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>dev<span class=\"token operator\">*=</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//声明临时数组</span>\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>mod <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//将数据按照当前位放置到对应的桶中</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">&lt;</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">//最好手绘验证一下</span>\n                <span class=\"token keyword\">int</span> bucket <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">%</span>mod<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>dev<span class=\"token operator\">+</span>mod<span class=\"token punctuation\">;</span>\n                tmp<span class=\"token punctuation\">[</span>bucket<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">arryAppand</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">[</span>bucket<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arry<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">//分别遍历每个桶中的元素，并将它们按序再放回数组中</span>\n            <span class=\"token keyword\">int</span> pos <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bucket<span class=\"token operator\">:</span>tmp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>bucket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    arry<span class=\"token punctuation\">[</span>pos<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 数组扩容并保存\n     * @param arry\n     * @param value\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">arryAppand</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        arry <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">,</span> arry<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        arry<span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> arry<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 获取整数位数\n     * @param value\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getBitCount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            value <span class=\"token operator\">/=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n            count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>算法如果按照模块分，<code>排序算法绝对算得上割据一方的存在</code>。我们无可避免地会想，对一组数据进行排序让你玩得这么花，有这个必要吗？我想被要求手写快排的人至少是认为有的~</p>\n<p>就如同以前历史老师所说的那般：学习历史学的不是历史本身，而是<code>历史背后的故事</code>。</p>\n<p>而排序算法背后，<code>分治思想，二分思想，优化，时空复杂度</code>都是需要我们去探寻的故事，而不同的排序算法在相同场景下的性能大相径庭，到底选谁呢？有没有什么衡量依据呢？人们更常用的是哪种呢？故事的大幕就此拉开——</p>\n<blockquote>\n<p>注：文章中的图均来自于极客时间数据结构与算法专栏。文章初衷是作为笔记使用，所以缺乏详细推导，仅用于回顾知识点。</p>\n</blockquote>\n<hr>\n<h1 id=\"一、排序上——冒泡-插入-选择排序\"><a href=\"#一、排序上——冒泡-插入-选择排序\" class=\"headerlink\" title=\"一、排序上——冒泡,插入,选择排序\"></a>一、排序上——冒泡,插入,选择排序</h1><h2 id=\"1-1-从一个问题开始\"><a href=\"#1-1-从一个问题开始\" class=\"headerlink\" title=\"1.1 从一个问题开始\"></a>1.1 从一个问题开始</h2><p><code>Q</code>：插入排序和冒泡排序的时间复杂度都为O(n2),但为什么人们更倾向于选择插入排序呢？</p>\n<p><code>A</code>：<strong>插入排序和冒泡排序的时间复杂度都为O(n2),且他们都是稳定的原地排序算法，但他们的性能区别在于比较次数和交换次数。</strong></p>\n<p>冒泡排序不管怎么优化，它的交换次数，也就是<code>移动元素次数</code>都是固定值，即原始数据的<code>逆序度</code>。插入排序同样如是。</p>\n<p>但从代码实现上来说，冒泡排序需要<code>三次赋值</code>，而插入排序只需要<code>一次赋值</code>。也就是说冒泡排序的数据交换比插入排序的数据交换更复杂，我们来具象的看一下——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//冒泡排序中的交换操作</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n    flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//插入排序中的交换操作</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\ta<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"1-2-如何分析一个排序算法\"><a href=\"#1-2-如何分析一个排序算法\" class=\"headerlink\" title=\"1.2 如何分析一个排序算法\"></a>1.2 如何分析一个排序算法</h2><h3 id=\"1-2-1-排序算法的执行效率\"><a href=\"#1-2-1-排序算法的执行效率\" class=\"headerlink\" title=\"1.2.1 排序算法的执行效率\"></a>1.2.1 排序算法的执行效率</h3><h4 id=\"最好情况，最坏情况，平均情况时间复杂度\"><a href=\"#最好情况，最坏情况，平均情况时间复杂度\" class=\"headerlink\" title=\"最好情况，最坏情况，平均情况时间复杂度\"></a>最好情况，最坏情况，平均情况时间复杂度</h4><p>在之前的学习中，我们只需要粗略的比较时间复杂度，那为什么在排序时，又需要引入这些具体的参数呢?</p>\n<ol>\n<li>有些排序算法有区分的必要；</li>\n<li>对于要排序的数据，<strong>有序度</strong>是截然不同的。</li>\n</ol>\n<h4 id=\"时间复杂度的系数，常数和低阶\"><a href=\"#时间复杂度的系数，常数和低阶\" class=\"headerlink\" title=\"时间复杂度的系数，常数和低阶\"></a>时间复杂度的系数，常数和低阶</h4><p>同样的困惑，但这个要好解答的多，无非是<strong>数据规模小的情况</strong>下，这些参数本身就可以表达一种<strong>趋势</strong>。</p>\n<h4 id=\"比较次数和交换次数\"><a href=\"#比较次数和交换次数\" class=\"headerlink\" title=\"比较次数和交换次数\"></a>比较次数和交换次数</h4><p>排序算法有两类，一类基于排序，一类不基于排序。在分析基于排序的算法中，<strong>数据交换就意味着数据搬移，是要耗费性能的</strong>，所以有必要区分。</p>\n<h3 id=\"1-2-2-排序算法的内存消耗\"><a href=\"#1-2-2-排序算法的内存消耗\" class=\"headerlink\" title=\"1.2.2 排序算法的内存消耗\"></a>1.2.2 排序算法的内存消耗</h3><p>为了描述内存消耗，我们引入<strong>原地排序</strong>的概念，所谓原地排序，就是指**空间复杂度为O(1)**。</p>\n<h3 id=\"1-2-3-排序算法的稳定性\"><a href=\"#1-2-3-排序算法的稳定性\" class=\"headerlink\" title=\"1.2.3 排序算法的稳定性\"></a>1.2.3 排序算法的稳定性</h3><p>稳定性的大致意思是在新的需求被引入后，原本系统能够维持相对稳定。而在这里，排序算法的稳定性指的是，<strong>如果待排序的序列中存在值相等的元素，经过排序以后，相等元素之间的原有的先后顺序不变。</strong></p>\n<p>但是业务中的排序，往往不是对单纯的整数进行排序，而是一组<code>对象</code>，我们需要根据对象的<code>某个KEY</code>进行排序。来看一个小例子——</p>\n<blockquote>\n<p>假如说，我们需要给电商交易系统中的订单排序。订单有两个属性，一个是下单时间，一个是订单金额。如果我们现在有10万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照订单时间排序，对于这样的需求，我们要怎么做？</p>\n<p>很明显，先入为主的一种方式是，首先根据订单金额进行排序，在对订单金额相同的区间按照时间排序。</p>\n<p>很自然没错，但在每个小区间要交换元素的次数太多了，有没有性能更高的方法呢？</p>\n<p><strong>我们需要选择一种稳定的排序算法，也就是先对订单按照时间进行排序，再使用稳定排序算法按照金额进行排序，这样的话，我们就能确保金额相同的两个对象，在排序后的前后顺序不变。</strong></p>\n</blockquote>\n<h2 id=\"1-3-冒泡排序\"><a href=\"#1-3-冒泡排序\" class=\"headerlink\" title=\"1.3 冒泡排序\"></a>1.3 冒泡排序</h2><h3 id=\"1-3-1-冒泡排序概述\"><a href=\"#1-3-1-冒泡排序概述\" class=\"headerlink\" title=\"1.3.1 冒泡排序概述\"></a>1.3.1 冒泡排序概述</h3><p>冒泡排序比较相邻的两个元素，如果不满足大小关系，则互换位置，一次冒泡会让至少一个元素移动到它应该在的位置。重复n次即可完成排序。</p>\n<p>下面我们来看具体的例子：对一组数据4,5,6,3,2,1从小到大进行排序。</p>\n<p>那么第一次冒泡的过程是这样的——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e47dbf3b0ff8dea0e83d65e1a17fe4fe.png\" alt=\"image-20210214151417841\"></p>\n<p>这样重复n次即可完成冒泡排序。但这样的排序方式是可以优化的，因为在某次冒泡后，整个数据已经是有序的了，就不需要再排序。所以我们<code>需要一个标志量来标识有序的状态</code>，下面是优化后的代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n    * 冒泡排序\n    */</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n           <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//比较n-1趟</span>\n       <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n           <span class=\"token keyword\">boolean</span> flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n           <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">-</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n               <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                   <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                   a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                   a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n                   <span class=\"token comment\">//表明有数据交换</span>\n                   flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">&#125;</span>\n           <span class=\"token punctuation\">&#125;</span>\n           <span class=\"token comment\">//如果没有数据交换，则退出</span>\n           <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flag<span class=\"token punctuation\">)</span>\n               <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-3-2-冒泡排序的分析\"><a href=\"#1-3-2-冒泡排序的分析\" class=\"headerlink\" title=\"1.3.2 冒泡排序的分析\"></a>1.3.2 冒泡排序的分析</h3><ol>\n<li><p><code>原地排序算法:</code>冒泡的过程只涉及相邻两个元素的交换操作，只需要常量级的临时空间，所以空间复杂度为O(1),即原地排序算法。</p>\n</li>\n<li><p><code>稳定的排序算法:</code>在比较时，相等的元素不需要交换位置，所以是稳定的排序算法</p>\n</li>\n<li><p><code>时间复杂度均为O(n2):</code>最好情况即是整个数据都是有序的，只需要进行一次冒泡就ok了，即最好时间复杂度为O(N)。同理，最坏情况下的时间复杂度为O(N2)。</p>\n<p>那平均时间复杂度如何计算呢?按部就班的说，应该计算<strong>期望</strong>，但规模大的数据，计算期望是非常麻烦的，为了更好地描述平均时间复杂度，我们这里引入<strong>有序度</strong>的概念。</p>\n<blockquote>\n<p><strong>有序度是数组中具有有序关系的元素对的个数</strong>。用数学表达式表示就是——<br>$$<br>a[i]&gt;a[j],i&gt;j<br>$$</p>\n</blockquote>\n<p>同理，假如有6个元素，那这组数据的满序度就是6*(6-1)/2,应用到更宽泛的范围，满序度可以表示为——<br>$$<br>n*(n-1)/2<br>$$<br>自然，我们也可以得到逆序度的概念：<code>逆序度=满序度-有序度</code>。</p>\n<p>我们现在再来描述平均时间复杂度。最坏情况下，有序度为0，需要进行n*(n-1)/2次交换。最好情况下，有序度为n，不需要进行交换，则平均时间复杂度为<br>$$<br>n*   (n-1)/4<br>$$</p>\n</li>\n</ol>\n<h2 id=\"1-4-插入排序\"><a href=\"#1-4-插入排序\" class=\"headerlink\" title=\"1.4 插入排序\"></a>1.4 插入排序</h2><h3 id=\"1-4-1-插入排序概述\"><a href=\"#1-4-1-插入排序概述\" class=\"headerlink\" title=\"1.4.1 插入排序概述\"></a>1.4.1 插入排序概述</h3><p>插入排序是借助区分<strong>已排序区间和未排序区间</strong>的思路来展开描述的。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 插入算法的<strong>核心</strong>是<strong>取未排序区间中的元素，将其插入到已排序区间的合适位置，并保证已排序区间数据一致有序。</strong></li>\n</ul>\n<p>如下图所示，要排序的数据为<strong>4,5,6,1,3,2</strong>——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c080151ce91820fc9a8697ee4e70d98e.png\" alt=\"image-20210214155307987\"></p>\n<p>插入排序同冒泡排序，包含元素的比较进而元素的移动两种操作，那我们如何描述需要移动元素多少次呢？</p>\n<p>这里直接给出概念，<code>移动次数就等于逆序度</code>。当然，也容易理解，移动完成后逆序度为0，那么移动次数自然等于逆序度。</p>\n<p>来看下插入排序的代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n     * 插入排序\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//需要将未排序区间的n-1个元素放置到已排序区间合适的位置</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//记录要排序的值</span>\n            <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//已排序区间</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">//插入数据</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-4-2-插入排序分析\"><a href=\"#1-4-2-插入排序分析\" class=\"headerlink\" title=\"1.4.2 插入排序分析\"></a>1.4.2 插入排序分析</h3><ul>\n<li><code>原地排序算法：</code>比较数据交换元素时只需要常数级的空间，即空间复杂度为O(1);</li>\n<li><code>稳定的排序算法</code>：  当遇到相同元素时，<strong>只需要将未排序数据中的元素插入到已排序相同元素的后面即可</strong>，因此也是稳定的排序算法。</li>\n<li><code>时间复杂度：</code>最好时间复杂度为<strong>O(N)</strong>,最坏情况下，时间复杂度为<strong>O(N2)</strong>.在分析平均时间复杂度时，可以看做是将n-1个数据分别插入到有序的数组中去，一次这样的过程时间复杂度为O(N),那么整个过程的平均时间复杂度就为<strong>O(N2)</strong></li>\n</ul>\n<h2 id=\"1-5-选择排序\"><a href=\"#1-5-选择排序\" class=\"headerlink\" title=\"1.5 选择排序\"></a>1.5 选择排序</h2><h3 id=\"1-5-1-选择排序概述\"><a href=\"#1-5-1-选择排序概述\" class=\"headerlink\" title=\"1.5.1 选择排序概述\"></a>1.5.1 选择排序概述</h3><p>选择排序的<strong>思路类似于插入排序</strong>，同样基于<strong>已排序区间和未排序区间</strong>的思路。不同的是，选择排序依次找出<strong>未排序区间中的最小元素</strong>，<strong>将其与未排序区间的第一个元素互换位置,排好序的部分作为已排序区间。</strong></p>\n<p>我们来看下面的小例子——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/cfffb76ec8fbe3678179f5d397b4047c.png\" alt=\"image-20210214182637560\"><br>再来看下具体的代码实现——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n* 选择排序\n*/</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">selectSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//每一趟最小值的初始值</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//标志位</span>\n            <span class=\"token keyword\">boolean</span> isSwap <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//记录最小值的下标</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">//存在比最小值更小的值</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>min <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    min <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">//记录新的最小值的下标</span>\n                    index <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n                    isSwap <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">//该趟中存在需要互换位置的元素</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>isSwap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> min<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-5-2-选择排序分析\"><a href=\"#1-5-2-选择排序分析\" class=\"headerlink\" title=\"1.5.2 选择排序分析\"></a>1.5.2 选择排序分析</h3><ul>\n<li><code>原地排序算法：</code>代码执行时只需要常数级的空间，即空间复杂度为O(1).</li>\n<li><code>不稳定的算法：</code>交换位置导致有可能颠倒相同值的相对位置，所以是不稳定的排序算法。</li>\n<li><code>时间复杂度分析：</code>最好，最坏，平均时间复杂度均为O(N2).</li>\n</ul>\n<hr>\n<h1 id=\"二、排序下\"><a href=\"#二、排序下\" class=\"headerlink\" title=\"二、排序下\"></a>二、排序下</h1><h2 id=\"摘要-1\"><a href=\"#摘要-1\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在排序上中提及到了冒泡排序，选择排序，插入排序。这三种排序是因为时间复杂度较高，所以<strong>适用于规模小</strong>的数据排序，因为y = x 2曲线的数据规模较小时增长趋势并不快。但在实际项目开发中，动辄上万的数据排序，我们应该怎样处理呢？这就涉及到<strong>时间复杂度相对较小的快速排序与归并排序</strong>，这两种排序都是使用<strong>分治的编程思想</strong>，理解起来相对困难一点，但在面试时，出于他们性能折中又适用范围广的特点，因此成为<strong>面试的宠儿</strong>。好啦，接下来进入正题——</p>\n<h2 id=\"2-1-从一个问题开始\"><a href=\"#2-1-从一个问题开始\" class=\"headerlink\" title=\"2.1 从一个问题开始\"></a>2.1 从一个问题开始</h2><p><code>如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？</code></p>\n<p>乍看上去，不管是快排还是归并排序，他们的时间复杂度都是O(NlogN),但使用分区技巧的快速排序<strong>在合并之前就已经是一个有序的数据集了。</strong></p>\n<p>假设原始的数据集是这样的：<code>4,2,5,12,3</code>,要找到第3大的元素4.</p>\n<p>我们将数据已分区点为界分为三个区间，如果K等于分区点，则直接返回即可，假设不等于，我们就去<strong>递归的分治的另外两个区间，直到区间缩小为1.</strong></p>\n<p>来计算下时间复杂度：首先遍历数据集找到分区点，时间复杂度为O(n),第二次只需要分治一半的元素，也就是时间复杂度为O(n/2).递推得到第n次分治需要的时间复杂度为O(n/2的n-1次方)，最后一次不需要分治，时间复杂度为O(1)，把这些时间复杂度加起来，构成一个等比数列的求和，<strong>求和结果为2n-1</strong>,也就是时间复杂度为O(n).</p>\n<h2 id=\"2-2-归并排序\"><a href=\"#2-2-归并排序\" class=\"headerlink\" title=\"2.2 归并排序\"></a>2.2 归并排序</h2><h3 id=\"2-2-1-概述\"><a href=\"#2-2-1-概述\" class=\"headerlink\" title=\"2.2.1 概述\"></a>2.2.1 概述</h3><p>归并排序是用<strong>分治</strong>的思想，将大问题分成小问题，小问题解决了，大问题自然也就解决了。</p>\n<p>归并排序时，首先执行<strong>递</strong>，将数组从中间分成两部分，对这两部分<strong>分别进行分治，直到区间为1为止</strong>。然后是<strong>归</strong>的过程，<strong>依次排序合并每个小区间成大区间，直到得到排好序的数据集</strong>。</p>\n<p>这样说总归是不形象的，我们来看下图解——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/a0c1aaa677cec70cea2934481234173b.png\" alt=\"image-20210215112204718\"></p>\n<h3 id=\"2-2-2-代码实现\"><a href=\"#2-2-2-代码实现\" class=\"headerlink\" title=\"2.2.2 代码实现\"></a>2.2.2 代码实现</h3><p>有了大致的思路，我们来使用递归实现归并排序，既然是递归问题，那就先找递归终止条件和递归公式咯——</p>\n<ul>\n<li><p><code>递归终止条件</code>：<br>$$<br>merge_sort(p…r) = merge(merge_sort(p,q),merge_sort(q+1,r))<br>$$</p>\n</li>\n<li><p><code>递归公式</code>：<br>$$<br>p&gt;=r<br>$$</p>\n</li>\n</ul>\n<p>我们再将其转化为代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> <span class=\"token comment\">/**\n     * 归并排序\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//递归终止条件</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>from <span class=\"token operator\">>=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//得到该区间的中间位置</span>\n        <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>from<span class=\"token operator\">+</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//分治递归</span>\n        <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> from<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">mergeSort_s</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>from<span class=\"token punctuation\">,</span>mid<span class=\"token punctuation\">,</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 合并两个有序数组并返回\n     * @param a\n     * @param from\n     * @param mid\n     * @param to\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> mid<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//申请一个临时数组来存储合并结果</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>from<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//合并</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> from<span class=\"token punctuation\">,</span>j <span class=\"token operator\">=</span> mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;=</span>mid <span class=\"token operator\">&amp;&amp;</span> j<span class=\"token operator\">&lt;=</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//下面这句的思路好厉害！</span>\n        <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> mid <span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//右边还有剩余元素</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            start <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n            end <span class=\"token operator\">=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//拷贝剩余元素到tmp中</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            tmp<span class=\"token punctuation\">[</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>start<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//拷贝临时数组到a中</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>from<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            a<span class=\"token punctuation\">[</span>from<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里加点私货，在写归并排序代码的时候，犯了一个从来没有去主动意识的致命错误，这个错误就是在某些场景下，else要不要写？我们先分析一段代码——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        res <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是一段很简洁的代码，小伙伴们认为会输出什么呢？</p>\n<p>我以前有些完整的if与else的习惯，今天犯懒了，索性没有写else，因为我认为if之后部分的第一行就是else的代码，但是真的是这样吗？</p>\n<p><code>这里我没有写else，系统会认为else不执行任何事情，而不是默认执行if语句块后的第一行代码。</code></p>\n<p>那么怎样的编程习惯更值得提倡呢？</p>\n<p>先给出结论，<strong>if和else要写就写成对！</strong>，因为这样对测试人员友好一些，另外检测bug也容易检测出来，我们再延伸一下，什么情况下用if，什么情况下用if else.</p>\n<blockquote>\n<ul>\n<li>if用于逻辑追加</li>\n<li>if else用于逻辑分支</li>\n</ul>\n</blockquote>\n<p>另外，针对硬件的设计，我们可以给出一个小技巧：为真的条件写在前面。</p>\n<p>这是因为现代CPU并不会做逻辑判断，而是顺序执行，假如发现不满足条件，则会回滚并执行下一条语句。所以在写if,else的前提下尽可能将为真的条件写在前面。</p>\n<h3 id=\"2-2-3-性能分析\"><a href=\"#2-2-3-性能分析\" class=\"headerlink\" title=\"2.2.3 性能分析\"></a>2.2.3 性能分析</h3><ul>\n<li><p><code>稳定的排序算法：</code>归并排序的稳定与否取决于合并的方式，在合并时针对相同元素，不改变他们的相对位置即可。所以归并排序是稳定的排序算法。</p>\n</li>\n<li><p><code>时间复杂度分析</code>：这里先给出一个结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong>归并排序的时间复杂度包括子问题的时间复杂度与合并代码的时间复杂度<strong>加和</strong>。假设包括b和c两个子问题，则：<br>$$<br>T(a)=T(b)+T(c)+K<br>$$<br>这里的K指的是合并的时间复杂度，即为O(N).又因为两个子问题的时间复杂度都为O(N/2),则归并排序的时间复杂度为：<br>$$<br>T(1) = C\\</p>\n<p>T(n) = 2<em>T(N/2)+N n&gt;1<br>$$<br>我们求解后可以得到——<br>$$<br>T(n) = 2</em>T(n/2) + n\\<br>   = 2*(2<em>T(n/4) + n/2) + n = 4</em>T(n/4) + 2<em>n\\<br>   = 4</em>(2<em>T(n/8) + n/4) + 2</em>n = 8<em>T(n/8) + 3</em>n\\<br>   = 8*(2<em>T(n/16) + n/8) + 3</em>n = 16<em>T(n/16) + 4</em>n\\<br>   ……\\<br>   = 2^k * T(n/2^k) + k * n\\<br>   ……<br>$$<br><strong>当T(n/2^k) = T(1)时，即k = log2N，将其带入上式，可以得到，T(n)=Cn+nlogn,即归并排序的时间复杂度为O(nlogn).</strong></p>\n</li>\n<li><p><code>不是原地排序算法</code>:归并排序用到递归的思想，所以自然不会是原地排序算法。那它的空间复杂度是什么呢?</p>\n<blockquote>\n<p>在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"2-3-快速排序\"><a href=\"#2-3-快速排序\" class=\"headerlink\" title=\"2.3 快速排序\"></a>2.3 快速排序</h2><h3 id=\"2-3-1-概述\"><a href=\"#2-3-1-概述\" class=\"headerlink\" title=\"2.3.1 概述\"></a>2.3.1 概述</h3><p>Java1.8源码中Arrays.sort()排序函数使用快速排序算法。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230458288.png\" alt=\"image-20210707230458288\"></p>\n<p>快速排序是用<strong>递归与分治</strong>，将数据集按照<strong>某个分区点</strong>分为<strong>比分区点小的区间</strong>和<strong>比分区间大的区间</strong>，然后在区间内再<strong>递归</strong>这项操作<strong>直到区间内只有一个元素为止</strong>。</p>\n<p>既然是递归，我们同样写出<strong>递归终止条件</strong>和<strong>递推公式</strong>——<br>$$<br>递推公式：<br>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)<br>\\<br>终止条件：<br>p &gt;= r<br>$$<br>到这，我们只需要选出适合的分区点即可，通常将<strong>区间内的最后一个元素</strong>作为分区点，然后将比分区点小的元素放到一个数组中，把比分区点大的元素放到一个数组中。</p>\n<p>思路完全合理，但并不优雅，因为这意味着需要额外的空间。那怎样才能不申请额外空间呢？这里我们借助选择排序的思路，即核心是<strong>交换元素</strong>。</p>\n<p>那归并与快排有什么区别呢？归并排序的处理过程是自下往上的，而快排则是自上往下的。</p>\n<p>我们通过图解来认识排序的过程——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/158c9e4dc48b12dfdbfb1ea6fe8e785c.png\" alt=\"image-20210215195133829\"></p>\n<h3 id=\"2-3-2-代码实现\"><a href=\"#2-3-2-代码实现\" class=\"headerlink\" title=\"2.3.2 代码实现\"></a>2.3.2 代码实现</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n     * 快速排序\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>from <span class=\"token operator\">>=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>from<span class=\"token punctuation\">,</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>from<span class=\"token punctuation\">,</span>p<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">quickSort_c</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>p<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">/**\n     * 分区函数\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//将最后一个元素作为分区点</span>\n        <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> from<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span>from<span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//小于分界点，则使用交换的方式将元素放到已排序区间</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">//</span>\n                <span class=\"token operator\">++</span>i<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a<span class=\"token punctuation\">[</span><span class=\"token keyword\">to</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-3-3-性能分析\"><a href=\"#2-3-3-性能分析\" class=\"headerlink\" title=\"2.3.3 性能分析\"></a>2.3.3 性能分析</h3><p>这里不再推到具体过程，直接给出结论——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <code>归并排序是一种不稳定的原地排序算法，它大部分情况下的时间复杂度为O(nlogn),只有个别情况下才会退化为O(n2)</code></li>\n</ul>\n<hr>\n<h1 id=\"三-、线性排序分析总结\"><a href=\"#三-、线性排序分析总结\" class=\"headerlink\" title=\"三.、线性排序分析总结\"></a>三.、线性排序分析总结</h1><h2 id=\"3-1-前言\"><a href=\"#3-1-前言\" class=\"headerlink\" title=\"3.1 前言\"></a>3.1 前言</h2><p>在已经学习了五种基于比较的排序算法的基础上，我们仍要继续学习<strong>三种特定场景下更优的不基于比较的排序算法</strong>，那我们肯定会困惑，为什么不基于比较的算法在某些场景下性能更优呢，换句话说，基于比较的算法有什么不能逾越的天花板呢？</p>\n<p>这就需要引入CBA理论：<code>任何基于比较的排序算法的性能天花板就是O(nlogn)</code>.我们来探究一下这个结论是如何得出的——</p>\n<blockquote>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 来自：<a href=\"https://yfsyfs.github.io/2019/05/25/CBA%E7%90%86%E8%AE%BA-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%9E%81%E9%99%90%E6%98%AFO-nlogn/\">https://yfsyfs.github.io/2019/05/25/CBA%E7%90%86%E8%AE%BA-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%9E%81%E9%99%90%E6%98%AFO-nlogn/</a></li>\n</ul>\n<p>原因很简单, n个元素的全排列是<code>n!.</code> 而最终排序的结果只是其中一种（一棵含有n!个叶子节点的<code>二叉树</code>）. 每次比较, 我们可以砍掉一半的元素. 所以比较的次数就是树的高度.而此树的高度是<br>$$<br>\\log_2n!<br>$$<br>由分析数学中的<code>Stirling公式</code>便知.速度不可能突破NlogN.</p>\n</blockquote>\n<p>既然是基因限制，那我们就有必要另辟蹊径，学习一下**时间复杂度为O(N)**的线性排序咯。</p>\n<h2 id=\"3-2-桶排序\"><a href=\"#3-2-桶排序\" class=\"headerlink\" title=\"3.2 桶排序\"></a>3.2 桶排序</h2><h3 id=\"3-2-1-概述\"><a href=\"#3-2-1-概述\" class=\"headerlink\" title=\"3.2.1 概述\"></a>3.2.1 概述</h3><p>这三种排序方式都会用到桶，而桶排序的核心思想是将<code>要排序的数据发到几个有序的桶里，每个桶里的数据再单独进行排序，排完序后再将每个桶中的数据按照顺序依次取出，组成的序列就是有序的了。</code></p>\n<p>按照它的核心思想，我们来拆解一下桶排序的实现过程：</p>\n<ol>\n<li><p>显然，桶的个数是首先应该被确定的，如果你再完后看的话，就会发现三种线性排序核心的区别就是<code>桶的大小粒度不同</code>，也就是每个桶中放的数据个数不同，就拿桶排序来说，它适用<strong>外部排序</strong>，也就是磁盘空间很充足，但内存不足,这就需要将磁盘中的文件分批地放入内存.</p>\n<p>桶排序的桶的大小一般会预设好。所以桶的个数就等于数据的范围除以桶的大小。</p>\n</li>\n<li><p>接着就需要将数据按照<code>映射函数的规则</code>放置到对应的桶中。具体实现无非就是按大小分类到相应的桶下标。</p>\n</li>\n<li><p>然后自然就是排序啦，排序选用<strong>java封装的快排方法</strong>还是很舒适的，最后将排序后的桶元素放置到原数组即可。</p>\n</li>\n</ol>\n<h4 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li><p><code>时间复杂度</code>：假设有n个数据，分成m个桶，那每个桶中就有数据k=n/m个，每个桶中使用快排，时间复杂度为O(klogk),代入后可以得到O(n/mlog(n/m)),那总体的时间复杂度就是<br>$$<br>O(nlog(n/m))<br>$$<br>当<strong>桶的个数趋近与数据量</strong>时，桶排序的时间复杂度就可看做O(N).</p>\n</li>\n<li><p><code>空间复杂度</code>：在将源数据分配到对应的桶时需要申请额外的空间，所以N个数据就需要额外申请N个空间，也就是空间复杂度为O(N).</p>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>桶排序堆排序数据的要求很苛刻，首先，要排序的数据需要<code>很容易就能划分成m个桶</code>，并且，桶和桶之间之间有着<code>天然的大小关系</code>。其次，数据在每个桶中的<code>分布是比较均匀</code>的，如果将数据都划分到同一个桶中，就会退化为O(nlogn)的排序算法啦。</p>\n</blockquote>\n<h3 id=\"3-2-2-趣味图解\"><a href=\"#3-2-2-趣味图解\" class=\"headerlink\" title=\"3.2.2 趣味图解\"></a>3.2.2 趣味图解</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230520254.png\" alt=\"image-20210707230520254\"></p>\n<h3 id=\"3-2-3-代码演示\"><a href=\"#3-2-3-代码演示\" class=\"headerlink\" title=\"3.2.3 代码演示\"></a>3.2.3 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>practice<span class=\"token punctuation\">.</span>sort</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n *桶排序\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BucketSort</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>rry<span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        arry <span class=\"token operator\">=</span> <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> sourceArr<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> bucketSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//首先拷贝数据,防止源数据因为没有备份而乱序</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>sourceArr<span class=\"token punctuation\">,</span> sourceArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">BucketSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token class-name\">BucketSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> bucketSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//根据最小值，最大值确定分多少个桶</span>\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> data<span class=\"token operator\">:</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                max <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">&lt;</span> min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                min <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//确定桶数的原则</span>\n        <span class=\"token keyword\">int</span> bucketCount <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>max<span class=\"token operator\">-</span>min<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>bucketSize<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明桶的标号</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buckets <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>bucketCount<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//通过映射函数将数据放到桶中</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//确定数据对应的桶下标</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>min<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>bucketSize<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//扩充二维数组对应行的列</span>\n            buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">arrAppand</span><span class=\"token punctuation\">(</span>buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">int</span> arryIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//为每个桶排序</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bucket<span class=\"token operator\">:</span>buckets<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//特判</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>bucket<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                arr<span class=\"token punctuation\">[</span>arryIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 动态扩容,并保存数据\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">arrAppand</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        arr <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        arr<span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3-3-计数排序\"><a href=\"#3-3-计数排序\" class=\"headerlink\" title=\"3.3 计数排序\"></a>3.3 计数排序</h2><h3 id=\"3-3-1-概述\"><a href=\"#3-3-1-概述\" class=\"headerlink\" title=\"3.3.1 概述\"></a>3.3.1 概述</h3><p>计数排序可以看做是桶排序的一种特殊情况，当要排序的数据所处的范围并不大时，我们将按数据最大值作为痛的个数，这样就省却了桶内排序的时间。</p>\n<p>我们同样聊聊来计数排序的实现：</p>\n<ol>\n<li><p>类似于桶排序，计数排序同样首先确定桶的个数，这个就不再赘述。</p>\n</li>\n<li><p>然后，我们需要将源数据分配到对应的桶中，显然，如果分配到了对应的桶中，排序就已经完成了。那如何分配呢？</p>\n<p>这个环节就是计数排序的核心啦——</p>\n<p>假设有一组数据A[8]:2,5,3,0,2,3,0,3,我们首先遍历一遍数据，得到对应数据的个数C[6]——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230533740.png\" alt=\"image-20210707230533740\"></p>\n<p>再对数据做顺序求和：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230544186.png\" alt=\"image-20210707230544186\"></p>\n<p>也就是说C[i]里面存储的是小于等于I的数据个数。</p>\n<p>最后的最后，最容易蒙圈的一步——</p>\n<p><code>逆序遍历数组，然后在数组C中找到与其相同的下标，然后通过下标对应的元素确定排序后数据的下标，再将个数减1。</code></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707230600134.png\" alt=\"image-20210707230600134\"></p>\n<p>王争老师的图绝了，非常有用！！！</p>\n</li>\n</ol>\n<h4 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li><code>时间复杂度：</code>计数的量级最大，但也不过于O(N).</li>\n<li><code>空间复杂度：</code>只需要额外申请一个计数数组，即计数的桶，则空间复杂度为O(N).</li>\n</ul>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>计数排序只能用在<code>数据范围不大的场景</code>中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给<code>非负整数</code>排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>\n</blockquote>\n<h3 id=\"3-3-2-趣味图解\"><a href=\"#3-3-2-趣味图解\" class=\"headerlink\" title=\"3.3.2 趣味图解\"></a>3.3.2 趣味图解</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif\" alt=\"img\"></p>\n<h3 id=\"3-3-3-代码演示\"><a href=\"#3-3-3-代码演示\" class=\"headerlink\" title=\"3.3.3 代码演示\"></a>3.3.3 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>practice<span class=\"token punctuation\">.</span>sort</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 计数排序\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CountingSort</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">countSort</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">,</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">countSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//特判</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//计数排序的特征：值的范围小，将最大值作为桶的个数</span>\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">int</span> bucketCount <span class=\"token operator\">=</span> max<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明并初始化桶</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buckets <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>bucketCount<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>buckets<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            buckets<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//计数</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token operator\">++</span>buckets<span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//累加</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">&lt;</span>buckets<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            buckets<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> buckets<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//声明用于存储结果的tmp</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//猎杀时刻~</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m<span class=\"token operator\">=</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>m<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>m<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> buckets<span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            tmp<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            buckets<span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3-4-基数排序\"><a href=\"#3-4-基数排序\" class=\"headerlink\" title=\"3.4 基数排序\"></a>3.4 基数排序</h2><h3 id=\"3-4-1-概述\"><a href=\"#3-4-1-概述\" class=\"headerlink\" title=\"3.4.1 概述\"></a>3.4.1 概述</h3><blockquote>\n<p>基数排序要求数据可以划分成高低位，位之间有递进关系，比较两个数，我们只需要比较高位，高位相同再去比较低位，而且每一位的数据范围不能太大，因为基数排序需要借助桶排序或者计数排序来完成每一位的排序。</p>\n</blockquote>\n<p>还是熟悉的配方，我们来复现一下实现的过程——</p>\n<ol>\n<li><p>首先根据数据中的<strong>最大值位数</strong>确定<strong>桶的个数</strong>。</p>\n</li>\n<li><p>接着<strong>按位逆序排序</strong>，我们这里只考虑通过最后一位对数据的划分：</p>\n<p>通过取余运算得到的余数即为<code>桶对应的下标</code>，这里将数据分配到桶可以使用<code>二维数组</code>实现，最后将桶中的元素按序放回数组，准备下一位的比较。</p>\n</li>\n</ol>\n<h3 id=\"3-4-2-趣味图解\"><a href=\"#3-4-2-趣味图解\" class=\"headerlink\" title=\"3.4.2 趣味图解\"></a>3.4.2 趣味图解</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif\" alt=\"img\"></p>\n<h3 id=\"3-4-3-代码演示\"><a href=\"#3-4-3-代码演示\" class=\"headerlink\" title=\"3.4.3 代码演示\"></a>3.4.3 代码演示</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>practice<span class=\"token punctuation\">.</span>sort</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 基数排序\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RadixSort</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">,</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>arry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//确定桶的个数</span>\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>max <span class=\"token operator\">&lt;</span> arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                max <span class=\"token operator\">=</span> arry<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//得到它的位数</span>\n        <span class=\"token keyword\">int</span> bitCount <span class=\"token operator\">=</span> <span class=\"token function\">getBitCount</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//按位逆序排序,首先声明除数和余数</span>\n        <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> dev <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//bitcount趟比较</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>bitCount<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span>mod<span class=\"token operator\">*=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>dev<span class=\"token operator\">*=</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//声明临时数组</span>\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>mod <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//将数据按照当前位放置到对应的桶中</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>k<span class=\"token operator\">&lt;</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">//最好手绘验证一下</span>\n                <span class=\"token keyword\">int</span> bucket <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">%</span>mod<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>dev<span class=\"token operator\">+</span>mod<span class=\"token punctuation\">;</span>\n                tmp<span class=\"token punctuation\">[</span>bucket<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">arryAppand</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">[</span>bucket<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arry<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">//分别遍历每个桶中的元素，并将它们按序再放回数组中</span>\n            <span class=\"token keyword\">int</span> pos <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bucket<span class=\"token operator\">:</span>tmp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token operator\">:</span>bucket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    arry<span class=\"token punctuation\">[</span>pos<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 数组扩容并保存\n     * @param arry\n     * @param value\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">arryAppand</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arry<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        arry <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>arry<span class=\"token punctuation\">,</span> arry<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        arry<span class=\"token punctuation\">[</span>arry<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> arry<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 获取整数位数\n     * @param value\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getBitCount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            value <span class=\"token operator\">/=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n            count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n"},{"title":"那年深秋,在教室临窗写下的汇编","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T04:00:52.000Z","password":null,"summary":null,"_content":"\n## 前言\n\n### 1. 为什么要学习汇编语言？\n\n编程语言发展到如今，**高级语言**大行其道，他们通常被标榜为学习成本低。但由于高级语言不是直接调用**操作系统**，因而**执行效率**相对低一些。\n\n比如java语言，java源文件首先被编译，然后经过**JVM**的连接，最终执行得到运行于某平台的**机器码**。也就是说最终被计算机执行的是机器码。\n\n但机器码是不易于人理解的，虽说大道至简，在计算机的世界里，**0,1**才是王道。但计算机的模型通过0,1是很难窥见的，因而我们需要一种即易于人理解，且能够了解计算机执行机制的语言，这便是——**汇编语言**。\n\n#### C语言与汇编\n\n直观的看，操作系统的百分之九十代码是用C语言写的，数据库等软件同样是使用C语言编写的。也就是说，C语言执行效率高，适合用于描述底层的东西。\n\n我们可以把**工作技能**比作裁缝做成的**衣服**，java是衬衫，C++是长裤，但只会做衬衫的裁缝可不是一个好裁缝，裁缝铺需要的是，根据顾客的要求，`不管什么服装都可以做的好裁缝`。\n\n但这可不容易，我们需要了解不同类型衣服的共同之处，而衣服都是由**裁缝机**做成的，那么裁缝机是什么样，也会一定程度决定做成的衣服是什么样(`PS:这里我们不讨论先有鸡还是先有蛋的问题`)。\n\n这就如同语言，语言最终是去驱使硬件工作的，硬件也会反过来决定语言的特性，硬件的工作状态是高，低电平，对应计算机语言的0和1，所以哪种语言能够更好的解释0和1，而又为人所理解，那就会最先被衍生出来。\n\n这就是大家心心念念的C语言了，C语言向上沟通众多高级语言，无往不利，向下连通\"取指执行\"的圣经。\n\n而C语言要描述0和1，可不是直接编译那么简单，它要首先编辑为汇编语言，最终被连接执行为机器语言。\n\n### 2 . 汇编语言的定义\n\n> 汇编语言是二进制指令的文本形式\n\n### 3 . 学习汇编的要求\n\n通过使用**汇编指令**对**寄存器**和**内存**的操作来深刻理解**计算机执行指令**的机制。\n\n[^undefined]: 注 ： 我们这里的汇编专指8086CPU的汇编语言\n\n## 基础知识\n\n### 1. 为什么要使用寄存器\n\nCPU本身只负责**运算**，不负责**存储数据**，数据一般都存储在**内存**之中，CPU要用的时候就去内存读写数据，但是CPU读写的速度**远高于**内存的读写速度，为了避免被拖慢，CPU都自带一级缓存和二级缓存，**CPU缓存**可以看作是读写速度较快的内存。\n\n但是，CPU缓存还是不够快，另外数据在缓存里面的地址是**不固定**的，CPU每次读写都要**寻址**也会拖慢速度，因此，除了缓存之外，CPU还自带了**寄存器**，用来存储最常用的数据。也就是说，那些最频繁读写的数据，比如循环变量，都会放在寄存器中，CPU优先读写寄存器，再由寄存器跟内存交换数据\n\n![image-20201103224649594](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201103224649594.png)\n\n寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉CPU去具体哪一个寄存器中拿数据，这样的速度是最快的，因而也称寄存器是CPU的**零级缓存**。\n\n------\n\n### 2.寄存器的概述\n\n8086的寄存器都是16位的，可以存放两个字节的数据，也就是说它的寻址能力就只有2的16次方个字节空间，也就是64KB。\n\n通俗的将，32位，64位系统指的就是寄存器的位数。32位寄存器可以存放的数据是2的32次方，也就是4GB，换句话说，32位的系统最多能寻址的数据只有4GB。\n\n寄存器要存储数据，首先需要从内存中取出数据，而从内存中读取数据，就要知道数据在内存中存储的地址，也就是物理地址。\n\n### 3.物理地址\n\n8086CPU有20位的地址总线，可以传送20位地址，达到1MB寻址能力，但数据总线只有16位，它只能传输16的地址，表现出来的寻址能力只有64KB，所以我们需要使用两个16位的地址来合成20位的物理地址。\n\n这两个16位的地址，一个是段地址CS，一个是偏移地址IP，采用物理地址=短地址*16+偏移地址的运算方式扩展16位到20位，换句话说，也就是逻辑左移4位。\n\n有了物理地址，我们就可以知道从哪个内存地址读取指令，那如何将取出来的指令执行呢？\n\n![image-20201108221905157](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201108221905157.png)\n\n了解了指令执行的模型，我们知道CS,IP的值是从寄存器中读取的，那寄存器是怎样存储值的呢？\n\n### 4.寄存器的分类\n\n从类型上说，我们存储的数据有两类，字节型和字型。\n\n而从数据类型来说，数据分为通用的数据和具有特定意义的数据，在计算时，通用的寄存器存储在通用寄存器中，而特殊的数据，比如需要保留状态的数据，会被存储在标志寄存器中。下面我们来看具体的描述——\n\n8086CPU有8个寄存器，且都是16位的，即可以存放两个字节，8个寄存器中包括4个通用寄存器，4个段寄存器。\n\n4个通用的寄存器分别是AX,BX,CX,DX,用于存放一般性的数据。而考虑到兼容，又将这四个寄存器分成了独立的8个寄存器来使用。比如取AX的低八位组成了AL寄存器，高八位组成了AH寄存器。\n\n当CPU要访问内存时，由段寄存器来提供内存单元的段地址，这些寄存器包括DS,ES,SS,CS.\n\n其中DS寄存器通常用于存放要访问数据的段地址，CS寄存器是代码段寄存器，当我们要访问栈段时，栈段的起始地址从SS寄存器中读取，偏移地址从SP寄存器中读取，ES为扩展段寄存器。\n\n### 2. 内存模型\n\n寄存器只能存放少量的数据，大多数时候，CPU要指挥寄存器与内存进行数据交换，所以，除了寄存器，还必须了解内存如何存储数据。\n\n当程序运行时，操作系统会为程序分配一段内存空间，用于存储程序和程序运行产生的结果。这段内存空间有一个起始地址和一个结束地址。且低位的是起始地址，高位的是结束地址。\n\n通俗的说，内存中存放的是源程序，源程序中有效的部分称为程序，而程序是由数据和指令组成的，那内存是如何区分数据和指令的呢？CS:IP指向的内存单元存放的是指令，其他的则是数据。但数据的使用频度是不同的，使用场景也是不同的，因此我们把一般性的数据存放在堆中，而把需要保存状态的数据存放在栈中，那堆栈有怎样的结构特点呢——\n\n### 堆\n\n程序运行过程中，对于动态的内存占用请求，比如说新建对象，或者使用malloc命令，系统就会从预先分配好的那段内存找那个，划出一部分给用户，规则是从起始地址算起，而实际上起始地址会有一段静态数据，这里暂且忽略。\n\n这种因为用户主动请求而划分出来的内存区域，叫做heap（堆），它由起始地址开始向高位增长，Heap的一个重要特点就是不会自动消失，必须手动的释放或者通过内存垃圾回收机制来回收。\n\n除了Heap以外，其他的内存占用叫做Stack(栈)，简单说，栈是函数运行时被临时使用的内存空间。\n\n请看下面的例子——\n\n```java\nint main(){\n\tint a;\n\tint b;\n\treturn add(a,b);\n}\n```\n\n当系统开始执行main函数时，会为其在内存中建立一个帧，这个数据帧中会存放main函数中声明的内部变量a,b.而当程序执行到调用add函数时，这时就需要为这个函数也建立一个帧，用来存储它的内部变量。一般来说，调用了多少层的帧，就有多少个栈，等到add函数执行结束，它的帧就会被回收，程序再次回到main函数中断的地方，继续往下执行，系统使用这种机制，实现了函数的层层调用。\n\n所有的帧，都存放在栈中，生成新的帧，叫做入栈，英文是push.将栈回收，叫做出栈,英文是pop,栈的特点就是先进后出，栈顶指针始终指向最外层的帧，帧是从栈的高地址开始存放，之后内存地址不断递减直至栈满。\n\n那栈的空间是由谁来决定的呢？系统能否判断栈是否已满呢？\n\n并不能，当需要使用栈的时候，我们需要声明一段内存空间作为栈段，我们只能人为的避免造成栈满，而不能寄希望于操作系统。\n\n## 常用指令\n\n### 1. 伪指令与指令\n\n程序是指令的集合，每一条指令都对应CPU的操作，但仅有指令是不够的，指令不能告诉编译器，程序什么时候结束，也不能告诉编译器，数据段存储在哪段内存空间，代码段又存储在哪段内存空间。所以需要有一种能被编译器所识别的，用于定义程序结构化的语言。这就是伪指令了。\n\n伪指令是用于告诉汇编程序如何进行**汇编**的指令。它既不控制机器的操作也不被汇编成机器代码，只能为汇编器所识别并指导汇编程序如何进行。 将相对于程序或相对于寄存器的地址载入寄存器中。\n\n### 2 .常用指令\n\n| 序号 | **语法**             | **功能**               |                **案例**                 | **说明**                                                     | **备注**                                                    |\n| ---- | -------------------- | ---------------------- | :-------------------------------------: | ------------------------------------------------------------ | ----------------------------------------------------------- |\n| 1    | mov                  | 数据传送指令           |                mov[0],cs                | 将寄存器CS中的内容传送到偏移地址为0的内存单元中              | 符合反对称                                                  |\n| 2    | add/sub              | 加、减指令             |                sub ax,bx                | 将ax寄存器中的内容减去bx寄存器中的内容的结果存储在ax中       |                                                             |\n| 3    | push                 | 入栈                   |                 push ax                 | 分两步，首先栈顶指针偏移，其次将ax寄存器中的内容入栈         | 段地址从ds中取得                                            |\n| 4    | pop                  | 出栈                   |                 pop ax                  | 分两步，首先将栈顶指针指向的内容赋给ax寄存器，然后栈顶指针偏移 |                                                             |\n| 5    | loop 标号            | 跳转至标号处           |              loop continue              | CPU执行loop指令时，进行两步操作：首先CX递减，然后判断CX中的值，若不为0，则跳转标号处，若为0，则向下执行 | CX专用于存放循环次数                                        |\n| 6    | and                  | 逻辑与                 |          and      al,01100011B          | 按位进行与运算                                               | 常用于位清除                                                |\n| 7    | or                   | 逻辑或                 |             or al,01100011B             | 按位进行或运算                                               | 常用于位填充                                                |\n| 8    | div                  | 除法                   |           div byte ptr ds:[0]           | 做除法操作时，除数有8位和16位两种，存放在在一个reg/内存单元中。被除数默认放在AX或者DX和AX中，如果除数为8位，被除数则为**16位**，默认在**AX**中存放；如果除数为16位，被除数为**32位**，在**DX和AX**中存放，D**X存放高16位，AX存放低16位**。结果：如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数；如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数， | 进行除法操作前，首先要进行除数和被除数的设置                |\n| 9    | jmp                  | 无条件转移指令         |               jmp short s               | **段内短位移**，转到标号s处执行指令。                        | jmp指令应该包含两种信息：转移的**目的地址**与转移的**距离** |\n| 10   |                      |                        |              jmp far ptr s              | **段间转移**，使用S的段地址和偏移地址修改CS和IP              |                                                             |\n| 11   |                      |                        |                 jmp AX                  | **段内偏移**，将寄存器AX中的内容赋给IP                       |                                                             |\n| 12   |                      |                        |           jmp word ptr ds:[0]           | **段内偏移**，从内存单元的地址处开始存放一个字，即转移的目的**偏移地址** |                                                             |\n| 13   | jcxz                 | 有条件转移指令         |                 jcxz s                  | **短位移**，指令中包含转移位移，而不是目的地址。等同于 if(CX == 0) jmp short 标号 |                                                             |\n| 14   | call                 | 转移指令               |                 call s                  | 不能实现短位移，执行call指令，执行两步操作：push IP ， jmp  near ptr 标号 |                                                             |\n| 15   | ret                  | 复原指令               |                   ret                   | CPU执行ret操作时，等同于执行指令 pop IP                      |                                                             |\n| 16   | retf                 | 复原指令               |                  retf                   | CPU执行retf操作时，等同于执行指令pop IP,pop CS               |                                                             |\n| 17   | mul                  | 乘法指令               |     mov ax,100 mov bx,10000 mul bx      | 类div指令                                                    |                                                             |\n| 18   | adc                  | 带进位加法             |                adc AX,BX                | 等同于add AX,BX, ADD AX,CF                                   |                                                             |\n| 19   | sub                  | 带借位减法             |                sub AX,BX                | 等同于sub AX,BX, sub AX,CF                                   |                                                             |\n| 20   | cmp                  | 比较指令               | mov ax,8        mov bx,3      cmp ax,bx | 相当于减法操作，计算结果会对标志寄存器产生影响               |                                                             |\n| 21   | je jne jb jnb ja jna | 根据比较结果的跳转指令 |                  jxx s                  | 等于/不等于/低于/不低于/大于/不大于                          |                                                             |\n| 22   | pushf  popf          |                        |               pushf  popf               | 将标志寄存器中的值压栈/出栈                                  |                                                             |\n| 23   | iret                 | 复原指令               |                  iret                   | 等同于：pop IP，pop CS,popf                                  |                                                             |\n| 24   | int                  | 中断指令               |                  int n                  | 这里的n表示的是中断类型码。CPU执行int n指令，执行过程：首先取中断类型码n，然后标志寄存器入栈，接着CS，IP入栈。最后跳转执行 |                                                             |\n| 25   | shl                  | 逻辑左移指令           |                shl al,1                 | 将al中的数据逻辑左移1位，最后移出的1位写入CF，最低位用0补充  |                                                             |\n| 26   | shr                  | 逻辑右移指令           |                shr al,1                 | 将al中的数据逻辑右移1位，最后移出的1位写入CF，最高位用0补充  |                                                             |\n\n### 3.常用的伪指令\n\n| 名称            | 功能                     | 案例            | 说明                                 | 备注 |\n| --------------- | ------------------------ | --------------- | ------------------------------------ | ---- |\n| dd(double word) | 定义双字型数据           | dd 12345        | 定义了占2个字的数据12345             |      |\n| db(define byte) | 定义字节型数据           | db 1            | 定义了占1个字节的数据1               |      |\n| dw(define word) | 定义字型数据             | dw 100          | 定义了占1个字的数据100               |      |\n| dup             | 用于进行数据的重复       | db 3 dup (0,1,) | 定义了6个字节数据，分别是0,1,0,1,0,1 |      |\n| offset          | 取得标号的偏移地址       | mov si,offset s | 将标号s的偏移地址赋给si              |      |\n| seg             | 回送变量或者标号的段地址 |                 |                                      |      |\n\n- [ ] 更多的可参考http://blog.sina.com.cn/s/blog_4a92ce12010006m2.html\n\n### 4. 以学促用\n\n#### 问题描述\n\n> 将实验七中的Power idea 公司的数据，按照图10.2所下图屏幕中显示出来\n\n![image-20201112151602560](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201112151602560.png)\n\n#### 代码与注释\n\n```ASM\nassume cs:codesg\n;将整个data段看作是一个数组，长度一共为\n;21*4+21*4+2*21=168+42=210字节\ndata segment\n    db '1975', '1976', '1977', '1978', '1979', '1980', '1981', '1982', '1983'\n    db '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992'\n    db '1993', '1994', '1995'\n    ;长度为84的数组，一个字符一个字节：4X21\n\n    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514\n    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000\n    \n    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226\n    dw 11542, 14430, 15257, 17800\n\ndata ends\n\n;ax+210/16向上取整，即ax+14h\n;对于ds，偏移量为16*14=224\ntable segment\n    db 21 dup('year summ ne ?? ')\ntable ends\n\nshow segment\n    db 100 dup(0)\nshow ends\n\ntemp segment\n    dw 10 dup(0)\ntemp ends\n\ncodesg segment\nstart:\t  \tmov ax, data\n\t\t\tmov ds, ax \n\t\t\tmov bx, table\n\t\t\tmov es, bx  \n\t\t\tmov bx, 0   ;定位结构体数组元素\n\t\t\tmov di, 0   ;定位data中的4字节数据\n\t\t\tmov si, 0   ;定位data中的2字节数据\n\t\t\tmov cx, 15h\ns0:\t\t\t;转移年份\n\t\t\tmov ax, ds:[di]\n\t\t\tmov es:[bx], ax\n\t\t\tmov ax, ds:[di+2]\n\t\t\tmov es:[bx+2], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+4], 32\n\n\t\t\t;转移收入\n\t\t\t;作为被除数\n\t\t\tmov ax, ds:[di+84];\n\t\t\tmov es:[bx+5], ax\n\t\t\tmov ax, ds:[di+86]\n\t\t\tmov es:[bx+7], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+9], 32\n\t\n\t\t\t;转移雇员数量\n\t\t\tmov ax, ds:[si+168]\n\t\t\tmov es:[bx+10], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+12], 32\n\t\n\t\t\t;计算人均收入，并转移到table中\n\t\t\tmov ax, es:[bx+5]   ;低16位\n\t\t\tmov dx, es:[bx+7]   ;高16位\n\t\t\tdiv word ptr es:[bx+10]\n\t\t\tmov es:[bx+13], ax  ;商默认存放在ax中 \n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+15], 32\n\t\t\t;操作完成，bx加16，di加2\n\t\t\tadd bx, 16  \n\t\t\tadd di, 4\n\t\t\tadd si, 2\n\t\t\tloop s0\n\n;s0循环的作用主要是将数据存储到table段中\n;而在s1循环中，先把table段中的数据转化为字符串，转储到\n;show段中，然后再在s2循环中调用show_str子程序来将这些字符串一行一行地\n;显示到屏幕上\n\t\t\tmov ax, table\n\t\t\tmov ds, ax\n\t\t\tmov ax, show\n\t\t\tmov es, ax\n\t\t\tmov dx, 0\n\t\t\tmov dh, 4\n\t\t\tmov bx, 0\n\t\t\tmov cx, 15h\ns1:\t\t\tmov di, 0\n\t\t\t;这里的di作为table数据段的指针\n\t\t\tpush ds\n\t\t\tpush es\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\t;保存行列信息，在调用show_str时会用到\n\t\t\t;转储年份\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tadd di, 2\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tmov byte ptr es:[di+4], 0\n\t\t\t;转储收入\n\t\t\tmov di, 5\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov dx, ds:[bx+di+2]\n\t\t\tcall dtoc \n\t\t\t;转储人数\n\t\t\tmov ax, ds:[bx+10]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc \n\t\t\t;转储人均收入\n\t\t\tmov ax, ds:[bx+13]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc\n\t\t\t;以上就是table段中的一行转换为ASCII码值的处理过程\n\t\t\t\n\n\t\t\t;下面开始显示过程，此过程需要循环四次\n\t\t\tpop dx\t\t\t\n\t\t\tmov di, 0\n\t\t\t;这里的di作为待输出数据段的指针\n\t\t\tmov cx, 4\n\ns2:\t\t\tmov si, 0\n\t\t\tcall show_str\n\t\t\tadd dl, 20\n\t\t\t;把列错开\n\t\t\tloop s2\n\t\t\tmov dl, 0\n\t\t\tadd dh, 1\n\t\t\tadd bx, 16\n\t\t\tpop cx\n\t\t\tpop es\n\t\t\tpop ds\n\t\t\tloop s1\n\t\t\t\n\n\t\t\tmov ax, 4c00h\n\t\t\tint 21h\n\ndtoc:\t\t;该子程序用于将数值型的数字转换为字符串\n\t\t\t;十进制数值转换为ASCII码值，转换关系为：ascii=10进制+30H\n\t\t\t;要想将一个十进制的整数拆分成一个一个\n\t\t\t\n\n\t\t\t的数值，那我们需要让这个数\n\t\t\t;除以10，然后将得到的结果依次入栈，除完之后再依次出栈，即可得到由高位到低位\n\t\t\t;的所有数值，之后将这些值加上30H，即得到其对应的ASCII码值，然后将这些\n\t\t\t;ASCII码值存放到一个数据段中，调用show_str函数，来在屏幕上显示这些数值\n\t\t\t;为了存储转换后的ASCII码值，我们需要新开辟一个数据段\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush ds \n\t\t\tpush ax\n\t\t\tpush si\n\t\t\tpush es\n\n  \t\t\tmov bx, 0\n\t\t\t;记录十进制数据的位数\nsplit:\t\tmov cx, 0ah\n\t\t\t;cx存放除数  \n\t\t\tcall divdw\n\t\t\t\n\n\t\t\t;如果被除数大于2550，al是无法存放商的，会造成溢出，因此，我们需要调用本实验中第二个程序\n\t\t\t;专门用于解决除法溢出问题的程序\n\t\t\t;此程序返回运算后的商和余数，分别保存在ax和cx中\n\n \t\t\tpush cx\n\t\t\t;余数入栈\n\t\t\tinc bx\n\t\t\t;当循环终止的时候可以进行弹栈存储操作了，但是我们需要一个标记，来标识我们需要\n\t\t\t;弹出多少次，我们使用bx来进行存储\n\t\t\tmov cx, ax\n\t\t\tadd cx, dx\n\t\t\t;ax中的值在下一次运算中一定会用到，dx中的值也有可能会用到（当被除数很大时）\n\t\t\t;此时可以临时保存数据的只有cx了，因此我们直接将运算结果放到cx中\n\t\t\t;一举两得\n\t\t\t;判断条件是商==0，因此我么需要高16位和低16位全都为0\n\t\t\tjcxz ok1\n\t\t\t;处理过程是需要循环的，循环结束的条件是商==0 \n\t\t\t;我们只需要将执行jcxz指令即可，当cx的值位0的时候，它会自动跳转到ok1循环的\n\t\t\tjmp short split \nok1:\t\tpop ax\n\t\t\tadd al, 30h\n\t\t\tmov byte ptr es:[di], al\n\t\t\tinc di\n\t\t\tdec bx\n\t\t\tmov cx, bx\n\t\t\tjcxz last\n\t\t\tjmp short ok1\n\nlast:\t\t;最后一步，在数据的ASCII数据形式的最后加上一个0\n\t\t\tmov ah, 0\n\t\t\tmov byte ptr es:[di], ah \n\t\t\tinc di\n\n\t\t\tpop es\n\t\t\tpop si\n\t\t\tpop ax \n\t\t\tpop ds\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tret\n\ndivdw:\t\tpush ds\n\t\t\tpush dx\n\t\t\tpush cx\n\t\t\tpush bx\n\t\t\tpush ax \n\n\t\t\tmov ax, temp\n\t\t\tmov ds, ax \n\t\t\tmov ax, dx \n\t\t\tmov dx, 0 \n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;根据公式，使用被除数高位除以除数得到的商×65536\n\t\t\t;*65536等价于在低位加16个0，因此操作就会变得非常简单\n\t\t\t;使用被除数高位除以除数得到的余数×65536+被除数的低位，再将得到的结果除以除数\n\t\t\t;两者的结果相加，即可得到32位/16位的无溢出结果\n\t\t\tpush dx\n\t\t\t;使用栈临时保存余数\n\t\t\tmov dx, ax\n\t\t\tmov ax, 0\n\t\t\tmov ds:[0], ax\n\t\t\tmov ds:[2], dx\n\t\t\tpop dx\n\t\t\t;弹出余数，作为右操作数中被除数的高16位\n\t\t\tpop ax\n\t\t\t;得到被除数的低16位\n\t\t\tpush ax\n\t\t\t;恢复栈顶数据，避免对主程序造成干扰 \n\t\t\t;将右操作数[]中的左操作数的低16位和被除数的低16位相加\n\t\t\t;但是右操作数[]中的左操作数的低16位一定是全0的，因此我们可以省略这一步\n\t\t\t;直接执行pop ax，将被除数的低16位作为右操作数的低16位\n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;由于左操作数的低16位一定是全0，所以不必与其相加，直接将\n\t\t\t;右操作数的低16位存储到ds:[0]内存单元即可\n\t\t\tmov ds:[0], ax\n\t\t\t;商的低16位放到ds:[0]单元中\n\t\t\tmov ds:[4], dx  \n\t\t\t;余数放到ds:[4]单元中\n\t\t\t;ds:[2]中一直保存的都是商的高16位，且没有被更改过，因此无须任何操作\n\t\n\t\t\tpop ax\n\t\t\tpop bx\n\t\t\tpop cx\n\t\t\tpop dx\n\t\t\tmov ax, ds:[0]\n\t\t\t;ax保存商的低16位\n\t\t\tmov dx, ds:[2]\n\t\t\t;dx保存商的高16位\n\t\t\tmov cx, ds:[4]\n\t\t\t;cx保存余数  \n\t\t\tpop ds\n\t\t\t;之所以要在pop ds之前将数据转移，是因为子程序divdw调用前，ds已经被使用\n\t\t\t;指向的是其他的段，如果不在pop之前转移数据，那么div段的数据就无法获取了\n\t\t\tret\t \n\nshow_str:\tpush ax\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush es \n\t\t\tpush ds\n\t\t\t;根据上节中的框架，为了不让子程序干扰主程序中寄存器的值，将所有子程序会用到的寄存器进行压栈\n\t\t\tmov ax, 0b800h\n\t\t\tmov es, ax\n\t\t\t;颜色区的段地址\n\t\t\tmov ax, show\n\t\t\tmov ds, ax\n\t\t\t;要读入的数据区的段地址\n\t\t\tmov al, 160 \n\t\t\tmul dh\n\t\t\t;每行占160个字节，乘以行数\n\t\t\tpush ax\n\t\t\t;将行计算的结果存储到栈中\n\t\t\tmov al, 2\n\t\t\tmul dl\n\t\t\t;每列占2个字节，乘以列数\n\t\t\tpop bx\n\t\t\t;将上次运算的结果（160×行数）的值转移到bx中\n\t\t\tadd bx, ax  ;此时的ax值为（2×列数）\n\t\t\t;将两者相加，最终结果保存到bx中\n\t\t\tmov dl, 130\n\t\t\t;显示颜色为绿色\nchange:\t\tmov cl, ds:[di]\n\t\t\tinc di \n\t\t\tmov ch, 0\n\t\t\tjcxz ok\n\t\t\tmov ch, dl\n\t\t\tmov es:[bx+si], cx\n\t\t\tadd si, 2 \n\t\t\tjmp short change\n\nok:\t\t\tpop ds \n\t\t\tpop es\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tpop ax\n\t\t\tret\n\ncodesg ends\nend start\n\ncodesg ends\nend start\n\ncodesg ends\nend start\n```\n\n## 中断\n\n### 1. 分类\n\n所谓**中断**，指的是CPU不再接着**刚执行完的指令**往下执行，而是转而处理由CPU内部或者外部产生的一种**特殊信息**。这种特殊信息我们称之为**中断信息**。中断信息要求CPU马上进行某种处理，并对所要进行的处理提供**必备参数**的通知信息。\n\n中断信息可以来自外部，也可以来自内部。\n\n我们通常将来自内部的中断称为**异常**，而把来自外部的中断称为**中断**。\n\n### 2. 机制\n\n#### 内中断\n\n对于8086CPU来说，当CPU内部有下面的情况发生时，将产生相应的中断信息——\n\n1. **除法错误**。如执行除法指令产生的除法溢出\n2. **单步执行**\n3. 执行**into指令**\n4. 执行**int指令**\n\n那么CPU接收到中断信息以后，会做出怎样的响应呢?\n\nCPU首先会判断中断信息的来源，因而中断信息中必须包含有能够识别中断来源的编码，这种编码就是**中断类型码**。\n\nCPU收到中断信息后，根据中断类型码会触发特定的**中断处理程序**，而要定位一段程序，就需要知道这段程序的**入口地址**。显然中断信息和其处理程序入口地址之间存在着某种**联系**。\n\n这种联系就是中断向量表。CPU可以通过8位的中断类型码通过中断向量表找到中断处理程序的入口地址。\n\n中断向量表，就是中断向量的列表。我们通常将具有大小和方向两个性质的几何对象称为**向量**，这里的中断向量**指的就是**中断处理程序的入口地址。\n\n中断向量表在**内存**中保存，其中存放了256个中断源所对应中断处理程序的入口，对于8086CPU来说，中断向量表**指定**放在内存地址0处，从内存**0000:0000**到**0000:03FF**的1024个单元中存放着中断向量表。\n\n那么在中断向量表中，一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU来说，这个入口地址包括段地址和偏移地址，所以一个表项占2个字，高地址存放段地址，低地址存放偏移地址。存储**N号中断源**所对应的中断处理程序的入口的**段地址**和**偏移地址**的内存单元地址分别是：**4N**，**4N+2**\n\n有一个问题需要考虑：CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令，所以在中断过程中，在设置CS:IP之前，还要将原来的CS:IP值保存起来。\n\n下面我们来概括一下中断过程的机制——\n\n> 1. 从中断信息中取得中断类型码\n> 2. 标志寄存器中的值入栈\n> 3. 设置标志寄存器TF和IF的值为0\n> 4. CS，IP的内容入栈\n> 5. 从内存单元为中断类型码×4和中断类型码*4+2的两个字单元中读取中断处理程序的入口设置IP和CS\n\n## 端口与BIOS读写\n\n待更新\n\n------\n\n参考目录\n\n1. 王燕老师的《汇编语言》，如果想简单了解下汇编语言的小伙伴，入手这本书就对啦。\n\n> 山高路远，静水深流\n\n","source":"_posts/那年深秋-在教室临窗写下的汇编.md","raw":"---\ntitle: '那年深秋,在教室临窗写下的汇编'\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 12:00:52\npassword:\nsummary:\ntags: intel8086汇编\ncategories: 计算机基础\n---\n\n## 前言\n\n### 1. 为什么要学习汇编语言？\n\n编程语言发展到如今，**高级语言**大行其道，他们通常被标榜为学习成本低。但由于高级语言不是直接调用**操作系统**，因而**执行效率**相对低一些。\n\n比如java语言，java源文件首先被编译，然后经过**JVM**的连接，最终执行得到运行于某平台的**机器码**。也就是说最终被计算机执行的是机器码。\n\n但机器码是不易于人理解的，虽说大道至简，在计算机的世界里，**0,1**才是王道。但计算机的模型通过0,1是很难窥见的，因而我们需要一种即易于人理解，且能够了解计算机执行机制的语言，这便是——**汇编语言**。\n\n#### C语言与汇编\n\n直观的看，操作系统的百分之九十代码是用C语言写的，数据库等软件同样是使用C语言编写的。也就是说，C语言执行效率高，适合用于描述底层的东西。\n\n我们可以把**工作技能**比作裁缝做成的**衣服**，java是衬衫，C++是长裤，但只会做衬衫的裁缝可不是一个好裁缝，裁缝铺需要的是，根据顾客的要求，`不管什么服装都可以做的好裁缝`。\n\n但这可不容易，我们需要了解不同类型衣服的共同之处，而衣服都是由**裁缝机**做成的，那么裁缝机是什么样，也会一定程度决定做成的衣服是什么样(`PS:这里我们不讨论先有鸡还是先有蛋的问题`)。\n\n这就如同语言，语言最终是去驱使硬件工作的，硬件也会反过来决定语言的特性，硬件的工作状态是高，低电平，对应计算机语言的0和1，所以哪种语言能够更好的解释0和1，而又为人所理解，那就会最先被衍生出来。\n\n这就是大家心心念念的C语言了，C语言向上沟通众多高级语言，无往不利，向下连通\"取指执行\"的圣经。\n\n而C语言要描述0和1，可不是直接编译那么简单，它要首先编辑为汇编语言，最终被连接执行为机器语言。\n\n### 2 . 汇编语言的定义\n\n> 汇编语言是二进制指令的文本形式\n\n### 3 . 学习汇编的要求\n\n通过使用**汇编指令**对**寄存器**和**内存**的操作来深刻理解**计算机执行指令**的机制。\n\n[^undefined]: 注 ： 我们这里的汇编专指8086CPU的汇编语言\n\n## 基础知识\n\n### 1. 为什么要使用寄存器\n\nCPU本身只负责**运算**，不负责**存储数据**，数据一般都存储在**内存**之中，CPU要用的时候就去内存读写数据，但是CPU读写的速度**远高于**内存的读写速度，为了避免被拖慢，CPU都自带一级缓存和二级缓存，**CPU缓存**可以看作是读写速度较快的内存。\n\n但是，CPU缓存还是不够快，另外数据在缓存里面的地址是**不固定**的，CPU每次读写都要**寻址**也会拖慢速度，因此，除了缓存之外，CPU还自带了**寄存器**，用来存储最常用的数据。也就是说，那些最频繁读写的数据，比如循环变量，都会放在寄存器中，CPU优先读写寄存器，再由寄存器跟内存交换数据\n\n![image-20201103224649594](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201103224649594.png)\n\n寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉CPU去具体哪一个寄存器中拿数据，这样的速度是最快的，因而也称寄存器是CPU的**零级缓存**。\n\n------\n\n### 2.寄存器的概述\n\n8086的寄存器都是16位的，可以存放两个字节的数据，也就是说它的寻址能力就只有2的16次方个字节空间，也就是64KB。\n\n通俗的将，32位，64位系统指的就是寄存器的位数。32位寄存器可以存放的数据是2的32次方，也就是4GB，换句话说，32位的系统最多能寻址的数据只有4GB。\n\n寄存器要存储数据，首先需要从内存中取出数据，而从内存中读取数据，就要知道数据在内存中存储的地址，也就是物理地址。\n\n### 3.物理地址\n\n8086CPU有20位的地址总线，可以传送20位地址，达到1MB寻址能力，但数据总线只有16位，它只能传输16的地址，表现出来的寻址能力只有64KB，所以我们需要使用两个16位的地址来合成20位的物理地址。\n\n这两个16位的地址，一个是段地址CS，一个是偏移地址IP，采用物理地址=短地址*16+偏移地址的运算方式扩展16位到20位，换句话说，也就是逻辑左移4位。\n\n有了物理地址，我们就可以知道从哪个内存地址读取指令，那如何将取出来的指令执行呢？\n\n![image-20201108221905157](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201108221905157.png)\n\n了解了指令执行的模型，我们知道CS,IP的值是从寄存器中读取的，那寄存器是怎样存储值的呢？\n\n### 4.寄存器的分类\n\n从类型上说，我们存储的数据有两类，字节型和字型。\n\n而从数据类型来说，数据分为通用的数据和具有特定意义的数据，在计算时，通用的寄存器存储在通用寄存器中，而特殊的数据，比如需要保留状态的数据，会被存储在标志寄存器中。下面我们来看具体的描述——\n\n8086CPU有8个寄存器，且都是16位的，即可以存放两个字节，8个寄存器中包括4个通用寄存器，4个段寄存器。\n\n4个通用的寄存器分别是AX,BX,CX,DX,用于存放一般性的数据。而考虑到兼容，又将这四个寄存器分成了独立的8个寄存器来使用。比如取AX的低八位组成了AL寄存器，高八位组成了AH寄存器。\n\n当CPU要访问内存时，由段寄存器来提供内存单元的段地址，这些寄存器包括DS,ES,SS,CS.\n\n其中DS寄存器通常用于存放要访问数据的段地址，CS寄存器是代码段寄存器，当我们要访问栈段时，栈段的起始地址从SS寄存器中读取，偏移地址从SP寄存器中读取，ES为扩展段寄存器。\n\n### 2. 内存模型\n\n寄存器只能存放少量的数据，大多数时候，CPU要指挥寄存器与内存进行数据交换，所以，除了寄存器，还必须了解内存如何存储数据。\n\n当程序运行时，操作系统会为程序分配一段内存空间，用于存储程序和程序运行产生的结果。这段内存空间有一个起始地址和一个结束地址。且低位的是起始地址，高位的是结束地址。\n\n通俗的说，内存中存放的是源程序，源程序中有效的部分称为程序，而程序是由数据和指令组成的，那内存是如何区分数据和指令的呢？CS:IP指向的内存单元存放的是指令，其他的则是数据。但数据的使用频度是不同的，使用场景也是不同的，因此我们把一般性的数据存放在堆中，而把需要保存状态的数据存放在栈中，那堆栈有怎样的结构特点呢——\n\n### 堆\n\n程序运行过程中，对于动态的内存占用请求，比如说新建对象，或者使用malloc命令，系统就会从预先分配好的那段内存找那个，划出一部分给用户，规则是从起始地址算起，而实际上起始地址会有一段静态数据，这里暂且忽略。\n\n这种因为用户主动请求而划分出来的内存区域，叫做heap（堆），它由起始地址开始向高位增长，Heap的一个重要特点就是不会自动消失，必须手动的释放或者通过内存垃圾回收机制来回收。\n\n除了Heap以外，其他的内存占用叫做Stack(栈)，简单说，栈是函数运行时被临时使用的内存空间。\n\n请看下面的例子——\n\n```java\nint main(){\n\tint a;\n\tint b;\n\treturn add(a,b);\n}\n```\n\n当系统开始执行main函数时，会为其在内存中建立一个帧，这个数据帧中会存放main函数中声明的内部变量a,b.而当程序执行到调用add函数时，这时就需要为这个函数也建立一个帧，用来存储它的内部变量。一般来说，调用了多少层的帧，就有多少个栈，等到add函数执行结束，它的帧就会被回收，程序再次回到main函数中断的地方，继续往下执行，系统使用这种机制，实现了函数的层层调用。\n\n所有的帧，都存放在栈中，生成新的帧，叫做入栈，英文是push.将栈回收，叫做出栈,英文是pop,栈的特点就是先进后出，栈顶指针始终指向最外层的帧，帧是从栈的高地址开始存放，之后内存地址不断递减直至栈满。\n\n那栈的空间是由谁来决定的呢？系统能否判断栈是否已满呢？\n\n并不能，当需要使用栈的时候，我们需要声明一段内存空间作为栈段，我们只能人为的避免造成栈满，而不能寄希望于操作系统。\n\n## 常用指令\n\n### 1. 伪指令与指令\n\n程序是指令的集合，每一条指令都对应CPU的操作，但仅有指令是不够的，指令不能告诉编译器，程序什么时候结束，也不能告诉编译器，数据段存储在哪段内存空间，代码段又存储在哪段内存空间。所以需要有一种能被编译器所识别的，用于定义程序结构化的语言。这就是伪指令了。\n\n伪指令是用于告诉汇编程序如何进行**汇编**的指令。它既不控制机器的操作也不被汇编成机器代码，只能为汇编器所识别并指导汇编程序如何进行。 将相对于程序或相对于寄存器的地址载入寄存器中。\n\n### 2 .常用指令\n\n| 序号 | **语法**             | **功能**               |                **案例**                 | **说明**                                                     | **备注**                                                    |\n| ---- | -------------------- | ---------------------- | :-------------------------------------: | ------------------------------------------------------------ | ----------------------------------------------------------- |\n| 1    | mov                  | 数据传送指令           |                mov[0],cs                | 将寄存器CS中的内容传送到偏移地址为0的内存单元中              | 符合反对称                                                  |\n| 2    | add/sub              | 加、减指令             |                sub ax,bx                | 将ax寄存器中的内容减去bx寄存器中的内容的结果存储在ax中       |                                                             |\n| 3    | push                 | 入栈                   |                 push ax                 | 分两步，首先栈顶指针偏移，其次将ax寄存器中的内容入栈         | 段地址从ds中取得                                            |\n| 4    | pop                  | 出栈                   |                 pop ax                  | 分两步，首先将栈顶指针指向的内容赋给ax寄存器，然后栈顶指针偏移 |                                                             |\n| 5    | loop 标号            | 跳转至标号处           |              loop continue              | CPU执行loop指令时，进行两步操作：首先CX递减，然后判断CX中的值，若不为0，则跳转标号处，若为0，则向下执行 | CX专用于存放循环次数                                        |\n| 6    | and                  | 逻辑与                 |          and      al,01100011B          | 按位进行与运算                                               | 常用于位清除                                                |\n| 7    | or                   | 逻辑或                 |             or al,01100011B             | 按位进行或运算                                               | 常用于位填充                                                |\n| 8    | div                  | 除法                   |           div byte ptr ds:[0]           | 做除法操作时，除数有8位和16位两种，存放在在一个reg/内存单元中。被除数默认放在AX或者DX和AX中，如果除数为8位，被除数则为**16位**，默认在**AX**中存放；如果除数为16位，被除数为**32位**，在**DX和AX**中存放，D**X存放高16位，AX存放低16位**。结果：如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数；如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数， | 进行除法操作前，首先要进行除数和被除数的设置                |\n| 9    | jmp                  | 无条件转移指令         |               jmp short s               | **段内短位移**，转到标号s处执行指令。                        | jmp指令应该包含两种信息：转移的**目的地址**与转移的**距离** |\n| 10   |                      |                        |              jmp far ptr s              | **段间转移**，使用S的段地址和偏移地址修改CS和IP              |                                                             |\n| 11   |                      |                        |                 jmp AX                  | **段内偏移**，将寄存器AX中的内容赋给IP                       |                                                             |\n| 12   |                      |                        |           jmp word ptr ds:[0]           | **段内偏移**，从内存单元的地址处开始存放一个字，即转移的目的**偏移地址** |                                                             |\n| 13   | jcxz                 | 有条件转移指令         |                 jcxz s                  | **短位移**，指令中包含转移位移，而不是目的地址。等同于 if(CX == 0) jmp short 标号 |                                                             |\n| 14   | call                 | 转移指令               |                 call s                  | 不能实现短位移，执行call指令，执行两步操作：push IP ， jmp  near ptr 标号 |                                                             |\n| 15   | ret                  | 复原指令               |                   ret                   | CPU执行ret操作时，等同于执行指令 pop IP                      |                                                             |\n| 16   | retf                 | 复原指令               |                  retf                   | CPU执行retf操作时，等同于执行指令pop IP,pop CS               |                                                             |\n| 17   | mul                  | 乘法指令               |     mov ax,100 mov bx,10000 mul bx      | 类div指令                                                    |                                                             |\n| 18   | adc                  | 带进位加法             |                adc AX,BX                | 等同于add AX,BX, ADD AX,CF                                   |                                                             |\n| 19   | sub                  | 带借位减法             |                sub AX,BX                | 等同于sub AX,BX, sub AX,CF                                   |                                                             |\n| 20   | cmp                  | 比较指令               | mov ax,8        mov bx,3      cmp ax,bx | 相当于减法操作，计算结果会对标志寄存器产生影响               |                                                             |\n| 21   | je jne jb jnb ja jna | 根据比较结果的跳转指令 |                  jxx s                  | 等于/不等于/低于/不低于/大于/不大于                          |                                                             |\n| 22   | pushf  popf          |                        |               pushf  popf               | 将标志寄存器中的值压栈/出栈                                  |                                                             |\n| 23   | iret                 | 复原指令               |                  iret                   | 等同于：pop IP，pop CS,popf                                  |                                                             |\n| 24   | int                  | 中断指令               |                  int n                  | 这里的n表示的是中断类型码。CPU执行int n指令，执行过程：首先取中断类型码n，然后标志寄存器入栈，接着CS，IP入栈。最后跳转执行 |                                                             |\n| 25   | shl                  | 逻辑左移指令           |                shl al,1                 | 将al中的数据逻辑左移1位，最后移出的1位写入CF，最低位用0补充  |                                                             |\n| 26   | shr                  | 逻辑右移指令           |                shr al,1                 | 将al中的数据逻辑右移1位，最后移出的1位写入CF，最高位用0补充  |                                                             |\n\n### 3.常用的伪指令\n\n| 名称            | 功能                     | 案例            | 说明                                 | 备注 |\n| --------------- | ------------------------ | --------------- | ------------------------------------ | ---- |\n| dd(double word) | 定义双字型数据           | dd 12345        | 定义了占2个字的数据12345             |      |\n| db(define byte) | 定义字节型数据           | db 1            | 定义了占1个字节的数据1               |      |\n| dw(define word) | 定义字型数据             | dw 100          | 定义了占1个字的数据100               |      |\n| dup             | 用于进行数据的重复       | db 3 dup (0,1,) | 定义了6个字节数据，分别是0,1,0,1,0,1 |      |\n| offset          | 取得标号的偏移地址       | mov si,offset s | 将标号s的偏移地址赋给si              |      |\n| seg             | 回送变量或者标号的段地址 |                 |                                      |      |\n\n- [ ] 更多的可参考http://blog.sina.com.cn/s/blog_4a92ce12010006m2.html\n\n### 4. 以学促用\n\n#### 问题描述\n\n> 将实验七中的Power idea 公司的数据，按照图10.2所下图屏幕中显示出来\n\n![image-20201112151602560](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201112151602560.png)\n\n#### 代码与注释\n\n```ASM\nassume cs:codesg\n;将整个data段看作是一个数组，长度一共为\n;21*4+21*4+2*21=168+42=210字节\ndata segment\n    db '1975', '1976', '1977', '1978', '1979', '1980', '1981', '1982', '1983'\n    db '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992'\n    db '1993', '1994', '1995'\n    ;长度为84的数组，一个字符一个字节：4X21\n\n    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514\n    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000\n    \n    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226\n    dw 11542, 14430, 15257, 17800\n\ndata ends\n\n;ax+210/16向上取整，即ax+14h\n;对于ds，偏移量为16*14=224\ntable segment\n    db 21 dup('year summ ne ?? ')\ntable ends\n\nshow segment\n    db 100 dup(0)\nshow ends\n\ntemp segment\n    dw 10 dup(0)\ntemp ends\n\ncodesg segment\nstart:\t  \tmov ax, data\n\t\t\tmov ds, ax \n\t\t\tmov bx, table\n\t\t\tmov es, bx  \n\t\t\tmov bx, 0   ;定位结构体数组元素\n\t\t\tmov di, 0   ;定位data中的4字节数据\n\t\t\tmov si, 0   ;定位data中的2字节数据\n\t\t\tmov cx, 15h\ns0:\t\t\t;转移年份\n\t\t\tmov ax, ds:[di]\n\t\t\tmov es:[bx], ax\n\t\t\tmov ax, ds:[di+2]\n\t\t\tmov es:[bx+2], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+4], 32\n\n\t\t\t;转移收入\n\t\t\t;作为被除数\n\t\t\tmov ax, ds:[di+84];\n\t\t\tmov es:[bx+5], ax\n\t\t\tmov ax, ds:[di+86]\n\t\t\tmov es:[bx+7], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+9], 32\n\t\n\t\t\t;转移雇员数量\n\t\t\tmov ax, ds:[si+168]\n\t\t\tmov es:[bx+10], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+12], 32\n\t\n\t\t\t;计算人均收入，并转移到table中\n\t\t\tmov ax, es:[bx+5]   ;低16位\n\t\t\tmov dx, es:[bx+7]   ;高16位\n\t\t\tdiv word ptr es:[bx+10]\n\t\t\tmov es:[bx+13], ax  ;商默认存放在ax中 \n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+15], 32\n\t\t\t;操作完成，bx加16，di加2\n\t\t\tadd bx, 16  \n\t\t\tadd di, 4\n\t\t\tadd si, 2\n\t\t\tloop s0\n\n;s0循环的作用主要是将数据存储到table段中\n;而在s1循环中，先把table段中的数据转化为字符串，转储到\n;show段中，然后再在s2循环中调用show_str子程序来将这些字符串一行一行地\n;显示到屏幕上\n\t\t\tmov ax, table\n\t\t\tmov ds, ax\n\t\t\tmov ax, show\n\t\t\tmov es, ax\n\t\t\tmov dx, 0\n\t\t\tmov dh, 4\n\t\t\tmov bx, 0\n\t\t\tmov cx, 15h\ns1:\t\t\tmov di, 0\n\t\t\t;这里的di作为table数据段的指针\n\t\t\tpush ds\n\t\t\tpush es\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\t;保存行列信息，在调用show_str时会用到\n\t\t\t;转储年份\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tadd di, 2\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tmov byte ptr es:[di+4], 0\n\t\t\t;转储收入\n\t\t\tmov di, 5\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov dx, ds:[bx+di+2]\n\t\t\tcall dtoc \n\t\t\t;转储人数\n\t\t\tmov ax, ds:[bx+10]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc \n\t\t\t;转储人均收入\n\t\t\tmov ax, ds:[bx+13]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc\n\t\t\t;以上就是table段中的一行转换为ASCII码值的处理过程\n\t\t\t\n\n\t\t\t;下面开始显示过程，此过程需要循环四次\n\t\t\tpop dx\t\t\t\n\t\t\tmov di, 0\n\t\t\t;这里的di作为待输出数据段的指针\n\t\t\tmov cx, 4\n\ns2:\t\t\tmov si, 0\n\t\t\tcall show_str\n\t\t\tadd dl, 20\n\t\t\t;把列错开\n\t\t\tloop s2\n\t\t\tmov dl, 0\n\t\t\tadd dh, 1\n\t\t\tadd bx, 16\n\t\t\tpop cx\n\t\t\tpop es\n\t\t\tpop ds\n\t\t\tloop s1\n\t\t\t\n\n\t\t\tmov ax, 4c00h\n\t\t\tint 21h\n\ndtoc:\t\t;该子程序用于将数值型的数字转换为字符串\n\t\t\t;十进制数值转换为ASCII码值，转换关系为：ascii=10进制+30H\n\t\t\t;要想将一个十进制的整数拆分成一个一个\n\t\t\t\n\n\t\t\t的数值，那我们需要让这个数\n\t\t\t;除以10，然后将得到的结果依次入栈，除完之后再依次出栈，即可得到由高位到低位\n\t\t\t;的所有数值，之后将这些值加上30H，即得到其对应的ASCII码值，然后将这些\n\t\t\t;ASCII码值存放到一个数据段中，调用show_str函数，来在屏幕上显示这些数值\n\t\t\t;为了存储转换后的ASCII码值，我们需要新开辟一个数据段\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush ds \n\t\t\tpush ax\n\t\t\tpush si\n\t\t\tpush es\n\n  \t\t\tmov bx, 0\n\t\t\t;记录十进制数据的位数\nsplit:\t\tmov cx, 0ah\n\t\t\t;cx存放除数  \n\t\t\tcall divdw\n\t\t\t\n\n\t\t\t;如果被除数大于2550，al是无法存放商的，会造成溢出，因此，我们需要调用本实验中第二个程序\n\t\t\t;专门用于解决除法溢出问题的程序\n\t\t\t;此程序返回运算后的商和余数，分别保存在ax和cx中\n\n \t\t\tpush cx\n\t\t\t;余数入栈\n\t\t\tinc bx\n\t\t\t;当循环终止的时候可以进行弹栈存储操作了，但是我们需要一个标记，来标识我们需要\n\t\t\t;弹出多少次，我们使用bx来进行存储\n\t\t\tmov cx, ax\n\t\t\tadd cx, dx\n\t\t\t;ax中的值在下一次运算中一定会用到，dx中的值也有可能会用到（当被除数很大时）\n\t\t\t;此时可以临时保存数据的只有cx了，因此我们直接将运算结果放到cx中\n\t\t\t;一举两得\n\t\t\t;判断条件是商==0，因此我么需要高16位和低16位全都为0\n\t\t\tjcxz ok1\n\t\t\t;处理过程是需要循环的，循环结束的条件是商==0 \n\t\t\t;我们只需要将执行jcxz指令即可，当cx的值位0的时候，它会自动跳转到ok1循环的\n\t\t\tjmp short split \nok1:\t\tpop ax\n\t\t\tadd al, 30h\n\t\t\tmov byte ptr es:[di], al\n\t\t\tinc di\n\t\t\tdec bx\n\t\t\tmov cx, bx\n\t\t\tjcxz last\n\t\t\tjmp short ok1\n\nlast:\t\t;最后一步，在数据的ASCII数据形式的最后加上一个0\n\t\t\tmov ah, 0\n\t\t\tmov byte ptr es:[di], ah \n\t\t\tinc di\n\n\t\t\tpop es\n\t\t\tpop si\n\t\t\tpop ax \n\t\t\tpop ds\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tret\n\ndivdw:\t\tpush ds\n\t\t\tpush dx\n\t\t\tpush cx\n\t\t\tpush bx\n\t\t\tpush ax \n\n\t\t\tmov ax, temp\n\t\t\tmov ds, ax \n\t\t\tmov ax, dx \n\t\t\tmov dx, 0 \n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;根据公式，使用被除数高位除以除数得到的商×65536\n\t\t\t;*65536等价于在低位加16个0，因此操作就会变得非常简单\n\t\t\t;使用被除数高位除以除数得到的余数×65536+被除数的低位，再将得到的结果除以除数\n\t\t\t;两者的结果相加，即可得到32位/16位的无溢出结果\n\t\t\tpush dx\n\t\t\t;使用栈临时保存余数\n\t\t\tmov dx, ax\n\t\t\tmov ax, 0\n\t\t\tmov ds:[0], ax\n\t\t\tmov ds:[2], dx\n\t\t\tpop dx\n\t\t\t;弹出余数，作为右操作数中被除数的高16位\n\t\t\tpop ax\n\t\t\t;得到被除数的低16位\n\t\t\tpush ax\n\t\t\t;恢复栈顶数据，避免对主程序造成干扰 \n\t\t\t;将右操作数[]中的左操作数的低16位和被除数的低16位相加\n\t\t\t;但是右操作数[]中的左操作数的低16位一定是全0的，因此我们可以省略这一步\n\t\t\t;直接执行pop ax，将被除数的低16位作为右操作数的低16位\n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;由于左操作数的低16位一定是全0，所以不必与其相加，直接将\n\t\t\t;右操作数的低16位存储到ds:[0]内存单元即可\n\t\t\tmov ds:[0], ax\n\t\t\t;商的低16位放到ds:[0]单元中\n\t\t\tmov ds:[4], dx  \n\t\t\t;余数放到ds:[4]单元中\n\t\t\t;ds:[2]中一直保存的都是商的高16位，且没有被更改过，因此无须任何操作\n\t\n\t\t\tpop ax\n\t\t\tpop bx\n\t\t\tpop cx\n\t\t\tpop dx\n\t\t\tmov ax, ds:[0]\n\t\t\t;ax保存商的低16位\n\t\t\tmov dx, ds:[2]\n\t\t\t;dx保存商的高16位\n\t\t\tmov cx, ds:[4]\n\t\t\t;cx保存余数  \n\t\t\tpop ds\n\t\t\t;之所以要在pop ds之前将数据转移，是因为子程序divdw调用前，ds已经被使用\n\t\t\t;指向的是其他的段，如果不在pop之前转移数据，那么div段的数据就无法获取了\n\t\t\tret\t \n\nshow_str:\tpush ax\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush es \n\t\t\tpush ds\n\t\t\t;根据上节中的框架，为了不让子程序干扰主程序中寄存器的值，将所有子程序会用到的寄存器进行压栈\n\t\t\tmov ax, 0b800h\n\t\t\tmov es, ax\n\t\t\t;颜色区的段地址\n\t\t\tmov ax, show\n\t\t\tmov ds, ax\n\t\t\t;要读入的数据区的段地址\n\t\t\tmov al, 160 \n\t\t\tmul dh\n\t\t\t;每行占160个字节，乘以行数\n\t\t\tpush ax\n\t\t\t;将行计算的结果存储到栈中\n\t\t\tmov al, 2\n\t\t\tmul dl\n\t\t\t;每列占2个字节，乘以列数\n\t\t\tpop bx\n\t\t\t;将上次运算的结果（160×行数）的值转移到bx中\n\t\t\tadd bx, ax  ;此时的ax值为（2×列数）\n\t\t\t;将两者相加，最终结果保存到bx中\n\t\t\tmov dl, 130\n\t\t\t;显示颜色为绿色\nchange:\t\tmov cl, ds:[di]\n\t\t\tinc di \n\t\t\tmov ch, 0\n\t\t\tjcxz ok\n\t\t\tmov ch, dl\n\t\t\tmov es:[bx+si], cx\n\t\t\tadd si, 2 \n\t\t\tjmp short change\n\nok:\t\t\tpop ds \n\t\t\tpop es\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tpop ax\n\t\t\tret\n\ncodesg ends\nend start\n\ncodesg ends\nend start\n\ncodesg ends\nend start\n```\n\n## 中断\n\n### 1. 分类\n\n所谓**中断**，指的是CPU不再接着**刚执行完的指令**往下执行，而是转而处理由CPU内部或者外部产生的一种**特殊信息**。这种特殊信息我们称之为**中断信息**。中断信息要求CPU马上进行某种处理，并对所要进行的处理提供**必备参数**的通知信息。\n\n中断信息可以来自外部，也可以来自内部。\n\n我们通常将来自内部的中断称为**异常**，而把来自外部的中断称为**中断**。\n\n### 2. 机制\n\n#### 内中断\n\n对于8086CPU来说，当CPU内部有下面的情况发生时，将产生相应的中断信息——\n\n1. **除法错误**。如执行除法指令产生的除法溢出\n2. **单步执行**\n3. 执行**into指令**\n4. 执行**int指令**\n\n那么CPU接收到中断信息以后，会做出怎样的响应呢?\n\nCPU首先会判断中断信息的来源，因而中断信息中必须包含有能够识别中断来源的编码，这种编码就是**中断类型码**。\n\nCPU收到中断信息后，根据中断类型码会触发特定的**中断处理程序**，而要定位一段程序，就需要知道这段程序的**入口地址**。显然中断信息和其处理程序入口地址之间存在着某种**联系**。\n\n这种联系就是中断向量表。CPU可以通过8位的中断类型码通过中断向量表找到中断处理程序的入口地址。\n\n中断向量表，就是中断向量的列表。我们通常将具有大小和方向两个性质的几何对象称为**向量**，这里的中断向量**指的就是**中断处理程序的入口地址。\n\n中断向量表在**内存**中保存，其中存放了256个中断源所对应中断处理程序的入口，对于8086CPU来说，中断向量表**指定**放在内存地址0处，从内存**0000:0000**到**0000:03FF**的1024个单元中存放着中断向量表。\n\n那么在中断向量表中，一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU来说，这个入口地址包括段地址和偏移地址，所以一个表项占2个字，高地址存放段地址，低地址存放偏移地址。存储**N号中断源**所对应的中断处理程序的入口的**段地址**和**偏移地址**的内存单元地址分别是：**4N**，**4N+2**\n\n有一个问题需要考虑：CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令，所以在中断过程中，在设置CS:IP之前，还要将原来的CS:IP值保存起来。\n\n下面我们来概括一下中断过程的机制——\n\n> 1. 从中断信息中取得中断类型码\n> 2. 标志寄存器中的值入栈\n> 3. 设置标志寄存器TF和IF的值为0\n> 4. CS，IP的内容入栈\n> 5. 从内存单元为中断类型码×4和中断类型码*4+2的两个字单元中读取中断处理程序的入口设置IP和CS\n\n## 端口与BIOS读写\n\n待更新\n\n------\n\n参考目录\n\n1. 王燕老师的《汇编语言》，如果想简单了解下汇编语言的小伙伴，入手这本书就对啦。\n\n> 山高路远，静水深流\n\n","slug":"那年深秋-在教室临窗写下的汇编","published":1,"updated":"2023-09-24T09:50:29.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7m1001wxjccdlpa0gyu","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h3 id=\"1-为什么要学习汇编语言？\"><a href=\"#1-为什么要学习汇编语言？\" class=\"headerlink\" title=\"1. 为什么要学习汇编语言？\"></a>1. 为什么要学习汇编语言？</h3><p>编程语言发展到如今，<strong>高级语言</strong>大行其道，他们通常被标榜为学习成本低。但由于高级语言不是直接调用<strong>操作系统</strong>，因而<strong>执行效率</strong>相对低一些。</p>\n<p>比如java语言，java源文件首先被编译，然后经过<strong>JVM</strong>的连接，最终执行得到运行于某平台的<strong>机器码</strong>。也就是说最终被计算机执行的是机器码。</p>\n<p>但机器码是不易于人理解的，虽说大道至简，在计算机的世界里，<strong>0,1</strong>才是王道。但计算机的模型通过0,1是很难窥见的，因而我们需要一种即易于人理解，且能够了解计算机执行机制的语言，这便是——<strong>汇编语言</strong>。</p>\n<h4 id=\"C语言与汇编\"><a href=\"#C语言与汇编\" class=\"headerlink\" title=\"C语言与汇编\"></a>C语言与汇编</h4><p>直观的看，操作系统的百分之九十代码是用C语言写的，数据库等软件同样是使用C语言编写的。也就是说，C语言执行效率高，适合用于描述底层的东西。</p>\n<p>我们可以把<strong>工作技能</strong>比作裁缝做成的<strong>衣服</strong>，java是衬衫，C++是长裤，但只会做衬衫的裁缝可不是一个好裁缝，裁缝铺需要的是，根据顾客的要求，<code>不管什么服装都可以做的好裁缝</code>。</p>\n<p>但这可不容易，我们需要了解不同类型衣服的共同之处，而衣服都是由<strong>裁缝机</strong>做成的，那么裁缝机是什么样，也会一定程度决定做成的衣服是什么样(<code>PS:这里我们不讨论先有鸡还是先有蛋的问题</code>)。</p>\n<p>这就如同语言，语言最终是去驱使硬件工作的，硬件也会反过来决定语言的特性，硬件的工作状态是高，低电平，对应计算机语言的0和1，所以哪种语言能够更好的解释0和1，而又为人所理解，那就会最先被衍生出来。</p>\n<p>这就是大家心心念念的C语言了，C语言向上沟通众多高级语言，无往不利，向下连通”取指执行”的圣经。</p>\n<p>而C语言要描述0和1，可不是直接编译那么简单，它要首先编辑为汇编语言，最终被连接执行为机器语言。</p>\n<h3 id=\"2-汇编语言的定义\"><a href=\"#2-汇编语言的定义\" class=\"headerlink\" title=\"2 . 汇编语言的定义\"></a>2 . 汇编语言的定义</h3><blockquote>\n<p>汇编语言是二进制指令的文本形式</p>\n</blockquote>\n<h3 id=\"3-学习汇编的要求\"><a href=\"#3-学习汇编的要求\" class=\"headerlink\" title=\"3 . 学习汇编的要求\"></a>3 . 学习汇编的要求</h3><p>通过使用<strong>汇编指令</strong>对<strong>寄存器</strong>和<strong>内存</strong>的操作来深刻理解<strong>计算机执行指令</strong>的机制。</p>\n<p>[^undefined]: 注 ： 我们这里的汇编专指8086CPU的汇编语言</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"1-为什么要使用寄存器\"><a href=\"#1-为什么要使用寄存器\" class=\"headerlink\" title=\"1. 为什么要使用寄存器\"></a>1. 为什么要使用寄存器</h3><p>CPU本身只负责<strong>运算</strong>，不负责<strong>存储数据</strong>，数据一般都存储在<strong>内存</strong>之中，CPU要用的时候就去内存读写数据，但是CPU读写的速度<strong>远高于</strong>内存的读写速度，为了避免被拖慢，CPU都自带一级缓存和二级缓存，<strong>CPU缓存</strong>可以看作是读写速度较快的内存。</p>\n<p>但是，CPU缓存还是不够快，另外数据在缓存里面的地址是<strong>不固定</strong>的，CPU每次读写都要<strong>寻址</strong>也会拖慢速度，因此，除了缓存之外，CPU还自带了<strong>寄存器</strong>，用来存储最常用的数据。也就是说，那些最频繁读写的数据，比如循环变量，都会放在寄存器中，CPU优先读写寄存器，再由寄存器跟内存交换数据</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201103224649594.png\" alt=\"image-20201103224649594\"></p>\n<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉CPU去具体哪一个寄存器中拿数据，这样的速度是最快的，因而也称寄存器是CPU的<strong>零级缓存</strong>。</p>\n<hr>\n<h3 id=\"2-寄存器的概述\"><a href=\"#2-寄存器的概述\" class=\"headerlink\" title=\"2.寄存器的概述\"></a>2.寄存器的概述</h3><p>8086的寄存器都是16位的，可以存放两个字节的数据，也就是说它的寻址能力就只有2的16次方个字节空间，也就是64KB。</p>\n<p>通俗的将，32位，64位系统指的就是寄存器的位数。32位寄存器可以存放的数据是2的32次方，也就是4GB，换句话说，32位的系统最多能寻址的数据只有4GB。</p>\n<p>寄存器要存储数据，首先需要从内存中取出数据，而从内存中读取数据，就要知道数据在内存中存储的地址，也就是物理地址。</p>\n<h3 id=\"3-物理地址\"><a href=\"#3-物理地址\" class=\"headerlink\" title=\"3.物理地址\"></a>3.物理地址</h3><p>8086CPU有20位的地址总线，可以传送20位地址，达到1MB寻址能力，但数据总线只有16位，它只能传输16的地址，表现出来的寻址能力只有64KB，所以我们需要使用两个16位的地址来合成20位的物理地址。</p>\n<p>这两个16位的地址，一个是段地址CS，一个是偏移地址IP，采用物理地址=短地址*16+偏移地址的运算方式扩展16位到20位，换句话说，也就是逻辑左移4位。</p>\n<p>有了物理地址，我们就可以知道从哪个内存地址读取指令，那如何将取出来的指令执行呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201108221905157.png\" alt=\"image-20201108221905157\"></p>\n<p>了解了指令执行的模型，我们知道CS,IP的值是从寄存器中读取的，那寄存器是怎样存储值的呢？</p>\n<h3 id=\"4-寄存器的分类\"><a href=\"#4-寄存器的分类\" class=\"headerlink\" title=\"4.寄存器的分类\"></a>4.寄存器的分类</h3><p>从类型上说，我们存储的数据有两类，字节型和字型。</p>\n<p>而从数据类型来说，数据分为通用的数据和具有特定意义的数据，在计算时，通用的寄存器存储在通用寄存器中，而特殊的数据，比如需要保留状态的数据，会被存储在标志寄存器中。下面我们来看具体的描述——</p>\n<p>8086CPU有8个寄存器，且都是16位的，即可以存放两个字节，8个寄存器中包括4个通用寄存器，4个段寄存器。</p>\n<p>4个通用的寄存器分别是AX,BX,CX,DX,用于存放一般性的数据。而考虑到兼容，又将这四个寄存器分成了独立的8个寄存器来使用。比如取AX的低八位组成了AL寄存器，高八位组成了AH寄存器。</p>\n<p>当CPU要访问内存时，由段寄存器来提供内存单元的段地址，这些寄存器包括DS,ES,SS,CS.</p>\n<p>其中DS寄存器通常用于存放要访问数据的段地址，CS寄存器是代码段寄存器，当我们要访问栈段时，栈段的起始地址从SS寄存器中读取，偏移地址从SP寄存器中读取，ES为扩展段寄存器。</p>\n<h3 id=\"2-内存模型\"><a href=\"#2-内存模型\" class=\"headerlink\" title=\"2. 内存模型\"></a>2. 内存模型</h3><p>寄存器只能存放少量的数据，大多数时候，CPU要指挥寄存器与内存进行数据交换，所以，除了寄存器，还必须了解内存如何存储数据。</p>\n<p>当程序运行时，操作系统会为程序分配一段内存空间，用于存储程序和程序运行产生的结果。这段内存空间有一个起始地址和一个结束地址。且低位的是起始地址，高位的是结束地址。</p>\n<p>通俗的说，内存中存放的是源程序，源程序中有效的部分称为程序，而程序是由数据和指令组成的，那内存是如何区分数据和指令的呢？CS:IP指向的内存单元存放的是指令，其他的则是数据。但数据的使用频度是不同的，使用场景也是不同的，因此我们把一般性的数据存放在堆中，而把需要保存状态的数据存放在栈中，那堆栈有怎样的结构特点呢——</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>程序运行过程中，对于动态的内存占用请求，比如说新建对象，或者使用malloc命令，系统就会从预先分配好的那段内存找那个，划出一部分给用户，规则是从起始地址算起，而实际上起始地址会有一段静态数据，这里暂且忽略。</p>\n<p>这种因为用户主动请求而划分出来的内存区域，叫做heap（堆），它由起始地址开始向高位增长，Heap的一个重要特点就是不会自动消失，必须手动的释放或者通过内存垃圾回收机制来回收。</p>\n<p>除了Heap以外，其他的内存占用叫做Stack(栈)，简单说，栈是函数运行时被临时使用的内存空间。</p>\n<p>请看下面的例子——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当系统开始执行main函数时，会为其在内存中建立一个帧，这个数据帧中会存放main函数中声明的内部变量a,b.而当程序执行到调用add函数时，这时就需要为这个函数也建立一个帧，用来存储它的内部变量。一般来说，调用了多少层的帧，就有多少个栈，等到add函数执行结束，它的帧就会被回收，程序再次回到main函数中断的地方，继续往下执行，系统使用这种机制，实现了函数的层层调用。</p>\n<p>所有的帧，都存放在栈中，生成新的帧，叫做入栈，英文是push.将栈回收，叫做出栈,英文是pop,栈的特点就是先进后出，栈顶指针始终指向最外层的帧，帧是从栈的高地址开始存放，之后内存地址不断递减直至栈满。</p>\n<p>那栈的空间是由谁来决定的呢？系统能否判断栈是否已满呢？</p>\n<p>并不能，当需要使用栈的时候，我们需要声明一段内存空间作为栈段，我们只能人为的避免造成栈满，而不能寄希望于操作系统。</p>\n<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><h3 id=\"1-伪指令与指令\"><a href=\"#1-伪指令与指令\" class=\"headerlink\" title=\"1. 伪指令与指令\"></a>1. 伪指令与指令</h3><p>程序是指令的集合，每一条指令都对应CPU的操作，但仅有指令是不够的，指令不能告诉编译器，程序什么时候结束，也不能告诉编译器，数据段存储在哪段内存空间，代码段又存储在哪段内存空间。所以需要有一种能被编译器所识别的，用于定义程序结构化的语言。这就是伪指令了。</p>\n<p>伪指令是用于告诉汇编程序如何进行<strong>汇编</strong>的指令。它既不控制机器的操作也不被汇编成机器代码，只能为汇编器所识别并指导汇编程序如何进行。 将相对于程序或相对于寄存器的地址载入寄存器中。</p>\n<h3 id=\"2-常用指令\"><a href=\"#2-常用指令\" class=\"headerlink\" title=\"2 .常用指令\"></a>2 .常用指令</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th><strong>语法</strong></th>\n<th><strong>功能</strong></th>\n<th align=\"center\"><strong>案例</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>mov</td>\n<td>数据传送指令</td>\n<td align=\"center\">mov[0],cs</td>\n<td>将寄存器CS中的内容传送到偏移地址为0的内存单元中</td>\n<td>符合反对称</td>\n</tr>\n<tr>\n<td>2</td>\n<td>add/sub</td>\n<td>加、减指令</td>\n<td align=\"center\">sub ax,bx</td>\n<td>将ax寄存器中的内容减去bx寄存器中的内容的结果存储在ax中</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>push</td>\n<td>入栈</td>\n<td align=\"center\">push ax</td>\n<td>分两步，首先栈顶指针偏移，其次将ax寄存器中的内容入栈</td>\n<td>段地址从ds中取得</td>\n</tr>\n<tr>\n<td>4</td>\n<td>pop</td>\n<td>出栈</td>\n<td align=\"center\">pop ax</td>\n<td>分两步，首先将栈顶指针指向的内容赋给ax寄存器，然后栈顶指针偏移</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>loop 标号</td>\n<td>跳转至标号处</td>\n<td align=\"center\">loop continue</td>\n<td>CPU执行loop指令时，进行两步操作：首先CX递减，然后判断CX中的值，若不为0，则跳转标号处，若为0，则向下执行</td>\n<td>CX专用于存放循环次数</td>\n</tr>\n<tr>\n<td>6</td>\n<td>and</td>\n<td>逻辑与</td>\n<td align=\"center\">and      al,01100011B</td>\n<td>按位进行与运算</td>\n<td>常用于位清除</td>\n</tr>\n<tr>\n<td>7</td>\n<td>or</td>\n<td>逻辑或</td>\n<td align=\"center\">or al,01100011B</td>\n<td>按位进行或运算</td>\n<td>常用于位填充</td>\n</tr>\n<tr>\n<td>8</td>\n<td>div</td>\n<td>除法</td>\n<td align=\"center\">div byte ptr ds:[0]</td>\n<td>做除法操作时，除数有8位和16位两种，存放在在一个reg/内存单元中。被除数默认放在AX或者DX和AX中，如果除数为8位，被除数则为<strong>16位</strong>，默认在<strong>AX</strong>中存放；如果除数为16位，被除数为<strong>32位</strong>，在<strong>DX和AX</strong>中存放，D<strong>X存放高16位，AX存放低16位</strong>。结果：如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数；如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数，</td>\n<td>进行除法操作前，首先要进行除数和被除数的设置</td>\n</tr>\n<tr>\n<td>9</td>\n<td>jmp</td>\n<td>无条件转移指令</td>\n<td align=\"center\">jmp short s</td>\n<td><strong>段内短位移</strong>，转到标号s处执行指令。</td>\n<td>jmp指令应该包含两种信息：转移的<strong>目的地址</strong>与转移的<strong>距离</strong></td>\n</tr>\n<tr>\n<td>10</td>\n<td></td>\n<td></td>\n<td align=\"center\">jmp far ptr s</td>\n<td><strong>段间转移</strong>，使用S的段地址和偏移地址修改CS和IP</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td></td>\n<td></td>\n<td align=\"center\">jmp AX</td>\n<td><strong>段内偏移</strong>，将寄存器AX中的内容赋给IP</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td></td>\n<td></td>\n<td align=\"center\">jmp word ptr ds:[0]</td>\n<td><strong>段内偏移</strong>，从内存单元的地址处开始存放一个字，即转移的目的<strong>偏移地址</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>jcxz</td>\n<td>有条件转移指令</td>\n<td align=\"center\">jcxz s</td>\n<td><strong>短位移</strong>，指令中包含转移位移，而不是目的地址。等同于 if(CX == 0) jmp short 标号</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>call</td>\n<td>转移指令</td>\n<td align=\"center\">call s</td>\n<td>不能实现短位移，执行call指令，执行两步操作：push IP ， jmp  near ptr 标号</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>ret</td>\n<td>复原指令</td>\n<td align=\"center\">ret</td>\n<td>CPU执行ret操作时，等同于执行指令 pop IP</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>retf</td>\n<td>复原指令</td>\n<td align=\"center\">retf</td>\n<td>CPU执行retf操作时，等同于执行指令pop IP,pop CS</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>mul</td>\n<td>乘法指令</td>\n<td align=\"center\">mov ax,100 mov bx,10000 mul bx</td>\n<td>类div指令</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>adc</td>\n<td>带进位加法</td>\n<td align=\"center\">adc AX,BX</td>\n<td>等同于add AX,BX, ADD AX,CF</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>sub</td>\n<td>带借位减法</td>\n<td align=\"center\">sub AX,BX</td>\n<td>等同于sub AX,BX, sub AX,CF</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>cmp</td>\n<td>比较指令</td>\n<td align=\"center\">mov ax,8        mov bx,3      cmp ax,bx</td>\n<td>相当于减法操作，计算结果会对标志寄存器产生影响</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>je jne jb jnb ja jna</td>\n<td>根据比较结果的跳转指令</td>\n<td align=\"center\">jxx s</td>\n<td>等于/不等于/低于/不低于/大于/不大于</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>pushf  popf</td>\n<td></td>\n<td align=\"center\">pushf  popf</td>\n<td>将标志寄存器中的值压栈/出栈</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>iret</td>\n<td>复原指令</td>\n<td align=\"center\">iret</td>\n<td>等同于：pop IP，pop CS,popf</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>int</td>\n<td>中断指令</td>\n<td align=\"center\">int n</td>\n<td>这里的n表示的是中断类型码。CPU执行int n指令，执行过程：首先取中断类型码n，然后标志寄存器入栈，接着CS，IP入栈。最后跳转执行</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>shl</td>\n<td>逻辑左移指令</td>\n<td align=\"center\">shl al,1</td>\n<td>将al中的数据逻辑左移1位，最后移出的1位写入CF，最低位用0补充</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>shr</td>\n<td>逻辑右移指令</td>\n<td align=\"center\">shr al,1</td>\n<td>将al中的数据逻辑右移1位，最后移出的1位写入CF，最高位用0补充</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"3-常用的伪指令\"><a href=\"#3-常用的伪指令\" class=\"headerlink\" title=\"3.常用的伪指令\"></a>3.常用的伪指令</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n<th>案例</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dd(double word)</td>\n<td>定义双字型数据</td>\n<td>dd 12345</td>\n<td>定义了占2个字的数据12345</td>\n<td></td>\n</tr>\n<tr>\n<td>db(define byte)</td>\n<td>定义字节型数据</td>\n<td>db 1</td>\n<td>定义了占1个字节的数据1</td>\n<td></td>\n</tr>\n<tr>\n<td>dw(define word)</td>\n<td>定义字型数据</td>\n<td>dw 100</td>\n<td>定义了占1个字的数据100</td>\n<td></td>\n</tr>\n<tr>\n<td>dup</td>\n<td>用于进行数据的重复</td>\n<td>db 3 dup (0,1,)</td>\n<td>定义了6个字节数据，分别是0,1,0,1,0,1</td>\n<td></td>\n</tr>\n<tr>\n<td>offset</td>\n<td>取得标号的偏移地址</td>\n<td>mov si,offset s</td>\n<td>将标号s的偏移地址赋给si</td>\n<td></td>\n</tr>\n<tr>\n<td>seg</td>\n<td>回送变量或者标号的段地址</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 更多的可参考<a href=\"http://blog.sina.com.cn/s/blog_4a92ce12010006m2.html\">http://blog.sina.com.cn/s/blog_4a92ce12010006m2.html</a></li>\n</ul>\n<h3 id=\"4-以学促用\"><a href=\"#4-以学促用\" class=\"headerlink\" title=\"4. 以学促用\"></a>4. 以学促用</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><blockquote>\n<p>将实验七中的Power idea 公司的数据，按照图10.2所下图屏幕中显示出来</p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201112151602560.png\" alt=\"image-20201112151602560\"></p>\n<h4 id=\"代码与注释\"><a href=\"#代码与注释\" class=\"headerlink\" title=\"代码与注释\"></a>代码与注释</h4><pre class=\"line-numbers language-ASM\" data-language=\"ASM\"><code class=\"language-ASM\">assume cs:codesg\n;将整个data段看作是一个数组，长度一共为\n;21*4+21*4+2*21&#x3D;168+42&#x3D;210字节\ndata segment\n    db &#39;1975&#39;, &#39;1976&#39;, &#39;1977&#39;, &#39;1978&#39;, &#39;1979&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;, &#39;1983&#39;\n    db &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39;\n    db &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39;\n    ;长度为84的数组，一个字符一个字节：4X21\n\n    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514\n    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000\n    \n    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226\n    dw 11542, 14430, 15257, 17800\n\ndata ends\n\n;ax+210&#x2F;16向上取整，即ax+14h\n;对于ds，偏移量为16*14&#x3D;224\ntable segment\n    db 21 dup(&#39;year summ ne ?? &#39;)\ntable ends\n\nshow segment\n    db 100 dup(0)\nshow ends\n\ntemp segment\n    dw 10 dup(0)\ntemp ends\n\ncodesg segment\nstart:\t  \tmov ax, data\n\t\t\tmov ds, ax \n\t\t\tmov bx, table\n\t\t\tmov es, bx  \n\t\t\tmov bx, 0   ;定位结构体数组元素\n\t\t\tmov di, 0   ;定位data中的4字节数据\n\t\t\tmov si, 0   ;定位data中的2字节数据\n\t\t\tmov cx, 15h\ns0:\t\t\t;转移年份\n\t\t\tmov ax, ds:[di]\n\t\t\tmov es:[bx], ax\n\t\t\tmov ax, ds:[di+2]\n\t\t\tmov es:[bx+2], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+4], 32\n\n\t\t\t;转移收入\n\t\t\t;作为被除数\n\t\t\tmov ax, ds:[di+84];\n\t\t\tmov es:[bx+5], ax\n\t\t\tmov ax, ds:[di+86]\n\t\t\tmov es:[bx+7], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+9], 32\n\t\n\t\t\t;转移雇员数量\n\t\t\tmov ax, ds:[si+168]\n\t\t\tmov es:[bx+10], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+12], 32\n\t\n\t\t\t;计算人均收入，并转移到table中\n\t\t\tmov ax, es:[bx+5]   ;低16位\n\t\t\tmov dx, es:[bx+7]   ;高16位\n\t\t\tdiv word ptr es:[bx+10]\n\t\t\tmov es:[bx+13], ax  ;商默认存放在ax中 \n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+15], 32\n\t\t\t;操作完成，bx加16，di加2\n\t\t\tadd bx, 16  \n\t\t\tadd di, 4\n\t\t\tadd si, 2\n\t\t\tloop s0\n\n;s0循环的作用主要是将数据存储到table段中\n;而在s1循环中，先把table段中的数据转化为字符串，转储到\n;show段中，然后再在s2循环中调用show_str子程序来将这些字符串一行一行地\n;显示到屏幕上\n\t\t\tmov ax, table\n\t\t\tmov ds, ax\n\t\t\tmov ax, show\n\t\t\tmov es, ax\n\t\t\tmov dx, 0\n\t\t\tmov dh, 4\n\t\t\tmov bx, 0\n\t\t\tmov cx, 15h\ns1:\t\t\tmov di, 0\n\t\t\t;这里的di作为table数据段的指针\n\t\t\tpush ds\n\t\t\tpush es\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\t;保存行列信息，在调用show_str时会用到\n\t\t\t;转储年份\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tadd di, 2\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tmov byte ptr es:[di+4], 0\n\t\t\t;转储收入\n\t\t\tmov di, 5\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov dx, ds:[bx+di+2]\n\t\t\tcall dtoc \n\t\t\t;转储人数\n\t\t\tmov ax, ds:[bx+10]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc \n\t\t\t;转储人均收入\n\t\t\tmov ax, ds:[bx+13]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc\n\t\t\t;以上就是table段中的一行转换为ASCII码值的处理过程\n\t\t\t\n\n\t\t\t;下面开始显示过程，此过程需要循环四次\n\t\t\tpop dx\t\t\t\n\t\t\tmov di, 0\n\t\t\t;这里的di作为待输出数据段的指针\n\t\t\tmov cx, 4\n\ns2:\t\t\tmov si, 0\n\t\t\tcall show_str\n\t\t\tadd dl, 20\n\t\t\t;把列错开\n\t\t\tloop s2\n\t\t\tmov dl, 0\n\t\t\tadd dh, 1\n\t\t\tadd bx, 16\n\t\t\tpop cx\n\t\t\tpop es\n\t\t\tpop ds\n\t\t\tloop s1\n\t\t\t\n\n\t\t\tmov ax, 4c00h\n\t\t\tint 21h\n\ndtoc:\t\t;该子程序用于将数值型的数字转换为字符串\n\t\t\t;十进制数值转换为ASCII码值，转换关系为：ascii&#x3D;10进制+30H\n\t\t\t;要想将一个十进制的整数拆分成一个一个\n\t\t\t\n\n\t\t\t的数值，那我们需要让这个数\n\t\t\t;除以10，然后将得到的结果依次入栈，除完之后再依次出栈，即可得到由高位到低位\n\t\t\t;的所有数值，之后将这些值加上30H，即得到其对应的ASCII码值，然后将这些\n\t\t\t;ASCII码值存放到一个数据段中，调用show_str函数，来在屏幕上显示这些数值\n\t\t\t;为了存储转换后的ASCII码值，我们需要新开辟一个数据段\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush ds \n\t\t\tpush ax\n\t\t\tpush si\n\t\t\tpush es\n\n  \t\t\tmov bx, 0\n\t\t\t;记录十进制数据的位数\nsplit:\t\tmov cx, 0ah\n\t\t\t;cx存放除数  \n\t\t\tcall divdw\n\t\t\t\n\n\t\t\t;如果被除数大于2550，al是无法存放商的，会造成溢出，因此，我们需要调用本实验中第二个程序\n\t\t\t;专门用于解决除法溢出问题的程序\n\t\t\t;此程序返回运算后的商和余数，分别保存在ax和cx中\n\n \t\t\tpush cx\n\t\t\t;余数入栈\n\t\t\tinc bx\n\t\t\t;当循环终止的时候可以进行弹栈存储操作了，但是我们需要一个标记，来标识我们需要\n\t\t\t;弹出多少次，我们使用bx来进行存储\n\t\t\tmov cx, ax\n\t\t\tadd cx, dx\n\t\t\t;ax中的值在下一次运算中一定会用到，dx中的值也有可能会用到（当被除数很大时）\n\t\t\t;此时可以临时保存数据的只有cx了，因此我们直接将运算结果放到cx中\n\t\t\t;一举两得\n\t\t\t;判断条件是商&#x3D;&#x3D;0，因此我么需要高16位和低16位全都为0\n\t\t\tjcxz ok1\n\t\t\t;处理过程是需要循环的，循环结束的条件是商&#x3D;&#x3D;0 \n\t\t\t;我们只需要将执行jcxz指令即可，当cx的值位0的时候，它会自动跳转到ok1循环的\n\t\t\tjmp short split \nok1:\t\tpop ax\n\t\t\tadd al, 30h\n\t\t\tmov byte ptr es:[di], al\n\t\t\tinc di\n\t\t\tdec bx\n\t\t\tmov cx, bx\n\t\t\tjcxz last\n\t\t\tjmp short ok1\n\nlast:\t\t;最后一步，在数据的ASCII数据形式的最后加上一个0\n\t\t\tmov ah, 0\n\t\t\tmov byte ptr es:[di], ah \n\t\t\tinc di\n\n\t\t\tpop es\n\t\t\tpop si\n\t\t\tpop ax \n\t\t\tpop ds\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tret\n\ndivdw:\t\tpush ds\n\t\t\tpush dx\n\t\t\tpush cx\n\t\t\tpush bx\n\t\t\tpush ax \n\n\t\t\tmov ax, temp\n\t\t\tmov ds, ax \n\t\t\tmov ax, dx \n\t\t\tmov dx, 0 \n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;根据公式，使用被除数高位除以除数得到的商×65536\n\t\t\t;*65536等价于在低位加16个0，因此操作就会变得非常简单\n\t\t\t;使用被除数高位除以除数得到的余数×65536+被除数的低位，再将得到的结果除以除数\n\t\t\t;两者的结果相加，即可得到32位&#x2F;16位的无溢出结果\n\t\t\tpush dx\n\t\t\t;使用栈临时保存余数\n\t\t\tmov dx, ax\n\t\t\tmov ax, 0\n\t\t\tmov ds:[0], ax\n\t\t\tmov ds:[2], dx\n\t\t\tpop dx\n\t\t\t;弹出余数，作为右操作数中被除数的高16位\n\t\t\tpop ax\n\t\t\t;得到被除数的低16位\n\t\t\tpush ax\n\t\t\t;恢复栈顶数据，避免对主程序造成干扰 \n\t\t\t;将右操作数[]中的左操作数的低16位和被除数的低16位相加\n\t\t\t;但是右操作数[]中的左操作数的低16位一定是全0的，因此我们可以省略这一步\n\t\t\t;直接执行pop ax，将被除数的低16位作为右操作数的低16位\n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;由于左操作数的低16位一定是全0，所以不必与其相加，直接将\n\t\t\t;右操作数的低16位存储到ds:[0]内存单元即可\n\t\t\tmov ds:[0], ax\n\t\t\t;商的低16位放到ds:[0]单元中\n\t\t\tmov ds:[4], dx  \n\t\t\t;余数放到ds:[4]单元中\n\t\t\t;ds:[2]中一直保存的都是商的高16位，且没有被更改过，因此无须任何操作\n\t\n\t\t\tpop ax\n\t\t\tpop bx\n\t\t\tpop cx\n\t\t\tpop dx\n\t\t\tmov ax, ds:[0]\n\t\t\t;ax保存商的低16位\n\t\t\tmov dx, ds:[2]\n\t\t\t;dx保存商的高16位\n\t\t\tmov cx, ds:[4]\n\t\t\t;cx保存余数  \n\t\t\tpop ds\n\t\t\t;之所以要在pop ds之前将数据转移，是因为子程序divdw调用前，ds已经被使用\n\t\t\t;指向的是其他的段，如果不在pop之前转移数据，那么div段的数据就无法获取了\n\t\t\tret\t \n\nshow_str:\tpush ax\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush es \n\t\t\tpush ds\n\t\t\t;根据上节中的框架，为了不让子程序干扰主程序中寄存器的值，将所有子程序会用到的寄存器进行压栈\n\t\t\tmov ax, 0b800h\n\t\t\tmov es, ax\n\t\t\t;颜色区的段地址\n\t\t\tmov ax, show\n\t\t\tmov ds, ax\n\t\t\t;要读入的数据区的段地址\n\t\t\tmov al, 160 \n\t\t\tmul dh\n\t\t\t;每行占160个字节，乘以行数\n\t\t\tpush ax\n\t\t\t;将行计算的结果存储到栈中\n\t\t\tmov al, 2\n\t\t\tmul dl\n\t\t\t;每列占2个字节，乘以列数\n\t\t\tpop bx\n\t\t\t;将上次运算的结果（160×行数）的值转移到bx中\n\t\t\tadd bx, ax  ;此时的ax值为（2×列数）\n\t\t\t;将两者相加，最终结果保存到bx中\n\t\t\tmov dl, 130\n\t\t\t;显示颜色为绿色\nchange:\t\tmov cl, ds:[di]\n\t\t\tinc di \n\t\t\tmov ch, 0\n\t\t\tjcxz ok\n\t\t\tmov ch, dl\n\t\t\tmov es:[bx+si], cx\n\t\t\tadd si, 2 \n\t\t\tjmp short change\n\nok:\t\t\tpop ds \n\t\t\tpop es\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tpop ax\n\t\t\tret\n\ncodesg ends\nend start\n\ncodesg ends\nend start\n\ncodesg ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><h3 id=\"1-分类\"><a href=\"#1-分类\" class=\"headerlink\" title=\"1. 分类\"></a>1. 分类</h3><p>所谓<strong>中断</strong>，指的是CPU不再接着<strong>刚执行完的指令</strong>往下执行，而是转而处理由CPU内部或者外部产生的一种<strong>特殊信息</strong>。这种特殊信息我们称之为<strong>中断信息</strong>。中断信息要求CPU马上进行某种处理，并对所要进行的处理提供<strong>必备参数</strong>的通知信息。</p>\n<p>中断信息可以来自外部，也可以来自内部。</p>\n<p>我们通常将来自内部的中断称为<strong>异常</strong>，而把来自外部的中断称为<strong>中断</strong>。</p>\n<h3 id=\"2-机制\"><a href=\"#2-机制\" class=\"headerlink\" title=\"2. 机制\"></a>2. 机制</h3><h4 id=\"内中断\"><a href=\"#内中断\" class=\"headerlink\" title=\"内中断\"></a>内中断</h4><p>对于8086CPU来说，当CPU内部有下面的情况发生时，将产生相应的中断信息——</p>\n<ol>\n<li><strong>除法错误</strong>。如执行除法指令产生的除法溢出</li>\n<li><strong>单步执行</strong></li>\n<li>执行<strong>into指令</strong></li>\n<li>执行<strong>int指令</strong></li>\n</ol>\n<p>那么CPU接收到中断信息以后，会做出怎样的响应呢?</p>\n<p>CPU首先会判断中断信息的来源，因而中断信息中必须包含有能够识别中断来源的编码，这种编码就是<strong>中断类型码</strong>。</p>\n<p>CPU收到中断信息后，根据中断类型码会触发特定的<strong>中断处理程序</strong>，而要定位一段程序，就需要知道这段程序的<strong>入口地址</strong>。显然中断信息和其处理程序入口地址之间存在着某种<strong>联系</strong>。</p>\n<p>这种联系就是中断向量表。CPU可以通过8位的中断类型码通过中断向量表找到中断处理程序的入口地址。</p>\n<p>中断向量表，就是中断向量的列表。我们通常将具有大小和方向两个性质的几何对象称为<strong>向量</strong>，这里的中断向量<strong>指的就是</strong>中断处理程序的入口地址。</p>\n<p>中断向量表在<strong>内存</strong>中保存，其中存放了256个中断源所对应中断处理程序的入口，对于8086CPU来说，中断向量表<strong>指定</strong>放在内存地址0处，从内存<strong>0000:0000</strong>到<strong>0000:03FF</strong>的1024个单元中存放着中断向量表。</p>\n<p>那么在中断向量表中，一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU来说，这个入口地址包括段地址和偏移地址，所以一个表项占2个字，高地址存放段地址，低地址存放偏移地址。存储<strong>N号中断源</strong>所对应的中断处理程序的入口的<strong>段地址</strong>和<strong>偏移地址</strong>的内存单元地址分别是：<strong>4N</strong>，<strong>4N+2</strong></p>\n<p>有一个问题需要考虑：CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令，所以在中断过程中，在设置CS:IP之前，还要将原来的CS:IP值保存起来。</p>\n<p>下面我们来概括一下中断过程的机制——</p>\n<blockquote>\n<ol>\n<li>从中断信息中取得中断类型码</li>\n<li>标志寄存器中的值入栈</li>\n<li>设置标志寄存器TF和IF的值为0</li>\n<li>CS，IP的内容入栈</li>\n<li>从内存单元为中断类型码×4和中断类型码*4+2的两个字单元中读取中断处理程序的入口设置IP和CS</li>\n</ol>\n</blockquote>\n<h2 id=\"端口与BIOS读写\"><a href=\"#端口与BIOS读写\" class=\"headerlink\" title=\"端口与BIOS读写\"></a>端口与BIOS读写</h2><p>待更新</p>\n<hr>\n<p>参考目录</p>\n<ol>\n<li>王燕老师的《汇编语言》，如果想简单了解下汇编语言的小伙伴，入手这本书就对啦。</li>\n</ol>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h3 id=\"1-为什么要学习汇编语言？\"><a href=\"#1-为什么要学习汇编语言？\" class=\"headerlink\" title=\"1. 为什么要学习汇编语言？\"></a>1. 为什么要学习汇编语言？</h3><p>编程语言发展到如今，<strong>高级语言</strong>大行其道，他们通常被标榜为学习成本低。但由于高级语言不是直接调用<strong>操作系统</strong>，因而<strong>执行效率</strong>相对低一些。</p>\n<p>比如java语言，java源文件首先被编译，然后经过<strong>JVM</strong>的连接，最终执行得到运行于某平台的<strong>机器码</strong>。也就是说最终被计算机执行的是机器码。</p>\n<p>但机器码是不易于人理解的，虽说大道至简，在计算机的世界里，<strong>0,1</strong>才是王道。但计算机的模型通过0,1是很难窥见的，因而我们需要一种即易于人理解，且能够了解计算机执行机制的语言，这便是——<strong>汇编语言</strong>。</p>\n<h4 id=\"C语言与汇编\"><a href=\"#C语言与汇编\" class=\"headerlink\" title=\"C语言与汇编\"></a>C语言与汇编</h4><p>直观的看，操作系统的百分之九十代码是用C语言写的，数据库等软件同样是使用C语言编写的。也就是说，C语言执行效率高，适合用于描述底层的东西。</p>\n<p>我们可以把<strong>工作技能</strong>比作裁缝做成的<strong>衣服</strong>，java是衬衫，C++是长裤，但只会做衬衫的裁缝可不是一个好裁缝，裁缝铺需要的是，根据顾客的要求，<code>不管什么服装都可以做的好裁缝</code>。</p>\n<p>但这可不容易，我们需要了解不同类型衣服的共同之处，而衣服都是由<strong>裁缝机</strong>做成的，那么裁缝机是什么样，也会一定程度决定做成的衣服是什么样(<code>PS:这里我们不讨论先有鸡还是先有蛋的问题</code>)。</p>\n<p>这就如同语言，语言最终是去驱使硬件工作的，硬件也会反过来决定语言的特性，硬件的工作状态是高，低电平，对应计算机语言的0和1，所以哪种语言能够更好的解释0和1，而又为人所理解，那就会最先被衍生出来。</p>\n<p>这就是大家心心念念的C语言了，C语言向上沟通众多高级语言，无往不利，向下连通”取指执行”的圣经。</p>\n<p>而C语言要描述0和1，可不是直接编译那么简单，它要首先编辑为汇编语言，最终被连接执行为机器语言。</p>\n<h3 id=\"2-汇编语言的定义\"><a href=\"#2-汇编语言的定义\" class=\"headerlink\" title=\"2 . 汇编语言的定义\"></a>2 . 汇编语言的定义</h3><blockquote>\n<p>汇编语言是二进制指令的文本形式</p>\n</blockquote>\n<h3 id=\"3-学习汇编的要求\"><a href=\"#3-学习汇编的要求\" class=\"headerlink\" title=\"3 . 学习汇编的要求\"></a>3 . 学习汇编的要求</h3><p>通过使用<strong>汇编指令</strong>对<strong>寄存器</strong>和<strong>内存</strong>的操作来深刻理解<strong>计算机执行指令</strong>的机制。</p>\n<p>[^undefined]: 注 ： 我们这里的汇编专指8086CPU的汇编语言</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"1-为什么要使用寄存器\"><a href=\"#1-为什么要使用寄存器\" class=\"headerlink\" title=\"1. 为什么要使用寄存器\"></a>1. 为什么要使用寄存器</h3><p>CPU本身只负责<strong>运算</strong>，不负责<strong>存储数据</strong>，数据一般都存储在<strong>内存</strong>之中，CPU要用的时候就去内存读写数据，但是CPU读写的速度<strong>远高于</strong>内存的读写速度，为了避免被拖慢，CPU都自带一级缓存和二级缓存，<strong>CPU缓存</strong>可以看作是读写速度较快的内存。</p>\n<p>但是，CPU缓存还是不够快，另外数据在缓存里面的地址是<strong>不固定</strong>的，CPU每次读写都要<strong>寻址</strong>也会拖慢速度，因此，除了缓存之外，CPU还自带了<strong>寄存器</strong>，用来存储最常用的数据。也就是说，那些最频繁读写的数据，比如循环变量，都会放在寄存器中，CPU优先读写寄存器，再由寄存器跟内存交换数据</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201103224649594.png\" alt=\"image-20201103224649594\"></p>\n<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉CPU去具体哪一个寄存器中拿数据，这样的速度是最快的，因而也称寄存器是CPU的<strong>零级缓存</strong>。</p>\n<hr>\n<h3 id=\"2-寄存器的概述\"><a href=\"#2-寄存器的概述\" class=\"headerlink\" title=\"2.寄存器的概述\"></a>2.寄存器的概述</h3><p>8086的寄存器都是16位的，可以存放两个字节的数据，也就是说它的寻址能力就只有2的16次方个字节空间，也就是64KB。</p>\n<p>通俗的将，32位，64位系统指的就是寄存器的位数。32位寄存器可以存放的数据是2的32次方，也就是4GB，换句话说，32位的系统最多能寻址的数据只有4GB。</p>\n<p>寄存器要存储数据，首先需要从内存中取出数据，而从内存中读取数据，就要知道数据在内存中存储的地址，也就是物理地址。</p>\n<h3 id=\"3-物理地址\"><a href=\"#3-物理地址\" class=\"headerlink\" title=\"3.物理地址\"></a>3.物理地址</h3><p>8086CPU有20位的地址总线，可以传送20位地址，达到1MB寻址能力，但数据总线只有16位，它只能传输16的地址，表现出来的寻址能力只有64KB，所以我们需要使用两个16位的地址来合成20位的物理地址。</p>\n<p>这两个16位的地址，一个是段地址CS，一个是偏移地址IP，采用物理地址=短地址*16+偏移地址的运算方式扩展16位到20位，换句话说，也就是逻辑左移4位。</p>\n<p>有了物理地址，我们就可以知道从哪个内存地址读取指令，那如何将取出来的指令执行呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201108221905157.png\" alt=\"image-20201108221905157\"></p>\n<p>了解了指令执行的模型，我们知道CS,IP的值是从寄存器中读取的，那寄存器是怎样存储值的呢？</p>\n<h3 id=\"4-寄存器的分类\"><a href=\"#4-寄存器的分类\" class=\"headerlink\" title=\"4.寄存器的分类\"></a>4.寄存器的分类</h3><p>从类型上说，我们存储的数据有两类，字节型和字型。</p>\n<p>而从数据类型来说，数据分为通用的数据和具有特定意义的数据，在计算时，通用的寄存器存储在通用寄存器中，而特殊的数据，比如需要保留状态的数据，会被存储在标志寄存器中。下面我们来看具体的描述——</p>\n<p>8086CPU有8个寄存器，且都是16位的，即可以存放两个字节，8个寄存器中包括4个通用寄存器，4个段寄存器。</p>\n<p>4个通用的寄存器分别是AX,BX,CX,DX,用于存放一般性的数据。而考虑到兼容，又将这四个寄存器分成了独立的8个寄存器来使用。比如取AX的低八位组成了AL寄存器，高八位组成了AH寄存器。</p>\n<p>当CPU要访问内存时，由段寄存器来提供内存单元的段地址，这些寄存器包括DS,ES,SS,CS.</p>\n<p>其中DS寄存器通常用于存放要访问数据的段地址，CS寄存器是代码段寄存器，当我们要访问栈段时，栈段的起始地址从SS寄存器中读取，偏移地址从SP寄存器中读取，ES为扩展段寄存器。</p>\n<h3 id=\"2-内存模型\"><a href=\"#2-内存模型\" class=\"headerlink\" title=\"2. 内存模型\"></a>2. 内存模型</h3><p>寄存器只能存放少量的数据，大多数时候，CPU要指挥寄存器与内存进行数据交换，所以，除了寄存器，还必须了解内存如何存储数据。</p>\n<p>当程序运行时，操作系统会为程序分配一段内存空间，用于存储程序和程序运行产生的结果。这段内存空间有一个起始地址和一个结束地址。且低位的是起始地址，高位的是结束地址。</p>\n<p>通俗的说，内存中存放的是源程序，源程序中有效的部分称为程序，而程序是由数据和指令组成的，那内存是如何区分数据和指令的呢？CS:IP指向的内存单元存放的是指令，其他的则是数据。但数据的使用频度是不同的，使用场景也是不同的，因此我们把一般性的数据存放在堆中，而把需要保存状态的数据存放在栈中，那堆栈有怎样的结构特点呢——</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>程序运行过程中，对于动态的内存占用请求，比如说新建对象，或者使用malloc命令，系统就会从预先分配好的那段内存找那个，划出一部分给用户，规则是从起始地址算起，而实际上起始地址会有一段静态数据，这里暂且忽略。</p>\n<p>这种因为用户主动请求而划分出来的内存区域，叫做heap（堆），它由起始地址开始向高位增长，Heap的一个重要特点就是不会自动消失，必须手动的释放或者通过内存垃圾回收机制来回收。</p>\n<p>除了Heap以外，其他的内存占用叫做Stack(栈)，简单说，栈是函数运行时被临时使用的内存空间。</p>\n<p>请看下面的例子——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当系统开始执行main函数时，会为其在内存中建立一个帧，这个数据帧中会存放main函数中声明的内部变量a,b.而当程序执行到调用add函数时，这时就需要为这个函数也建立一个帧，用来存储它的内部变量。一般来说，调用了多少层的帧，就有多少个栈，等到add函数执行结束，它的帧就会被回收，程序再次回到main函数中断的地方，继续往下执行，系统使用这种机制，实现了函数的层层调用。</p>\n<p>所有的帧，都存放在栈中，生成新的帧，叫做入栈，英文是push.将栈回收，叫做出栈,英文是pop,栈的特点就是先进后出，栈顶指针始终指向最外层的帧，帧是从栈的高地址开始存放，之后内存地址不断递减直至栈满。</p>\n<p>那栈的空间是由谁来决定的呢？系统能否判断栈是否已满呢？</p>\n<p>并不能，当需要使用栈的时候，我们需要声明一段内存空间作为栈段，我们只能人为的避免造成栈满，而不能寄希望于操作系统。</p>\n<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><h3 id=\"1-伪指令与指令\"><a href=\"#1-伪指令与指令\" class=\"headerlink\" title=\"1. 伪指令与指令\"></a>1. 伪指令与指令</h3><p>程序是指令的集合，每一条指令都对应CPU的操作，但仅有指令是不够的，指令不能告诉编译器，程序什么时候结束，也不能告诉编译器，数据段存储在哪段内存空间，代码段又存储在哪段内存空间。所以需要有一种能被编译器所识别的，用于定义程序结构化的语言。这就是伪指令了。</p>\n<p>伪指令是用于告诉汇编程序如何进行<strong>汇编</strong>的指令。它既不控制机器的操作也不被汇编成机器代码，只能为汇编器所识别并指导汇编程序如何进行。 将相对于程序或相对于寄存器的地址载入寄存器中。</p>\n<h3 id=\"2-常用指令\"><a href=\"#2-常用指令\" class=\"headerlink\" title=\"2 .常用指令\"></a>2 .常用指令</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th><strong>语法</strong></th>\n<th><strong>功能</strong></th>\n<th align=\"center\"><strong>案例</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>mov</td>\n<td>数据传送指令</td>\n<td align=\"center\">mov[0],cs</td>\n<td>将寄存器CS中的内容传送到偏移地址为0的内存单元中</td>\n<td>符合反对称</td>\n</tr>\n<tr>\n<td>2</td>\n<td>add/sub</td>\n<td>加、减指令</td>\n<td align=\"center\">sub ax,bx</td>\n<td>将ax寄存器中的内容减去bx寄存器中的内容的结果存储在ax中</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>push</td>\n<td>入栈</td>\n<td align=\"center\">push ax</td>\n<td>分两步，首先栈顶指针偏移，其次将ax寄存器中的内容入栈</td>\n<td>段地址从ds中取得</td>\n</tr>\n<tr>\n<td>4</td>\n<td>pop</td>\n<td>出栈</td>\n<td align=\"center\">pop ax</td>\n<td>分两步，首先将栈顶指针指向的内容赋给ax寄存器，然后栈顶指针偏移</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>loop 标号</td>\n<td>跳转至标号处</td>\n<td align=\"center\">loop continue</td>\n<td>CPU执行loop指令时，进行两步操作：首先CX递减，然后判断CX中的值，若不为0，则跳转标号处，若为0，则向下执行</td>\n<td>CX专用于存放循环次数</td>\n</tr>\n<tr>\n<td>6</td>\n<td>and</td>\n<td>逻辑与</td>\n<td align=\"center\">and      al,01100011B</td>\n<td>按位进行与运算</td>\n<td>常用于位清除</td>\n</tr>\n<tr>\n<td>7</td>\n<td>or</td>\n<td>逻辑或</td>\n<td align=\"center\">or al,01100011B</td>\n<td>按位进行或运算</td>\n<td>常用于位填充</td>\n</tr>\n<tr>\n<td>8</td>\n<td>div</td>\n<td>除法</td>\n<td align=\"center\">div byte ptr ds:[0]</td>\n<td>做除法操作时，除数有8位和16位两种，存放在在一个reg/内存单元中。被除数默认放在AX或者DX和AX中，如果除数为8位，被除数则为<strong>16位</strong>，默认在<strong>AX</strong>中存放；如果除数为16位，被除数为<strong>32位</strong>，在<strong>DX和AX</strong>中存放，D<strong>X存放高16位，AX存放低16位</strong>。结果：如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数；如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数，</td>\n<td>进行除法操作前，首先要进行除数和被除数的设置</td>\n</tr>\n<tr>\n<td>9</td>\n<td>jmp</td>\n<td>无条件转移指令</td>\n<td align=\"center\">jmp short s</td>\n<td><strong>段内短位移</strong>，转到标号s处执行指令。</td>\n<td>jmp指令应该包含两种信息：转移的<strong>目的地址</strong>与转移的<strong>距离</strong></td>\n</tr>\n<tr>\n<td>10</td>\n<td></td>\n<td></td>\n<td align=\"center\">jmp far ptr s</td>\n<td><strong>段间转移</strong>，使用S的段地址和偏移地址修改CS和IP</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td></td>\n<td></td>\n<td align=\"center\">jmp AX</td>\n<td><strong>段内偏移</strong>，将寄存器AX中的内容赋给IP</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td></td>\n<td></td>\n<td align=\"center\">jmp word ptr ds:[0]</td>\n<td><strong>段内偏移</strong>，从内存单元的地址处开始存放一个字，即转移的目的<strong>偏移地址</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>jcxz</td>\n<td>有条件转移指令</td>\n<td align=\"center\">jcxz s</td>\n<td><strong>短位移</strong>，指令中包含转移位移，而不是目的地址。等同于 if(CX == 0) jmp short 标号</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>call</td>\n<td>转移指令</td>\n<td align=\"center\">call s</td>\n<td>不能实现短位移，执行call指令，执行两步操作：push IP ， jmp  near ptr 标号</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>ret</td>\n<td>复原指令</td>\n<td align=\"center\">ret</td>\n<td>CPU执行ret操作时，等同于执行指令 pop IP</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>retf</td>\n<td>复原指令</td>\n<td align=\"center\">retf</td>\n<td>CPU执行retf操作时，等同于执行指令pop IP,pop CS</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>mul</td>\n<td>乘法指令</td>\n<td align=\"center\">mov ax,100 mov bx,10000 mul bx</td>\n<td>类div指令</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>adc</td>\n<td>带进位加法</td>\n<td align=\"center\">adc AX,BX</td>\n<td>等同于add AX,BX, ADD AX,CF</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>sub</td>\n<td>带借位减法</td>\n<td align=\"center\">sub AX,BX</td>\n<td>等同于sub AX,BX, sub AX,CF</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>cmp</td>\n<td>比较指令</td>\n<td align=\"center\">mov ax,8        mov bx,3      cmp ax,bx</td>\n<td>相当于减法操作，计算结果会对标志寄存器产生影响</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>je jne jb jnb ja jna</td>\n<td>根据比较结果的跳转指令</td>\n<td align=\"center\">jxx s</td>\n<td>等于/不等于/低于/不低于/大于/不大于</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>pushf  popf</td>\n<td></td>\n<td align=\"center\">pushf  popf</td>\n<td>将标志寄存器中的值压栈/出栈</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>iret</td>\n<td>复原指令</td>\n<td align=\"center\">iret</td>\n<td>等同于：pop IP，pop CS,popf</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>int</td>\n<td>中断指令</td>\n<td align=\"center\">int n</td>\n<td>这里的n表示的是中断类型码。CPU执行int n指令，执行过程：首先取中断类型码n，然后标志寄存器入栈，接着CS，IP入栈。最后跳转执行</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>shl</td>\n<td>逻辑左移指令</td>\n<td align=\"center\">shl al,1</td>\n<td>将al中的数据逻辑左移1位，最后移出的1位写入CF，最低位用0补充</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>shr</td>\n<td>逻辑右移指令</td>\n<td align=\"center\">shr al,1</td>\n<td>将al中的数据逻辑右移1位，最后移出的1位写入CF，最高位用0补充</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"3-常用的伪指令\"><a href=\"#3-常用的伪指令\" class=\"headerlink\" title=\"3.常用的伪指令\"></a>3.常用的伪指令</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n<th>案例</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dd(double word)</td>\n<td>定义双字型数据</td>\n<td>dd 12345</td>\n<td>定义了占2个字的数据12345</td>\n<td></td>\n</tr>\n<tr>\n<td>db(define byte)</td>\n<td>定义字节型数据</td>\n<td>db 1</td>\n<td>定义了占1个字节的数据1</td>\n<td></td>\n</tr>\n<tr>\n<td>dw(define word)</td>\n<td>定义字型数据</td>\n<td>dw 100</td>\n<td>定义了占1个字的数据100</td>\n<td></td>\n</tr>\n<tr>\n<td>dup</td>\n<td>用于进行数据的重复</td>\n<td>db 3 dup (0,1,)</td>\n<td>定义了6个字节数据，分别是0,1,0,1,0,1</td>\n<td></td>\n</tr>\n<tr>\n<td>offset</td>\n<td>取得标号的偏移地址</td>\n<td>mov si,offset s</td>\n<td>将标号s的偏移地址赋给si</td>\n<td></td>\n</tr>\n<tr>\n<td>seg</td>\n<td>回送变量或者标号的段地址</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 更多的可参考<a href=\"http://blog.sina.com.cn/s/blog_4a92ce12010006m2.html\">http://blog.sina.com.cn/s/blog_4a92ce12010006m2.html</a></li>\n</ul>\n<h3 id=\"4-以学促用\"><a href=\"#4-以学促用\" class=\"headerlink\" title=\"4. 以学促用\"></a>4. 以学促用</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><blockquote>\n<p>将实验七中的Power idea 公司的数据，按照图10.2所下图屏幕中显示出来</p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201112151602560.png\" alt=\"image-20201112151602560\"></p>\n<h4 id=\"代码与注释\"><a href=\"#代码与注释\" class=\"headerlink\" title=\"代码与注释\"></a>代码与注释</h4><pre class=\"line-numbers language-ASM\" data-language=\"ASM\"><code class=\"language-ASM\">assume cs:codesg\n;将整个data段看作是一个数组，长度一共为\n;21*4+21*4+2*21&#x3D;168+42&#x3D;210字节\ndata segment\n    db &#39;1975&#39;, &#39;1976&#39;, &#39;1977&#39;, &#39;1978&#39;, &#39;1979&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;, &#39;1983&#39;\n    db &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39;\n    db &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39;\n    ;长度为84的数组，一个字符一个字节：4X21\n\n    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514\n    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000\n    \n    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226\n    dw 11542, 14430, 15257, 17800\n\ndata ends\n\n;ax+210&#x2F;16向上取整，即ax+14h\n;对于ds，偏移量为16*14&#x3D;224\ntable segment\n    db 21 dup(&#39;year summ ne ?? &#39;)\ntable ends\n\nshow segment\n    db 100 dup(0)\nshow ends\n\ntemp segment\n    dw 10 dup(0)\ntemp ends\n\ncodesg segment\nstart:\t  \tmov ax, data\n\t\t\tmov ds, ax \n\t\t\tmov bx, table\n\t\t\tmov es, bx  \n\t\t\tmov bx, 0   ;定位结构体数组元素\n\t\t\tmov di, 0   ;定位data中的4字节数据\n\t\t\tmov si, 0   ;定位data中的2字节数据\n\t\t\tmov cx, 15h\ns0:\t\t\t;转移年份\n\t\t\tmov ax, ds:[di]\n\t\t\tmov es:[bx], ax\n\t\t\tmov ax, ds:[di+2]\n\t\t\tmov es:[bx+2], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+4], 32\n\n\t\t\t;转移收入\n\t\t\t;作为被除数\n\t\t\tmov ax, ds:[di+84];\n\t\t\tmov es:[bx+5], ax\n\t\t\tmov ax, ds:[di+86]\n\t\t\tmov es:[bx+7], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+9], 32\n\t\n\t\t\t;转移雇员数量\n\t\t\tmov ax, ds:[si+168]\n\t\t\tmov es:[bx+10], ax\n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+12], 32\n\t\n\t\t\t;计算人均收入，并转移到table中\n\t\t\tmov ax, es:[bx+5]   ;低16位\n\t\t\tmov dx, es:[bx+7]   ;高16位\n\t\t\tdiv word ptr es:[bx+10]\n\t\t\tmov es:[bx+13], ax  ;商默认存放在ax中 \n\t\t\t;添加空格 \n\t\t\tmov byte ptr es:[bx+15], 32\n\t\t\t;操作完成，bx加16，di加2\n\t\t\tadd bx, 16  \n\t\t\tadd di, 4\n\t\t\tadd si, 2\n\t\t\tloop s0\n\n;s0循环的作用主要是将数据存储到table段中\n;而在s1循环中，先把table段中的数据转化为字符串，转储到\n;show段中，然后再在s2循环中调用show_str子程序来将这些字符串一行一行地\n;显示到屏幕上\n\t\t\tmov ax, table\n\t\t\tmov ds, ax\n\t\t\tmov ax, show\n\t\t\tmov es, ax\n\t\t\tmov dx, 0\n\t\t\tmov dh, 4\n\t\t\tmov bx, 0\n\t\t\tmov cx, 15h\ns1:\t\t\tmov di, 0\n\t\t\t;这里的di作为table数据段的指针\n\t\t\tpush ds\n\t\t\tpush es\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\t;保存行列信息，在调用show_str时会用到\n\t\t\t;转储年份\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tadd di, 2\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov es:[di], ax\n\t\t\tmov byte ptr es:[di+4], 0\n\t\t\t;转储收入\n\t\t\tmov di, 5\n\t\t\tmov ax, ds:[bx+di]\n\t\t\tmov dx, ds:[bx+di+2]\n\t\t\tcall dtoc \n\t\t\t;转储人数\n\t\t\tmov ax, ds:[bx+10]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc \n\t\t\t;转储人均收入\n\t\t\tmov ax, ds:[bx+13]\n\t\t\tmov dx, 0\n\t\t\tcall dtoc\n\t\t\t;以上就是table段中的一行转换为ASCII码值的处理过程\n\t\t\t\n\n\t\t\t;下面开始显示过程，此过程需要循环四次\n\t\t\tpop dx\t\t\t\n\t\t\tmov di, 0\n\t\t\t;这里的di作为待输出数据段的指针\n\t\t\tmov cx, 4\n\ns2:\t\t\tmov si, 0\n\t\t\tcall show_str\n\t\t\tadd dl, 20\n\t\t\t;把列错开\n\t\t\tloop s2\n\t\t\tmov dl, 0\n\t\t\tadd dh, 1\n\t\t\tadd bx, 16\n\t\t\tpop cx\n\t\t\tpop es\n\t\t\tpop ds\n\t\t\tloop s1\n\t\t\t\n\n\t\t\tmov ax, 4c00h\n\t\t\tint 21h\n\ndtoc:\t\t;该子程序用于将数值型的数字转换为字符串\n\t\t\t;十进制数值转换为ASCII码值，转换关系为：ascii&#x3D;10进制+30H\n\t\t\t;要想将一个十进制的整数拆分成一个一个\n\t\t\t\n\n\t\t\t的数值，那我们需要让这个数\n\t\t\t;除以10，然后将得到的结果依次入栈，除完之后再依次出栈，即可得到由高位到低位\n\t\t\t;的所有数值，之后将这些值加上30H，即得到其对应的ASCII码值，然后将这些\n\t\t\t;ASCII码值存放到一个数据段中，调用show_str函数，来在屏幕上显示这些数值\n\t\t\t;为了存储转换后的ASCII码值，我们需要新开辟一个数据段\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush ds \n\t\t\tpush ax\n\t\t\tpush si\n\t\t\tpush es\n\n  \t\t\tmov bx, 0\n\t\t\t;记录十进制数据的位数\nsplit:\t\tmov cx, 0ah\n\t\t\t;cx存放除数  \n\t\t\tcall divdw\n\t\t\t\n\n\t\t\t;如果被除数大于2550，al是无法存放商的，会造成溢出，因此，我们需要调用本实验中第二个程序\n\t\t\t;专门用于解决除法溢出问题的程序\n\t\t\t;此程序返回运算后的商和余数，分别保存在ax和cx中\n\n \t\t\tpush cx\n\t\t\t;余数入栈\n\t\t\tinc bx\n\t\t\t;当循环终止的时候可以进行弹栈存储操作了，但是我们需要一个标记，来标识我们需要\n\t\t\t;弹出多少次，我们使用bx来进行存储\n\t\t\tmov cx, ax\n\t\t\tadd cx, dx\n\t\t\t;ax中的值在下一次运算中一定会用到，dx中的值也有可能会用到（当被除数很大时）\n\t\t\t;此时可以临时保存数据的只有cx了，因此我们直接将运算结果放到cx中\n\t\t\t;一举两得\n\t\t\t;判断条件是商&#x3D;&#x3D;0，因此我么需要高16位和低16位全都为0\n\t\t\tjcxz ok1\n\t\t\t;处理过程是需要循环的，循环结束的条件是商&#x3D;&#x3D;0 \n\t\t\t;我们只需要将执行jcxz指令即可，当cx的值位0的时候，它会自动跳转到ok1循环的\n\t\t\tjmp short split \nok1:\t\tpop ax\n\t\t\tadd al, 30h\n\t\t\tmov byte ptr es:[di], al\n\t\t\tinc di\n\t\t\tdec bx\n\t\t\tmov cx, bx\n\t\t\tjcxz last\n\t\t\tjmp short ok1\n\nlast:\t\t;最后一步，在数据的ASCII数据形式的最后加上一个0\n\t\t\tmov ah, 0\n\t\t\tmov byte ptr es:[di], ah \n\t\t\tinc di\n\n\t\t\tpop es\n\t\t\tpop si\n\t\t\tpop ax \n\t\t\tpop ds\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tret\n\ndivdw:\t\tpush ds\n\t\t\tpush dx\n\t\t\tpush cx\n\t\t\tpush bx\n\t\t\tpush ax \n\n\t\t\tmov ax, temp\n\t\t\tmov ds, ax \n\t\t\tmov ax, dx \n\t\t\tmov dx, 0 \n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;根据公式，使用被除数高位除以除数得到的商×65536\n\t\t\t;*65536等价于在低位加16个0，因此操作就会变得非常简单\n\t\t\t;使用被除数高位除以除数得到的余数×65536+被除数的低位，再将得到的结果除以除数\n\t\t\t;两者的结果相加，即可得到32位&#x2F;16位的无溢出结果\n\t\t\tpush dx\n\t\t\t;使用栈临时保存余数\n\t\t\tmov dx, ax\n\t\t\tmov ax, 0\n\t\t\tmov ds:[0], ax\n\t\t\tmov ds:[2], dx\n\t\t\tpop dx\n\t\t\t;弹出余数，作为右操作数中被除数的高16位\n\t\t\tpop ax\n\t\t\t;得到被除数的低16位\n\t\t\tpush ax\n\t\t\t;恢复栈顶数据，避免对主程序造成干扰 \n\t\t\t;将右操作数[]中的左操作数的低16位和被除数的低16位相加\n\t\t\t;但是右操作数[]中的左操作数的低16位一定是全0的，因此我们可以省略这一步\n\t\t\t;直接执行pop ax，将被除数的低16位作为右操作数的低16位\n\t\t\tdiv cx\n\t\t\t;ax存放商，dx存放余数\n\t\t\t;由于左操作数的低16位一定是全0，所以不必与其相加，直接将\n\t\t\t;右操作数的低16位存储到ds:[0]内存单元即可\n\t\t\tmov ds:[0], ax\n\t\t\t;商的低16位放到ds:[0]单元中\n\t\t\tmov ds:[4], dx  \n\t\t\t;余数放到ds:[4]单元中\n\t\t\t;ds:[2]中一直保存的都是商的高16位，且没有被更改过，因此无须任何操作\n\t\n\t\t\tpop ax\n\t\t\tpop bx\n\t\t\tpop cx\n\t\t\tpop dx\n\t\t\tmov ax, ds:[0]\n\t\t\t;ax保存商的低16位\n\t\t\tmov dx, ds:[2]\n\t\t\t;dx保存商的高16位\n\t\t\tmov cx, ds:[4]\n\t\t\t;cx保存余数  \n\t\t\tpop ds\n\t\t\t;之所以要在pop ds之前将数据转移，是因为子程序divdw调用前，ds已经被使用\n\t\t\t;指向的是其他的段，如果不在pop之前转移数据，那么div段的数据就无法获取了\n\t\t\tret\t \n\nshow_str:\tpush ax\n\t\t\tpush bx\n\t\t\tpush cx\n\t\t\tpush dx\n\t\t\tpush es \n\t\t\tpush ds\n\t\t\t;根据上节中的框架，为了不让子程序干扰主程序中寄存器的值，将所有子程序会用到的寄存器进行压栈\n\t\t\tmov ax, 0b800h\n\t\t\tmov es, ax\n\t\t\t;颜色区的段地址\n\t\t\tmov ax, show\n\t\t\tmov ds, ax\n\t\t\t;要读入的数据区的段地址\n\t\t\tmov al, 160 \n\t\t\tmul dh\n\t\t\t;每行占160个字节，乘以行数\n\t\t\tpush ax\n\t\t\t;将行计算的结果存储到栈中\n\t\t\tmov al, 2\n\t\t\tmul dl\n\t\t\t;每列占2个字节，乘以列数\n\t\t\tpop bx\n\t\t\t;将上次运算的结果（160×行数）的值转移到bx中\n\t\t\tadd bx, ax  ;此时的ax值为（2×列数）\n\t\t\t;将两者相加，最终结果保存到bx中\n\t\t\tmov dl, 130\n\t\t\t;显示颜色为绿色\nchange:\t\tmov cl, ds:[di]\n\t\t\tinc di \n\t\t\tmov ch, 0\n\t\t\tjcxz ok\n\t\t\tmov ch, dl\n\t\t\tmov es:[bx+si], cx\n\t\t\tadd si, 2 \n\t\t\tjmp short change\n\nok:\t\t\tpop ds \n\t\t\tpop es\n\t\t\tpop dx\n\t\t\tpop cx\n\t\t\tpop bx\n\t\t\tpop ax\n\t\t\tret\n\ncodesg ends\nend start\n\ncodesg ends\nend start\n\ncodesg ends\nend start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><h3 id=\"1-分类\"><a href=\"#1-分类\" class=\"headerlink\" title=\"1. 分类\"></a>1. 分类</h3><p>所谓<strong>中断</strong>，指的是CPU不再接着<strong>刚执行完的指令</strong>往下执行，而是转而处理由CPU内部或者外部产生的一种<strong>特殊信息</strong>。这种特殊信息我们称之为<strong>中断信息</strong>。中断信息要求CPU马上进行某种处理，并对所要进行的处理提供<strong>必备参数</strong>的通知信息。</p>\n<p>中断信息可以来自外部，也可以来自内部。</p>\n<p>我们通常将来自内部的中断称为<strong>异常</strong>，而把来自外部的中断称为<strong>中断</strong>。</p>\n<h3 id=\"2-机制\"><a href=\"#2-机制\" class=\"headerlink\" title=\"2. 机制\"></a>2. 机制</h3><h4 id=\"内中断\"><a href=\"#内中断\" class=\"headerlink\" title=\"内中断\"></a>内中断</h4><p>对于8086CPU来说，当CPU内部有下面的情况发生时，将产生相应的中断信息——</p>\n<ol>\n<li><strong>除法错误</strong>。如执行除法指令产生的除法溢出</li>\n<li><strong>单步执行</strong></li>\n<li>执行<strong>into指令</strong></li>\n<li>执行<strong>int指令</strong></li>\n</ol>\n<p>那么CPU接收到中断信息以后，会做出怎样的响应呢?</p>\n<p>CPU首先会判断中断信息的来源，因而中断信息中必须包含有能够识别中断来源的编码，这种编码就是<strong>中断类型码</strong>。</p>\n<p>CPU收到中断信息后，根据中断类型码会触发特定的<strong>中断处理程序</strong>，而要定位一段程序，就需要知道这段程序的<strong>入口地址</strong>。显然中断信息和其处理程序入口地址之间存在着某种<strong>联系</strong>。</p>\n<p>这种联系就是中断向量表。CPU可以通过8位的中断类型码通过中断向量表找到中断处理程序的入口地址。</p>\n<p>中断向量表，就是中断向量的列表。我们通常将具有大小和方向两个性质的几何对象称为<strong>向量</strong>，这里的中断向量<strong>指的就是</strong>中断处理程序的入口地址。</p>\n<p>中断向量表在<strong>内存</strong>中保存，其中存放了256个中断源所对应中断处理程序的入口，对于8086CPU来说，中断向量表<strong>指定</strong>放在内存地址0处，从内存<strong>0000:0000</strong>到<strong>0000:03FF</strong>的1024个单元中存放着中断向量表。</p>\n<p>那么在中断向量表中，一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU来说，这个入口地址包括段地址和偏移地址，所以一个表项占2个字，高地址存放段地址，低地址存放偏移地址。存储<strong>N号中断源</strong>所对应的中断处理程序的入口的<strong>段地址</strong>和<strong>偏移地址</strong>的内存单元地址分别是：<strong>4N</strong>，<strong>4N+2</strong></p>\n<p>有一个问题需要考虑：CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令，所以在中断过程中，在设置CS:IP之前，还要将原来的CS:IP值保存起来。</p>\n<p>下面我们来概括一下中断过程的机制——</p>\n<blockquote>\n<ol>\n<li>从中断信息中取得中断类型码</li>\n<li>标志寄存器中的值入栈</li>\n<li>设置标志寄存器TF和IF的值为0</li>\n<li>CS，IP的内容入栈</li>\n<li>从内存单元为中断类型码×4和中断类型码*4+2的两个字单元中读取中断处理程序的入口设置IP和CS</li>\n</ol>\n</blockquote>\n<h2 id=\"端口与BIOS读写\"><a href=\"#端口与BIOS读写\" class=\"headerlink\" title=\"端口与BIOS读写\"></a>端口与BIOS读写</h2><p>待更新</p>\n<hr>\n<p>参考目录</p>\n<ol>\n<li>王燕老师的《汇编语言》，如果想简单了解下汇编语言的小伙伴，入手这本书就对啦。</li>\n</ol>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"磁盘与文件","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T03:31:02.000Z","password":null,"summary":null,"_content":"\n# 一、磁盘与文件\n\n------\n\n## 1.生磁盘的使用\n\n生磁盘指单独的磁盘，不包括文件系统。\n\n**磁盘的使用同外设一样**，它的工作机制也是三步走：CPU向磁盘控制器中的**寄存器**读写数据，**磁盘控制器**完成真正的工作，并**向CPU发中断**信息。\n\n学习磁盘从认识磁盘开始，磁盘是长这样的——\n\n![image-20201124193703592](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124193703592.png)\n\n那磁盘是如何工作的呢？我们以**磁盘读写一个字节**为例：\n\n首先移动**磁头**，并移动**磁盘**到**磁道**上，然后旋转磁道到**扇区**，在这个过程中**磁生电**，从扇区中读出一个字节到**内存缓冲区**。\n\n同样的，如果要从内存读取一个字节到磁盘，则应该从内存缓冲区中读取字节，再把它放在相应磁道的特定扇区中。\n\n了解了表层的工作机制，接下来需要将这个过程**具象化**，也就是说要往控制器中写**柱面C，磁头H，扇区S，缓存位置**就可以读写磁盘了。\n\n那用什么写入呢？自然是**out指令**——\n\n![image-20201124194841844](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124194841844.png)\n\n到这里，操作系统已经可以运行了，但**传入的参数太多**了，每次读写都要做这么繁琐的，那能否**将这些操作封装**，我们来看第一层的抽象——\n\n### 通过盘块号读写磁盘\n\nCPU可以通过提供的盘块号来算出上面的三个参数，也就是用**一维的参数来算出三维的参数**，在计算的过程中，就需要使用到**编址**，那么怎样编址才最高效呢？考虑到我们使用文件时通常是**读取block相邻的盘块**，因而编址的设计需要使得**读取相邻的盘块比较快速**。\n\n> 磁盘访问时间=写入控制器时间+寻道时间+旋转时间+传输时间。\n\n在这个过程中，**寻道花费的时间最多**，因为它是一种移动的机械运动。\n\n所以为了节省时间，可以将相邻的盘块放在同一个扇区——\n\n![image-20201124200503945](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124200503945.png)\n\n\n\n那么问题是如何**通过C,H,S得到扇区号block**呢？\n\n![image-20201124200629352](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124200629352.png)\n\n\n\n![image-20201124201018062](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124201018062.png)\n\n因为访问磁盘的时间绝大部分是用于寻道的，因而随着**读取磁盘扇区增大**，**读写的速度会显著的提高**，但同时也会带来**空间的浪费**，表现为磁盘的碎片增多。\n\n那我们怎样**折中**呢？很抱歉，我们空间多得是，**用空间换时间**是大势所趋。\n\n而随着读写空间的增大，读写的单位也**从扇区变为了盘块**，有头有尾，不过如是。\n\n------\n\n在第二次封装之前，我们补充一点知识，也为下文埋下伏笔：\n\nlinux0.11的盘块号有多大呢？\n\n每读取一个盘块，会读取两个扇区，因此可以说盘块等于两个扇区。\n\n### 多个进程通过队列使用磁盘\n\n在上文中，我们说的是CPU分配资源的最小单元——一个进程，但实际应用中多道程序并发执行才是常态，这时就需要引入队列——\n\n![image-20201124202710472](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124202710472.png)\n\n那怎样组织磁盘访问的请求效率最高呢？我们主要考虑**平均访问延迟**和**寻道时间**，而寻求一种相对高效的解决方案，换言之就是寻求一种算法——\n\n说到调度算法，最直观的自然是FCFS。\n\n### FCFS\n\n![image-20201124225422783](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124225422783.png)\n\n我们可以观察到先来先服务的算法会导致**磁头总在长途奔袭**，而不顾它经过的可以**顺便访问**的进程。\n\n在这个基础上改进的想法是先处理离当前磁头近的进程，也就是**SSTF**——**最短寻道时间优先算法**\n\n### SSTF\n\n![image-20201124230201466](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124230201466.png)\n\n这种算法的确解决了磁头耗时的问题，但因为**程序的局部性**，进程对磁盘的**请求总会比较集中**，这会导致**边缘化的进程**即便等待了很久，也**没有得到IO资源**，也就是**饥饿**问题。\n\n所以我们再接下来的改进中既要兼顾最短寻址，也要满足雨露均沾的需要，这就引出了**电梯算法**——SCAN\n\n### SCAN\n\n既然请求有局部性，那我们首先从**请求密集**的地方开始**磁头扫描**，然后磁头沿着某一方向扫描，扫描完后折返，我们来具象化的看下——\n\n![image-20201124231412870](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124231412870.png)\n\n可以看到中间请求密集的地方仍然被扫描多次，这就好比**我要坐着正在往下的电梯去上面，这可不怎么明智**，在现实生活中，我们通常会等电梯先下去，然后我们再乘坐向上的电梯，这个算法的优化也应该如此——\n\n![image-20201124232126400](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124232126400.png)\n\n理论完了，上正菜——\n\n![image-20201124234604990](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124234604990.png)\n\n在这段代码中，首先**将请求加入到队列**中，又IO资源是临界区资源，因此用**cli(),sti()**的方式给临界区上锁，处理完请求后再返回。\n\n至此，调度算法告一段落，我们来做一总结——\n\n![image-20201124235425309](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124235425309.png)\n\n## 2.从生磁盘到文件\n\n前面提及进程通过盘块号从而算出扇区号，那**盘块号是怎样得到的**呢？就是通过**文件**。我们的核心在于了解**如何从文件获取盘块号**。\n\n不使用文件的磁盘是生磁盘，这小结我们就将这生米煮成熟饭，来看**熟磁盘的工作机制**。\n\n那如何引入文件呢？我们对盘块做进一步的抽象，就成了文件。\n\n那从用户视角来看，文件是什么？**文件是用来存储字符的**，因此不妨说**文件是字符流**。\n\n我们的问题转变为要建立**字符流到盘块集合的映射**关系，那映射如何理解呢？基于盘块号的映射又是什么呢，我们来看下面的小例子——\n\n![image-20201125092547498](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125092547498.png)\n\n我们通过映射得到了字符的位置，但这个映射的细节对用户是隐藏的，我们不妨剥茧抽丝，看看映射是通过怎样的结构来实现的？\n\n最常规的映射结构是以连续结构实现文件——\n\n![image-20201125093111022](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093111022.png)\n\n字符的位置确定了，映射建立起来了，为了方便查询，自然就形成了**FCB——文件控制块**，通过查表我们得知了对应的磁盘块：\n\n![image-20201125093355040](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093355040.png)\n\n我们再来回顾一下这个过程——\n\n`首先用户打开一个文件，然后用户操作某些字符流，这些字符流通过查FCB表对应到相应的盘块，然后根据盘块号的得到CHS，最终读写文件。`\n\n------\n\n通过顺序结构查询文件位置，本质上是通过**数组**的方式访问，数组对于词典式的静态文件访问非常友好，但假如在数组中再插入一个元素，就需要对其他元素做位置的移动，显然不方便，那这种动态的写入用怎样的结构实现呢——**链表**\n\n![image-20201125095036685](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125095036685.png)\n\n链表的结构只需要添加一个`逻辑块号`，将这个逻辑块号与物理块号`建立映射关系`，就可以实现动态的在空闲块中写入，但链表的缺点也显而易见，假如需要某个盘块号，它需要遍历之前的所有盘块号，增加了访问时间。\n\n哎，安得世间万全法，不负数组不负卿。\n\n但是吧，还真有，但这就是另一个故事了——**索引结构**\n\n索引结构在生活中很常见，书本的目录就是索引，目录下的页是连续的，符合数组的特点，而目录页是不连续的，也就是链表结构。\n\n我们`查FCB表`可以得到`索引块`，再通过索引块得到`特定盘块的索引`。它是一种连续和链式分配的有效折中。\n\n那索引如何具象表示呢？其实我们之前也提及过，也就是**inode**，即**index node。**\n\n## 3.文件使用磁盘的实现\n\n上一小节中我们完成了生磁盘的使用，而后对生磁盘进行一层层的抽象，最终用文件的形式来使用磁盘，那文件是如何使用磁盘的呢？它与生磁盘的使用有什么异同，通过文件使用磁盘的核心又是什么？\n\n------\n\n我们首先给出一个大致的脉络——\n![image-20201125105359803](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105359803.png)\n\n可见，对磁盘的读写不过是在对文件读写的基础上`显示得加了一步`：通过inode找到磁盘盘块号。\n\n这个故事从系统调用**sys_write**开始——\n\n![image-20201125105002918](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105002918.png)\n\n在这段代码中，首先通过**文件描述符fd**得到那个文件**file**，然后通过file得到**文件结构描述信息inode**，最终调用文件写入**file_write函数**。\n\n而file_write就是我们需要的那张地图：\n\n- [ ] **file_write(inode,file,buf,count)**\n\ninode也就是索引节点，从inode中我们可以得到盘块号，从file中我们可以要读写的是那一段字符串，具体的说，file中有一个读写指针fssek，fseek指向这段字符的开始地址，而参数count表示要读写多少个字符，也就是偏移，最后将这段字符写到buf这段缓冲区上去。\n\n大致的脉络有了，我们来看具体的实现——\n\n![image-20201125110645363](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125110645363.png)\n\n\n\n如果是追加字符，则首先得到文件的大小，然后指针偏移到文件末尾，最后要实现**将这段字符写入到磁盘中去**。\n\n![image-20201125111052897](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125111052897.png)\n\n首先使用文件末尾的地址除以盘块的大小得到**对应的盘块号**，然后将盘块号放入到**电梯的调度队列**中，接着得到**具体的写入位置**，或者说是在**盘块号内的偏移**。\n\n那具体的盘块号如何算的呢，这同时也是使用**文件区别于使用盘块号的核心**，如下图~\n\n\n\n![image-20201125112728570](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125112728570.png)\n\n在操作系统中，万物皆文件，我们上面提及的仅仅是一个普通文件，但如果是一个设备文件呢？\n\n文件的**框架是不变**的，**变化的只是inode**中存储的内容，对于**设备文件**来说，inode中存储有**文件的属性，类型**等——\n\n![image-20201125113249026](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125113249026.png)\n\n整个脉络已经明晰了起来，但隐隐之中还是有一点留白，我们把从文件名得到文件描述符，再通过fd得到inode的过程当做一个黑盒子来使用，至于这个黑盒子是否是潘多拉魔盒，我们会在后一节的学习中看到，至此，我们来概括的看一下文件视图的两条主线：**生磁盘与熟磁盘**——\n![image-20201125114043926](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125114043926.png)\n\n# 二、文件系统\n\n## 1.目录与文件系统\n\n在**文件的基础**上，通过**目录**把整个磁盘抽象成**文件系统**的形式，是磁盘的**第四层抽象**。\n\n而这也是最终呈现给用户的视图，在用户眼中，**磁盘就是一堆有组织的文件**。而剥茧抽丝之后，我们知道**文件系统最终会映射到一个个的盘块号**中。\n\n文件系统只是我们先入为主的从主观上得到的抽象，但实际上从文件到文件系统仍是一个**漫长的过程**。\n\n首先我们从**文件**可以很自然的想到**多文件**，那多个文件如何组织起来呢？起初多个文件自然应该是在**一层目录**的，但一层目录管理起来着实困难，所以**目录树**就应运而生了。\n\n假设将文件划分为特定目录下的不同文件，将划分后的集合再进行划分，K次划分后，每个集合中的文件数为**O(logk N)**.\n\n可以看出从多文件到目录树的**核心**是需要**引入目录**的概念，那目录是怎样实现的呢？\n\n那我们首先来看，**目录怎样使用**，我们**使用路径来定位某个文件**，更具体的说，使用路径可以得到某个文件的**FCB**。\n\n换句话说，要识别某个文件，就要得到这个文件的FCB，再对FCB的信息进行匹配，就可以确认这个文件是什么。\n\n而从路径定位文件的过程，直观的说，目录应该要有它目录下的每个文件的FCB和文件名，但是**FCB是庞大**的，将它读入内存显然是**低效**的，那只要将**需要的那个文件的FCB**加载到**内存**中，所以FCB需要被识别，因而需要一个**FCB的编号**，而这个编号需要**FCB数组**来维护。\n\n### 树状目录的完整实现\n\n![image-20201125201135235](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125201135235.png)\n\n\n\n现在目录的脉络已经**明晰**了。磁盘只需要维护**FCB数组**和**对应FCB号的数据块**即可，数据块中包含有**文件名**和**对应FCB的地址**。而对于一个**目录**来说，它会维护**目录下文件的FCB数组和数据块**。逐层循环，最终得到需要的文件。\n\n但仅仅这样是不够的的，要想一个**系统能自举**，也就是**可移植**，就需要首先做好**框架**，进一步说，就是有一个**扎实的根基**，也就是**根目录的维护**。\n\n![image-20201125203034066](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125203034066.png)\n\n\n\n尽管PPT已经很详细了，但为了加深记忆，我们再来总结一手——\n\n`引导块`：操作系统启动之后加载，即`固化的引导块`\n\n`超级块`：记录位图的空间大小等信息\n\n`i节点的位图`：记录**i节点的事务**，就相当于是动态记录i节点的信息，比如i节点的大小，位置，性质等信息\n\n`盘块位图` ：记录盘块的状态，大小，位置等,可类比计算机网络里P2P体系中的每人持有一部分数据，并使用**位图来表征数据的状态**。\n\n至此，就到了我们熟悉的总结环节了——\n\n![image-20201125204155061](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125204155061.png)\n\n## 2.目录解析代码实现\n\n在上面的流程中，仅有**目录的实现**我们是以**黑盒子**的形式展示的，现在我们来打开这个黑盒子——\n\n**目录同样是文件**，而对文件的探寻，是从**open开始**的，又**以inode作为主线**的：\n\n![image-20201125213742823](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125213742823.png)\n\n首先根据路径名得到索引，通过索引找到目录名，最终进入核心的**get_dir函数**——\n\n![image-20201125214016996](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214016996.png)\n\n在这个函数中，首先获取根目录的inode，指向路径名的指针后移。**目录的inode**是在系统初始化是就存储在**shell进程中**，而**后来创建的进程都要由shell进程创建**，自然也会**拷贝shell进程的内容**，根目录的inode得以流传下来。\n\n> 关键的流程就是首先找到根目录root，接着从路径中读取到目录项，然后从目录项的FCB中找到索引节点号inode，最终根据数据块内容再读取下一个目录。\n\n![image-20201125214627114](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214627114.png)\n\n**操作系统初始化**时，会完成**设备的挂载**，而磁盘的挂载，本质上是**超级块的读取**。\n\n![image-20201125214942682](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214942682.png)\n\n然后根据这个数组中前半部分的占用空间得到**inode的位置**，找到了inode的位置，目录这个文件就不再神秘了——\n\n![image-20201125215119581](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215119581.png)\n\n**循环读取**到叶子结点的文件，**大结局**——\n![image-20201125215235130](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215235130.png)\n\n------\n\n> 山高路远，静水深流。","source":"_posts/磁盘与文件.md","raw":"---\ntitle: 磁盘与文件\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 11:31:02\npassword:\nsummary:\ntags: 操作系统\ncategories: 计算机基础\n---\n\n# 一、磁盘与文件\n\n------\n\n## 1.生磁盘的使用\n\n生磁盘指单独的磁盘，不包括文件系统。\n\n**磁盘的使用同外设一样**，它的工作机制也是三步走：CPU向磁盘控制器中的**寄存器**读写数据，**磁盘控制器**完成真正的工作，并**向CPU发中断**信息。\n\n学习磁盘从认识磁盘开始，磁盘是长这样的——\n\n![image-20201124193703592](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124193703592.png)\n\n那磁盘是如何工作的呢？我们以**磁盘读写一个字节**为例：\n\n首先移动**磁头**，并移动**磁盘**到**磁道**上，然后旋转磁道到**扇区**，在这个过程中**磁生电**，从扇区中读出一个字节到**内存缓冲区**。\n\n同样的，如果要从内存读取一个字节到磁盘，则应该从内存缓冲区中读取字节，再把它放在相应磁道的特定扇区中。\n\n了解了表层的工作机制，接下来需要将这个过程**具象化**，也就是说要往控制器中写**柱面C，磁头H，扇区S，缓存位置**就可以读写磁盘了。\n\n那用什么写入呢？自然是**out指令**——\n\n![image-20201124194841844](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124194841844.png)\n\n到这里，操作系统已经可以运行了，但**传入的参数太多**了，每次读写都要做这么繁琐的，那能否**将这些操作封装**，我们来看第一层的抽象——\n\n### 通过盘块号读写磁盘\n\nCPU可以通过提供的盘块号来算出上面的三个参数，也就是用**一维的参数来算出三维的参数**，在计算的过程中，就需要使用到**编址**，那么怎样编址才最高效呢？考虑到我们使用文件时通常是**读取block相邻的盘块**，因而编址的设计需要使得**读取相邻的盘块比较快速**。\n\n> 磁盘访问时间=写入控制器时间+寻道时间+旋转时间+传输时间。\n\n在这个过程中，**寻道花费的时间最多**，因为它是一种移动的机械运动。\n\n所以为了节省时间，可以将相邻的盘块放在同一个扇区——\n\n![image-20201124200503945](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124200503945.png)\n\n\n\n那么问题是如何**通过C,H,S得到扇区号block**呢？\n\n![image-20201124200629352](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124200629352.png)\n\n\n\n![image-20201124201018062](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124201018062.png)\n\n因为访问磁盘的时间绝大部分是用于寻道的，因而随着**读取磁盘扇区增大**，**读写的速度会显著的提高**，但同时也会带来**空间的浪费**，表现为磁盘的碎片增多。\n\n那我们怎样**折中**呢？很抱歉，我们空间多得是，**用空间换时间**是大势所趋。\n\n而随着读写空间的增大，读写的单位也**从扇区变为了盘块**，有头有尾，不过如是。\n\n------\n\n在第二次封装之前，我们补充一点知识，也为下文埋下伏笔：\n\nlinux0.11的盘块号有多大呢？\n\n每读取一个盘块，会读取两个扇区，因此可以说盘块等于两个扇区。\n\n### 多个进程通过队列使用磁盘\n\n在上文中，我们说的是CPU分配资源的最小单元——一个进程，但实际应用中多道程序并发执行才是常态，这时就需要引入队列——\n\n![image-20201124202710472](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124202710472.png)\n\n那怎样组织磁盘访问的请求效率最高呢？我们主要考虑**平均访问延迟**和**寻道时间**，而寻求一种相对高效的解决方案，换言之就是寻求一种算法——\n\n说到调度算法，最直观的自然是FCFS。\n\n### FCFS\n\n![image-20201124225422783](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124225422783.png)\n\n我们可以观察到先来先服务的算法会导致**磁头总在长途奔袭**，而不顾它经过的可以**顺便访问**的进程。\n\n在这个基础上改进的想法是先处理离当前磁头近的进程，也就是**SSTF**——**最短寻道时间优先算法**\n\n### SSTF\n\n![image-20201124230201466](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124230201466.png)\n\n这种算法的确解决了磁头耗时的问题，但因为**程序的局部性**，进程对磁盘的**请求总会比较集中**，这会导致**边缘化的进程**即便等待了很久，也**没有得到IO资源**，也就是**饥饿**问题。\n\n所以我们再接下来的改进中既要兼顾最短寻址，也要满足雨露均沾的需要，这就引出了**电梯算法**——SCAN\n\n### SCAN\n\n既然请求有局部性，那我们首先从**请求密集**的地方开始**磁头扫描**，然后磁头沿着某一方向扫描，扫描完后折返，我们来具象化的看下——\n\n![image-20201124231412870](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124231412870.png)\n\n可以看到中间请求密集的地方仍然被扫描多次，这就好比**我要坐着正在往下的电梯去上面，这可不怎么明智**，在现实生活中，我们通常会等电梯先下去，然后我们再乘坐向上的电梯，这个算法的优化也应该如此——\n\n![image-20201124232126400](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124232126400.png)\n\n理论完了，上正菜——\n\n![image-20201124234604990](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124234604990.png)\n\n在这段代码中，首先**将请求加入到队列**中，又IO资源是临界区资源，因此用**cli(),sti()**的方式给临界区上锁，处理完请求后再返回。\n\n至此，调度算法告一段落，我们来做一总结——\n\n![image-20201124235425309](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124235425309.png)\n\n## 2.从生磁盘到文件\n\n前面提及进程通过盘块号从而算出扇区号，那**盘块号是怎样得到的**呢？就是通过**文件**。我们的核心在于了解**如何从文件获取盘块号**。\n\n不使用文件的磁盘是生磁盘，这小结我们就将这生米煮成熟饭，来看**熟磁盘的工作机制**。\n\n那如何引入文件呢？我们对盘块做进一步的抽象，就成了文件。\n\n那从用户视角来看，文件是什么？**文件是用来存储字符的**，因此不妨说**文件是字符流**。\n\n我们的问题转变为要建立**字符流到盘块集合的映射**关系，那映射如何理解呢？基于盘块号的映射又是什么呢，我们来看下面的小例子——\n\n![image-20201125092547498](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125092547498.png)\n\n我们通过映射得到了字符的位置，但这个映射的细节对用户是隐藏的，我们不妨剥茧抽丝，看看映射是通过怎样的结构来实现的？\n\n最常规的映射结构是以连续结构实现文件——\n\n![image-20201125093111022](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093111022.png)\n\n字符的位置确定了，映射建立起来了，为了方便查询，自然就形成了**FCB——文件控制块**，通过查表我们得知了对应的磁盘块：\n\n![image-20201125093355040](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093355040.png)\n\n我们再来回顾一下这个过程——\n\n`首先用户打开一个文件，然后用户操作某些字符流，这些字符流通过查FCB表对应到相应的盘块，然后根据盘块号的得到CHS，最终读写文件。`\n\n------\n\n通过顺序结构查询文件位置，本质上是通过**数组**的方式访问，数组对于词典式的静态文件访问非常友好，但假如在数组中再插入一个元素，就需要对其他元素做位置的移动，显然不方便，那这种动态的写入用怎样的结构实现呢——**链表**\n\n![image-20201125095036685](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125095036685.png)\n\n链表的结构只需要添加一个`逻辑块号`，将这个逻辑块号与物理块号`建立映射关系`，就可以实现动态的在空闲块中写入，但链表的缺点也显而易见，假如需要某个盘块号，它需要遍历之前的所有盘块号，增加了访问时间。\n\n哎，安得世间万全法，不负数组不负卿。\n\n但是吧，还真有，但这就是另一个故事了——**索引结构**\n\n索引结构在生活中很常见，书本的目录就是索引，目录下的页是连续的，符合数组的特点，而目录页是不连续的，也就是链表结构。\n\n我们`查FCB表`可以得到`索引块`，再通过索引块得到`特定盘块的索引`。它是一种连续和链式分配的有效折中。\n\n那索引如何具象表示呢？其实我们之前也提及过，也就是**inode**，即**index node。**\n\n## 3.文件使用磁盘的实现\n\n上一小节中我们完成了生磁盘的使用，而后对生磁盘进行一层层的抽象，最终用文件的形式来使用磁盘，那文件是如何使用磁盘的呢？它与生磁盘的使用有什么异同，通过文件使用磁盘的核心又是什么？\n\n------\n\n我们首先给出一个大致的脉络——\n![image-20201125105359803](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105359803.png)\n\n可见，对磁盘的读写不过是在对文件读写的基础上`显示得加了一步`：通过inode找到磁盘盘块号。\n\n这个故事从系统调用**sys_write**开始——\n\n![image-20201125105002918](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105002918.png)\n\n在这段代码中，首先通过**文件描述符fd**得到那个文件**file**，然后通过file得到**文件结构描述信息inode**，最终调用文件写入**file_write函数**。\n\n而file_write就是我们需要的那张地图：\n\n- [ ] **file_write(inode,file,buf,count)**\n\ninode也就是索引节点，从inode中我们可以得到盘块号，从file中我们可以要读写的是那一段字符串，具体的说，file中有一个读写指针fssek，fseek指向这段字符的开始地址，而参数count表示要读写多少个字符，也就是偏移，最后将这段字符写到buf这段缓冲区上去。\n\n大致的脉络有了，我们来看具体的实现——\n\n![image-20201125110645363](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125110645363.png)\n\n\n\n如果是追加字符，则首先得到文件的大小，然后指针偏移到文件末尾，最后要实现**将这段字符写入到磁盘中去**。\n\n![image-20201125111052897](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125111052897.png)\n\n首先使用文件末尾的地址除以盘块的大小得到**对应的盘块号**，然后将盘块号放入到**电梯的调度队列**中，接着得到**具体的写入位置**，或者说是在**盘块号内的偏移**。\n\n那具体的盘块号如何算的呢，这同时也是使用**文件区别于使用盘块号的核心**，如下图~\n\n\n\n![image-20201125112728570](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125112728570.png)\n\n在操作系统中，万物皆文件，我们上面提及的仅仅是一个普通文件，但如果是一个设备文件呢？\n\n文件的**框架是不变**的，**变化的只是inode**中存储的内容，对于**设备文件**来说，inode中存储有**文件的属性，类型**等——\n\n![image-20201125113249026](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125113249026.png)\n\n整个脉络已经明晰了起来，但隐隐之中还是有一点留白，我们把从文件名得到文件描述符，再通过fd得到inode的过程当做一个黑盒子来使用，至于这个黑盒子是否是潘多拉魔盒，我们会在后一节的学习中看到，至此，我们来概括的看一下文件视图的两条主线：**生磁盘与熟磁盘**——\n![image-20201125114043926](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125114043926.png)\n\n# 二、文件系统\n\n## 1.目录与文件系统\n\n在**文件的基础**上，通过**目录**把整个磁盘抽象成**文件系统**的形式，是磁盘的**第四层抽象**。\n\n而这也是最终呈现给用户的视图，在用户眼中，**磁盘就是一堆有组织的文件**。而剥茧抽丝之后，我们知道**文件系统最终会映射到一个个的盘块号**中。\n\n文件系统只是我们先入为主的从主观上得到的抽象，但实际上从文件到文件系统仍是一个**漫长的过程**。\n\n首先我们从**文件**可以很自然的想到**多文件**，那多个文件如何组织起来呢？起初多个文件自然应该是在**一层目录**的，但一层目录管理起来着实困难，所以**目录树**就应运而生了。\n\n假设将文件划分为特定目录下的不同文件，将划分后的集合再进行划分，K次划分后，每个集合中的文件数为**O(logk N)**.\n\n可以看出从多文件到目录树的**核心**是需要**引入目录**的概念，那目录是怎样实现的呢？\n\n那我们首先来看，**目录怎样使用**，我们**使用路径来定位某个文件**，更具体的说，使用路径可以得到某个文件的**FCB**。\n\n换句话说，要识别某个文件，就要得到这个文件的FCB，再对FCB的信息进行匹配，就可以确认这个文件是什么。\n\n而从路径定位文件的过程，直观的说，目录应该要有它目录下的每个文件的FCB和文件名，但是**FCB是庞大**的，将它读入内存显然是**低效**的，那只要将**需要的那个文件的FCB**加载到**内存**中，所以FCB需要被识别，因而需要一个**FCB的编号**，而这个编号需要**FCB数组**来维护。\n\n### 树状目录的完整实现\n\n![image-20201125201135235](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125201135235.png)\n\n\n\n现在目录的脉络已经**明晰**了。磁盘只需要维护**FCB数组**和**对应FCB号的数据块**即可，数据块中包含有**文件名**和**对应FCB的地址**。而对于一个**目录**来说，它会维护**目录下文件的FCB数组和数据块**。逐层循环，最终得到需要的文件。\n\n但仅仅这样是不够的的，要想一个**系统能自举**，也就是**可移植**，就需要首先做好**框架**，进一步说，就是有一个**扎实的根基**，也就是**根目录的维护**。\n\n![image-20201125203034066](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125203034066.png)\n\n\n\n尽管PPT已经很详细了，但为了加深记忆，我们再来总结一手——\n\n`引导块`：操作系统启动之后加载，即`固化的引导块`\n\n`超级块`：记录位图的空间大小等信息\n\n`i节点的位图`：记录**i节点的事务**，就相当于是动态记录i节点的信息，比如i节点的大小，位置，性质等信息\n\n`盘块位图` ：记录盘块的状态，大小，位置等,可类比计算机网络里P2P体系中的每人持有一部分数据，并使用**位图来表征数据的状态**。\n\n至此，就到了我们熟悉的总结环节了——\n\n![image-20201125204155061](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125204155061.png)\n\n## 2.目录解析代码实现\n\n在上面的流程中，仅有**目录的实现**我们是以**黑盒子**的形式展示的，现在我们来打开这个黑盒子——\n\n**目录同样是文件**，而对文件的探寻，是从**open开始**的，又**以inode作为主线**的：\n\n![image-20201125213742823](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125213742823.png)\n\n首先根据路径名得到索引，通过索引找到目录名，最终进入核心的**get_dir函数**——\n\n![image-20201125214016996](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214016996.png)\n\n在这个函数中，首先获取根目录的inode，指向路径名的指针后移。**目录的inode**是在系统初始化是就存储在**shell进程中**，而**后来创建的进程都要由shell进程创建**，自然也会**拷贝shell进程的内容**，根目录的inode得以流传下来。\n\n> 关键的流程就是首先找到根目录root，接着从路径中读取到目录项，然后从目录项的FCB中找到索引节点号inode，最终根据数据块内容再读取下一个目录。\n\n![image-20201125214627114](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214627114.png)\n\n**操作系统初始化**时，会完成**设备的挂载**，而磁盘的挂载，本质上是**超级块的读取**。\n\n![image-20201125214942682](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214942682.png)\n\n然后根据这个数组中前半部分的占用空间得到**inode的位置**，找到了inode的位置，目录这个文件就不再神秘了——\n\n![image-20201125215119581](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215119581.png)\n\n**循环读取**到叶子结点的文件，**大结局**——\n![image-20201125215235130](https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215235130.png)\n\n------\n\n> 山高路远，静水深流。","slug":"磁盘与文件","published":1,"updated":"2023-09-24T09:50:29.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7m2001xxjcccu6efpct","content":"<h1 id=\"一、磁盘与文件\"><a href=\"#一、磁盘与文件\" class=\"headerlink\" title=\"一、磁盘与文件\"></a>一、磁盘与文件</h1><hr>\n<h2 id=\"1-生磁盘的使用\"><a href=\"#1-生磁盘的使用\" class=\"headerlink\" title=\"1.生磁盘的使用\"></a>1.生磁盘的使用</h2><p>生磁盘指单独的磁盘，不包括文件系统。</p>\n<p><strong>磁盘的使用同外设一样</strong>，它的工作机制也是三步走：CPU向磁盘控制器中的<strong>寄存器</strong>读写数据，<strong>磁盘控制器</strong>完成真正的工作，并<strong>向CPU发中断</strong>信息。</p>\n<p>学习磁盘从认识磁盘开始，磁盘是长这样的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124193703592.png\" alt=\"image-20201124193703592\"></p>\n<p>那磁盘是如何工作的呢？我们以<strong>磁盘读写一个字节</strong>为例：</p>\n<p>首先移动<strong>磁头</strong>，并移动<strong>磁盘</strong>到<strong>磁道</strong>上，然后旋转磁道到<strong>扇区</strong>，在这个过程中<strong>磁生电</strong>，从扇区中读出一个字节到<strong>内存缓冲区</strong>。</p>\n<p>同样的，如果要从内存读取一个字节到磁盘，则应该从内存缓冲区中读取字节，再把它放在相应磁道的特定扇区中。</p>\n<p>了解了表层的工作机制，接下来需要将这个过程<strong>具象化</strong>，也就是说要往控制器中写<strong>柱面C，磁头H，扇区S，缓存位置</strong>就可以读写磁盘了。</p>\n<p>那用什么写入呢？自然是<strong>out指令</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124194841844.png\" alt=\"image-20201124194841844\"></p>\n<p>到这里，操作系统已经可以运行了，但<strong>传入的参数太多</strong>了，每次读写都要做这么繁琐的，那能否<strong>将这些操作封装</strong>，我们来看第一层的抽象——</p>\n<h3 id=\"通过盘块号读写磁盘\"><a href=\"#通过盘块号读写磁盘\" class=\"headerlink\" title=\"通过盘块号读写磁盘\"></a>通过盘块号读写磁盘</h3><p>CPU可以通过提供的盘块号来算出上面的三个参数，也就是用<strong>一维的参数来算出三维的参数</strong>，在计算的过程中，就需要使用到<strong>编址</strong>，那么怎样编址才最高效呢？考虑到我们使用文件时通常是<strong>读取block相邻的盘块</strong>，因而编址的设计需要使得<strong>读取相邻的盘块比较快速</strong>。</p>\n<blockquote>\n<p>磁盘访问时间=写入控制器时间+寻道时间+旋转时间+传输时间。</p>\n</blockquote>\n<p>在这个过程中，<strong>寻道花费的时间最多</strong>，因为它是一种移动的机械运动。</p>\n<p>所以为了节省时间，可以将相邻的盘块放在同一个扇区——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124200503945.png\" alt=\"image-20201124200503945\"></p>\n<p>那么问题是如何<strong>通过C,H,S得到扇区号block</strong>呢？</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124200629352.png\" alt=\"image-20201124200629352\"></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124201018062.png\" alt=\"image-20201124201018062\"></p>\n<p>因为访问磁盘的时间绝大部分是用于寻道的，因而随着<strong>读取磁盘扇区增大</strong>，<strong>读写的速度会显著的提高</strong>，但同时也会带来<strong>空间的浪费</strong>，表现为磁盘的碎片增多。</p>\n<p>那我们怎样<strong>折中</strong>呢？很抱歉，我们空间多得是，<strong>用空间换时间</strong>是大势所趋。</p>\n<p>而随着读写空间的增大，读写的单位也<strong>从扇区变为了盘块</strong>，有头有尾，不过如是。</p>\n<hr>\n<p>在第二次封装之前，我们补充一点知识，也为下文埋下伏笔：</p>\n<p>linux0.11的盘块号有多大呢？</p>\n<p>每读取一个盘块，会读取两个扇区，因此可以说盘块等于两个扇区。</p>\n<h3 id=\"多个进程通过队列使用磁盘\"><a href=\"#多个进程通过队列使用磁盘\" class=\"headerlink\" title=\"多个进程通过队列使用磁盘\"></a>多个进程通过队列使用磁盘</h3><p>在上文中，我们说的是CPU分配资源的最小单元——一个进程，但实际应用中多道程序并发执行才是常态，这时就需要引入队列——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124202710472.png\" alt=\"image-20201124202710472\"></p>\n<p>那怎样组织磁盘访问的请求效率最高呢？我们主要考虑<strong>平均访问延迟</strong>和<strong>寻道时间</strong>，而寻求一种相对高效的解决方案，换言之就是寻求一种算法——</p>\n<p>说到调度算法，最直观的自然是FCFS。</p>\n<h3 id=\"FCFS\"><a href=\"#FCFS\" class=\"headerlink\" title=\"FCFS\"></a>FCFS</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124225422783.png\" alt=\"image-20201124225422783\"></p>\n<p>我们可以观察到先来先服务的算法会导致<strong>磁头总在长途奔袭</strong>，而不顾它经过的可以<strong>顺便访问</strong>的进程。</p>\n<p>在这个基础上改进的想法是先处理离当前磁头近的进程，也就是<strong>SSTF</strong>——<strong>最短寻道时间优先算法</strong></p>\n<h3 id=\"SSTF\"><a href=\"#SSTF\" class=\"headerlink\" title=\"SSTF\"></a>SSTF</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124230201466.png\" alt=\"image-20201124230201466\"></p>\n<p>这种算法的确解决了磁头耗时的问题，但因为<strong>程序的局部性</strong>，进程对磁盘的<strong>请求总会比较集中</strong>，这会导致<strong>边缘化的进程</strong>即便等待了很久，也<strong>没有得到IO资源</strong>，也就是<strong>饥饿</strong>问题。</p>\n<p>所以我们再接下来的改进中既要兼顾最短寻址，也要满足雨露均沾的需要，这就引出了<strong>电梯算法</strong>——SCAN</p>\n<h3 id=\"SCAN\"><a href=\"#SCAN\" class=\"headerlink\" title=\"SCAN\"></a>SCAN</h3><p>既然请求有局部性，那我们首先从<strong>请求密集</strong>的地方开始<strong>磁头扫描</strong>，然后磁头沿着某一方向扫描，扫描完后折返，我们来具象化的看下——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124231412870.png\" alt=\"image-20201124231412870\"></p>\n<p>可以看到中间请求密集的地方仍然被扫描多次，这就好比<strong>我要坐着正在往下的电梯去上面，这可不怎么明智</strong>，在现实生活中，我们通常会等电梯先下去，然后我们再乘坐向上的电梯，这个算法的优化也应该如此——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124232126400.png\" alt=\"image-20201124232126400\"></p>\n<p>理论完了，上正菜——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124234604990.png\" alt=\"image-20201124234604990\"></p>\n<p>在这段代码中，首先<strong>将请求加入到队列</strong>中，又IO资源是临界区资源，因此用**cli(),sti()**的方式给临界区上锁，处理完请求后再返回。</p>\n<p>至此，调度算法告一段落，我们来做一总结——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124235425309.png\" alt=\"image-20201124235425309\"></p>\n<h2 id=\"2-从生磁盘到文件\"><a href=\"#2-从生磁盘到文件\" class=\"headerlink\" title=\"2.从生磁盘到文件\"></a>2.从生磁盘到文件</h2><p>前面提及进程通过盘块号从而算出扇区号，那<strong>盘块号是怎样得到的</strong>呢？就是通过<strong>文件</strong>。我们的核心在于了解<strong>如何从文件获取盘块号</strong>。</p>\n<p>不使用文件的磁盘是生磁盘，这小结我们就将这生米煮成熟饭，来看<strong>熟磁盘的工作机制</strong>。</p>\n<p>那如何引入文件呢？我们对盘块做进一步的抽象，就成了文件。</p>\n<p>那从用户视角来看，文件是什么？<strong>文件是用来存储字符的</strong>，因此不妨说<strong>文件是字符流</strong>。</p>\n<p>我们的问题转变为要建立<strong>字符流到盘块集合的映射</strong>关系，那映射如何理解呢？基于盘块号的映射又是什么呢，我们来看下面的小例子——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125092547498.png\" alt=\"image-20201125092547498\"></p>\n<p>我们通过映射得到了字符的位置，但这个映射的细节对用户是隐藏的，我们不妨剥茧抽丝，看看映射是通过怎样的结构来实现的？</p>\n<p>最常规的映射结构是以连续结构实现文件——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093111022.png\" alt=\"image-20201125093111022\"></p>\n<p>字符的位置确定了，映射建立起来了，为了方便查询，自然就形成了<strong>FCB——文件控制块</strong>，通过查表我们得知了对应的磁盘块：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093355040.png\" alt=\"image-20201125093355040\"></p>\n<p>我们再来回顾一下这个过程——</p>\n<p><code>首先用户打开一个文件，然后用户操作某些字符流，这些字符流通过查FCB表对应到相应的盘块，然后根据盘块号的得到CHS，最终读写文件。</code></p>\n<hr>\n<p>通过顺序结构查询文件位置，本质上是通过<strong>数组</strong>的方式访问，数组对于词典式的静态文件访问非常友好，但假如在数组中再插入一个元素，就需要对其他元素做位置的移动，显然不方便，那这种动态的写入用怎样的结构实现呢——<strong>链表</strong></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125095036685.png\" alt=\"image-20201125095036685\"></p>\n<p>链表的结构只需要添加一个<code>逻辑块号</code>，将这个逻辑块号与物理块号<code>建立映射关系</code>，就可以实现动态的在空闲块中写入，但链表的缺点也显而易见，假如需要某个盘块号，它需要遍历之前的所有盘块号，增加了访问时间。</p>\n<p>哎，安得世间万全法，不负数组不负卿。</p>\n<p>但是吧，还真有，但这就是另一个故事了——<strong>索引结构</strong></p>\n<p>索引结构在生活中很常见，书本的目录就是索引，目录下的页是连续的，符合数组的特点，而目录页是不连续的，也就是链表结构。</p>\n<p>我们<code>查FCB表</code>可以得到<code>索引块</code>，再通过索引块得到<code>特定盘块的索引</code>。它是一种连续和链式分配的有效折中。</p>\n<p>那索引如何具象表示呢？其实我们之前也提及过，也就是<strong>inode</strong>，即<strong>index node。</strong></p>\n<h2 id=\"3-文件使用磁盘的实现\"><a href=\"#3-文件使用磁盘的实现\" class=\"headerlink\" title=\"3.文件使用磁盘的实现\"></a>3.文件使用磁盘的实现</h2><p>上一小节中我们完成了生磁盘的使用，而后对生磁盘进行一层层的抽象，最终用文件的形式来使用磁盘，那文件是如何使用磁盘的呢？它与生磁盘的使用有什么异同，通过文件使用磁盘的核心又是什么？</p>\n<hr>\n<p>我们首先给出一个大致的脉络——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105359803.png\" alt=\"image-20201125105359803\"></p>\n<p>可见，对磁盘的读写不过是在对文件读写的基础上<code>显示得加了一步</code>：通过inode找到磁盘盘块号。</p>\n<p>这个故事从系统调用<strong>sys_write</strong>开始——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105002918.png\" alt=\"image-20201125105002918\"></p>\n<p>在这段代码中，首先通过<strong>文件描述符fd</strong>得到那个文件<strong>file</strong>，然后通过file得到<strong>文件结构描述信息inode</strong>，最终调用文件写入<strong>file_write函数</strong>。</p>\n<p>而file_write就是我们需要的那张地图：</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>file_write(inode,file,buf,count)</strong></li>\n</ul>\n<p>inode也就是索引节点，从inode中我们可以得到盘块号，从file中我们可以要读写的是那一段字符串，具体的说，file中有一个读写指针fssek，fseek指向这段字符的开始地址，而参数count表示要读写多少个字符，也就是偏移，最后将这段字符写到buf这段缓冲区上去。</p>\n<p>大致的脉络有了，我们来看具体的实现——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125110645363.png\" alt=\"image-20201125110645363\"></p>\n<p>如果是追加字符，则首先得到文件的大小，然后指针偏移到文件末尾，最后要实现<strong>将这段字符写入到磁盘中去</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125111052897.png\" alt=\"image-20201125111052897\"></p>\n<p>首先使用文件末尾的地址除以盘块的大小得到<strong>对应的盘块号</strong>，然后将盘块号放入到<strong>电梯的调度队列</strong>中，接着得到<strong>具体的写入位置</strong>，或者说是在<strong>盘块号内的偏移</strong>。</p>\n<p>那具体的盘块号如何算的呢，这同时也是使用<strong>文件区别于使用盘块号的核心</strong>，如下图~</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125112728570.png\" alt=\"image-20201125112728570\"></p>\n<p>在操作系统中，万物皆文件，我们上面提及的仅仅是一个普通文件，但如果是一个设备文件呢？</p>\n<p>文件的<strong>框架是不变</strong>的，<strong>变化的只是inode</strong>中存储的内容，对于<strong>设备文件</strong>来说，inode中存储有<strong>文件的属性，类型</strong>等——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125113249026.png\" alt=\"image-20201125113249026\"></p>\n<p>整个脉络已经明晰了起来，但隐隐之中还是有一点留白，我们把从文件名得到文件描述符，再通过fd得到inode的过程当做一个黑盒子来使用，至于这个黑盒子是否是潘多拉魔盒，我们会在后一节的学习中看到，至此，我们来概括的看一下文件视图的两条主线：<strong>生磁盘与熟磁盘</strong>——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125114043926.png\" alt=\"image-20201125114043926\"></p>\n<h1 id=\"二、文件系统\"><a href=\"#二、文件系统\" class=\"headerlink\" title=\"二、文件系统\"></a>二、文件系统</h1><h2 id=\"1-目录与文件系统\"><a href=\"#1-目录与文件系统\" class=\"headerlink\" title=\"1.目录与文件系统\"></a>1.目录与文件系统</h2><p>在<strong>文件的基础</strong>上，通过<strong>目录</strong>把整个磁盘抽象成<strong>文件系统</strong>的形式，是磁盘的<strong>第四层抽象</strong>。</p>\n<p>而这也是最终呈现给用户的视图，在用户眼中，<strong>磁盘就是一堆有组织的文件</strong>。而剥茧抽丝之后，我们知道<strong>文件系统最终会映射到一个个的盘块号</strong>中。</p>\n<p>文件系统只是我们先入为主的从主观上得到的抽象，但实际上从文件到文件系统仍是一个<strong>漫长的过程</strong>。</p>\n<p>首先我们从<strong>文件</strong>可以很自然的想到<strong>多文件</strong>，那多个文件如何组织起来呢？起初多个文件自然应该是在<strong>一层目录</strong>的，但一层目录管理起来着实困难，所以<strong>目录树</strong>就应运而生了。</p>\n<p>假设将文件划分为特定目录下的不同文件，将划分后的集合再进行划分，K次划分后，每个集合中的文件数为<strong>O(logk N)</strong>.</p>\n<p>可以看出从多文件到目录树的<strong>核心</strong>是需要<strong>引入目录</strong>的概念，那目录是怎样实现的呢？</p>\n<p>那我们首先来看，<strong>目录怎样使用</strong>，我们<strong>使用路径来定位某个文件</strong>，更具体的说，使用路径可以得到某个文件的<strong>FCB</strong>。</p>\n<p>换句话说，要识别某个文件，就要得到这个文件的FCB，再对FCB的信息进行匹配，就可以确认这个文件是什么。</p>\n<p>而从路径定位文件的过程，直观的说，目录应该要有它目录下的每个文件的FCB和文件名，但是<strong>FCB是庞大</strong>的，将它读入内存显然是<strong>低效</strong>的，那只要将<strong>需要的那个文件的FCB</strong>加载到<strong>内存</strong>中，所以FCB需要被识别，因而需要一个<strong>FCB的编号</strong>，而这个编号需要<strong>FCB数组</strong>来维护。</p>\n<h3 id=\"树状目录的完整实现\"><a href=\"#树状目录的完整实现\" class=\"headerlink\" title=\"树状目录的完整实现\"></a>树状目录的完整实现</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125201135235.png\" alt=\"image-20201125201135235\"></p>\n<p>现在目录的脉络已经<strong>明晰</strong>了。磁盘只需要维护<strong>FCB数组</strong>和<strong>对应FCB号的数据块</strong>即可，数据块中包含有<strong>文件名</strong>和<strong>对应FCB的地址</strong>。而对于一个<strong>目录</strong>来说，它会维护<strong>目录下文件的FCB数组和数据块</strong>。逐层循环，最终得到需要的文件。</p>\n<p>但仅仅这样是不够的的，要想一个<strong>系统能自举</strong>，也就是<strong>可移植</strong>，就需要首先做好<strong>框架</strong>，进一步说，就是有一个<strong>扎实的根基</strong>，也就是<strong>根目录的维护</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125203034066.png\" alt=\"image-20201125203034066\"></p>\n<p>尽管PPT已经很详细了，但为了加深记忆，我们再来总结一手——</p>\n<p><code>引导块</code>：操作系统启动之后加载，即<code>固化的引导块</code></p>\n<p><code>超级块</code>：记录位图的空间大小等信息</p>\n<p><code>i节点的位图</code>：记录<strong>i节点的事务</strong>，就相当于是动态记录i节点的信息，比如i节点的大小，位置，性质等信息</p>\n<p><code>盘块位图</code> ：记录盘块的状态，大小，位置等,可类比计算机网络里P2P体系中的每人持有一部分数据，并使用<strong>位图来表征数据的状态</strong>。</p>\n<p>至此，就到了我们熟悉的总结环节了——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125204155061.png\" alt=\"image-20201125204155061\"></p>\n<h2 id=\"2-目录解析代码实现\"><a href=\"#2-目录解析代码实现\" class=\"headerlink\" title=\"2.目录解析代码实现\"></a>2.目录解析代码实现</h2><p>在上面的流程中，仅有<strong>目录的实现</strong>我们是以<strong>黑盒子</strong>的形式展示的，现在我们来打开这个黑盒子——</p>\n<p><strong>目录同样是文件</strong>，而对文件的探寻，是从<strong>open开始</strong>的，又<strong>以inode作为主线</strong>的：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125213742823.png\" alt=\"image-20201125213742823\"></p>\n<p>首先根据路径名得到索引，通过索引找到目录名，最终进入核心的<strong>get_dir函数</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214016996.png\" alt=\"image-20201125214016996\"></p>\n<p>在这个函数中，首先获取根目录的inode，指向路径名的指针后移。<strong>目录的inode</strong>是在系统初始化是就存储在<strong>shell进程中</strong>，而<strong>后来创建的进程都要由shell进程创建</strong>，自然也会<strong>拷贝shell进程的内容</strong>，根目录的inode得以流传下来。</p>\n<blockquote>\n<p>关键的流程就是首先找到根目录root，接着从路径中读取到目录项，然后从目录项的FCB中找到索引节点号inode，最终根据数据块内容再读取下一个目录。</p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214627114.png\" alt=\"image-20201125214627114\"></p>\n<p><strong>操作系统初始化</strong>时，会完成<strong>设备的挂载</strong>，而磁盘的挂载，本质上是<strong>超级块的读取</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214942682.png\" alt=\"image-20201125214942682\"></p>\n<p>然后根据这个数组中前半部分的占用空间得到<strong>inode的位置</strong>，找到了inode的位置，目录这个文件就不再神秘了——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215119581.png\" alt=\"image-20201125215119581\"></p>\n<p><strong>循环读取</strong>到叶子结点的文件，<strong>大结局</strong>——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215235130.png\" alt=\"image-20201125215235130\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、磁盘与文件\"><a href=\"#一、磁盘与文件\" class=\"headerlink\" title=\"一、磁盘与文件\"></a>一、磁盘与文件</h1><hr>\n<h2 id=\"1-生磁盘的使用\"><a href=\"#1-生磁盘的使用\" class=\"headerlink\" title=\"1.生磁盘的使用\"></a>1.生磁盘的使用</h2><p>生磁盘指单独的磁盘，不包括文件系统。</p>\n<p><strong>磁盘的使用同外设一样</strong>，它的工作机制也是三步走：CPU向磁盘控制器中的<strong>寄存器</strong>读写数据，<strong>磁盘控制器</strong>完成真正的工作，并<strong>向CPU发中断</strong>信息。</p>\n<p>学习磁盘从认识磁盘开始，磁盘是长这样的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124193703592.png\" alt=\"image-20201124193703592\"></p>\n<p>那磁盘是如何工作的呢？我们以<strong>磁盘读写一个字节</strong>为例：</p>\n<p>首先移动<strong>磁头</strong>，并移动<strong>磁盘</strong>到<strong>磁道</strong>上，然后旋转磁道到<strong>扇区</strong>，在这个过程中<strong>磁生电</strong>，从扇区中读出一个字节到<strong>内存缓冲区</strong>。</p>\n<p>同样的，如果要从内存读取一个字节到磁盘，则应该从内存缓冲区中读取字节，再把它放在相应磁道的特定扇区中。</p>\n<p>了解了表层的工作机制，接下来需要将这个过程<strong>具象化</strong>，也就是说要往控制器中写<strong>柱面C，磁头H，扇区S，缓存位置</strong>就可以读写磁盘了。</p>\n<p>那用什么写入呢？自然是<strong>out指令</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124194841844.png\" alt=\"image-20201124194841844\"></p>\n<p>到这里，操作系统已经可以运行了，但<strong>传入的参数太多</strong>了，每次读写都要做这么繁琐的，那能否<strong>将这些操作封装</strong>，我们来看第一层的抽象——</p>\n<h3 id=\"通过盘块号读写磁盘\"><a href=\"#通过盘块号读写磁盘\" class=\"headerlink\" title=\"通过盘块号读写磁盘\"></a>通过盘块号读写磁盘</h3><p>CPU可以通过提供的盘块号来算出上面的三个参数，也就是用<strong>一维的参数来算出三维的参数</strong>，在计算的过程中，就需要使用到<strong>编址</strong>，那么怎样编址才最高效呢？考虑到我们使用文件时通常是<strong>读取block相邻的盘块</strong>，因而编址的设计需要使得<strong>读取相邻的盘块比较快速</strong>。</p>\n<blockquote>\n<p>磁盘访问时间=写入控制器时间+寻道时间+旋转时间+传输时间。</p>\n</blockquote>\n<p>在这个过程中，<strong>寻道花费的时间最多</strong>，因为它是一种移动的机械运动。</p>\n<p>所以为了节省时间，可以将相邻的盘块放在同一个扇区——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124200503945.png\" alt=\"image-20201124200503945\"></p>\n<p>那么问题是如何<strong>通过C,H,S得到扇区号block</strong>呢？</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201124200629352.png\" alt=\"image-20201124200629352\"></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124201018062.png\" alt=\"image-20201124201018062\"></p>\n<p>因为访问磁盘的时间绝大部分是用于寻道的，因而随着<strong>读取磁盘扇区增大</strong>，<strong>读写的速度会显著的提高</strong>，但同时也会带来<strong>空间的浪费</strong>，表现为磁盘的碎片增多。</p>\n<p>那我们怎样<strong>折中</strong>呢？很抱歉，我们空间多得是，<strong>用空间换时间</strong>是大势所趋。</p>\n<p>而随着读写空间的增大，读写的单位也<strong>从扇区变为了盘块</strong>，有头有尾，不过如是。</p>\n<hr>\n<p>在第二次封装之前，我们补充一点知识，也为下文埋下伏笔：</p>\n<p>linux0.11的盘块号有多大呢？</p>\n<p>每读取一个盘块，会读取两个扇区，因此可以说盘块等于两个扇区。</p>\n<h3 id=\"多个进程通过队列使用磁盘\"><a href=\"#多个进程通过队列使用磁盘\" class=\"headerlink\" title=\"多个进程通过队列使用磁盘\"></a>多个进程通过队列使用磁盘</h3><p>在上文中，我们说的是CPU分配资源的最小单元——一个进程，但实际应用中多道程序并发执行才是常态，这时就需要引入队列——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124202710472.png\" alt=\"image-20201124202710472\"></p>\n<p>那怎样组织磁盘访问的请求效率最高呢？我们主要考虑<strong>平均访问延迟</strong>和<strong>寻道时间</strong>，而寻求一种相对高效的解决方案，换言之就是寻求一种算法——</p>\n<p>说到调度算法，最直观的自然是FCFS。</p>\n<h3 id=\"FCFS\"><a href=\"#FCFS\" class=\"headerlink\" title=\"FCFS\"></a>FCFS</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124225422783.png\" alt=\"image-20201124225422783\"></p>\n<p>我们可以观察到先来先服务的算法会导致<strong>磁头总在长途奔袭</strong>，而不顾它经过的可以<strong>顺便访问</strong>的进程。</p>\n<p>在这个基础上改进的想法是先处理离当前磁头近的进程，也就是<strong>SSTF</strong>——<strong>最短寻道时间优先算法</strong></p>\n<h3 id=\"SSTF\"><a href=\"#SSTF\" class=\"headerlink\" title=\"SSTF\"></a>SSTF</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124230201466.png\" alt=\"image-20201124230201466\"></p>\n<p>这种算法的确解决了磁头耗时的问题，但因为<strong>程序的局部性</strong>，进程对磁盘的<strong>请求总会比较集中</strong>，这会导致<strong>边缘化的进程</strong>即便等待了很久，也<strong>没有得到IO资源</strong>，也就是<strong>饥饿</strong>问题。</p>\n<p>所以我们再接下来的改进中既要兼顾最短寻址，也要满足雨露均沾的需要，这就引出了<strong>电梯算法</strong>——SCAN</p>\n<h3 id=\"SCAN\"><a href=\"#SCAN\" class=\"headerlink\" title=\"SCAN\"></a>SCAN</h3><p>既然请求有局部性，那我们首先从<strong>请求密集</strong>的地方开始<strong>磁头扫描</strong>，然后磁头沿着某一方向扫描，扫描完后折返，我们来具象化的看下——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124231412870.png\" alt=\"image-20201124231412870\"></p>\n<p>可以看到中间请求密集的地方仍然被扫描多次，这就好比<strong>我要坐着正在往下的电梯去上面，这可不怎么明智</strong>，在现实生活中，我们通常会等电梯先下去，然后我们再乘坐向上的电梯，这个算法的优化也应该如此——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124232126400.png\" alt=\"image-20201124232126400\"></p>\n<p>理论完了，上正菜——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124234604990.png\" alt=\"image-20201124234604990\"></p>\n<p>在这段代码中，首先<strong>将请求加入到队列</strong>中，又IO资源是临界区资源，因此用**cli(),sti()**的方式给临界区上锁，处理完请求后再返回。</p>\n<p>至此，调度算法告一段落，我们来做一总结——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201124235425309.png\" alt=\"image-20201124235425309\"></p>\n<h2 id=\"2-从生磁盘到文件\"><a href=\"#2-从生磁盘到文件\" class=\"headerlink\" title=\"2.从生磁盘到文件\"></a>2.从生磁盘到文件</h2><p>前面提及进程通过盘块号从而算出扇区号，那<strong>盘块号是怎样得到的</strong>呢？就是通过<strong>文件</strong>。我们的核心在于了解<strong>如何从文件获取盘块号</strong>。</p>\n<p>不使用文件的磁盘是生磁盘，这小结我们就将这生米煮成熟饭，来看<strong>熟磁盘的工作机制</strong>。</p>\n<p>那如何引入文件呢？我们对盘块做进一步的抽象，就成了文件。</p>\n<p>那从用户视角来看，文件是什么？<strong>文件是用来存储字符的</strong>，因此不妨说<strong>文件是字符流</strong>。</p>\n<p>我们的问题转变为要建立<strong>字符流到盘块集合的映射</strong>关系，那映射如何理解呢？基于盘块号的映射又是什么呢，我们来看下面的小例子——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125092547498.png\" alt=\"image-20201125092547498\"></p>\n<p>我们通过映射得到了字符的位置，但这个映射的细节对用户是隐藏的，我们不妨剥茧抽丝，看看映射是通过怎样的结构来实现的？</p>\n<p>最常规的映射结构是以连续结构实现文件——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093111022.png\" alt=\"image-20201125093111022\"></p>\n<p>字符的位置确定了，映射建立起来了，为了方便查询，自然就形成了<strong>FCB——文件控制块</strong>，通过查表我们得知了对应的磁盘块：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125093355040.png\" alt=\"image-20201125093355040\"></p>\n<p>我们再来回顾一下这个过程——</p>\n<p><code>首先用户打开一个文件，然后用户操作某些字符流，这些字符流通过查FCB表对应到相应的盘块，然后根据盘块号的得到CHS，最终读写文件。</code></p>\n<hr>\n<p>通过顺序结构查询文件位置，本质上是通过<strong>数组</strong>的方式访问，数组对于词典式的静态文件访问非常友好，但假如在数组中再插入一个元素，就需要对其他元素做位置的移动，显然不方便，那这种动态的写入用怎样的结构实现呢——<strong>链表</strong></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125095036685.png\" alt=\"image-20201125095036685\"></p>\n<p>链表的结构只需要添加一个<code>逻辑块号</code>，将这个逻辑块号与物理块号<code>建立映射关系</code>，就可以实现动态的在空闲块中写入，但链表的缺点也显而易见，假如需要某个盘块号，它需要遍历之前的所有盘块号，增加了访问时间。</p>\n<p>哎，安得世间万全法，不负数组不负卿。</p>\n<p>但是吧，还真有，但这就是另一个故事了——<strong>索引结构</strong></p>\n<p>索引结构在生活中很常见，书本的目录就是索引，目录下的页是连续的，符合数组的特点，而目录页是不连续的，也就是链表结构。</p>\n<p>我们<code>查FCB表</code>可以得到<code>索引块</code>，再通过索引块得到<code>特定盘块的索引</code>。它是一种连续和链式分配的有效折中。</p>\n<p>那索引如何具象表示呢？其实我们之前也提及过，也就是<strong>inode</strong>，即<strong>index node。</strong></p>\n<h2 id=\"3-文件使用磁盘的实现\"><a href=\"#3-文件使用磁盘的实现\" class=\"headerlink\" title=\"3.文件使用磁盘的实现\"></a>3.文件使用磁盘的实现</h2><p>上一小节中我们完成了生磁盘的使用，而后对生磁盘进行一层层的抽象，最终用文件的形式来使用磁盘，那文件是如何使用磁盘的呢？它与生磁盘的使用有什么异同，通过文件使用磁盘的核心又是什么？</p>\n<hr>\n<p>我们首先给出一个大致的脉络——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105359803.png\" alt=\"image-20201125105359803\"></p>\n<p>可见，对磁盘的读写不过是在对文件读写的基础上<code>显示得加了一步</code>：通过inode找到磁盘盘块号。</p>\n<p>这个故事从系统调用<strong>sys_write</strong>开始——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125105002918.png\" alt=\"image-20201125105002918\"></p>\n<p>在这段代码中，首先通过<strong>文件描述符fd</strong>得到那个文件<strong>file</strong>，然后通过file得到<strong>文件结构描述信息inode</strong>，最终调用文件写入<strong>file_write函数</strong>。</p>\n<p>而file_write就是我们需要的那张地图：</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>file_write(inode,file,buf,count)</strong></li>\n</ul>\n<p>inode也就是索引节点，从inode中我们可以得到盘块号，从file中我们可以要读写的是那一段字符串，具体的说，file中有一个读写指针fssek，fseek指向这段字符的开始地址，而参数count表示要读写多少个字符，也就是偏移，最后将这段字符写到buf这段缓冲区上去。</p>\n<p>大致的脉络有了，我们来看具体的实现——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125110645363.png\" alt=\"image-20201125110645363\"></p>\n<p>如果是追加字符，则首先得到文件的大小，然后指针偏移到文件末尾，最后要实现<strong>将这段字符写入到磁盘中去</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125111052897.png\" alt=\"image-20201125111052897\"></p>\n<p>首先使用文件末尾的地址除以盘块的大小得到<strong>对应的盘块号</strong>，然后将盘块号放入到<strong>电梯的调度队列</strong>中，接着得到<strong>具体的写入位置</strong>，或者说是在<strong>盘块号内的偏移</strong>。</p>\n<p>那具体的盘块号如何算的呢，这同时也是使用<strong>文件区别于使用盘块号的核心</strong>，如下图~</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125112728570.png\" alt=\"image-20201125112728570\"></p>\n<p>在操作系统中，万物皆文件，我们上面提及的仅仅是一个普通文件，但如果是一个设备文件呢？</p>\n<p>文件的<strong>框架是不变</strong>的，<strong>变化的只是inode</strong>中存储的内容，对于<strong>设备文件</strong>来说，inode中存储有<strong>文件的属性，类型</strong>等——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125113249026.png\" alt=\"image-20201125113249026\"></p>\n<p>整个脉络已经明晰了起来，但隐隐之中还是有一点留白，我们把从文件名得到文件描述符，再通过fd得到inode的过程当做一个黑盒子来使用，至于这个黑盒子是否是潘多拉魔盒，我们会在后一节的学习中看到，至此，我们来概括的看一下文件视图的两条主线：<strong>生磁盘与熟磁盘</strong>——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125114043926.png\" alt=\"image-20201125114043926\"></p>\n<h1 id=\"二、文件系统\"><a href=\"#二、文件系统\" class=\"headerlink\" title=\"二、文件系统\"></a>二、文件系统</h1><h2 id=\"1-目录与文件系统\"><a href=\"#1-目录与文件系统\" class=\"headerlink\" title=\"1.目录与文件系统\"></a>1.目录与文件系统</h2><p>在<strong>文件的基础</strong>上，通过<strong>目录</strong>把整个磁盘抽象成<strong>文件系统</strong>的形式，是磁盘的<strong>第四层抽象</strong>。</p>\n<p>而这也是最终呈现给用户的视图，在用户眼中，<strong>磁盘就是一堆有组织的文件</strong>。而剥茧抽丝之后，我们知道<strong>文件系统最终会映射到一个个的盘块号</strong>中。</p>\n<p>文件系统只是我们先入为主的从主观上得到的抽象，但实际上从文件到文件系统仍是一个<strong>漫长的过程</strong>。</p>\n<p>首先我们从<strong>文件</strong>可以很自然的想到<strong>多文件</strong>，那多个文件如何组织起来呢？起初多个文件自然应该是在<strong>一层目录</strong>的，但一层目录管理起来着实困难，所以<strong>目录树</strong>就应运而生了。</p>\n<p>假设将文件划分为特定目录下的不同文件，将划分后的集合再进行划分，K次划分后，每个集合中的文件数为<strong>O(logk N)</strong>.</p>\n<p>可以看出从多文件到目录树的<strong>核心</strong>是需要<strong>引入目录</strong>的概念，那目录是怎样实现的呢？</p>\n<p>那我们首先来看，<strong>目录怎样使用</strong>，我们<strong>使用路径来定位某个文件</strong>，更具体的说，使用路径可以得到某个文件的<strong>FCB</strong>。</p>\n<p>换句话说，要识别某个文件，就要得到这个文件的FCB，再对FCB的信息进行匹配，就可以确认这个文件是什么。</p>\n<p>而从路径定位文件的过程，直观的说，目录应该要有它目录下的每个文件的FCB和文件名，但是<strong>FCB是庞大</strong>的，将它读入内存显然是<strong>低效</strong>的，那只要将<strong>需要的那个文件的FCB</strong>加载到<strong>内存</strong>中，所以FCB需要被识别，因而需要一个<strong>FCB的编号</strong>，而这个编号需要<strong>FCB数组</strong>来维护。</p>\n<h3 id=\"树状目录的完整实现\"><a href=\"#树状目录的完整实现\" class=\"headerlink\" title=\"树状目录的完整实现\"></a>树状目录的完整实现</h3><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125201135235.png\" alt=\"image-20201125201135235\"></p>\n<p>现在目录的脉络已经<strong>明晰</strong>了。磁盘只需要维护<strong>FCB数组</strong>和<strong>对应FCB号的数据块</strong>即可，数据块中包含有<strong>文件名</strong>和<strong>对应FCB的地址</strong>。而对于一个<strong>目录</strong>来说，它会维护<strong>目录下文件的FCB数组和数据块</strong>。逐层循环，最终得到需要的文件。</p>\n<p>但仅仅这样是不够的的，要想一个<strong>系统能自举</strong>，也就是<strong>可移植</strong>，就需要首先做好<strong>框架</strong>，进一步说，就是有一个<strong>扎实的根基</strong>，也就是<strong>根目录的维护</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125203034066.png\" alt=\"image-20201125203034066\"></p>\n<p>尽管PPT已经很详细了，但为了加深记忆，我们再来总结一手——</p>\n<p><code>引导块</code>：操作系统启动之后加载，即<code>固化的引导块</code></p>\n<p><code>超级块</code>：记录位图的空间大小等信息</p>\n<p><code>i节点的位图</code>：记录<strong>i节点的事务</strong>，就相当于是动态记录i节点的信息，比如i节点的大小，位置，性质等信息</p>\n<p><code>盘块位图</code> ：记录盘块的状态，大小，位置等,可类比计算机网络里P2P体系中的每人持有一部分数据，并使用<strong>位图来表征数据的状态</strong>。</p>\n<p>至此，就到了我们熟悉的总结环节了——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125204155061.png\" alt=\"image-20201125204155061\"></p>\n<h2 id=\"2-目录解析代码实现\"><a href=\"#2-目录解析代码实现\" class=\"headerlink\" title=\"2.目录解析代码实现\"></a>2.目录解析代码实现</h2><p>在上面的流程中，仅有<strong>目录的实现</strong>我们是以<strong>黑盒子</strong>的形式展示的，现在我们来打开这个黑盒子——</p>\n<p><strong>目录同样是文件</strong>，而对文件的探寻，是从<strong>open开始</strong>的，又<strong>以inode作为主线</strong>的：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125213742823.png\" alt=\"image-20201125213742823\"></p>\n<p>首先根据路径名得到索引，通过索引找到目录名，最终进入核心的<strong>get_dir函数</strong>——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214016996.png\" alt=\"image-20201125214016996\"></p>\n<p>在这个函数中，首先获取根目录的inode，指向路径名的指针后移。<strong>目录的inode</strong>是在系统初始化是就存储在<strong>shell进程中</strong>，而<strong>后来创建的进程都要由shell进程创建</strong>，自然也会<strong>拷贝shell进程的内容</strong>，根目录的inode得以流传下来。</p>\n<blockquote>\n<p>关键的流程就是首先找到根目录root，接着从路径中读取到目录项，然后从目录项的FCB中找到索引节点号inode，最终根据数据块内容再读取下一个目录。</p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214627114.png\" alt=\"image-20201125214627114\"></p>\n<p><strong>操作系统初始化</strong>时，会完成<strong>设备的挂载</strong>，而磁盘的挂载，本质上是<strong>超级块的读取</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125214942682.png\" alt=\"image-20201125214942682\"></p>\n<p>然后根据这个数组中前半部分的占用空间得到<strong>inode的位置</strong>，找到了inode的位置，目录这个文件就不再神秘了——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215119581.png\" alt=\"image-20201125215119581\"></p>\n<p><strong>循环读取</strong>到叶子结点的文件，<strong>大结局</strong>——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img2/image-20201125215235130.png\" alt=\"image-20201125215235130\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n"},{"title":"链表算法集锦(图文详解哦)","top":false,"cover":true,"toc":true,"mathjax":true,"date":"2021-07-12T07:59:06.000Z","password":null,"summary":null,"_content":"\n# 一、单链表的反转_递归&迭代\n\n## 1.1 问题描述\n\n> 反转一个单链表。\n>\n> 示例:\n>\n> 输入: 1->2->3->4->5->NULL\n> 输出: 5->4->3->2->1->NULL\n> 进阶:\n> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n## 1.2 思路及复杂度分析\n\n反转单链表，直观的理解，就是**将每个节点的指针指向它的上一个节点**。显然，这是一个循环操作。而循环操作中除了原生的循环之外，还包括**迭代**和**递归**两种特殊场景下的循环。\n\n很多人搞不清楚迭代与递归有怎样的爱恨情仇，其实答主同样是如此。我们来迈过这个砍——\n\n> 迭代与递归都是循环的一种。从代码结构上看，**递归重复调用函数自身。而迭代只是循环代码的一部分**。\n>\n> 另外，迭代中变量的结果会保存作为下一次循环的初始值。考虑递归时不要为难自己的大脑，想清楚一层就ok了，\n>\n> 递归本质上就是一个问题的演化。\n\n好了，回归正题。我们首先选择好理解的迭代实现方式。既然需要变后继节点为前驱节点，我们不妨申请两个指针，指针curr指向当前节点，**指针prev指向前驱节点。让curr指向head节点**，而prev自然声明为null。在迭代部分分为两步，**第一步即将当前节点的指针指向上一个节点**，**第二步需要为下一次的迭代变量确定初始值**，具体操作是curr,prev指针均后移即可。迭代部分确定了，我们再来看**边界条件**：这里循环结束的条件比较难确认，需要手绘试一下。最终能同时满足链表长度为空，只有一个元素时代码仍可以正常运行的边界条件是**curr!=null**.\n\n再来看递归实现，递归的问题规模可能很多，但每一层实际做的不过是调用函数自身。递归的问题我们只需要抓住两个核心点：**递归公式+递归终止条件**。这里的递归终止条件很朴素，也就是head!=null && head.next!=null.所以我们需要考虑的只有递归公式。假设F表示的是反转关系，则F(n)表示第n层的链表反转，那F(n)可以表示为第n层的头结点与第n-1层反转后的结果整体做反转。有点拗口，我们用数学公式描述一下——\n$$\nF(n)=F(head,F(n-1))\n$$\n那么这个数学公式用代码怎么转化呢？其实就很简洁了.\n\n```java\nListNode newHead = reverseList(head.next);\nhead.next.next = head;\nhead.next = null;\n```\n\n## 1.3 趣味图解\n\n> 双指针实现，图来自https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\n\n![img](https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)\n\n> 递归实现，图来自https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\n\n![img](https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)\n\n## 1.4 代码演示\n\n```java\n/**\n  Definition for singly-linked list.\n  public class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n  }\n */\n\nclass Solution {\n  //迭代解法\n  public ListNode reverseList(ListNode head) {\n      //声明两个指针，分别指向当前元素和上一个元素\n   ListNode curr = head;\n    ListNode pre = null;\n    while(curr != null){\n      //得到下一次操作的节点\n      ListNode node = curr.next;\n      //反转两个节点的指针\n      curr.next = pre;\n      //下一次反转的初始状态\n      pre = curr;\n      curr = node;\n    }\n    return pre;\n  }\n\n  //递归解法\n  public ListNode reverseList(ListNode head) {\n    if(head==null || head.next==null){\n      return head;\n    }\n    ListNode newHead = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n  }\n\n}\n```\n\n------\n\n# 二、回文链表的常规与递归解法\n\n## 2.1 问题描述\n\n> 请判断一个链表是否为回文链表。\n>\n> 示例 1:\n>\n> 输入: 1->2\n> 输出: false\n> 示例 2:\n>\n> 输入: 1->2->2->1\n> 输出: true\n> 进阶：\n> 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n\n------\n\n## 2.2 思路及复杂度分析\n\n老规矩先审题，将链表是否是回文的问题转化一下，即**以中间节点作为分界点，前半部分与后半部分的反转对应节点位置上的数值相同**，显然步骤已经呼之欲出了。但在上手之前，我们有必要先入为主地判断下代码的**执行效率与内存消耗。**\n\n我们知道判断时间复杂度只需要找到**量级最大的代码**就行了。找中间节点使用快慢指针的方式，时间复杂度为O(n).反转代码刚写过，O(n)没意外，比较对应位置上元素是否相等，不严谨的说还是O(n).那空间复杂度呢？\n\n假如使用递归方式的反转链表，因为要保存局部变量就还会用到栈，不推荐，相对而言，**使用迭代的方式**在运行时不需要额外的空间，所以**空间复杂度为O(1)**，就它了！\n\n接下来，就是**思路剖析**环节——\n\n1. 首先找中间节点，无疑使用**快慢指针**的方式。但这里有一个小细节，假如在偶数场景下，我们将中间之前的节点作为中间节点，在后面判断时就会出现**head.next.next**。虽然逻辑满分，但实际运行时非常容易出现空指针错误。所以将中间偏后的节点作为中间节点是首选。\n2. 反转没得说，建议使用**迭代方式**降低内存消耗。\n3. 最终判断环节，显然后半部分是更短的，那循环结束条件自然是满足限制大的，即**满足后半部分边界条件**即可。\n\n### 递归解法？\n\n逛了下leetcode评论区，朋友们清一色的留下<递归，永远的的神>这样的评论。\n\n我不由得老脸一红，不用递归实现下岂不是没有牌面，那使用递归怎么实现呢？\n\n在刚看到这道题的时候，相信很多朋友碎碎念，要是用数组实现就舒服了，因为数组能够实现反序遍历，但链表不行，至少严谨的说是这样的。\n\n诚然，单链表没有前驱指针。但并不是说没有前驱指针链表的反向遍历就不能实现！！！\n\n前面谈及解决递归问题有两个核心：**递归终止条件和递归公式**。这里，终止条件无疑是**head==null**,。再假设F表示逆序遍历的关系，则第n层的逆序遍历可以表示为：\n$$\nF(n)=F(head,F(n-1))\n$$\n到这里，非常有必要在纸上画类似这样的一张图——\n\n![img](https://img-blog.csdnimg.cn/20200323134306815.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1dGhlcks=,size_16,color_FFFFFF,t_70)\n\n> 图来自 https://blog.csdn.net/LutherK/article/details/105046744\n\n所以对链表的逆序遍历是这样子的——\n\n```java\npublic void reverseTraversalListNode(ListNode head) {\n    if (head == null)\n        return;\n    reverseTraversalListNode(head.next);\n    System.out.print(head.val);\n}\n```\n\n那我们只需要在实现逆序遍历的同时判断顺序遍历和逆序遍历对应的值是否相等即可，代码非常简洁，但我写不出来。\n\n![image-20210707231628900](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231628900.png)\n\n### 福利环节\n\n![img](https://pic2.zhimg.com/80/v2-6b854efd30ba33dbd1d758605fbf7c44_1440w.jpg?source=1940ef5c)\n\n```java\n\n```\n\n\n\n## .3 趣味图解\n\n> 图片来自 ：https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/\n\n![img](https://assets.leetcode-cn.com/solution-static/234/31.PNG)\n\n## 2.4 代码演示\n\n### 常规解法\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head==null || head.next==null)\n            return true;\n        //偶数和技术确定重点的方式不同，但都使用双指针机制\n        ListNode slow = head,fast = head;\n        while(fast!=null && fast.next!= null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if(fast != null)\n            slow = slow.next;\n        //以中点为界将链表分成两部分\n        fast = slow;\n        //反转后半部分\n        fast = reverseList(fast);\n        //遍历比较\n        while(fast != null){\n            if(head.val != fast.val)\n                return false;\n            else{\n                head = head.next;\n                fast = fast.next;\n            }\n            \n        }\n        return true;   \n    }\n\n  public ListNode reverseList(ListNode head) {\n      //声明两个指针，分别指向当前元素和上一个元素\n   ListNode curr = head;\n    ListNode pre = null;\n    while(curr != null){\n      //得到下一次操作的节点\n      ListNode node = curr.next;\n      //反转两个节点的指针\n      curr.next = pre;\n      //下一次反转的初始状态\n      pre = curr;\n      curr = node;\n    }\n    return pre;\n  }\n}\n```\n\n### 迭代解法\n\n```java\nListNode temp;\n\npublic boolean isPalindrome(ListNode head) {\n    temp = head;\n    return check(head);\n}\n\nprivate boolean check(ListNode head) {\n    if (head == null)\n        return true;\n    boolean res = check(head.next) && (temp.val == head.val);\n    //顺序遍历的指针指向下一个节点\n    temp = temp.next;\n    return res;\n}\n```\n\n------\n\n# 三 、链表是否有环\n\n## 3.1 问题描述\n\n> 给定一个链表，判断链表中是否有环。\n>\n> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n>\n> 如果链表中存在环，则返回 true 。 否则，返回 false 。\n>\n> 进阶：\n>\n> 你能用 O(1)（即，常量）内存解决此问题吗？\n>\n> 示例 1：\n>\n> ![image-20210206224828269](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210206224828269.png)\n>\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：true\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n\n## 3.2 思路及复杂度分析\n\n在我看来，解决算法问题**最重要的是对问题的抽象和转化**，那么链表是否有环这个问题要从何下手分析呢？\n\n链表有环的具体表现为在遍历链表时，对相同的节点会遍历不止一次。所以直观地看，**我们只需要判断在遍历链表时是否有节点被二次遍历即可**，也就是说，我们需要使用**一种可以保证元素唯一性的数据结构**来存顺序添加链表元素，显然，那就是**散列表**咯。\n\n只是呢，引入散列表会导致空间复杂度为O(n),这可不能入各位看官的法眼。继续出发咯——\n\n### 快慢指针\n\n在初中时，我们经常会碰到相遇问题，这类问题说明了**在一个环形空间中，速度不一致的两个物体总会在某一时刻相遇。**\n\n对应到环形链表，同样如是。\n\n我们只需声明一个快指针，一个慢指针。快指针每次指向它的后继节点的后继节点。而慢指针只需循规蹈矩地指向它的后继节点即可。在每次遍历的时候都去判断是否出现快慢指针指向一致的情况就ok了。\n\n在逛leetcode评论区的时候，发现有大佬去测试**不同跳指针的优劣**。对此我个人觉得没有必要，映射到实际问题，要想让两个人尽快相遇，这取决于两个人速度的关系和跑道的长度。抛开跑道长只谈速度的关系意义不大。\n\n从思路上来说，编写快慢指针的代码很舒服，那它的时间空间复杂度是不是也是如此呢？\n\n快慢指针的相遇取决于问题的规模N，所以它的**时间复杂度为O(n)**,在代码运行时并不需要申请额外空间，**空间复杂度为O(1)**。nice~ 看起来是要皆大圆满的节奏，**但是从思维挑战来说，故事才刚刚开始**——\n\n### 链表反转后判断头结点\n\n先给出结论：**有环链表反转后头节点与反转前头结点相同**。为了得到这个结论，动手是必然的——\n\n![image-20210707231558495](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231558495.png)\n\n在反转的基础上加一个判断就行了。而它的时间空间复杂度自然同反转链表一致，分别为O(n),O(1).\n\n到这里，才算是皆大圆满了，碎觉觉。可是呢，大晚上的，本来挺困，画完贼精神。算法果然比咖啡管用~\n\n![img](https://image.dbbqb.com/202102062347/23aca80ed56c35ae3c68f96539ccba42/gZ7Xk)\n\n## 3.3 趣味图解\n\n> 图片来自于：https://leetcode-cn.com/problems/linked-list-cycle/solution/lian-biao-you-huan-zui-jia-jie-da-by-tinet-shenjg/\n\n![img](https://pic.leetcode-cn.com/689f74000ab31dfbd492c4ec1a35cf087d0c8797c95472f1f2674743a5b4f444.png)\n\n> 图片来自于：https://leetcode-cn.com/problems/linked-list-cycle/solution/dong-hua-yan-shi-141huan-xing-lian-biao-b99vd/\n\n![image-20210707231530342](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231530342.png)\n\n## 3.4 代码演示\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        //哈希表\n        Set<ListNode> set = new HashSet<>();\n        while(head != null){\n            if(!set.add(head)){\n                return true;\n            }\n            head = head.next;\n        }\n        return false;\n    }\n\n    public boolean hasCycle(ListNode head) {\n        //如果链表为空，则不成环\n        if(head == null)\n            return false;\n        //声明一个快指针\n        ListNode fast = head;\n        //快指针走两个格，慢指针走一格，判断能否相遇\n        while(fast!=null && fast.next != null){\n            head = head.next;\n            fast = fast.next.next;\n            if(head == fast)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean hasCycle(ListNode head) {\n        if(head==null || head.next==null)\n            return false;\n        ListNode curr = head;\n        ListNode prev = null;\n        while(curr != null){\n            //得到要反转的下一个节点\n            ListNode tmp = curr.next;\n            //反转\n            curr.next = prev;\n            //得到下一个状态的初始值\n            prev = curr;\n            curr = tmp;\n        }\n        //有环的链表反转后头结点与反转前头结点相同\n        if(prev == head)\n            return true;\n        return false;\n    }  \n}\n```\n\n------\n\n# 四、合并两个有序链表\n\n------\n\n## 4.1 问题描述\n\n> ![image-20210707231509844](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231509844.png)\n\n## 4.2 思路及复杂度分析\n\n老规矩，先审题。将两个有序的链表合并为一个有序的链表最直观简洁的方式就是合并链表再排序咯，这样问题就被转化为了排序问题。排序时可以考虑使用原地排序的桶排序算法，时间空间复杂度都为O(n)，效率还是很不错的。\n\n但排序不是我们的核心内容，至少目前不是。要合并为一个有序的单链表，就必然会涉及**基于遍历的比较**。而遍历链表，也就是循环的实现通常有两种，即迭代和递归。这里两种方法都能实现目标。让我们一探究竟咯——\n\n### 迭代\n\n迭代是我们最长使用的循环方式，再啰嗦下，迭代的典型特点是每次迭代的结果会作为下一次迭代的初始值。\n\n迭代的内容即是**找出两个链表所比较元素的较小值**，然后需要指针指向这个较小值作为合并后链表的元素。也就是说我们需要一个指针始终指向下一个比较得到的较小值。映射到第一次的比较，就会很明了的想到，需要一个**哨兵节点**。\n\n那哨兵节点需要满足什么条件呢？**不存储元素且指向为空**。这里有一个**小技巧**，为了不发生空指针错误，我们必须让引用指向一块内存空间。而使用带参数的构造方式时可以**将数据域声明为-1**,也就是不合法的数据，这样就不会干扰数据的正常排序了，当然，即便我们不显示地声明，虚拟机也会将其**默认声明为0**.\n\n这里还有另一个容易出错的内容，至少在我做的时候排查了很久才发现，那就是迭代部分的循环结束条件。我们在不手绘的情况下，容易先入为主地认为是**l1!=null || l2!=null**,这样想的原因是我们认为当出现一个链表为空后，**哨兵节点**会自然得指向另一个非空的链表，但却忽略了进入循环后仍需要比较，而在l1为空的情况相爱，l1.val会发生什么就显而易见了。\n\n也就是说，在循环结束后，还需要我们手动将哨兵节点指向非空的链表，这就很容易了：**prev.next = l1==null?l2:l1;**\n\n思路已经很详细了，我们来看下时空复杂度。时间复杂度取决于迭代的次数，显然，迭代的规模也就是需要比较的次数，即**O(n+m)**,而空间的话，只需要**常数的空间**存放元素就ok了，也就是**O(1)**.\n\n### 递归\n\n题解区对于递归解法的调侃无过于一看全会，一写全废。这说的不就是我嘛。\n\n![image-20210707231456371](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231456371.png)\n\n不可否认，这评价的确很中肯~\n\n递归的学习是**基于理解和熟练度**的，大多数的题目，都是有迹可循，使用适当的方法论就可以解决的，没有智商差一说。大可不必妄自菲薄。\n\n老规矩，找**递归公式**和**递归终止条件**。递归终止条件很友好，即**l1==null || l2==null.**而递归公式就需要分析了。合并的问题能否分为子问题 ，子问题的解决方法相同，而且又需要有递和归的演化，就是它咯——\n$$\nlist1[0]+merge(list1[1:],list2)   list1[0]<list2[0]\\\\\n\nlist2[0]+merge(list1,list2[1:])otherwise\n$$\n搞定了核心的两步，剩下的就只有将**l1/l2.next指向比较结果**这样的边角料了。\n\n## 4.3 趣味图解\n\n> 请大家移步力扣官方题解：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/\n\n在链表的章节，一定要保持手绘的习惯！！！图的解释能力比干巴巴的语言要好很多。\n\n## 4.4 代码演示\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n       //特判，如果链表为空，则\n        if(l1 == null || l2==null)\n            return l1==null?l2:l1;\n        if(l1.val > l2.val){\n            l2.next = mergeTwoLists(l1,l2.next);\n            return l2;\n        }\n        else{\n            l1.next =  mergeTwoLists(l1.next,l2);\n            return l1;\n        }\n    }\n\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        //声明哨兵节点\n        ListNode phread = new ListNode(-1);\n        //声明一个最终返回的节点\n        ListNode prev = phread;\n        //循环终止条件,手绘一下会发现如果是||会导致空指针\n        while(l1!=null && l2!=null){\n            if(l1.val <= l2.val){\n                prev.next = l1;\n                l1 = l1.next;\n            }else{\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n        //合并还有剩余节点的链表\n        prev.next = l1==null?l2:l1;\n        //返回\n        return phread.next;\n    } \n}\n```\n\n------\n\n# 五、 删除链表倒数第N个元素\n\n## 5.1 问题描述\n\n![image-20210707231440028](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231440028.png)\n\n## 5.2 思路及复杂度分析\n\n老规矩，先审题。要删除链表的某个元素，我们**必须知道它的前驱节点**，所以不管哪种解法，**哨兵节点**的添加都可以简化解题流程。\n\n最直观的解法解法无过于将问题转化为**删除链表第length-n+1个元素**。我们不妨称之为朴素的解法。\n\n### 朴素解法\n\n问题转化以后，思路就变得很明晰了。首先我们需要遍历得到链表的长度。然后，既然要删除链表的第length-n+1个元素，显然**首先需要得到第length-n个元素**。而链表是没有下标的，所以我们要维护一个计数器。然后遍历链表，计数器递增，当计数器的值等于length-n时，我们记录下当前指针指向的元素，也就是待删除节点的上一个节点。最后删除返回链表就ok了。\n\n![image-20210707231423480](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png)\n\n### 快慢指针\n\n在聊快慢指针之前，我们有必要先了解一下什么是**模式识别**。\n\n> 所谓模式识别的问题就是用计算的方法根据样本的**特征**将样本划分到一定的**类别**中去。\n\n这不就是数据挖掘中的**分类问题**吗？的确，算法的解决很多都要基于**方法论**。\n\n那对于删除倒数第N个节点，我们可以提取出什么模式呢——\n\n- `需要得到前驱节点`：哨兵节点\n- `需要定位确切位置的节点`：快慢指针\n\n讲真，九年义务教育我们最大的成果就是通过思考得到模式，再按照模式做题，但可笑的是，当我们在之后所谓的深造中，却将最大的财富抛在脑后，真是可怜至极。\n\n![image-20210707231355517](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png)\n\n好啦，言归正传。哨兵节点就不再赘述了。如何通过快慢指针找到要删除节点的前一个节点呢？\n\n开局一张图~\n\n![image-20210707231338256](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231338256.png)\n\n也就是说，快指针的初始位置为**慢指针向前移动n+1个位置**。然后遍历链表，移动快慢指针，确定慢指针的位置。最后，就是删除咯——\n![image-20210707231254243](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231254243.png)\n\n## 5.3 趣味图解\n\n请朋友们移步力扣官方视频，一如既往的给力——\n\nhttps://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\n\n## 5.4 代码演示\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    /**\n    *常规解法\n    */\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        //声明哨兵节点\n        ListNode dummy = new ListNode(0,head);\n        //得到链表长度\n        int length = getlength(head);\n        ListNode prev = dummy;\n        for(int i=1;i<=length-n;i++){\n            prev = prev.next;\n        }\n        prev.next = prev.next.next;\n        return dummy.next;\n    }\n\n    public int getlength(ListNode head){\n        int length = 0;\n        while(head != null){\n            length++;\n            head = head.next;\n        }\n        return length;\n    }\n\t/**\n\t*快慢指针\n\t*/\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        //我们总需要得到待删除节点的前一个节点，对于头结点来说，就需要一个哨兵节点\n        ListNode pummy = new ListNode(0,head);\n        //快慢指针法\n        ListNode slow = pummy;\n        ListNode fast = pummy;\n        //得到超前慢指针n+1个位置的fast指针\n        for(int i=0;i<=n;i++){\n            fast = fast.next;\n        }\n        //slow指针指向要删除的节点的前一个节点\n        while(fast != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        //删除节点\n        ListNode tmp = slow.next;\n        slow.next = tmp.next;\n        tmp.next = null;\n        return pummy.next;\n    }\n}\n```\n\n------\n\n> 山高路远，静水深流\n>\n> 注：补上昨天的，生活和学习的失衡是无可避免的事情，但维系每件重要事情的平衡也同样势在必行，加油吧，时光不问赶路人。\n\n","source":"_posts/链表算法集锦-图文详解哦.md","raw":"---\ntitle: 链表算法集锦(图文详解哦)\ntop: false\ncover: true\ntoc: true\nmathjax: true\ndate: 2021-07-12 15:59:06\npassword:\nsummary:\ntags: 链表\ncategories: 数据结构与算法\n---\n\n# 一、单链表的反转_递归&迭代\n\n## 1.1 问题描述\n\n> 反转一个单链表。\n>\n> 示例:\n>\n> 输入: 1->2->3->4->5->NULL\n> 输出: 5->4->3->2->1->NULL\n> 进阶:\n> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n## 1.2 思路及复杂度分析\n\n反转单链表，直观的理解，就是**将每个节点的指针指向它的上一个节点**。显然，这是一个循环操作。而循环操作中除了原生的循环之外，还包括**迭代**和**递归**两种特殊场景下的循环。\n\n很多人搞不清楚迭代与递归有怎样的爱恨情仇，其实答主同样是如此。我们来迈过这个砍——\n\n> 迭代与递归都是循环的一种。从代码结构上看，**递归重复调用函数自身。而迭代只是循环代码的一部分**。\n>\n> 另外，迭代中变量的结果会保存作为下一次循环的初始值。考虑递归时不要为难自己的大脑，想清楚一层就ok了，\n>\n> 递归本质上就是一个问题的演化。\n\n好了，回归正题。我们首先选择好理解的迭代实现方式。既然需要变后继节点为前驱节点，我们不妨申请两个指针，指针curr指向当前节点，**指针prev指向前驱节点。让curr指向head节点**，而prev自然声明为null。在迭代部分分为两步，**第一步即将当前节点的指针指向上一个节点**，**第二步需要为下一次的迭代变量确定初始值**，具体操作是curr,prev指针均后移即可。迭代部分确定了，我们再来看**边界条件**：这里循环结束的条件比较难确认，需要手绘试一下。最终能同时满足链表长度为空，只有一个元素时代码仍可以正常运行的边界条件是**curr!=null**.\n\n再来看递归实现，递归的问题规模可能很多，但每一层实际做的不过是调用函数自身。递归的问题我们只需要抓住两个核心点：**递归公式+递归终止条件**。这里的递归终止条件很朴素，也就是head!=null && head.next!=null.所以我们需要考虑的只有递归公式。假设F表示的是反转关系，则F(n)表示第n层的链表反转，那F(n)可以表示为第n层的头结点与第n-1层反转后的结果整体做反转。有点拗口，我们用数学公式描述一下——\n$$\nF(n)=F(head,F(n-1))\n$$\n那么这个数学公式用代码怎么转化呢？其实就很简洁了.\n\n```java\nListNode newHead = reverseList(head.next);\nhead.next.next = head;\nhead.next = null;\n```\n\n## 1.3 趣味图解\n\n> 双指针实现，图来自https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\n\n![img](https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)\n\n> 递归实现，图来自https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\n\n![img](https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)\n\n## 1.4 代码演示\n\n```java\n/**\n  Definition for singly-linked list.\n  public class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n  }\n */\n\nclass Solution {\n  //迭代解法\n  public ListNode reverseList(ListNode head) {\n      //声明两个指针，分别指向当前元素和上一个元素\n   ListNode curr = head;\n    ListNode pre = null;\n    while(curr != null){\n      //得到下一次操作的节点\n      ListNode node = curr.next;\n      //反转两个节点的指针\n      curr.next = pre;\n      //下一次反转的初始状态\n      pre = curr;\n      curr = node;\n    }\n    return pre;\n  }\n\n  //递归解法\n  public ListNode reverseList(ListNode head) {\n    if(head==null || head.next==null){\n      return head;\n    }\n    ListNode newHead = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n  }\n\n}\n```\n\n------\n\n# 二、回文链表的常规与递归解法\n\n## 2.1 问题描述\n\n> 请判断一个链表是否为回文链表。\n>\n> 示例 1:\n>\n> 输入: 1->2\n> 输出: false\n> 示例 2:\n>\n> 输入: 1->2->2->1\n> 输出: true\n> 进阶：\n> 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n\n------\n\n## 2.2 思路及复杂度分析\n\n老规矩先审题，将链表是否是回文的问题转化一下，即**以中间节点作为分界点，前半部分与后半部分的反转对应节点位置上的数值相同**，显然步骤已经呼之欲出了。但在上手之前，我们有必要先入为主地判断下代码的**执行效率与内存消耗。**\n\n我们知道判断时间复杂度只需要找到**量级最大的代码**就行了。找中间节点使用快慢指针的方式，时间复杂度为O(n).反转代码刚写过，O(n)没意外，比较对应位置上元素是否相等，不严谨的说还是O(n).那空间复杂度呢？\n\n假如使用递归方式的反转链表，因为要保存局部变量就还会用到栈，不推荐，相对而言，**使用迭代的方式**在运行时不需要额外的空间，所以**空间复杂度为O(1)**，就它了！\n\n接下来，就是**思路剖析**环节——\n\n1. 首先找中间节点，无疑使用**快慢指针**的方式。但这里有一个小细节，假如在偶数场景下，我们将中间之前的节点作为中间节点，在后面判断时就会出现**head.next.next**。虽然逻辑满分，但实际运行时非常容易出现空指针错误。所以将中间偏后的节点作为中间节点是首选。\n2. 反转没得说，建议使用**迭代方式**降低内存消耗。\n3. 最终判断环节，显然后半部分是更短的，那循环结束条件自然是满足限制大的，即**满足后半部分边界条件**即可。\n\n### 递归解法？\n\n逛了下leetcode评论区，朋友们清一色的留下<递归，永远的的神>这样的评论。\n\n我不由得老脸一红，不用递归实现下岂不是没有牌面，那使用递归怎么实现呢？\n\n在刚看到这道题的时候，相信很多朋友碎碎念，要是用数组实现就舒服了，因为数组能够实现反序遍历，但链表不行，至少严谨的说是这样的。\n\n诚然，单链表没有前驱指针。但并不是说没有前驱指针链表的反向遍历就不能实现！！！\n\n前面谈及解决递归问题有两个核心：**递归终止条件和递归公式**。这里，终止条件无疑是**head==null**,。再假设F表示逆序遍历的关系，则第n层的逆序遍历可以表示为：\n$$\nF(n)=F(head,F(n-1))\n$$\n到这里，非常有必要在纸上画类似这样的一张图——\n\n![img](https://img-blog.csdnimg.cn/20200323134306815.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1dGhlcks=,size_16,color_FFFFFF,t_70)\n\n> 图来自 https://blog.csdn.net/LutherK/article/details/105046744\n\n所以对链表的逆序遍历是这样子的——\n\n```java\npublic void reverseTraversalListNode(ListNode head) {\n    if (head == null)\n        return;\n    reverseTraversalListNode(head.next);\n    System.out.print(head.val);\n}\n```\n\n那我们只需要在实现逆序遍历的同时判断顺序遍历和逆序遍历对应的值是否相等即可，代码非常简洁，但我写不出来。\n\n![image-20210707231628900](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231628900.png)\n\n### 福利环节\n\n![img](https://pic2.zhimg.com/80/v2-6b854efd30ba33dbd1d758605fbf7c44_1440w.jpg?source=1940ef5c)\n\n```java\n\n```\n\n\n\n## .3 趣味图解\n\n> 图片来自 ：https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/\n\n![img](https://assets.leetcode-cn.com/solution-static/234/31.PNG)\n\n## 2.4 代码演示\n\n### 常规解法\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head==null || head.next==null)\n            return true;\n        //偶数和技术确定重点的方式不同，但都使用双指针机制\n        ListNode slow = head,fast = head;\n        while(fast!=null && fast.next!= null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if(fast != null)\n            slow = slow.next;\n        //以中点为界将链表分成两部分\n        fast = slow;\n        //反转后半部分\n        fast = reverseList(fast);\n        //遍历比较\n        while(fast != null){\n            if(head.val != fast.val)\n                return false;\n            else{\n                head = head.next;\n                fast = fast.next;\n            }\n            \n        }\n        return true;   \n    }\n\n  public ListNode reverseList(ListNode head) {\n      //声明两个指针，分别指向当前元素和上一个元素\n   ListNode curr = head;\n    ListNode pre = null;\n    while(curr != null){\n      //得到下一次操作的节点\n      ListNode node = curr.next;\n      //反转两个节点的指针\n      curr.next = pre;\n      //下一次反转的初始状态\n      pre = curr;\n      curr = node;\n    }\n    return pre;\n  }\n}\n```\n\n### 迭代解法\n\n```java\nListNode temp;\n\npublic boolean isPalindrome(ListNode head) {\n    temp = head;\n    return check(head);\n}\n\nprivate boolean check(ListNode head) {\n    if (head == null)\n        return true;\n    boolean res = check(head.next) && (temp.val == head.val);\n    //顺序遍历的指针指向下一个节点\n    temp = temp.next;\n    return res;\n}\n```\n\n------\n\n# 三 、链表是否有环\n\n## 3.1 问题描述\n\n> 给定一个链表，判断链表中是否有环。\n>\n> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n>\n> 如果链表中存在环，则返回 true 。 否则，返回 false 。\n>\n> 进阶：\n>\n> 你能用 O(1)（即，常量）内存解决此问题吗？\n>\n> 示例 1：\n>\n> ![image-20210206224828269](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210206224828269.png)\n>\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：true\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n\n## 3.2 思路及复杂度分析\n\n在我看来，解决算法问题**最重要的是对问题的抽象和转化**，那么链表是否有环这个问题要从何下手分析呢？\n\n链表有环的具体表现为在遍历链表时，对相同的节点会遍历不止一次。所以直观地看，**我们只需要判断在遍历链表时是否有节点被二次遍历即可**，也就是说，我们需要使用**一种可以保证元素唯一性的数据结构**来存顺序添加链表元素，显然，那就是**散列表**咯。\n\n只是呢，引入散列表会导致空间复杂度为O(n),这可不能入各位看官的法眼。继续出发咯——\n\n### 快慢指针\n\n在初中时，我们经常会碰到相遇问题，这类问题说明了**在一个环形空间中，速度不一致的两个物体总会在某一时刻相遇。**\n\n对应到环形链表，同样如是。\n\n我们只需声明一个快指针，一个慢指针。快指针每次指向它的后继节点的后继节点。而慢指针只需循规蹈矩地指向它的后继节点即可。在每次遍历的时候都去判断是否出现快慢指针指向一致的情况就ok了。\n\n在逛leetcode评论区的时候，发现有大佬去测试**不同跳指针的优劣**。对此我个人觉得没有必要，映射到实际问题，要想让两个人尽快相遇，这取决于两个人速度的关系和跑道的长度。抛开跑道长只谈速度的关系意义不大。\n\n从思路上来说，编写快慢指针的代码很舒服，那它的时间空间复杂度是不是也是如此呢？\n\n快慢指针的相遇取决于问题的规模N，所以它的**时间复杂度为O(n)**,在代码运行时并不需要申请额外空间，**空间复杂度为O(1)**。nice~ 看起来是要皆大圆满的节奏，**但是从思维挑战来说，故事才刚刚开始**——\n\n### 链表反转后判断头结点\n\n先给出结论：**有环链表反转后头节点与反转前头结点相同**。为了得到这个结论，动手是必然的——\n\n![image-20210707231558495](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231558495.png)\n\n在反转的基础上加一个判断就行了。而它的时间空间复杂度自然同反转链表一致，分别为O(n),O(1).\n\n到这里，才算是皆大圆满了，碎觉觉。可是呢，大晚上的，本来挺困，画完贼精神。算法果然比咖啡管用~\n\n![img](https://image.dbbqb.com/202102062347/23aca80ed56c35ae3c68f96539ccba42/gZ7Xk)\n\n## 3.3 趣味图解\n\n> 图片来自于：https://leetcode-cn.com/problems/linked-list-cycle/solution/lian-biao-you-huan-zui-jia-jie-da-by-tinet-shenjg/\n\n![img](https://pic.leetcode-cn.com/689f74000ab31dfbd492c4ec1a35cf087d0c8797c95472f1f2674743a5b4f444.png)\n\n> 图片来自于：https://leetcode-cn.com/problems/linked-list-cycle/solution/dong-hua-yan-shi-141huan-xing-lian-biao-b99vd/\n\n![image-20210707231530342](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231530342.png)\n\n## 3.4 代码演示\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        //哈希表\n        Set<ListNode> set = new HashSet<>();\n        while(head != null){\n            if(!set.add(head)){\n                return true;\n            }\n            head = head.next;\n        }\n        return false;\n    }\n\n    public boolean hasCycle(ListNode head) {\n        //如果链表为空，则不成环\n        if(head == null)\n            return false;\n        //声明一个快指针\n        ListNode fast = head;\n        //快指针走两个格，慢指针走一格，判断能否相遇\n        while(fast!=null && fast.next != null){\n            head = head.next;\n            fast = fast.next.next;\n            if(head == fast)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean hasCycle(ListNode head) {\n        if(head==null || head.next==null)\n            return false;\n        ListNode curr = head;\n        ListNode prev = null;\n        while(curr != null){\n            //得到要反转的下一个节点\n            ListNode tmp = curr.next;\n            //反转\n            curr.next = prev;\n            //得到下一个状态的初始值\n            prev = curr;\n            curr = tmp;\n        }\n        //有环的链表反转后头结点与反转前头结点相同\n        if(prev == head)\n            return true;\n        return false;\n    }  \n}\n```\n\n------\n\n# 四、合并两个有序链表\n\n------\n\n## 4.1 问题描述\n\n> ![image-20210707231509844](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231509844.png)\n\n## 4.2 思路及复杂度分析\n\n老规矩，先审题。将两个有序的链表合并为一个有序的链表最直观简洁的方式就是合并链表再排序咯，这样问题就被转化为了排序问题。排序时可以考虑使用原地排序的桶排序算法，时间空间复杂度都为O(n)，效率还是很不错的。\n\n但排序不是我们的核心内容，至少目前不是。要合并为一个有序的单链表，就必然会涉及**基于遍历的比较**。而遍历链表，也就是循环的实现通常有两种，即迭代和递归。这里两种方法都能实现目标。让我们一探究竟咯——\n\n### 迭代\n\n迭代是我们最长使用的循环方式，再啰嗦下，迭代的典型特点是每次迭代的结果会作为下一次迭代的初始值。\n\n迭代的内容即是**找出两个链表所比较元素的较小值**，然后需要指针指向这个较小值作为合并后链表的元素。也就是说我们需要一个指针始终指向下一个比较得到的较小值。映射到第一次的比较，就会很明了的想到，需要一个**哨兵节点**。\n\n那哨兵节点需要满足什么条件呢？**不存储元素且指向为空**。这里有一个**小技巧**，为了不发生空指针错误，我们必须让引用指向一块内存空间。而使用带参数的构造方式时可以**将数据域声明为-1**,也就是不合法的数据，这样就不会干扰数据的正常排序了，当然，即便我们不显示地声明，虚拟机也会将其**默认声明为0**.\n\n这里还有另一个容易出错的内容，至少在我做的时候排查了很久才发现，那就是迭代部分的循环结束条件。我们在不手绘的情况下，容易先入为主地认为是**l1!=null || l2!=null**,这样想的原因是我们认为当出现一个链表为空后，**哨兵节点**会自然得指向另一个非空的链表，但却忽略了进入循环后仍需要比较，而在l1为空的情况相爱，l1.val会发生什么就显而易见了。\n\n也就是说，在循环结束后，还需要我们手动将哨兵节点指向非空的链表，这就很容易了：**prev.next = l1==null?l2:l1;**\n\n思路已经很详细了，我们来看下时空复杂度。时间复杂度取决于迭代的次数，显然，迭代的规模也就是需要比较的次数，即**O(n+m)**,而空间的话，只需要**常数的空间**存放元素就ok了，也就是**O(1)**.\n\n### 递归\n\n题解区对于递归解法的调侃无过于一看全会，一写全废。这说的不就是我嘛。\n\n![image-20210707231456371](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231456371.png)\n\n不可否认，这评价的确很中肯~\n\n递归的学习是**基于理解和熟练度**的，大多数的题目，都是有迹可循，使用适当的方法论就可以解决的，没有智商差一说。大可不必妄自菲薄。\n\n老规矩，找**递归公式**和**递归终止条件**。递归终止条件很友好，即**l1==null || l2==null.**而递归公式就需要分析了。合并的问题能否分为子问题 ，子问题的解决方法相同，而且又需要有递和归的演化，就是它咯——\n$$\nlist1[0]+merge(list1[1:],list2)   list1[0]<list2[0]\\\\\n\nlist2[0]+merge(list1,list2[1:])otherwise\n$$\n搞定了核心的两步，剩下的就只有将**l1/l2.next指向比较结果**这样的边角料了。\n\n## 4.3 趣味图解\n\n> 请大家移步力扣官方题解：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/\n\n在链表的章节，一定要保持手绘的习惯！！！图的解释能力比干巴巴的语言要好很多。\n\n## 4.4 代码演示\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n       //特判，如果链表为空，则\n        if(l1 == null || l2==null)\n            return l1==null?l2:l1;\n        if(l1.val > l2.val){\n            l2.next = mergeTwoLists(l1,l2.next);\n            return l2;\n        }\n        else{\n            l1.next =  mergeTwoLists(l1.next,l2);\n            return l1;\n        }\n    }\n\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        //声明哨兵节点\n        ListNode phread = new ListNode(-1);\n        //声明一个最终返回的节点\n        ListNode prev = phread;\n        //循环终止条件,手绘一下会发现如果是||会导致空指针\n        while(l1!=null && l2!=null){\n            if(l1.val <= l2.val){\n                prev.next = l1;\n                l1 = l1.next;\n            }else{\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n        //合并还有剩余节点的链表\n        prev.next = l1==null?l2:l1;\n        //返回\n        return phread.next;\n    } \n}\n```\n\n------\n\n# 五、 删除链表倒数第N个元素\n\n## 5.1 问题描述\n\n![image-20210707231440028](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231440028.png)\n\n## 5.2 思路及复杂度分析\n\n老规矩，先审题。要删除链表的某个元素，我们**必须知道它的前驱节点**，所以不管哪种解法，**哨兵节点**的添加都可以简化解题流程。\n\n最直观的解法解法无过于将问题转化为**删除链表第length-n+1个元素**。我们不妨称之为朴素的解法。\n\n### 朴素解法\n\n问题转化以后，思路就变得很明晰了。首先我们需要遍历得到链表的长度。然后，既然要删除链表的第length-n+1个元素，显然**首先需要得到第length-n个元素**。而链表是没有下标的，所以我们要维护一个计数器。然后遍历链表，计数器递增，当计数器的值等于length-n时，我们记录下当前指针指向的元素，也就是待删除节点的上一个节点。最后删除返回链表就ok了。\n\n![image-20210707231423480](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png)\n\n### 快慢指针\n\n在聊快慢指针之前，我们有必要先了解一下什么是**模式识别**。\n\n> 所谓模式识别的问题就是用计算的方法根据样本的**特征**将样本划分到一定的**类别**中去。\n\n这不就是数据挖掘中的**分类问题**吗？的确，算法的解决很多都要基于**方法论**。\n\n那对于删除倒数第N个节点，我们可以提取出什么模式呢——\n\n- `需要得到前驱节点`：哨兵节点\n- `需要定位确切位置的节点`：快慢指针\n\n讲真，九年义务教育我们最大的成果就是通过思考得到模式，再按照模式做题，但可笑的是，当我们在之后所谓的深造中，却将最大的财富抛在脑后，真是可怜至极。\n\n![image-20210707231355517](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png)\n\n好啦，言归正传。哨兵节点就不再赘述了。如何通过快慢指针找到要删除节点的前一个节点呢？\n\n开局一张图~\n\n![image-20210707231338256](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231338256.png)\n\n也就是说，快指针的初始位置为**慢指针向前移动n+1个位置**。然后遍历链表，移动快慢指针，确定慢指针的位置。最后，就是删除咯——\n![image-20210707231254243](https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231254243.png)\n\n## 5.3 趣味图解\n\n请朋友们移步力扣官方视频，一如既往的给力——\n\nhttps://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\n\n## 5.4 代码演示\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    /**\n    *常规解法\n    */\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        //声明哨兵节点\n        ListNode dummy = new ListNode(0,head);\n        //得到链表长度\n        int length = getlength(head);\n        ListNode prev = dummy;\n        for(int i=1;i<=length-n;i++){\n            prev = prev.next;\n        }\n        prev.next = prev.next.next;\n        return dummy.next;\n    }\n\n    public int getlength(ListNode head){\n        int length = 0;\n        while(head != null){\n            length++;\n            head = head.next;\n        }\n        return length;\n    }\n\t/**\n\t*快慢指针\n\t*/\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        //我们总需要得到待删除节点的前一个节点，对于头结点来说，就需要一个哨兵节点\n        ListNode pummy = new ListNode(0,head);\n        //快慢指针法\n        ListNode slow = pummy;\n        ListNode fast = pummy;\n        //得到超前慢指针n+1个位置的fast指针\n        for(int i=0;i<=n;i++){\n            fast = fast.next;\n        }\n        //slow指针指向要删除的节点的前一个节点\n        while(fast != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        //删除节点\n        ListNode tmp = slow.next;\n        slow.next = tmp.next;\n        tmp.next = null;\n        return pummy.next;\n    }\n}\n```\n\n------\n\n> 山高路远，静水深流\n>\n> 注：补上昨天的，生活和学习的失衡是无可避免的事情，但维系每件重要事情的平衡也同样势在必行，加油吧，时光不问赶路人。\n\n","slug":"链表算法集锦-图文详解哦","published":1,"updated":"2023-09-24T09:50:29.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7m30021xjcc3m1r1upz","content":"<h1 id=\"一、单链表的反转-递归-amp-迭代\"><a href=\"#一、单链表的反转-递归-amp-迭代\" class=\"headerlink\" title=\"一、单链表的反转_递归&amp;迭代\"></a>一、单链表的反转_递归&amp;迭代</h1><h2 id=\"1-1-问题描述\"><a href=\"#1-1-问题描述\" class=\"headerlink\" title=\"1.1 问题描述\"></a>1.1 问题描述</h2><blockquote>\n<p>反转一个单链表。</p>\n<p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>\n</blockquote>\n<h2 id=\"1-2-思路及复杂度分析\"><a href=\"#1-2-思路及复杂度分析\" class=\"headerlink\" title=\"1.2 思路及复杂度分析\"></a>1.2 思路及复杂度分析</h2><p>反转单链表，直观的理解，就是<strong>将每个节点的指针指向它的上一个节点</strong>。显然，这是一个循环操作。而循环操作中除了原生的循环之外，还包括<strong>迭代</strong>和<strong>递归</strong>两种特殊场景下的循环。</p>\n<p>很多人搞不清楚迭代与递归有怎样的爱恨情仇，其实答主同样是如此。我们来迈过这个砍——</p>\n<blockquote>\n<p>迭代与递归都是循环的一种。从代码结构上看，<strong>递归重复调用函数自身。而迭代只是循环代码的一部分</strong>。</p>\n<p>另外，迭代中变量的结果会保存作为下一次循环的初始值。考虑递归时不要为难自己的大脑，想清楚一层就ok了，</p>\n<p>递归本质上就是一个问题的演化。</p>\n</blockquote>\n<p>好了，回归正题。我们首先选择好理解的迭代实现方式。既然需要变后继节点为前驱节点，我们不妨申请两个指针，指针curr指向当前节点，<strong>指针prev指向前驱节点。让curr指向head节点</strong>，而prev自然声明为null。在迭代部分分为两步，<strong>第一步即将当前节点的指针指向上一个节点</strong>，<strong>第二步需要为下一次的迭代变量确定初始值</strong>，具体操作是curr,prev指针均后移即可。迭代部分确定了，我们再来看<strong>边界条件</strong>：这里循环结束的条件比较难确认，需要手绘试一下。最终能同时满足链表长度为空，只有一个元素时代码仍可以正常运行的边界条件是<strong>curr!=null</strong>.</p>\n<p>再来看递归实现，递归的问题规模可能很多，但每一层实际做的不过是调用函数自身。递归的问题我们只需要抓住两个核心点：<strong>递归公式+递归终止条件</strong>。这里的递归终止条件很朴素，也就是head!=null &amp;&amp; head.next!=null.所以我们需要考虑的只有递归公式。假设F表示的是反转关系，则F(n)表示第n层的链表反转，那F(n)可以表示为第n层的头结点与第n-1层反转后的结果整体做反转。有点拗口，我们用数学公式描述一下——<br>$$<br>F(n)=F(head,F(n-1))<br>$$<br>那么这个数学公式用代码怎么转化呢？其实就很简洁了.</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ListNode</span> newHead <span class=\"token operator\">=</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhead<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\nhead<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"1-3-趣味图解\"><a href=\"#1-3-趣味图解\" class=\"headerlink\" title=\"1.3 趣味图解\"></a>1.3 趣味图解</h2><blockquote>\n<p>双指针实现，图来自<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\">https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/</a></p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif\" alt=\"img\"></p>\n<blockquote>\n<p>递归实现，图来自<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\">https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/</a></p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif\" alt=\"img\"></p>\n<h2 id=\"1-4-代码演示\"><a href=\"#1-4-代码演示\" class=\"headerlink\" title=\"1.4 代码演示\"></a>1.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n  Definition for singly-linked list.\n  public class ListNode &#123;\n    int val;\n    ListNode next;\n    ListNode() &#123;&#125;\n    ListNode(int val) &#123; this.val = val; &#125;\n    ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n  &#125;\n */</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">//迭代解法</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//声明两个指针，分别指向当前元素和上一个元素</span>\n   <span class=\"token class-name\">ListNode</span> curr <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">ListNode</span> pre <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>curr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//得到下一次操作的节点</span>\n      <span class=\"token class-name\">ListNode</span> node <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//反转两个节点的指针</span>\n      curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//下一次反转的初始状态</span>\n      pre <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n      curr <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> pre<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token comment\">//递归解法</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">==</span><span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>next<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token class-name\">ListNode</span> newHead <span class=\"token operator\">=</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> newHead<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"二、回文链表的常规与递归解法\"><a href=\"#二、回文链表的常规与递归解法\" class=\"headerlink\" title=\"二、回文链表的常规与递归解法\"></a>二、回文链表的常规与递归解法</h1><h2 id=\"2-1-问题描述\"><a href=\"#2-1-问题描述\" class=\"headerlink\" title=\"2.1 问题描述\"></a>2.1 问题描述</h2><blockquote>\n<p>请判断一个链表是否为回文链表。</p>\n<p>示例 1:</p>\n<p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p>\n<p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n</blockquote>\n<hr>\n<h2 id=\"2-2-思路及复杂度分析\"><a href=\"#2-2-思路及复杂度分析\" class=\"headerlink\" title=\"2.2 思路及复杂度分析\"></a>2.2 思路及复杂度分析</h2><p>老规矩先审题，将链表是否是回文的问题转化一下，即<strong>以中间节点作为分界点，前半部分与后半部分的反转对应节点位置上的数值相同</strong>，显然步骤已经呼之欲出了。但在上手之前，我们有必要先入为主地判断下代码的<strong>执行效率与内存消耗。</strong></p>\n<p>我们知道判断时间复杂度只需要找到<strong>量级最大的代码</strong>就行了。找中间节点使用快慢指针的方式，时间复杂度为O(n).反转代码刚写过，O(n)没意外，比较对应位置上元素是否相等，不严谨的说还是O(n).那空间复杂度呢？</p>\n<p>假如使用递归方式的反转链表，因为要保存局部变量就还会用到栈，不推荐，相对而言，<strong>使用迭代的方式</strong>在运行时不需要额外的空间，所以**空间复杂度为O(1)**，就它了！</p>\n<p>接下来，就是<strong>思路剖析</strong>环节——</p>\n<ol>\n<li>首先找中间节点，无疑使用<strong>快慢指针</strong>的方式。但这里有一个小细节，假如在偶数场景下，我们将中间之前的节点作为中间节点，在后面判断时就会出现<strong>head.next.next</strong>。虽然逻辑满分，但实际运行时非常容易出现空指针错误。所以将中间偏后的节点作为中间节点是首选。</li>\n<li>反转没得说，建议使用<strong>迭代方式</strong>降低内存消耗。</li>\n<li>最终判断环节，显然后半部分是更短的，那循环结束条件自然是满足限制大的，即<strong>满足后半部分边界条件</strong>即可。</li>\n</ol>\n<h3 id=\"递归解法？\"><a href=\"#递归解法？\" class=\"headerlink\" title=\"递归解法？\"></a>递归解法？</h3><p>逛了下leetcode评论区，朋友们清一色的留下&lt;递归，永远的的神&gt;这样的评论。</p>\n<p>我不由得老脸一红，不用递归实现下岂不是没有牌面，那使用递归怎么实现呢？</p>\n<p>在刚看到这道题的时候，相信很多朋友碎碎念，要是用数组实现就舒服了，因为数组能够实现反序遍历，但链表不行，至少严谨的说是这样的。</p>\n<p>诚然，单链表没有前驱指针。但并不是说没有前驱指针链表的反向遍历就不能实现！！！</p>\n<p>前面谈及解决递归问题有两个核心：<strong>递归终止条件和递归公式</strong>。这里，终止条件无疑是<strong>head==null</strong>,。再假设F表示逆序遍历的关系，则第n层的逆序遍历可以表示为：<br>$$<br>F(n)=F(head,F(n-1))<br>$$<br>到这里，非常有必要在纸上画类似这样的一张图——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200323134306815.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1dGhlcks=,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<blockquote>\n<p>图来自 <a href=\"https://blog.csdn.net/LutherK/article/details/105046744\">https://blog.csdn.net/LutherK/article/details/105046744</a></p>\n</blockquote>\n<p>所以对链表的逆序遍历是这样子的——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reverseTraversalListNode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">reverseTraversalListNode</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>那我们只需要在实现逆序遍历的同时判断顺序遍历和逆序遍历对应的值是否相等即可，代码非常简洁，但我写不出来。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231628900.png\" alt=\"image-20210707231628900\"></p>\n<h3 id=\"福利环节\"><a href=\"#福利环节\" class=\"headerlink\" title=\"福利环节\"></a>福利环节</h3><p><img src=\"https://pic2.zhimg.com/80/v2-6b854efd30ba33dbd1d758605fbf7c44_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h2 id=\"3-趣味图解\"><a href=\"#3-趣味图解\" class=\"headerlink\" title=\".3 趣味图解\"></a>.3 趣味图解</h2><blockquote>\n<p>图片来自 ：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/\">https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/</a></p>\n</blockquote>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/234/31.PNG\" alt=\"img\"></p>\n<h2 id=\"2-4-代码演示\"><a href=\"#2-4-代码演示\" class=\"headerlink\" title=\"2.4 代码演示\"></a>2.4 代码演示</h2><h3 id=\"常规解法\"><a href=\"#常规解法\" class=\"headerlink\" title=\"常规解法\"></a>常规解法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">==</span><span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>next<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//偶数和技术确定重点的方式不同，但都使用双指针机制</span>\n        <span class=\"token class-name\">ListNode</span> slow <span class=\"token operator\">=</span> head<span class=\"token punctuation\">,</span>fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fast <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//以中点为界将链表分成两部分</span>\n        fast <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//反转后半部分</span>\n        fast <span class=\"token operator\">=</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span>fast<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//遍历比较</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>val <span class=\"token operator\">!=</span> fast<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            \n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>   \n    <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//声明两个指针，分别指向当前元素和上一个元素</span>\n   <span class=\"token class-name\">ListNode</span> curr <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">ListNode</span> pre <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>curr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//得到下一次操作的节点</span>\n      <span class=\"token class-name\">ListNode</span> node <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//反转两个节点的指针</span>\n      curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//下一次反转的初始状态</span>\n      pre <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n      curr <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> pre<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"迭代解法\"><a href=\"#迭代解法\" class=\"headerlink\" title=\"迭代解法\"></a>迭代解法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ListNode</span> temp<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    temp <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> res <span class=\"token operator\">=</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span>val <span class=\"token operator\">==</span> head<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//顺序遍历的指针指向下一个节点</span>\n    temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"三-、链表是否有环\"><a href=\"#三-、链表是否有环\" class=\"headerlink\" title=\"三 、链表是否有环\"></a>三 、链表是否有环</h1><h2 id=\"3-1-问题描述\"><a href=\"#3-1-问题描述\" class=\"headerlink\" title=\"3.1 问题描述\"></a>3.1 问题描述</h2><blockquote>\n<p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>\n<p>进阶：</p>\n<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>\n<p>示例 1：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210206224828269.png\" alt=\"image-20210206224828269\"></p>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<h2 id=\"3-2-思路及复杂度分析\"><a href=\"#3-2-思路及复杂度分析\" class=\"headerlink\" title=\"3.2 思路及复杂度分析\"></a>3.2 思路及复杂度分析</h2><p>在我看来，解决算法问题<strong>最重要的是对问题的抽象和转化</strong>，那么链表是否有环这个问题要从何下手分析呢？</p>\n<p>链表有环的具体表现为在遍历链表时，对相同的节点会遍历不止一次。所以直观地看，<strong>我们只需要判断在遍历链表时是否有节点被二次遍历即可</strong>，也就是说，我们需要使用<strong>一种可以保证元素唯一性的数据结构</strong>来存顺序添加链表元素，显然，那就是<strong>散列表</strong>咯。</p>\n<p>只是呢，引入散列表会导致空间复杂度为O(n),这可不能入各位看官的法眼。继续出发咯——</p>\n<h3 id=\"快慢指针\"><a href=\"#快慢指针\" class=\"headerlink\" title=\"快慢指针\"></a>快慢指针</h3><p>在初中时，我们经常会碰到相遇问题，这类问题说明了<strong>在一个环形空间中，速度不一致的两个物体总会在某一时刻相遇。</strong></p>\n<p>对应到环形链表，同样如是。</p>\n<p>我们只需声明一个快指针，一个慢指针。快指针每次指向它的后继节点的后继节点。而慢指针只需循规蹈矩地指向它的后继节点即可。在每次遍历的时候都去判断是否出现快慢指针指向一致的情况就ok了。</p>\n<p>在逛leetcode评论区的时候，发现有大佬去测试<strong>不同跳指针的优劣</strong>。对此我个人觉得没有必要，映射到实际问题，要想让两个人尽快相遇，这取决于两个人速度的关系和跑道的长度。抛开跑道长只谈速度的关系意义不大。</p>\n<p>从思路上来说，编写快慢指针的代码很舒服，那它的时间空间复杂度是不是也是如此呢？</p>\n<p>快慢指针的相遇取决于问题的规模N，所以它的<strong>时间复杂度为O(n)</strong>,在代码运行时并不需要申请额外空间，<strong>空间复杂度为O(1)<strong>。nice~ 看起来是要皆大圆满的节奏，</strong>但是从思维挑战来说，故事才刚刚开始</strong>——</p>\n<h3 id=\"链表反转后判断头结点\"><a href=\"#链表反转后判断头结点\" class=\"headerlink\" title=\"链表反转后判断头结点\"></a>链表反转后判断头结点</h3><p>先给出结论：<strong>有环链表反转后头节点与反转前头结点相同</strong>。为了得到这个结论，动手是必然的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231558495.png\" alt=\"image-20210707231558495\"></p>\n<p>在反转的基础上加一个判断就行了。而它的时间空间复杂度自然同反转链表一致，分别为O(n),O(1).</p>\n<p>到这里，才算是皆大圆满了，碎觉觉。可是呢，大晚上的，本来挺困，画完贼精神。算法果然比咖啡管用~</p>\n<p><img src=\"https://image.dbbqb.com/202102062347/23aca80ed56c35ae3c68f96539ccba42/gZ7Xk\" alt=\"img\"></p>\n<h2 id=\"3-3-趣味图解\"><a href=\"#3-3-趣味图解\" class=\"headerlink\" title=\"3.3 趣味图解\"></a>3.3 趣味图解</h2><blockquote>\n<p>图片来自于：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/solution/lian-biao-you-huan-zui-jia-jie-da-by-tinet-shenjg/\">https://leetcode-cn.com/problems/linked-list-cycle/solution/lian-biao-you-huan-zui-jia-jie-da-by-tinet-shenjg/</a></p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/689f74000ab31dfbd492c4ec1a35cf087d0c8797c95472f1f2674743a5b4f444.png\" alt=\"img\"></p>\n<blockquote>\n<p>图片来自于：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/solution/dong-hua-yan-shi-141huan-xing-lian-biao-b99vd/\">https://leetcode-cn.com/problems/linked-list-cycle/solution/dong-hua-yan-shi-141huan-xing-lian-biao-b99vd/</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231530342.png\" alt=\"image-20210707231530342\"></p>\n<h2 id=\"3-4-代码演示\"><a href=\"#3-4-代码演示\" class=\"headerlink\" title=\"3.4 代码演示\"></a>3.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val = x;\n *         next = null;\n *     &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasCycle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//哈希表</span>\n        <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">></span></span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasCycle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//如果链表为空，则不成环</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明一个快指针</span>\n        <span class=\"token class-name\">ListNode</span> fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//快指针走两个格，慢指针走一格，判断能否相遇</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> fast<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasCycle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">==</span><span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>next<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> curr <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> prev <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>curr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//得到要反转的下一个节点</span>\n            <span class=\"token class-name\">ListNode</span> tmp <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//反转</span>\n            curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//得到下一个状态的初始值</span>\n            prev <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n            curr <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//有环的链表反转后头结点与反转前头结点相同</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>prev <span class=\"token operator\">==</span> head<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>  \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"四、合并两个有序链表\"><a href=\"#四、合并两个有序链表\" class=\"headerlink\" title=\"四、合并两个有序链表\"></a>四、合并两个有序链表</h1><hr>\n<h2 id=\"4-1-问题描述\"><a href=\"#4-1-问题描述\" class=\"headerlink\" title=\"4.1 问题描述\"></a>4.1 问题描述</h2><blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231509844.png\" alt=\"image-20210707231509844\"></p>\n</blockquote>\n<h2 id=\"4-2-思路及复杂度分析\"><a href=\"#4-2-思路及复杂度分析\" class=\"headerlink\" title=\"4.2 思路及复杂度分析\"></a>4.2 思路及复杂度分析</h2><p>老规矩，先审题。将两个有序的链表合并为一个有序的链表最直观简洁的方式就是合并链表再排序咯，这样问题就被转化为了排序问题。排序时可以考虑使用原地排序的桶排序算法，时间空间复杂度都为O(n)，效率还是很不错的。</p>\n<p>但排序不是我们的核心内容，至少目前不是。要合并为一个有序的单链表，就必然会涉及<strong>基于遍历的比较</strong>。而遍历链表，也就是循环的实现通常有两种，即迭代和递归。这里两种方法都能实现目标。让我们一探究竟咯——</p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>迭代是我们最长使用的循环方式，再啰嗦下，迭代的典型特点是每次迭代的结果会作为下一次迭代的初始值。</p>\n<p>迭代的内容即是<strong>找出两个链表所比较元素的较小值</strong>，然后需要指针指向这个较小值作为合并后链表的元素。也就是说我们需要一个指针始终指向下一个比较得到的较小值。映射到第一次的比较，就会很明了的想到，需要一个<strong>哨兵节点</strong>。</p>\n<p>那哨兵节点需要满足什么条件呢？<strong>不存储元素且指向为空</strong>。这里有一个<strong>小技巧</strong>，为了不发生空指针错误，我们必须让引用指向一块内存空间。而使用带参数的构造方式时可以<strong>将数据域声明为-1</strong>,也就是不合法的数据，这样就不会干扰数据的正常排序了，当然，即便我们不显示地声明，虚拟机也会将其<strong>默认声明为0</strong>.</p>\n<p>这里还有另一个容易出错的内容，至少在我做的时候排查了很久才发现，那就是迭代部分的循环结束条件。我们在不手绘的情况下，容易先入为主地认为是<strong>l1!=null || l2!=null</strong>,这样想的原因是我们认为当出现一个链表为空后，<strong>哨兵节点</strong>会自然得指向另一个非空的链表，但却忽略了进入循环后仍需要比较，而在l1为空的情况相爱，l1.val会发生什么就显而易见了。</p>\n<p>也就是说，在循环结束后，还需要我们手动将哨兵节点指向非空的链表，这就很容易了：<strong>prev.next = l1==null?l2:l1;</strong></p>\n<p>思路已经很详细了，我们来看下时空复杂度。时间复杂度取决于迭代的次数，显然，迭代的规模也就是需要比较的次数，即<strong>O(n+m)</strong>,而空间的话，只需要<strong>常数的空间</strong>存放元素就ok了，也就是<strong>O(1)</strong>.</p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>题解区对于递归解法的调侃无过于一看全会，一写全废。这说的不就是我嘛。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231456371.png\" alt=\"image-20210707231456371\"></p>\n<p>不可否认，这评价的确很中肯~</p>\n<p>递归的学习是<strong>基于理解和熟练度</strong>的，大多数的题目，都是有迹可循，使用适当的方法论就可以解决的，没有智商差一说。大可不必妄自菲薄。</p>\n<p>老规矩，找<strong>递归公式</strong>和<strong>递归终止条件</strong>。递归终止条件很友好，即**l1==null || l2==null.**而递归公式就需要分析了。合并的问题能否分为子问题 ，子问题的解决方法相同，而且又需要有递和归的演化，就是它咯——<br>$$<br>list1[0]+merge(list1[1:],list2)   list1[0]&lt;list2[0]\\</p>\n<p>list2[0]+merge(list1,list2[1:])otherwise<br>$$<br>搞定了核心的两步，剩下的就只有将<strong>l1/l2.next指向比较结果</strong>这样的边角料了。</p>\n<h2 id=\"4-3-趣味图解\"><a href=\"#4-3-趣味图解\" class=\"headerlink\" title=\"4.3 趣味图解\"></a>4.3 趣味图解</h2><blockquote>\n<p>请大家移步力扣官方题解：<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</a></p>\n</blockquote>\n<p>在链表的章节，一定要保持手绘的习惯！！！图的解释能力比干巴巴的语言要好很多。</p>\n<h2 id=\"4-4-代码演示\"><a href=\"#4-4-代码演示\" class=\"headerlink\" title=\"4.4 代码演示\"></a>4.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> l1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ListNode</span> l2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//特判，如果链表为空，则</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1 <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> l2<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> l1<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token operator\">?</span>l2<span class=\"token operator\">:</span>l1<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">></span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            l2<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">,</span>l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> l2<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n            l1<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span>  <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">,</span>l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> l1<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> l1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ListNode</span> l2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//声明哨兵节点</span>\n        <span class=\"token class-name\">ListNode</span> phread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明一个最终返回的节点</span>\n        <span class=\"token class-name\">ListNode</span> prev <span class=\"token operator\">=</span> phread<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//循环终止条件,手绘一下会发现如果是||会导致空指针</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>l1<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> l2<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;=</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">;</span>\n                l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">;</span>\n                l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            prev <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//合并还有剩余节点的链表</span>\n        prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> l1<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token operator\">?</span>l2<span class=\"token operator\">:</span>l1<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//返回</span>\n        <span class=\"token keyword\">return</span> phread<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"五、-删除链表倒数第N个元素\"><a href=\"#五、-删除链表倒数第N个元素\" class=\"headerlink\" title=\"五、 删除链表倒数第N个元素\"></a>五、 删除链表倒数第N个元素</h1><h2 id=\"5-1-问题描述\"><a href=\"#5-1-问题描述\" class=\"headerlink\" title=\"5.1 问题描述\"></a>5.1 问题描述</h2><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231440028.png\" alt=\"image-20210707231440028\"></p>\n<h2 id=\"5-2-思路及复杂度分析\"><a href=\"#5-2-思路及复杂度分析\" class=\"headerlink\" title=\"5.2 思路及复杂度分析\"></a>5.2 思路及复杂度分析</h2><p>老规矩，先审题。要删除链表的某个元素，我们<strong>必须知道它的前驱节点</strong>，所以不管哪种解法，<strong>哨兵节点</strong>的添加都可以简化解题流程。</p>\n<p>最直观的解法解法无过于将问题转化为<strong>删除链表第length-n+1个元素</strong>。我们不妨称之为朴素的解法。</p>\n<h3 id=\"朴素解法\"><a href=\"#朴素解法\" class=\"headerlink\" title=\"朴素解法\"></a>朴素解法</h3><p>问题转化以后，思路就变得很明晰了。首先我们需要遍历得到链表的长度。然后，既然要删除链表的第length-n+1个元素，显然<strong>首先需要得到第length-n个元素</strong>。而链表是没有下标的，所以我们要维护一个计数器。然后遍历链表，计数器递增，当计数器的值等于length-n时，我们记录下当前指针指向的元素，也就是待删除节点的上一个节点。最后删除返回链表就ok了。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png\" alt=\"image-20210707231423480\"></p>\n<h3 id=\"快慢指针-1\"><a href=\"#快慢指针-1\" class=\"headerlink\" title=\"快慢指针\"></a>快慢指针</h3><p>在聊快慢指针之前，我们有必要先了解一下什么是<strong>模式识别</strong>。</p>\n<blockquote>\n<p>所谓模式识别的问题就是用计算的方法根据样本的<strong>特征</strong>将样本划分到一定的<strong>类别</strong>中去。</p>\n</blockquote>\n<p>这不就是数据挖掘中的<strong>分类问题</strong>吗？的确，算法的解决很多都要基于<strong>方法论</strong>。</p>\n<p>那对于删除倒数第N个节点，我们可以提取出什么模式呢——</p>\n<ul>\n<li><code>需要得到前驱节点</code>：哨兵节点</li>\n<li><code>需要定位确切位置的节点</code>：快慢指针</li>\n</ul>\n<p>讲真，九年义务教育我们最大的成果就是通过思考得到模式，再按照模式做题，但可笑的是，当我们在之后所谓的深造中，却将最大的财富抛在脑后，真是可怜至极。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png\" alt=\"image-20210707231355517\"></p>\n<p>好啦，言归正传。哨兵节点就不再赘述了。如何通过快慢指针找到要删除节点的前一个节点呢？</p>\n<p>开局一张图~</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231338256.png\" alt=\"image-20210707231338256\"></p>\n<p>也就是说，快指针的初始位置为<strong>慢指针向前移动n+1个位置</strong>。然后遍历链表，移动快慢指针，确定慢指针的位置。最后，就是删除咯——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231254243.png\" alt=\"image-20210707231254243\"></p>\n<h2 id=\"5-3-趣味图解\"><a href=\"#5-3-趣味图解\" class=\"headerlink\" title=\"5.3 趣味图解\"></a>5.3 趣味图解</h2><p>请朋友们移步力扣官方视频，一如既往的给力——</p>\n<p><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</a></p>\n<h2 id=\"5-4-代码演示\"><a href=\"#5-4-代码演示\" class=\"headerlink\" title=\"5.4 代码演示\"></a>5.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/**\n    *常规解法\n    */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">removeNthFromEnd</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//声明哨兵节点</span>\n        <span class=\"token class-name\">ListNode</span> dummy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//得到链表长度</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> <span class=\"token function\">getlength</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> prev <span class=\"token operator\">=</span> dummy<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>length<span class=\"token operator\">-</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            prev <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getlength</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            length<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> length<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token comment\">/**\n\t*快慢指针\n\t*/</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">removeNthFromEnd</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//我们总需要得到待删除节点的前一个节点，对于头结点来说，就需要一个哨兵节点</span>\n        <span class=\"token class-name\">ListNode</span> pummy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//快慢指针法</span>\n        <span class=\"token class-name\">ListNode</span> slow <span class=\"token operator\">=</span> pummy<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> fast <span class=\"token operator\">=</span> pummy<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//得到超前慢指针n+1个位置的fast指针</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//slow指针指向要删除的节点的前一个节点</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//删除节点</span>\n        <span class=\"token class-name\">ListNode</span> tmp <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        slow<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        tmp<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> pummy<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n<p>注：补上昨天的，生活和学习的失衡是无可避免的事情，但维系每件重要事情的平衡也同样势在必行，加油吧，时光不问赶路人。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、单链表的反转-递归-amp-迭代\"><a href=\"#一、单链表的反转-递归-amp-迭代\" class=\"headerlink\" title=\"一、单链表的反转_递归&amp;迭代\"></a>一、单链表的反转_递归&amp;迭代</h1><h2 id=\"1-1-问题描述\"><a href=\"#1-1-问题描述\" class=\"headerlink\" title=\"1.1 问题描述\"></a>1.1 问题描述</h2><blockquote>\n<p>反转一个单链表。</p>\n<p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>\n</blockquote>\n<h2 id=\"1-2-思路及复杂度分析\"><a href=\"#1-2-思路及复杂度分析\" class=\"headerlink\" title=\"1.2 思路及复杂度分析\"></a>1.2 思路及复杂度分析</h2><p>反转单链表，直观的理解，就是<strong>将每个节点的指针指向它的上一个节点</strong>。显然，这是一个循环操作。而循环操作中除了原生的循环之外，还包括<strong>迭代</strong>和<strong>递归</strong>两种特殊场景下的循环。</p>\n<p>很多人搞不清楚迭代与递归有怎样的爱恨情仇，其实答主同样是如此。我们来迈过这个砍——</p>\n<blockquote>\n<p>迭代与递归都是循环的一种。从代码结构上看，<strong>递归重复调用函数自身。而迭代只是循环代码的一部分</strong>。</p>\n<p>另外，迭代中变量的结果会保存作为下一次循环的初始值。考虑递归时不要为难自己的大脑，想清楚一层就ok了，</p>\n<p>递归本质上就是一个问题的演化。</p>\n</blockquote>\n<p>好了，回归正题。我们首先选择好理解的迭代实现方式。既然需要变后继节点为前驱节点，我们不妨申请两个指针，指针curr指向当前节点，<strong>指针prev指向前驱节点。让curr指向head节点</strong>，而prev自然声明为null。在迭代部分分为两步，<strong>第一步即将当前节点的指针指向上一个节点</strong>，<strong>第二步需要为下一次的迭代变量确定初始值</strong>，具体操作是curr,prev指针均后移即可。迭代部分确定了，我们再来看<strong>边界条件</strong>：这里循环结束的条件比较难确认，需要手绘试一下。最终能同时满足链表长度为空，只有一个元素时代码仍可以正常运行的边界条件是<strong>curr!=null</strong>.</p>\n<p>再来看递归实现，递归的问题规模可能很多，但每一层实际做的不过是调用函数自身。递归的问题我们只需要抓住两个核心点：<strong>递归公式+递归终止条件</strong>。这里的递归终止条件很朴素，也就是head!=null &amp;&amp; head.next!=null.所以我们需要考虑的只有递归公式。假设F表示的是反转关系，则F(n)表示第n层的链表反转，那F(n)可以表示为第n层的头结点与第n-1层反转后的结果整体做反转。有点拗口，我们用数学公式描述一下——<br>$$<br>F(n)=F(head,F(n-1))<br>$$<br>那么这个数学公式用代码怎么转化呢？其实就很简洁了.</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ListNode</span> newHead <span class=\"token operator\">=</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhead<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\nhead<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"1-3-趣味图解\"><a href=\"#1-3-趣味图解\" class=\"headerlink\" title=\"1.3 趣味图解\"></a>1.3 趣味图解</h2><blockquote>\n<p>双指针实现，图来自<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\">https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/</a></p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif\" alt=\"img\"></p>\n<blockquote>\n<p>递归实现，图来自<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\">https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/</a></p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif\" alt=\"img\"></p>\n<h2 id=\"1-4-代码演示\"><a href=\"#1-4-代码演示\" class=\"headerlink\" title=\"1.4 代码演示\"></a>1.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n  Definition for singly-linked list.\n  public class ListNode &#123;\n    int val;\n    ListNode next;\n    ListNode() &#123;&#125;\n    ListNode(int val) &#123; this.val = val; &#125;\n    ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n  &#125;\n */</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">//迭代解法</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//声明两个指针，分别指向当前元素和上一个元素</span>\n   <span class=\"token class-name\">ListNode</span> curr <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">ListNode</span> pre <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>curr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//得到下一次操作的节点</span>\n      <span class=\"token class-name\">ListNode</span> node <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//反转两个节点的指针</span>\n      curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//下一次反转的初始状态</span>\n      pre <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n      curr <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> pre<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token comment\">//递归解法</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">==</span><span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>next<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token class-name\">ListNode</span> newHead <span class=\"token operator\">=</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> newHead<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"二、回文链表的常规与递归解法\"><a href=\"#二、回文链表的常规与递归解法\" class=\"headerlink\" title=\"二、回文链表的常规与递归解法\"></a>二、回文链表的常规与递归解法</h1><h2 id=\"2-1-问题描述\"><a href=\"#2-1-问题描述\" class=\"headerlink\" title=\"2.1 问题描述\"></a>2.1 问题描述</h2><blockquote>\n<p>请判断一个链表是否为回文链表。</p>\n<p>示例 1:</p>\n<p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p>\n<p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n</blockquote>\n<hr>\n<h2 id=\"2-2-思路及复杂度分析\"><a href=\"#2-2-思路及复杂度分析\" class=\"headerlink\" title=\"2.2 思路及复杂度分析\"></a>2.2 思路及复杂度分析</h2><p>老规矩先审题，将链表是否是回文的问题转化一下，即<strong>以中间节点作为分界点，前半部分与后半部分的反转对应节点位置上的数值相同</strong>，显然步骤已经呼之欲出了。但在上手之前，我们有必要先入为主地判断下代码的<strong>执行效率与内存消耗。</strong></p>\n<p>我们知道判断时间复杂度只需要找到<strong>量级最大的代码</strong>就行了。找中间节点使用快慢指针的方式，时间复杂度为O(n).反转代码刚写过，O(n)没意外，比较对应位置上元素是否相等，不严谨的说还是O(n).那空间复杂度呢？</p>\n<p>假如使用递归方式的反转链表，因为要保存局部变量就还会用到栈，不推荐，相对而言，<strong>使用迭代的方式</strong>在运行时不需要额外的空间，所以**空间复杂度为O(1)**，就它了！</p>\n<p>接下来，就是<strong>思路剖析</strong>环节——</p>\n<ol>\n<li>首先找中间节点，无疑使用<strong>快慢指针</strong>的方式。但这里有一个小细节，假如在偶数场景下，我们将中间之前的节点作为中间节点，在后面判断时就会出现<strong>head.next.next</strong>。虽然逻辑满分，但实际运行时非常容易出现空指针错误。所以将中间偏后的节点作为中间节点是首选。</li>\n<li>反转没得说，建议使用<strong>迭代方式</strong>降低内存消耗。</li>\n<li>最终判断环节，显然后半部分是更短的，那循环结束条件自然是满足限制大的，即<strong>满足后半部分边界条件</strong>即可。</li>\n</ol>\n<h3 id=\"递归解法？\"><a href=\"#递归解法？\" class=\"headerlink\" title=\"递归解法？\"></a>递归解法？</h3><p>逛了下leetcode评论区，朋友们清一色的留下&lt;递归，永远的的神&gt;这样的评论。</p>\n<p>我不由得老脸一红，不用递归实现下岂不是没有牌面，那使用递归怎么实现呢？</p>\n<p>在刚看到这道题的时候，相信很多朋友碎碎念，要是用数组实现就舒服了，因为数组能够实现反序遍历，但链表不行，至少严谨的说是这样的。</p>\n<p>诚然，单链表没有前驱指针。但并不是说没有前驱指针链表的反向遍历就不能实现！！！</p>\n<p>前面谈及解决递归问题有两个核心：<strong>递归终止条件和递归公式</strong>。这里，终止条件无疑是<strong>head==null</strong>,。再假设F表示逆序遍历的关系，则第n层的逆序遍历可以表示为：<br>$$<br>F(n)=F(head,F(n-1))<br>$$<br>到这里，非常有必要在纸上画类似这样的一张图——</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200323134306815.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1dGhlcks=,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<blockquote>\n<p>图来自 <a href=\"https://blog.csdn.net/LutherK/article/details/105046744\">https://blog.csdn.net/LutherK/article/details/105046744</a></p>\n</blockquote>\n<p>所以对链表的逆序遍历是这样子的——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reverseTraversalListNode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">reverseTraversalListNode</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>那我们只需要在实现逆序遍历的同时判断顺序遍历和逆序遍历对应的值是否相等即可，代码非常简洁，但我写不出来。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231628900.png\" alt=\"image-20210707231628900\"></p>\n<h3 id=\"福利环节\"><a href=\"#福利环节\" class=\"headerlink\" title=\"福利环节\"></a>福利环节</h3><p><img src=\"https://pic2.zhimg.com/80/v2-6b854efd30ba33dbd1d758605fbf7c44_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h2 id=\"3-趣味图解\"><a href=\"#3-趣味图解\" class=\"headerlink\" title=\".3 趣味图解\"></a>.3 趣味图解</h2><blockquote>\n<p>图片来自 ：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/\">https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/</a></p>\n</blockquote>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/234/31.PNG\" alt=\"img\"></p>\n<h2 id=\"2-4-代码演示\"><a href=\"#2-4-代码演示\" class=\"headerlink\" title=\"2.4 代码演示\"></a>2.4 代码演示</h2><h3 id=\"常规解法\"><a href=\"#常规解法\" class=\"headerlink\" title=\"常规解法\"></a>常规解法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">==</span><span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>next<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//偶数和技术确定重点的方式不同，但都使用双指针机制</span>\n        <span class=\"token class-name\">ListNode</span> slow <span class=\"token operator\">=</span> head<span class=\"token punctuation\">,</span>fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fast <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//以中点为界将链表分成两部分</span>\n        fast <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//反转后半部分</span>\n        fast <span class=\"token operator\">=</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span>fast<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//遍历比较</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>val <span class=\"token operator\">!=</span> fast<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            \n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>   \n    <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//声明两个指针，分别指向当前元素和上一个元素</span>\n   <span class=\"token class-name\">ListNode</span> curr <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">ListNode</span> pre <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>curr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//得到下一次操作的节点</span>\n      <span class=\"token class-name\">ListNode</span> node <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//反转两个节点的指针</span>\n      curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//下一次反转的初始状态</span>\n      pre <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n      curr <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> pre<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"迭代解法\"><a href=\"#迭代解法\" class=\"headerlink\" title=\"迭代解法\"></a>迭代解法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ListNode</span> temp<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    temp <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> res <span class=\"token operator\">=</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span>val <span class=\"token operator\">==</span> head<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//顺序遍历的指针指向下一个节点</span>\n    temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"三-、链表是否有环\"><a href=\"#三-、链表是否有环\" class=\"headerlink\" title=\"三 、链表是否有环\"></a>三 、链表是否有环</h1><h2 id=\"3-1-问题描述\"><a href=\"#3-1-问题描述\" class=\"headerlink\" title=\"3.1 问题描述\"></a>3.1 问题描述</h2><blockquote>\n<p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>\n<p>进阶：</p>\n<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>\n<p>示例 1：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210206224828269.png\" alt=\"image-20210206224828269\"></p>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<h2 id=\"3-2-思路及复杂度分析\"><a href=\"#3-2-思路及复杂度分析\" class=\"headerlink\" title=\"3.2 思路及复杂度分析\"></a>3.2 思路及复杂度分析</h2><p>在我看来，解决算法问题<strong>最重要的是对问题的抽象和转化</strong>，那么链表是否有环这个问题要从何下手分析呢？</p>\n<p>链表有环的具体表现为在遍历链表时，对相同的节点会遍历不止一次。所以直观地看，<strong>我们只需要判断在遍历链表时是否有节点被二次遍历即可</strong>，也就是说，我们需要使用<strong>一种可以保证元素唯一性的数据结构</strong>来存顺序添加链表元素，显然，那就是<strong>散列表</strong>咯。</p>\n<p>只是呢，引入散列表会导致空间复杂度为O(n),这可不能入各位看官的法眼。继续出发咯——</p>\n<h3 id=\"快慢指针\"><a href=\"#快慢指针\" class=\"headerlink\" title=\"快慢指针\"></a>快慢指针</h3><p>在初中时，我们经常会碰到相遇问题，这类问题说明了<strong>在一个环形空间中，速度不一致的两个物体总会在某一时刻相遇。</strong></p>\n<p>对应到环形链表，同样如是。</p>\n<p>我们只需声明一个快指针，一个慢指针。快指针每次指向它的后继节点的后继节点。而慢指针只需循规蹈矩地指向它的后继节点即可。在每次遍历的时候都去判断是否出现快慢指针指向一致的情况就ok了。</p>\n<p>在逛leetcode评论区的时候，发现有大佬去测试<strong>不同跳指针的优劣</strong>。对此我个人觉得没有必要，映射到实际问题，要想让两个人尽快相遇，这取决于两个人速度的关系和跑道的长度。抛开跑道长只谈速度的关系意义不大。</p>\n<p>从思路上来说，编写快慢指针的代码很舒服，那它的时间空间复杂度是不是也是如此呢？</p>\n<p>快慢指针的相遇取决于问题的规模N，所以它的<strong>时间复杂度为O(n)</strong>,在代码运行时并不需要申请额外空间，<strong>空间复杂度为O(1)<strong>。nice~ 看起来是要皆大圆满的节奏，</strong>但是从思维挑战来说，故事才刚刚开始</strong>——</p>\n<h3 id=\"链表反转后判断头结点\"><a href=\"#链表反转后判断头结点\" class=\"headerlink\" title=\"链表反转后判断头结点\"></a>链表反转后判断头结点</h3><p>先给出结论：<strong>有环链表反转后头节点与反转前头结点相同</strong>。为了得到这个结论，动手是必然的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231558495.png\" alt=\"image-20210707231558495\"></p>\n<p>在反转的基础上加一个判断就行了。而它的时间空间复杂度自然同反转链表一致，分别为O(n),O(1).</p>\n<p>到这里，才算是皆大圆满了，碎觉觉。可是呢，大晚上的，本来挺困，画完贼精神。算法果然比咖啡管用~</p>\n<p><img src=\"https://image.dbbqb.com/202102062347/23aca80ed56c35ae3c68f96539ccba42/gZ7Xk\" alt=\"img\"></p>\n<h2 id=\"3-3-趣味图解\"><a href=\"#3-3-趣味图解\" class=\"headerlink\" title=\"3.3 趣味图解\"></a>3.3 趣味图解</h2><blockquote>\n<p>图片来自于：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/solution/lian-biao-you-huan-zui-jia-jie-da-by-tinet-shenjg/\">https://leetcode-cn.com/problems/linked-list-cycle/solution/lian-biao-you-huan-zui-jia-jie-da-by-tinet-shenjg/</a></p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/689f74000ab31dfbd492c4ec1a35cf087d0c8797c95472f1f2674743a5b4f444.png\" alt=\"img\"></p>\n<blockquote>\n<p>图片来自于：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/solution/dong-hua-yan-shi-141huan-xing-lian-biao-b99vd/\">https://leetcode-cn.com/problems/linked-list-cycle/solution/dong-hua-yan-shi-141huan-xing-lian-biao-b99vd/</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231530342.png\" alt=\"image-20210707231530342\"></p>\n<h2 id=\"3-4-代码演示\"><a href=\"#3-4-代码演示\" class=\"headerlink\" title=\"3.4 代码演示\"></a>3.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val = x;\n *         next = null;\n *     &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasCycle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//哈希表</span>\n        <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">></span></span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasCycle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//如果链表为空，则不成环</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明一个快指针</span>\n        <span class=\"token class-name\">ListNode</span> fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//快指针走两个格，慢指针走一格，判断能否相遇</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> fast<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasCycle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">==</span><span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>next<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> curr <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> prev <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>curr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//得到要反转的下一个节点</span>\n            <span class=\"token class-name\">ListNode</span> tmp <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//反转</span>\n            curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//得到下一个状态的初始值</span>\n            prev <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n            curr <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//有环的链表反转后头结点与反转前头结点相同</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>prev <span class=\"token operator\">==</span> head<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>  \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"四、合并两个有序链表\"><a href=\"#四、合并两个有序链表\" class=\"headerlink\" title=\"四、合并两个有序链表\"></a>四、合并两个有序链表</h1><hr>\n<h2 id=\"4-1-问题描述\"><a href=\"#4-1-问题描述\" class=\"headerlink\" title=\"4.1 问题描述\"></a>4.1 问题描述</h2><blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231509844.png\" alt=\"image-20210707231509844\"></p>\n</blockquote>\n<h2 id=\"4-2-思路及复杂度分析\"><a href=\"#4-2-思路及复杂度分析\" class=\"headerlink\" title=\"4.2 思路及复杂度分析\"></a>4.2 思路及复杂度分析</h2><p>老规矩，先审题。将两个有序的链表合并为一个有序的链表最直观简洁的方式就是合并链表再排序咯，这样问题就被转化为了排序问题。排序时可以考虑使用原地排序的桶排序算法，时间空间复杂度都为O(n)，效率还是很不错的。</p>\n<p>但排序不是我们的核心内容，至少目前不是。要合并为一个有序的单链表，就必然会涉及<strong>基于遍历的比较</strong>。而遍历链表，也就是循环的实现通常有两种，即迭代和递归。这里两种方法都能实现目标。让我们一探究竟咯——</p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>迭代是我们最长使用的循环方式，再啰嗦下，迭代的典型特点是每次迭代的结果会作为下一次迭代的初始值。</p>\n<p>迭代的内容即是<strong>找出两个链表所比较元素的较小值</strong>，然后需要指针指向这个较小值作为合并后链表的元素。也就是说我们需要一个指针始终指向下一个比较得到的较小值。映射到第一次的比较，就会很明了的想到，需要一个<strong>哨兵节点</strong>。</p>\n<p>那哨兵节点需要满足什么条件呢？<strong>不存储元素且指向为空</strong>。这里有一个<strong>小技巧</strong>，为了不发生空指针错误，我们必须让引用指向一块内存空间。而使用带参数的构造方式时可以<strong>将数据域声明为-1</strong>,也就是不合法的数据，这样就不会干扰数据的正常排序了，当然，即便我们不显示地声明，虚拟机也会将其<strong>默认声明为0</strong>.</p>\n<p>这里还有另一个容易出错的内容，至少在我做的时候排查了很久才发现，那就是迭代部分的循环结束条件。我们在不手绘的情况下，容易先入为主地认为是<strong>l1!=null || l2!=null</strong>,这样想的原因是我们认为当出现一个链表为空后，<strong>哨兵节点</strong>会自然得指向另一个非空的链表，但却忽略了进入循环后仍需要比较，而在l1为空的情况相爱，l1.val会发生什么就显而易见了。</p>\n<p>也就是说，在循环结束后，还需要我们手动将哨兵节点指向非空的链表，这就很容易了：<strong>prev.next = l1==null?l2:l1;</strong></p>\n<p>思路已经很详细了，我们来看下时空复杂度。时间复杂度取决于迭代的次数，显然，迭代的规模也就是需要比较的次数，即<strong>O(n+m)</strong>,而空间的话，只需要<strong>常数的空间</strong>存放元素就ok了，也就是<strong>O(1)</strong>.</p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>题解区对于递归解法的调侃无过于一看全会，一写全废。这说的不就是我嘛。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231456371.png\" alt=\"image-20210707231456371\"></p>\n<p>不可否认，这评价的确很中肯~</p>\n<p>递归的学习是<strong>基于理解和熟练度</strong>的，大多数的题目，都是有迹可循，使用适当的方法论就可以解决的，没有智商差一说。大可不必妄自菲薄。</p>\n<p>老规矩，找<strong>递归公式</strong>和<strong>递归终止条件</strong>。递归终止条件很友好，即**l1==null || l2==null.**而递归公式就需要分析了。合并的问题能否分为子问题 ，子问题的解决方法相同，而且又需要有递和归的演化，就是它咯——<br>$$<br>list1[0]+merge(list1[1:],list2)   list1[0]&lt;list2[0]\\</p>\n<p>list2[0]+merge(list1,list2[1:])otherwise<br>$$<br>搞定了核心的两步，剩下的就只有将<strong>l1/l2.next指向比较结果</strong>这样的边角料了。</p>\n<h2 id=\"4-3-趣味图解\"><a href=\"#4-3-趣味图解\" class=\"headerlink\" title=\"4.3 趣味图解\"></a>4.3 趣味图解</h2><blockquote>\n<p>请大家移步力扣官方题解：<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</a></p>\n</blockquote>\n<p>在链表的章节，一定要保持手绘的习惯！！！图的解释能力比干巴巴的语言要好很多。</p>\n<h2 id=\"4-4-代码演示\"><a href=\"#4-4-代码演示\" class=\"headerlink\" title=\"4.4 代码演示\"></a>4.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> l1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ListNode</span> l2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//特判，如果链表为空，则</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1 <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> l2<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> l1<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token operator\">?</span>l2<span class=\"token operator\">:</span>l1<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">></span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            l2<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">,</span>l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> l2<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n            l1<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span>  <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">,</span>l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> l1<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> l1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ListNode</span> l2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//声明哨兵节点</span>\n        <span class=\"token class-name\">ListNode</span> phread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//声明一个最终返回的节点</span>\n        <span class=\"token class-name\">ListNode</span> prev <span class=\"token operator\">=</span> phread<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//循环终止条件,手绘一下会发现如果是||会导致空指针</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>l1<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> l2<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;=</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">;</span>\n                l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n                prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">;</span>\n                l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            prev <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//合并还有剩余节点的链表</span>\n        prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> l1<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token operator\">?</span>l2<span class=\"token operator\">:</span>l1<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//返回</span>\n        <span class=\"token keyword\">return</span> phread<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h1 id=\"五、-删除链表倒数第N个元素\"><a href=\"#五、-删除链表倒数第N个元素\" class=\"headerlink\" title=\"五、 删除链表倒数第N个元素\"></a>五、 删除链表倒数第N个元素</h1><h2 id=\"5-1-问题描述\"><a href=\"#5-1-问题描述\" class=\"headerlink\" title=\"5.1 问题描述\"></a>5.1 问题描述</h2><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231440028.png\" alt=\"image-20210707231440028\"></p>\n<h2 id=\"5-2-思路及复杂度分析\"><a href=\"#5-2-思路及复杂度分析\" class=\"headerlink\" title=\"5.2 思路及复杂度分析\"></a>5.2 思路及复杂度分析</h2><p>老规矩，先审题。要删除链表的某个元素，我们<strong>必须知道它的前驱节点</strong>，所以不管哪种解法，<strong>哨兵节点</strong>的添加都可以简化解题流程。</p>\n<p>最直观的解法解法无过于将问题转化为<strong>删除链表第length-n+1个元素</strong>。我们不妨称之为朴素的解法。</p>\n<h3 id=\"朴素解法\"><a href=\"#朴素解法\" class=\"headerlink\" title=\"朴素解法\"></a>朴素解法</h3><p>问题转化以后，思路就变得很明晰了。首先我们需要遍历得到链表的长度。然后，既然要删除链表的第length-n+1个元素，显然<strong>首先需要得到第length-n个元素</strong>。而链表是没有下标的，所以我们要维护一个计数器。然后遍历链表，计数器递增，当计数器的值等于length-n时，我们记录下当前指针指向的元素，也就是待删除节点的上一个节点。最后删除返回链表就ok了。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png\" alt=\"image-20210707231423480\"></p>\n<h3 id=\"快慢指针-1\"><a href=\"#快慢指针-1\" class=\"headerlink\" title=\"快慢指针\"></a>快慢指针</h3><p>在聊快慢指针之前，我们有必要先了解一下什么是<strong>模式识别</strong>。</p>\n<blockquote>\n<p>所谓模式识别的问题就是用计算的方法根据样本的<strong>特征</strong>将样本划分到一定的<strong>类别</strong>中去。</p>\n</blockquote>\n<p>这不就是数据挖掘中的<strong>分类问题</strong>吗？的确，算法的解决很多都要基于<strong>方法论</strong>。</p>\n<p>那对于删除倒数第N个节点，我们可以提取出什么模式呢——</p>\n<ul>\n<li><code>需要得到前驱节点</code>：哨兵节点</li>\n<li><code>需要定位确切位置的节点</code>：快慢指针</li>\n</ul>\n<p>讲真，九年义务教育我们最大的成果就是通过思考得到模式，再按照模式做题，但可笑的是，当我们在之后所谓的深造中，却将最大的财富抛在脑后，真是可怜至极。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231423480.png\" alt=\"image-20210707231355517\"></p>\n<p>好啦，言归正传。哨兵节点就不再赘述了。如何通过快慢指针找到要删除节点的前一个节点呢？</p>\n<p>开局一张图~</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231338256.png\" alt=\"image-20210707231338256\"></p>\n<p>也就是说，快指针的初始位置为<strong>慢指针向前移动n+1个位置</strong>。然后遍历链表，移动快慢指针，确定慢指针的位置。最后，就是删除咯——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img4/image-20210707231254243.png\" alt=\"image-20210707231254243\"></p>\n<h2 id=\"5-3-趣味图解\"><a href=\"#5-3-趣味图解\" class=\"headerlink\" title=\"5.3 趣味图解\"></a>5.3 趣味图解</h2><p>请朋友们移步力扣官方视频，一如既往的给力——</p>\n<p><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</a></p>\n<h2 id=\"5-4-代码演示\"><a href=\"#5-4-代码演示\" class=\"headerlink\" title=\"5.4 代码演示\"></a>5.4 代码演示</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/**\n    *常规解法\n    */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">removeNthFromEnd</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//声明哨兵节点</span>\n        <span class=\"token class-name\">ListNode</span> dummy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//得到链表长度</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> <span class=\"token function\">getlength</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> prev <span class=\"token operator\">=</span> dummy<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>length<span class=\"token operator\">-</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            prev <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getlength</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            length<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> length<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token comment\">/**\n\t*快慢指针\n\t*/</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ListNode</span> <span class=\"token function\">removeNthFromEnd</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListNode</span> head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//我们总需要得到待删除节点的前一个节点，对于头结点来说，就需要一个哨兵节点</span>\n        <span class=\"token class-name\">ListNode</span> pummy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//快慢指针法</span>\n        <span class=\"token class-name\">ListNode</span> slow <span class=\"token operator\">=</span> pummy<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ListNode</span> fast <span class=\"token operator\">=</span> pummy<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//得到超前慢指针n+1个位置的fast指针</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//slow指针指向要删除的节点的前一个节点</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//删除节点</span>\n        <span class=\"token class-name\">ListNode</span> tmp <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        slow<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        tmp<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> pummy<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n<p>注：补上昨天的，生活和学习的失衡是无可避免的事情，但维系每件重要事情的平衡也同样势在必行，加油吧，时光不问赶路人。</p>\n</blockquote>\n"},{"title":"java多线程的前世今生","top":true,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T07:45:51.000Z","password":null,"summary":null,"_content":"\n## 前言\n\n一个多月没写过博文了，不是没有**值得记录的故事**，确是静不下心。网申在即，靠目前的积淀，知识地图中缺了一大块，索性打消了网申的念头。但不免有些落寞，像极了**落跑的小橘子**。\n\n这个`时代越来越卷了`，但也正因如此，我才更信奉积淀的魅力，这也正是我整理心态，继续出发的缘由。\n\n这不是第一次学习多线程了，在自学时，培训班上都接触过多线程，但都只是浅尝辄止，这次咬定青山不放松，终于**顿悟了一些关键的知识**，恍然间柳暗花明，便有了这篇文章。\n\n------\n\n## 多线程——入门\n\n在操作系统中，我们了解到，**多进程图像**是操作系统最核心，最基础的图像。而用户通过系统调用的方式间接与操作系统交互。想象这样一种场景，我们一边放着音乐，一边浏览网页——\n\n![image-20210327092252968](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327092252968.png)\n\n这就是触目可及的多进程图像，显然，这两个进程之间使用的是不同的资源，不妨假设我的处理器是单核的，每一时刻只能处理一个进程，那`CPU就要为两个进程分配时间片`，然后根据调度算法切换进程，串行执行。\n\n如何切换进程呢？首先要理解进程是什么——\n\n![image-20210619000547145](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619000547145.png)\n\n也就是说，进程就是：**指令执行序列+资源**，因此直观的切换进程就是切换进程的这两部分，但资源的切换是非常浪费时间的，能不能`只切换指令执行序列`呢？聊到这，小伙伴就有了这样的猜想：指令执行序列与线程有什么关系呢？\n\n没错，**指令执行序列就是线程集**。我们深入到进程中找找，就会发现线程集没有我们想象中的那么遥不可及——\n\n![image-20210327094410019](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327094410019.png)\n\n下载听歌两不误，如此丝滑的切换，都得益于**线程的并发应用**。也就是多线程咯。到这里，故事才真正的拉开序幕——\n\n------\n\n### 1.进程与线程\n\n前面提到的都是直观的印象，这里由表及内地聊聊进程与线程——\n\n- `进程： `进程是**上下文切换之间的程序执行的部分**，而所谓上下文，即是`CPU与寄存器`。通俗地说，也就是说进程执行的环境。在这个环境下运行着的程序即是进程。\n- `线程： `线程是**轻量级的进程**，这里的轻量级如何理解呢？`线程集`共享了进程的`上下文环境，地址空间，更为细小的CPU时间片`。\n\n对于如何更好地理解进程与线程之间的关系，有大佬已经讲的非常形象了，我们不妨站在巨人的肩膀上——\n\n- [x] [将进程比作火车，线程比作车厢](https://www.zhihu.com/question/25532384)\n\n------\n\n### 2.所谓多线程\n\n在讲述多线程之前，非常有必要搞懂这几个概念——\n\n- `并发`：一些任务都处于可运行的状态，但只有一个任务可以被调度并执行，而具体是哪一个任务被处理仍是不确定的。\n\n- `串行与并行`\n\n  1. 多任务中**某时刻**只能有一个任务被运行，单核下皆为串行；\n  2. 某时刻可以有多个任务同时被执行，在多核计算机上可以实现并行；\n\n- `阻塞与非阻塞`：\n\n  1. 以文件读取为例，应用层会调用系统内核中的IO接口，如open，close等，在请求发出以后，如果调用的是**阻塞型IO**，应用层被挂起，一直处于等待数据返回的状态。直到从磁盘上读取数据并返回给应用层后，应用层采用获取到的数据进行下一步操作；\n  2. 如果应用层调用的是**非阻塞I/O**，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。\n\n  也就是说阻塞与非阻塞的区别在于**发出请求后等待数据返回时的状态**。\n\n- `同步与异步`：\n\n  - 阻塞与非阻塞决定了应用层等待数据返回的状态，而**数据如何从系统内核返回**呢？返回的方式取决于同步与异步——\n  - 对于同步型的调用，应用层会不**断问询系统内核**，但它的动作取决于是否阻塞，数据返回给应用层后，应用层继续做其他的事情；\n  - 对于异步型的调用，应用层**不关心数据何时返回**，此时它的动作同样却绝育是否阻塞，系统内核会主动通知应用层数据已经读取完毕并返回。\n\n------\n\n好啦，啰嗦了这么多，也该祭出这张图了——\n\n![image-20210327104345505](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327104345505.png)\n\n用语言描述就是：**多线程无非是多个线程处于并发的状态**。\n\n片头就这么多了，暂且告一段落。如果哪天灵光一现，也会再修修补补。\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 关于下文\n\n借鉴王一波前辈的书名，下面的篇幅按照多线程的重要程度渐进地划分为三个阶段——\n\n- `青铜时代`：主要描述线程的基本知识，也是最不可或缺的一部分，此外，由此衍生的静态代理，lambda表达式也可先入门一手；\n- `白银时代`：这一阶段是多线程并发的问题与基本解决方案，同样也是应用与面试的一大热门。\n- `黄金时代`：简言之，这一部分是高端操作，也是面试造火箭的宠儿，但其中的机制却并不新鲜，反而有点拾操作系统思想牙髓的意思。可见，最基本，最通用的反而具有最长久的生命力，\n\n------\n\n## 多线程——青铜时代\n\n### 1.创建的三种方式\n\n在java中，创建线程有3种方式，分别是继承Thread类，实现Runnable接口，实现Callable接口。而实现Runnable接口只能得到任务，**任务还需要线程驱动才能执行**、\n\n#### 实现Runnable接口\n\n![image-20210327130931773](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327130931773.png)\n\n首先实现Runnable接口得到Runnable实例。\n\n```java\npublic class CreateThread2 implements Runnable{\n   \n    @Override\n    public void run() {\n      //do something\n    }\n}\n```\n\n使用Runnable实例再创建一个Thread实例，调用Thread实例的start()开启一个线程——\n\n```java\npublic static void main(String[] args) {\n    //创建实现类\n    CreateThread2 t = new CreateThread2();\n    //同样调用Thread来开启线程，最终是使用runnable接口的代理来调用\n    new Thread(t).start();\n}\n```\n\n#### 实现Callable接口\n\n与Runnable相比，Callable接口具有返回值。返回值用**Future<V>**封装——\n\n```java\n/**\n * 使用Callable接口实现图片的下载\n *\n * callable的好处——\n * 1. 有返回值\n */\npublic class CreateThread3 implements Callable<Boolean> {\n    private String url;\n    private String name;\n\n    public CreateThread3(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n    @Override\n    public Boolean call() throws Exception {\n\n        try {\n            WebDownload webDownload = new WebDownload();\n            webDownload.download(url,name);\n            System.out.println(name+\"下载成功\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            System.out.println(\"图片下载异常\");\n        }\n        return true;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CreateThread3 t1 = new CreateThread3(\"https://img95.699pic.com/photo/40011/0709.jpg_wh860.jpg\",\"E:/1.png\");\n        CreateThread3 t2 = new CreateThread3(\"https://static.runoob.com/images/demo/demo4.jpg\",\"E:/2.png\");\n        CreateThread3 t3 = new CreateThread3(\"https://seopic.699pic.com/photo/50034/6414.jpg_wh1200.jpg\",\"E:/3.png\");\n\n        //创建固定线程数的线程池\n        ExecutorService service = Executors.newFixedThreadPool(3);\n\n        //提交执行\n        Future<Boolean> r1 = service.submit(t1);\n        Future<Boolean> r2 = service.submit(t2);\n        Future<Boolean> r3 = service.submit(t3);\n\n        //获取结果\n        Boolean res1 = r1.get();\n        Boolean res2 = r2.get();\n        Boolean res3 = r3.get();\n\n        //关闭服务\n        service.shutdownNow();\n    }\n}\n\nclass WebDownload{\n    public void download(String url,String name) throws IOException {\n        FileUtils.copyURLToFile(new URL(url),new File(name));\n    }\n}\n```\n\n#### 继承Thread类\n\n继承Thread类同样需要重写run方法，但run方法却仅仅只是Thread类的冰山一角，Thread类非常庞大，它包含了`线程的状态，分类，并发安全`，不一而足：\n\n![image-20210327132338149](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327132338149.png)\n\n来看代码实现——\n\n```java\npackage createThread;\n\npublic class CreateThread1 extends Thread{\n    /**\n     * run方法线程体\n     */\n    @Override\n    public void run() {\n        super.run();\n        for (int i=0;i<20;i++){\n            System.out.println(\"五味杂陈\");\n        }\n    }\n\n    /**\n     * 主线程方法体\n     * @param args\n     */\n    public static void main(String[] args) {\n        CreateThread1 t = new CreateThread1();\n        //可以看到调用start方法以后，主线程与run方法线程交替执行，总体先执行main主线程，也许是因为优先级较高！\n        //假如不是多线程，会怎样执行？\n        //那就应该在主线程中调用run的线程，在run线程执行完后再回到主线程，绝不会发生交替！\n        //线程的调度完全由CPU决定\n        t.start();\n        //可能会被提前终止\n        t.interrupt();\n        for (int i=0;i<200;i++){\n            System.out.println(\"陈杂味五\");\n        }\n    }\n}\n```\n\n当调用start以后，虚拟机将线程放入就绪队列等待被调度，线程被调度后则执行run方法。\n\n#### Runnable VS Thread\n\n实现接口会更好一些，因为：\n\n1. java是`单继承，可扩展性不好`，继承了Thread类就无法再继承其他类，而接口可以多实现；\n2. `Thread类这么臃肿`，如果只是执行简单的线程任务，则继承Thread类显得大而无用。\n\n------\n\n### 2.线程的状态与属性\n\n#### 开局一张图\n\n![线程的状态](C:\\Users\\zyz\\Desktop\\每日思维导图\\线程的状态.png)\n\n关于状态的琐碎知识，我就不展开了，**思维导图描述的更系统也更简洁这样记忆的效果更好**，针对状态的切换，在网上找到一张很细致的图片——\n![image-20210327134912906](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327134912906.png)\n\n来看切换内部的机制——\n\n![image-20210327141723664](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327141723664.png)\n\n#### 一点小贴士\n\n在这里，我们来解释一些关于线程切换与分类中，含糊不清的知识点：\n\n1. `进程与线程的状态基本一致`，一家之言；\n2. `阻塞是一种状态，挂起是一种行为`，挂起的结果是阻塞；\n3. 当run方法执行完后，线程则退出，变为死亡状态。而使用执行器，需要手动的关闭服务，从而关闭线程，关闭服务`shutDownNow`的底层会`调用interrupt方法`，该方法不一定是即时的，`它会使线程在安全的时候退出`,这同时也是中断的用途。\n4. `wait会释放对象的锁，而sleep并不会`。也就是说线程调用wait进入阻塞状态，使用notify唤醒线程，而后进入就绪队列等待。而sleep则可以直接执行。\n\n### 3.线程的基本机制\n\n在上面的内容中，我们突兀地使用了**很多看起来没有支撑的知识点**。我想小伙伴们也同样会困惑，对象锁是如何实现的？它的机制是怎样的？线程这么多的状态，我们都要耳提面命的测试吗？\n\n对于这些问题，java中的多线程给出了一个基本的机制来解决——\n\n#### 对象锁\n\n在JVM中，对象在内存中被分成了三个区域——\n\n1. **对象头**\n   1. `Mark_word(标记字段)`，默认存储`对象的锁标志位`，hashcode,分代年龄。它会根据锁的状态复用它的存储空间，也就是说，运行期间Mark_word中的信息会随着锁对象的变化而变化；\n   2. `Klass_point(类型指针)`：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象属于哪个类。\n2. **实例信息**：主要存放类的数据信息，父类的数据信息；\n3. **对齐填充**：即任何一个对象，都会被按位填充，即便是空对象也是如此。\n\n线程拥有对象的锁标志位，即表示线程可以访问该对象。从而可以通过对对象锁的操作来实现并发安全。\n\n#### 执行器\n\n如果程序员直接管理线程的生命周期，未免舍本逐末，太过繁琐。java为我们提供了大管家——***Executor***。\n\n**Exector会将线程的开启与运行机制分离开**，简化程序员的操作。它是是JUC包下的一个类，提供了三种可选的Executor:\n\n- `CachedThreadPool`：一个任务创建一个线程；\n- `FixedThreadPool`：所有任务只能使⽤用固定⼤小的线程；\n- `SingleThreadExecutor`：相当于大小为 1 的 FixedThreadPool。\n\n简要看下它的使用——\n\n```java\npublic static void main(String[] args) {\n    //创建线程池\n    ExecutorService executorService=Executors.newCachedThreadPool();\n    //执行\n    for (inti=0; i<5; i++) {\n        executorService.execute(new MyRunnable());    \n    }\n    //关闭服务\n    executorService.shutdown();}\n\n```\n\n------\n\n## 多线程——番外篇\n\n### 1.静态代理\n\n> 首先，考虑有这样一种需求，项目经理要求在所有类的每一个方法运行前后加上日志，但又要求不能对已有代码做改动，怎样解决呢？\n\n我们可以创建一个代理对象，让它和目标对象实现同样的接口，这样就可以借代理对象之手调用目标对象的方法了。此外，我们还需要为这个代理对象加上日志方法，问题就迎刃而解了。\n\n从这段描述中，我们试着提取静态代理的关键：\n\n- **代理对象=目标对象+加强代码**；\n- 代理对象和目标对象需要`实现同一个接口`；\n\n那小伙伴也许会困惑，咋们不是在学习多线程吗，难道多线程中使用到了静态代理？没错，Thread类就可以看做是Runnable接口实现类的静态代理，通过下面的小例子我们来巩固一下——\n\n```java\npublic class StaticProxy {\n    public static void main(String[] args) {\n\n        //使用lambda来开启线程\n        new Thread(()->System.out.println(\"我爱你\")).start();\n        //类比着看，说明线程底层使用的即是静态代理\n        new WeddingCompany(new You()).happyMarry();\n\n        //将真实对象作为代理对象的参数传入\n        WeddingCompany weddingCompany = new WeddingCompany(new You());\n        weddingCompany.happyMarry();\n    }\n}\n\n/**\n *都需要实现的顶层接口\n */\ninterface Marry{\n    void happyMarry();\n}\n\n/**\n * 真实角色\n */\nclass You implements Marry {\n\n    @Override\n    public void happyMarry() {\n        System.out.println(\"洞房花烛夜\");\n    }\n}\n\n/**\n * 代理角色，代理角色能做的事情更多\n */\nclass WeddingCompany implements Marry {\n    //这里是关键\n    private Marry target;\n\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n\n    @Override\n    public void happyMarry() {\n        before();\n        this.target.happyMarry();//这里是真实对象做的事情\n        after();\n    }\n\n    private void after() {\n        System.out.println(\"结婚之后，收尾款\");\n    }\n\n    private void before() {\n        System.out.println(\"结婚之前，布置现场\");\n    }\n}\n\n\n```\n\n### 2.Lambda表达式\n\n首先通过下面的小例子了解下lambda的写法——\n\n```java\nExecutorService service = Executors.ExecutorService();\n\nservice.submit( () -> {\n    System.out.println(\"肚子有点饿\");\n})\n```\n\n而这里的方法参数实际上应该是实现Runnable接口的任务，也就是说，**lambda表达式本身就是接口的实现**。它`扩展了匿名内部类`，使得写法更加简洁高效。\n\n通过下面的实例来看下lambda的成长历程：\n\n```java\n\n```\n\n------\n\n### 3.java内存模型\n\njava试图屏蔽不同硬件与操作系统之间的内存访问差异，来实现java程序在各种平台都能运行的一致性数据访问。\n\n#### 工作内存与主内存\n\n我们知道，CPU只负责运算，它将内存中的数据读取到寄存器中，CPU再取得寄存器的地址，最后执行指令。但寄存器(`CPU的零级缓存`)的读写速度比内存的读写速度快很多个数量级，为了缓冲这种速度差，引入了`高级缓存`。\n\n但加入高级缓存以后，又带来了新的问题：**缓存一致性**。如果多个缓存共享一个主内存中的变量，那么多个缓存中的数据可能不一样。需要引入协议来规范一致性问题：\n\n![image-20210327221223729](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221223729.png)\n\n工作内存通常存储在高速缓存和寄存器中，在工作内存中保存了`主内存变量的拷贝`。\n\n#### 内存间的交互操作\n\njava内存模型定义了8个操作来完成主内存和工作内存之间的交互——\n\n![image-20210327221528229](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221528229.png)\n\n- `read`：把一个变量的值从主内存传输到工作内存中\n- `load`：在 read 之后执行，把 read 得到的值放⼊工作内存的变量副本中\n- `use`：把工作内存中⼀个变量的值传递给执行引擎\n- `assign`：把一个从执行引擎接收到的值赋给工作内存的变量\n- `store`：把工作内存的一个变量的值传送到主内存中\n- `write`：在 store 之后执行，把 store 得到的值放入主内存的变量中\n- `lock`：作⽤用于主内存的变量\n\n#### 内存模型的三大特性\n\n1. **原子性：**\n\n   上面我们提到了8种对内存的操作，这些操作作用的变量在被volatile修饰时都是原子性的。但`内存模型允许java虚拟机将没有被volatile修饰的64位数据，即long,double，划分为两个32位的数据执行`，即在这种情况下，操作不是原子性的。\n\n   但int型的数据就是原子性的吗？也不尽然，对数据的操作通常不是单一的操作可以完成的，简要的说，count++就分为read,assign,write三步。这三步整合起来并不是原子性的。\n\n   那如何保证原子性呢？`直观的方式就是加锁`咯，将count++的代码块用synchronized修饰。还有其他基于同步框架的方式吗？\n\n   `AtomicInteger`就是JUC框架下的这样一种方式，那它是如何实现的呢？\n\n   ![image-20210327223155578](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327223155578.png)\n\n   显然，它应用了`CAS的自旋思想`。\n\n2. **可见性：**\n\n   可见性指的是`当一个线程修改了主内存中的值以后，其他线程可以立刻获知这个修改`，java内存模型是通过将变量修改后的值同步回主内存，在变量读取之前刷新主内存中的值来实现的。\n\n   主要有三种实现可见性的方式：\n\n   - `volatile`\n   - `synchronized`,对一个变量使用unlock之前，必须将变量的值同步回主内存；\n   - `final`,被final修饰的字段，在初始化之后，如果没有发生this逃逸，那么其他线程就能看见final字段的值。\n\n3. **有序性：**\n\n   有序性指的是：`在本线程中观察，所有操作都是有序的。在一个线程中观察另一个线程，所有操作都是无序的`。\n\n   本线程有序还好理解，另一个线程无序就有点摸不着头脑了。\n\n> 无序是因为发生了`指令重排序`，在java内存模型中，允许编译器和处理器对指令进行重排序，重排序的过程不会影响单线程程序的执行，却会影响多线程并发执行的正确性。\n>\n> volatile关键字通过添加`内存屏障`的方式来禁止指令重排，即重排序时不能把后面的指令放在内存屏障之前。\n>\n> 当然，也可以通过`sychronized`来保证有序性。\n\n> 日拱一卒，功不唐捐。\n\n------\n\n##  多线程——白银时代\n\n### 1.多线程不安全的案例\n\n多个线程在访问同一个变量时有可能出现并发错误，我们通过下面的例子来演示并发错误，并借此分析并发错误出现的原因及解决方式——\n\n```java\npackage synchonized;\n\npublic class TestMakeup {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Makeup(0, \"灰菇凉\"));\n        Thread thread1 = new Thread(new Makeup(1, \"白雪公主\"));\n        thread.start();\n        thread1.start();\n    }\n}\n\nclass LipStick{\n\n}\n\nclass Mirror{\n\n}\n\n/**\n * 两个女孩分别持有镜子与口红的锁，然后都去等待对方的资源\n */\nclass Makeup implements Runnable{\n    int choice;\n    String person;\n\n    //static表示只有一份\n    static LipStick lipStick = new LipStick();\n    static Mirror mirror = new Mirror();\n\n    public Makeup(int choice, String person) {\n        this.choice = choice;\n        this.person = person;\n    }\n\n    @Override\n    public void run() {\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    //互相请求对方所持有的的锁就会导致死锁，死锁的四个必要条件：互斥，请求与保持，不可剥夺，循环等待，\n    public void makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipStick){\n                System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n                Thread.sleep(1000);//一秒后要去获得镜子\n            }\n            synchronized (mirror){\n                System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n            }\n            /**死锁——\n             * synchronized (lipStick){\n                  System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n                     synchronized (mirror){\n                       Thread.sleep(1000);//一秒后要去获得镜子\n                       System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n                     }\n             }\n             *\n             */\n        }else{\n            synchronized (mirror){\n                System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n                Thread.sleep(2000);//2秒后要去获得口红\n            }\n            synchronized (lipStick){\n                System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n            }\n        }\n    }\n}\n\n\n```\n\n在上面的例子中，我们看到假如`双方都在持有自己锁的前提下，请求对方的锁`时。可能导致并发错误的表现之一——死锁，这里再来回顾一下形成死锁的必要条件——\n\n- `互斥：`一个资源只能被一个线程使用；\n- `循环等待：`死锁的状况不会因为时间改变而改善；\n- `请求与持有：`在没有获得请求锁的前提下，不会释放自己持有的锁。\n- `不可剥夺：`线程只能主动让出资源，不能强取；\n\n------\n\n那还有什么原因会导致并发错误呢？并发错误的表现有这样几种情况——\n\n1. 访问**共享变量**导致数据不一致；\n2. CPU还没有完成所有线程的调度，线程就已经提前结束了；\n\n那么，针对并发错误的原因，我们可以得到解决并发错误的策略——\n\n1. **互斥同步**：对发生更新的数据加锁，即java互斥同步的两种锁机制：synchronized与Lock;\n2. **final**: 直接将变量声明为 不可变的，就不存在变量了，这波曲线解决问题；\n3. **非阻塞同步**：CAS机制\n4. **不同步机制**：需要同步是因为多个线程共享一个变量，那要实现不同步，就让每个线程独享一份变量就好咯，通常解决方式有这么几种：\n   1. `栈封闭`\n   2. `线程本地存储`\n   3. `可重入代码`\n\n这里我们暂且只介绍互斥同步的解决方式，其他策略在黄金时代中会重点描述，现在混个眼熟~\n\n------\n\n### 2.synchronized\n\n#### 1.synchronized的使用场景\n\n- 修饰`代码块`\n\n  ![image-20210328100335007](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100335007.png)\n\n- 修饰`实例方法`，也就是对this对象加锁\n\n  ![image-20210328100502317](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100502317.png)\n\n- 修饰`静态方法`，即对class对象加锁\n\n  ​\t![image-20210328100915411](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100915411.png)\n\n#### 2.synchronized的基本机制\n\n我们之前谈到java内存模型有三大特性：`有序性，可见性，原子性`。而synchronized作用于存储在内存中的变量或代码块上，它除了拥有内存模型的三大特性外，还有`可重入性`，谈到可重入性首先要知道synchronized是如何实现加锁和解锁的。\n\n##### 加锁与解锁\n\n我们将**class文件反编译**可以得到：\n\n![image-20210328101501442](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328101501442.png)\n\n对应来看，加锁和解锁显然是通过**monitorenter和monitorexit**实现的。也就是说获取对象的锁，实质上就是获取对象的monitor，即**监视器**，那如何来标识线程拥有该监视器呢？synchronized在锁对象时会获得一个**计数器**，用来**标识线程获得锁的次数**，线程每重入一次锁，计数器就会加1，对应的线程每调用monitorexit退出一次锁，计数器就会减1.如果计数器减为0，则说明锁已被释放。\n\n这是线程获得锁的情况，但假如线程阻塞了呢——\n\n![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-2.png)\n\n显然，如果获取失败，线程就会进入**同步队列**，状态变更为**阻塞态**，直到锁被释放以后，同步队列中的线程才有机会获得锁。\n\n##### 可重入性原理\n\n现在来分析可重入性，就变得非常友好了。线程在重入时，`会首先判断计数器的值`，如果计数器不为0，也就是线程拥有锁，则直接进入，不需要反复获取锁。\n\n发生死锁的必要条件之一即为`循环等待`，而可重入性打破了这一原因，可见`可重入性能够有效防止死锁的出现`。\n\n##### 同步方法的底层实现\n\n同步方法区别于代码块，它会首先判断标志位**ACC_SYNCHRONIZED**,如果存在该标志位，才会去隐式的调用monitorenter与monitorexit指令。即最终都归于monitor对象。\n\n我们所熟识的锁升级，无非是调用了**ObjectMonitor对象不同的实现**，如果失败了，再调用更高级的实现即可。\n\n##### 重量锁\n\n在看ObjectMonitor的源码时，我们会发现内核函数的存在，它们分别对应**park()和unpark()**,而synchronized是JVM管理的，JVM是应用程序，处于用户态，而内核函数在内核态，`切换的过程耗费资源较低，因此得名重量锁`。\n\n再来简单回顾下内核态与用户态的切换——\n\n1. 用户态将数据存储在`寄存器`中，并保存堆栈信息；\n2. 通过`系统调用`的方式，即通过`外中断`进入内核态；\n3. `CPU取指执行`，即跳转到指定的内存位置处执行指令；\n4. `读取寄存器中的参数`，维护内核栈的堆栈信息；\n5. CPU`重置操作系统为内核态`。\n\n#### JVM中锁的优化\n\n既然用户态，内核态的切换是低效的，那我们不如**只在用户态做文章**，官方对锁的升级即是通过加函数调用，而非系统调用来实现的。首先概括性的看下图——\n\n<img src=\"https://pic2.zhimg.com/v2-79edfb4b2316d76ac653732fbdb72809_r.jpg\" alt=\"preview\" style=\"zoom:200%;\" />\n\n这张图着实有点烧脑，我们来看个简单的：\n\n![image-20210328105848069](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328105848069.png)\n\n这就是锁升级的方向咯。显然这个过程是不可逆的，我们来拆解它的每一步实现——\n\n- **偏向锁**\n\n  之前我们提到了，对象头是由Mark_Word和Klass_point组成，锁争夺也就是对monitor对象的争夺，`一旦线程持有该对象，标志位修改为1，进入偏向模式`。并将这个线程的ID记录在对象的Mark_Word中。\n\n  这个过程是使用`CAS乐观锁`来实现的，如果CAS失败，即锁对象获取失败。\n\n  偏向锁在`jdk1.6之后是默认开启`的，1.5中关闭。\n\n  ![preview](https://pic1.zhimg.com/v2-1c56b94b3f92c3aa3884f739a5e4b42c_r.jpg)\n\n  如果多个线程竞争偏向锁，那CAS乐观锁显然不那么实用了，就需要用到轻量级锁——\n\n- **轻量级锁**\n\n  轻量级锁的实现仍跟Mark_Word相关。如果对象是无锁的，JVM就会在当前线程的栈帧中创建一个叫做`锁记录(Lock Record)的空间`，用来存储锁对象`Mark_Word的拷贝`。最后将所记录的`owner字段指向当前对象`。\n\n  JVM接下来会利用CAS尝试将对象原本的`Mark_Word更新为Lock_Record的指针`。如果更新成功，改变锁的标志位，表明对象的锁已被获取，然后执行相关同步操作。\n\n  如果失败了，说明`锁可能被其他线程持有`，此时就需要继续升级锁，修改锁的状态，线程进入阻塞态。而还有一种可能，即当前`线程本身持有锁`，就需要判断当前对象的Mark_Wors是否指向当前线程的栈帧。\n\n  ![preview](https://pic3.zhimg.com/v2-a932f172d1e9ac967c213429054d8522_r.jpg)\n\n- **自旋锁**\n\n  上面提到如果修改不成功，就需要升级为自旋锁，自旋锁区别于重量锁，它如果没有竞争到锁对象，`就会不断循环，表现为CPU空转，而不是阻塞`。\n\n  空转的次数最多为10次，如果超过10次，就会升级为重量锁。\n\n------\n\n#### 锁的优缺点对比\n\n![image-20210328112941479](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328112941479.png)\n\n------\n\n### 3.lock\n\n剧情来到了互斥并发的半壁江山——lock。\n\nlock本身是一个`接口`，它提供了`更灵活的锁定操作`，即`手动的加锁与释放锁`。完全`不同的属性`，并且支持多个关联的对象`Condition`。\n\n特别地，它的实现类`ReadWriteLock`支持对共享资源的读锁。也可以使用`tryLock方法非阻塞`地获得锁。\n\n下面我们通过具体的实现类来看lock的实现机制——\n\n#### ReentrantLock\n\n![image-20210328124145535](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124145535.png)\n\nReentrantLock顾名思义，即`可重入的锁`。它的属性包含同步类的对象，该对象继承自AQS，即使用`双端队列实现的同步队列`。\n\n在来看下它的属性与方法——\n![image-20210328124815007](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124815007.png)\n\n嗯，提供了很多便捷，灵活的操作锁的方式，这里不再一一赘述，因为相比Lock的API，显然`JUC包下的API更香`~\n\n### 4.synchronized VS ReentrantLock\n\n- **重入**\n\n  `synchronized可重入`，因为加锁和解锁可以自动进程，不必担心最后释放锁。`ReentrantLock同样可以重入`，它的加锁和释放锁需要手动完成。\n\n- **实现**\n\n  `synchronied是JVM实现的`，而`ReentrantLock是JDK实现的`，也就是最终归于操作系统实现。\n\n- **性能**\n\n  jdk1.6以后对synchronied做了很多优化，。如今它们的性能平分秋色。\n\n- **功能**\n\n  ReentrantLock锁的粒度和灵活度，都明显优于synchronized.\n\n  ReentrantLock从它内部类可以看出，它有公平与非公平的同步方式之分。而`synchronized是非公平(不按时间顺序获取锁)的锁。`\n\n  ReentrantLock可以非阻塞的获取锁。且提供中断等待锁的线程机制。\n\n- **可见性**\n\n  我们知道，`synchronized的可见性是基于java内存模型的happens-before原则`，即在其他线程读取主内存的值前，主内存一定先被刷新。\n\n  而ReentrantLock的可见性是如何保障的呢？它的同步机制是基于AQS框架的，而`AQS框架的锁机制核心在于读写state变量`的值：\n\n  ![image-20210328152434820](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328152434820.png)\n\n这里简要插播一下：volatile是如何保证可见性的：\n\n> volatile基于JMM(java内存模型)的内存语义：\n>\n> 1. 当`写一个volatile变量`时，JMM会将线程本地内存中的变量刷新到主内存中；\n> 2. 当`读一个volatile变量`时，JMM会将线程对应的本地内存置为无效，然后从主内存中读取变量。\n\n那state变量既然由volatile修饰，那自然就可以保证可见性咯，当然，保证原子性是不可能的~\n\n## 多线程——黄金时代\n\n### 1.线程池\n\n#### 什么是线程池\n\n线程池的基本思想是`对象池`，当程序启动的时候，就会在内存中开辟出一块空间，来放置初始化好的线程。当需要使用线程时，就使用`线程调度器`从线程池中取出一个线程，当线程使用完后，再将它归还到线程池中。\n\n#### 使用线程池的好处\n\n- `方便管理线程`：比如延时执行，定时循环；\n- `控制线程并发数量`：如果线程数量不加控制，会大致线程占用内存过多，从而四死机；\n- `减少创建，销毁开销`：每个线程可以被重复利用，可以执行多个任务\n\n#### 线程池的主要组件\n\n![img](https://user-gold-cdn.xitu.io/2018/7/8/16477f7912b4552a?imageslim)\n\n1. `线程池管理器ThreadPool`：用于创建和管理线程池；\n2. `任务接口Task`：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，执行完的收尾工作，任务的执行状态；\n3. `工作线程workThread`：线程池中的线程，没有任务时处于等待状态；\n4. `任务队列taskQueue`：用于存放没有处理的任务，起一种`缓冲的作用`。\n\n#### ThreadPoolExecutor类解析\n\n我们可以通过ThreadPoolExecutor来创建一个线程——\n\n![image-20210328164241430](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328164241430.png)\n\n再来深入地看下这些参数的意义：\n\n1. `corePoolSize`：即线程池的基本大小，任务队列每提交一个任务，线程池就会创建一个线程，当提交的任务数大小线程池的基本大小时，就不再创建线程；\n2. `maxinumPoolSize`：即线程池允许创建的最大线程数；\n3. `KeepAliveTime`：即线程池的工作线程空闲了以后，保持存活的时间；\n4. `TImeUnit`：即线程活动保持时间的单位；\n5. `workQueue`：用来保存等待执行的阻塞队列；\n6. `threadFactory`：线程工厂，在debug和定位问题时非常有帮助；\n7. `RejectedExecutionHandler`：拒绝策略，下文会详细描述。\n\n##### 向线程池提交任务\n\n- `execute()`：无返回值，无法判断任务是否被执行成功；\n- `submit()`：返回一个future的泛型对象，通过get方法可以获得返回值。\n\n##### 线程池的关闭\n\n- `shutdown`：将线程池的状态设置为`SHUTDOWN状态`，然后中断所有没有执行任务的线程；\n- `shutdownNow`：遍历工作线程，逐个调用线程的`interrupt方法`。\n\n##### 线程池的执行流程\n\n![img](https://user-gold-cdn.xitu.io/2018/7/8/16477fc44a03d90f?imageslim)\n\n##### 四种拒绝策略\n\n1. `AbortPolicy`：丢弃任务并抛出RejectedExecutionException异常\n\n   ![\t](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171249081.png)\n\n2. `DiscardPolicy`：丢弃任务但不抛出异常\n\n   ![image-20210328171502262](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171502262.png)\n\n3. `DisCardOldSetPolicy`：丢弃队列最前面的任务，然后提交新来的任务\n\n   ![image-20210328171523558](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171523558.png)\n\n4. `CallerRunPolicy`：由调用线程处理该任务\n\n   ![image-20210328171435296](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171435296.png)\n\n#### 四种线程池\n\n- `CachedThreadPool()`:可缓冲线程池\n- `FIxedThreadPool()`:定长线程池\n- `ScheduledThreadPool()`:定时线程池\n- `SingleThreadExecutor()`:单线程化的线程池\n\n#### 为什么不推荐使用JUC的线程池\n\n1. newFixedThreadPool和newSingleThreadExecutor\n\n   创建的`任务等待队列容量过大，耗费非常多的内存`~\n\n   ![image-20210329201950011](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329201950011.png)\n\n   ![image-20210329202057662](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202057662.png)\n\n2.newScheduledThreadPool和newCachedThreadPool\n\n​\t会`创建非常多的线程`，CPU压力大~\n\n​\t![image-20210329202312593](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202312593.png)\n\n#### 线程池的参数设置\n\n参数的设置和系统的负载有着直接的关系，系统负载有这样的一些参数：\n\n- `tasks`：每秒需要处理的任务数\n- `threadtasks`：每个线程每秒可以处理的任务数\n- `responsetime`：系统允许任务的最大响应时间。\n\n下面将用这些系统负载的参数来衡量线程池的参数——\n\n##### corePoolSize\n\n假设系统每秒任务数为100 ~ 1000，每个线程每钞可处理10个任务，则需要100 / 10至1000 / 10，即10 ~ 100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据`8020原则`，因为系统每秒任务数为100 ~ 1000，`即80%情况下系统每秒任务数小于1000 * 20% = 200`，则corePoolSize可设置为`200 / 10 = 20`。\n\n##### queueCapacity\n\n任务队列的长度可以设置为：`所有核心线程每秒处理任务数 * 每个任务响应时间 = 每秒任务总响应时间`\n\n##### maxPoolSize\n\n当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程，增加的线程数取决于任务队列容量和需求。\n\n千万不能直接创建任务队列，不然容量过大，占用内存过多，对系统压力大。\n\n![image-20210329204208430](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210329204208430.png)\n\n##### keepAliveTime\n\n当`负载降低时，可以减少线程的数量`，当线程的空闲时间超过keepAliveTime，会自动释放线程。\n\n##### allowCoreThreadTimeout\n\n默认情况下核心级线程不会退出，可通过该参数设置为true,使其退出。\n\n一般经验：线程池的大小应该这样设置：\n\n1. 如果是`CPU密集型应用`，线程池大小设置为`N+1`,N指CPU的个数；\n2. 如果是`IO密集型应用`，则线程池大小设置为`2N+1`;\n\n#### 线程的五种状态\n\n![img](https://user-gold-cdn.xitu.io/2020/3/20/170f73cc0dad76a5?imageslim)\n\n#### 什么场景下怎么设置线程池\n\n- `高并发、任务执行时间短的业务`\n\n线程池线程数可以设置为CPU核数+1，**减少线程上下文的切换**\n\n- `并发不高、任务执行时间长的业务`\n\n这个需要判断执行时间是耗在哪个地方\n\n1. 假如是业务时间长集中在`IO操作上`，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目（**2 * CPU核数**），让CPU处理更多的业务。\n2. 假如是业务时间长集中在计算操作上，也就是`CPU密集型任务`，和（1）**CPU核数+1** 一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换\n\n- `并发高、业务执行时间长的业务`\n\n解决这种类型任务的关键不在于线程池而在于整体架构的设计\n\n### 2.JUC\n\n#### AQS框架\n\n我们知道JUC是一个**定义并发操作并安全处理并发**的框架。而要了解JUC包的全貌，我们首先需要定义处理`并发的组件`，也就是锁和同步器。这种功能就是由AQS所提供的。\n\nAQS的全称是`AbstractQueuedSynchronizer`，即抽象队列同步器。它是java并发用来构建锁和同步器的基础框架。它包含`先进先出的双端队列，状态量，线程持有者的引用`。\n\n![img](https://upload-images.jianshu.io/upload_images/24459569-f4323d6ace89b32d.png)\n\n这里的state是由volatile修饰的，即它满足线程间的可见性，另外，它记录了`锁的持有者`：\n\n![image-20210329223019662](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329223019662.png)\n\n当线程1想要获取monitor对象时，它的行为是这样的：\n\n![image-20210329224019027](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329224019027.png)\n\n------\n\n#### 工具类——同步器\n\n累了，不再文字描述了，把思维导图贴上来：\n\n![三大工具类-同步器](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/三大工具类-同步器.png)\n\n#### 其他组件\n\n![其他组件](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/其他组件.png)\n\n#### ThreadLocal\n\n[浅谈ThreadLocal](https://zhuanlan.zhihu.com/p/60375306)\n\n## 多线程——加餐\n\n### 1.关于多线程可行的实践\n\n- 给线程起个`有意义的名字`，这样可以方便找 Bug。\n- 缩小同步范围，从⽽而减少锁争用。例如对于 synchronized，应该`尽量使用同步块⽽而不是同步方法`。\n- 多用同步工具少用 wait() 和 notify()。首先`，CountDownLatch, CyclicBarrier, Semaphore 和Exchanger 这些同步类简化了了编码操作，⽽用 wait() 和 notify() 很难实现复杂控制流`；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不不断优化和完善。\n- 使用`BlockingQueue 实现生产者消费者问题`。多用并发集合少用同步集合，例如应该`使用 ConcurrentHashMap ⽽而不是 Hashtable`。\n- 使用`本地变量`和`不可变类`来保证线程安全。使用线程池⽽不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。\n\n------\n\n> 山高路远，静水深流.","source":"_posts/java多线程的前世今生.md","raw":"---\ntitle: java多线程的前世今生\ntop: true\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 15:45:51\npassword:\nsummary:\ncategories: 编程语言\ntags: \n\t- java\n\t- 并发编程\n---\n\n## 前言\n\n一个多月没写过博文了，不是没有**值得记录的故事**，确是静不下心。网申在即，靠目前的积淀，知识地图中缺了一大块，索性打消了网申的念头。但不免有些落寞，像极了**落跑的小橘子**。\n\n这个`时代越来越卷了`，但也正因如此，我才更信奉积淀的魅力，这也正是我整理心态，继续出发的缘由。\n\n这不是第一次学习多线程了，在自学时，培训班上都接触过多线程，但都只是浅尝辄止，这次咬定青山不放松，终于**顿悟了一些关键的知识**，恍然间柳暗花明，便有了这篇文章。\n\n------\n\n## 多线程——入门\n\n在操作系统中，我们了解到，**多进程图像**是操作系统最核心，最基础的图像。而用户通过系统调用的方式间接与操作系统交互。想象这样一种场景，我们一边放着音乐，一边浏览网页——\n\n![image-20210327092252968](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327092252968.png)\n\n这就是触目可及的多进程图像，显然，这两个进程之间使用的是不同的资源，不妨假设我的处理器是单核的，每一时刻只能处理一个进程，那`CPU就要为两个进程分配时间片`，然后根据调度算法切换进程，串行执行。\n\n如何切换进程呢？首先要理解进程是什么——\n\n![image-20210619000547145](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619000547145.png)\n\n也就是说，进程就是：**指令执行序列+资源**，因此直观的切换进程就是切换进程的这两部分，但资源的切换是非常浪费时间的，能不能`只切换指令执行序列`呢？聊到这，小伙伴就有了这样的猜想：指令执行序列与线程有什么关系呢？\n\n没错，**指令执行序列就是线程集**。我们深入到进程中找找，就会发现线程集没有我们想象中的那么遥不可及——\n\n![image-20210327094410019](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327094410019.png)\n\n下载听歌两不误，如此丝滑的切换，都得益于**线程的并发应用**。也就是多线程咯。到这里，故事才真正的拉开序幕——\n\n------\n\n### 1.进程与线程\n\n前面提到的都是直观的印象，这里由表及内地聊聊进程与线程——\n\n- `进程： `进程是**上下文切换之间的程序执行的部分**，而所谓上下文，即是`CPU与寄存器`。通俗地说，也就是说进程执行的环境。在这个环境下运行着的程序即是进程。\n- `线程： `线程是**轻量级的进程**，这里的轻量级如何理解呢？`线程集`共享了进程的`上下文环境，地址空间，更为细小的CPU时间片`。\n\n对于如何更好地理解进程与线程之间的关系，有大佬已经讲的非常形象了，我们不妨站在巨人的肩膀上——\n\n- [x] [将进程比作火车，线程比作车厢](https://www.zhihu.com/question/25532384)\n\n------\n\n### 2.所谓多线程\n\n在讲述多线程之前，非常有必要搞懂这几个概念——\n\n- `并发`：一些任务都处于可运行的状态，但只有一个任务可以被调度并执行，而具体是哪一个任务被处理仍是不确定的。\n\n- `串行与并行`\n\n  1. 多任务中**某时刻**只能有一个任务被运行，单核下皆为串行；\n  2. 某时刻可以有多个任务同时被执行，在多核计算机上可以实现并行；\n\n- `阻塞与非阻塞`：\n\n  1. 以文件读取为例，应用层会调用系统内核中的IO接口，如open，close等，在请求发出以后，如果调用的是**阻塞型IO**，应用层被挂起，一直处于等待数据返回的状态。直到从磁盘上读取数据并返回给应用层后，应用层采用获取到的数据进行下一步操作；\n  2. 如果应用层调用的是**非阻塞I/O**，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。\n\n  也就是说阻塞与非阻塞的区别在于**发出请求后等待数据返回时的状态**。\n\n- `同步与异步`：\n\n  - 阻塞与非阻塞决定了应用层等待数据返回的状态，而**数据如何从系统内核返回**呢？返回的方式取决于同步与异步——\n  - 对于同步型的调用，应用层会不**断问询系统内核**，但它的动作取决于是否阻塞，数据返回给应用层后，应用层继续做其他的事情；\n  - 对于异步型的调用，应用层**不关心数据何时返回**，此时它的动作同样却绝育是否阻塞，系统内核会主动通知应用层数据已经读取完毕并返回。\n\n------\n\n好啦，啰嗦了这么多，也该祭出这张图了——\n\n![image-20210327104345505](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327104345505.png)\n\n用语言描述就是：**多线程无非是多个线程处于并发的状态**。\n\n片头就这么多了，暂且告一段落。如果哪天灵光一现，也会再修修补补。\n\n> 日拱一卒，功不唐捐。\n\n------\n\n## 关于下文\n\n借鉴王一波前辈的书名，下面的篇幅按照多线程的重要程度渐进地划分为三个阶段——\n\n- `青铜时代`：主要描述线程的基本知识，也是最不可或缺的一部分，此外，由此衍生的静态代理，lambda表达式也可先入门一手；\n- `白银时代`：这一阶段是多线程并发的问题与基本解决方案，同样也是应用与面试的一大热门。\n- `黄金时代`：简言之，这一部分是高端操作，也是面试造火箭的宠儿，但其中的机制却并不新鲜，反而有点拾操作系统思想牙髓的意思。可见，最基本，最通用的反而具有最长久的生命力，\n\n------\n\n## 多线程——青铜时代\n\n### 1.创建的三种方式\n\n在java中，创建线程有3种方式，分别是继承Thread类，实现Runnable接口，实现Callable接口。而实现Runnable接口只能得到任务，**任务还需要线程驱动才能执行**、\n\n#### 实现Runnable接口\n\n![image-20210327130931773](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327130931773.png)\n\n首先实现Runnable接口得到Runnable实例。\n\n```java\npublic class CreateThread2 implements Runnable{\n   \n    @Override\n    public void run() {\n      //do something\n    }\n}\n```\n\n使用Runnable实例再创建一个Thread实例，调用Thread实例的start()开启一个线程——\n\n```java\npublic static void main(String[] args) {\n    //创建实现类\n    CreateThread2 t = new CreateThread2();\n    //同样调用Thread来开启线程，最终是使用runnable接口的代理来调用\n    new Thread(t).start();\n}\n```\n\n#### 实现Callable接口\n\n与Runnable相比，Callable接口具有返回值。返回值用**Future<V>**封装——\n\n```java\n/**\n * 使用Callable接口实现图片的下载\n *\n * callable的好处——\n * 1. 有返回值\n */\npublic class CreateThread3 implements Callable<Boolean> {\n    private String url;\n    private String name;\n\n    public CreateThread3(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n    @Override\n    public Boolean call() throws Exception {\n\n        try {\n            WebDownload webDownload = new WebDownload();\n            webDownload.download(url,name);\n            System.out.println(name+\"下载成功\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            System.out.println(\"图片下载异常\");\n        }\n        return true;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CreateThread3 t1 = new CreateThread3(\"https://img95.699pic.com/photo/40011/0709.jpg_wh860.jpg\",\"E:/1.png\");\n        CreateThread3 t2 = new CreateThread3(\"https://static.runoob.com/images/demo/demo4.jpg\",\"E:/2.png\");\n        CreateThread3 t3 = new CreateThread3(\"https://seopic.699pic.com/photo/50034/6414.jpg_wh1200.jpg\",\"E:/3.png\");\n\n        //创建固定线程数的线程池\n        ExecutorService service = Executors.newFixedThreadPool(3);\n\n        //提交执行\n        Future<Boolean> r1 = service.submit(t1);\n        Future<Boolean> r2 = service.submit(t2);\n        Future<Boolean> r3 = service.submit(t3);\n\n        //获取结果\n        Boolean res1 = r1.get();\n        Boolean res2 = r2.get();\n        Boolean res3 = r3.get();\n\n        //关闭服务\n        service.shutdownNow();\n    }\n}\n\nclass WebDownload{\n    public void download(String url,String name) throws IOException {\n        FileUtils.copyURLToFile(new URL(url),new File(name));\n    }\n}\n```\n\n#### 继承Thread类\n\n继承Thread类同样需要重写run方法，但run方法却仅仅只是Thread类的冰山一角，Thread类非常庞大，它包含了`线程的状态，分类，并发安全`，不一而足：\n\n![image-20210327132338149](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327132338149.png)\n\n来看代码实现——\n\n```java\npackage createThread;\n\npublic class CreateThread1 extends Thread{\n    /**\n     * run方法线程体\n     */\n    @Override\n    public void run() {\n        super.run();\n        for (int i=0;i<20;i++){\n            System.out.println(\"五味杂陈\");\n        }\n    }\n\n    /**\n     * 主线程方法体\n     * @param args\n     */\n    public static void main(String[] args) {\n        CreateThread1 t = new CreateThread1();\n        //可以看到调用start方法以后，主线程与run方法线程交替执行，总体先执行main主线程，也许是因为优先级较高！\n        //假如不是多线程，会怎样执行？\n        //那就应该在主线程中调用run的线程，在run线程执行完后再回到主线程，绝不会发生交替！\n        //线程的调度完全由CPU决定\n        t.start();\n        //可能会被提前终止\n        t.interrupt();\n        for (int i=0;i<200;i++){\n            System.out.println(\"陈杂味五\");\n        }\n    }\n}\n```\n\n当调用start以后，虚拟机将线程放入就绪队列等待被调度，线程被调度后则执行run方法。\n\n#### Runnable VS Thread\n\n实现接口会更好一些，因为：\n\n1. java是`单继承，可扩展性不好`，继承了Thread类就无法再继承其他类，而接口可以多实现；\n2. `Thread类这么臃肿`，如果只是执行简单的线程任务，则继承Thread类显得大而无用。\n\n------\n\n### 2.线程的状态与属性\n\n#### 开局一张图\n\n![线程的状态](C:\\Users\\zyz\\Desktop\\每日思维导图\\线程的状态.png)\n\n关于状态的琐碎知识，我就不展开了，**思维导图描述的更系统也更简洁这样记忆的效果更好**，针对状态的切换，在网上找到一张很细致的图片——\n![image-20210327134912906](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327134912906.png)\n\n来看切换内部的机制——\n\n![image-20210327141723664](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327141723664.png)\n\n#### 一点小贴士\n\n在这里，我们来解释一些关于线程切换与分类中，含糊不清的知识点：\n\n1. `进程与线程的状态基本一致`，一家之言；\n2. `阻塞是一种状态，挂起是一种行为`，挂起的结果是阻塞；\n3. 当run方法执行完后，线程则退出，变为死亡状态。而使用执行器，需要手动的关闭服务，从而关闭线程，关闭服务`shutDownNow`的底层会`调用interrupt方法`，该方法不一定是即时的，`它会使线程在安全的时候退出`,这同时也是中断的用途。\n4. `wait会释放对象的锁，而sleep并不会`。也就是说线程调用wait进入阻塞状态，使用notify唤醒线程，而后进入就绪队列等待。而sleep则可以直接执行。\n\n### 3.线程的基本机制\n\n在上面的内容中，我们突兀地使用了**很多看起来没有支撑的知识点**。我想小伙伴们也同样会困惑，对象锁是如何实现的？它的机制是怎样的？线程这么多的状态，我们都要耳提面命的测试吗？\n\n对于这些问题，java中的多线程给出了一个基本的机制来解决——\n\n#### 对象锁\n\n在JVM中，对象在内存中被分成了三个区域——\n\n1. **对象头**\n   1. `Mark_word(标记字段)`，默认存储`对象的锁标志位`，hashcode,分代年龄。它会根据锁的状态复用它的存储空间，也就是说，运行期间Mark_word中的信息会随着锁对象的变化而变化；\n   2. `Klass_point(类型指针)`：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象属于哪个类。\n2. **实例信息**：主要存放类的数据信息，父类的数据信息；\n3. **对齐填充**：即任何一个对象，都会被按位填充，即便是空对象也是如此。\n\n线程拥有对象的锁标志位，即表示线程可以访问该对象。从而可以通过对对象锁的操作来实现并发安全。\n\n#### 执行器\n\n如果程序员直接管理线程的生命周期，未免舍本逐末，太过繁琐。java为我们提供了大管家——***Executor***。\n\n**Exector会将线程的开启与运行机制分离开**，简化程序员的操作。它是是JUC包下的一个类，提供了三种可选的Executor:\n\n- `CachedThreadPool`：一个任务创建一个线程；\n- `FixedThreadPool`：所有任务只能使⽤用固定⼤小的线程；\n- `SingleThreadExecutor`：相当于大小为 1 的 FixedThreadPool。\n\n简要看下它的使用——\n\n```java\npublic static void main(String[] args) {\n    //创建线程池\n    ExecutorService executorService=Executors.newCachedThreadPool();\n    //执行\n    for (inti=0; i<5; i++) {\n        executorService.execute(new MyRunnable());    \n    }\n    //关闭服务\n    executorService.shutdown();}\n\n```\n\n------\n\n## 多线程——番外篇\n\n### 1.静态代理\n\n> 首先，考虑有这样一种需求，项目经理要求在所有类的每一个方法运行前后加上日志，但又要求不能对已有代码做改动，怎样解决呢？\n\n我们可以创建一个代理对象，让它和目标对象实现同样的接口，这样就可以借代理对象之手调用目标对象的方法了。此外，我们还需要为这个代理对象加上日志方法，问题就迎刃而解了。\n\n从这段描述中，我们试着提取静态代理的关键：\n\n- **代理对象=目标对象+加强代码**；\n- 代理对象和目标对象需要`实现同一个接口`；\n\n那小伙伴也许会困惑，咋们不是在学习多线程吗，难道多线程中使用到了静态代理？没错，Thread类就可以看做是Runnable接口实现类的静态代理，通过下面的小例子我们来巩固一下——\n\n```java\npublic class StaticProxy {\n    public static void main(String[] args) {\n\n        //使用lambda来开启线程\n        new Thread(()->System.out.println(\"我爱你\")).start();\n        //类比着看，说明线程底层使用的即是静态代理\n        new WeddingCompany(new You()).happyMarry();\n\n        //将真实对象作为代理对象的参数传入\n        WeddingCompany weddingCompany = new WeddingCompany(new You());\n        weddingCompany.happyMarry();\n    }\n}\n\n/**\n *都需要实现的顶层接口\n */\ninterface Marry{\n    void happyMarry();\n}\n\n/**\n * 真实角色\n */\nclass You implements Marry {\n\n    @Override\n    public void happyMarry() {\n        System.out.println(\"洞房花烛夜\");\n    }\n}\n\n/**\n * 代理角色，代理角色能做的事情更多\n */\nclass WeddingCompany implements Marry {\n    //这里是关键\n    private Marry target;\n\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n\n    @Override\n    public void happyMarry() {\n        before();\n        this.target.happyMarry();//这里是真实对象做的事情\n        after();\n    }\n\n    private void after() {\n        System.out.println(\"结婚之后，收尾款\");\n    }\n\n    private void before() {\n        System.out.println(\"结婚之前，布置现场\");\n    }\n}\n\n\n```\n\n### 2.Lambda表达式\n\n首先通过下面的小例子了解下lambda的写法——\n\n```java\nExecutorService service = Executors.ExecutorService();\n\nservice.submit( () -> {\n    System.out.println(\"肚子有点饿\");\n})\n```\n\n而这里的方法参数实际上应该是实现Runnable接口的任务，也就是说，**lambda表达式本身就是接口的实现**。它`扩展了匿名内部类`，使得写法更加简洁高效。\n\n通过下面的实例来看下lambda的成长历程：\n\n```java\n\n```\n\n------\n\n### 3.java内存模型\n\njava试图屏蔽不同硬件与操作系统之间的内存访问差异，来实现java程序在各种平台都能运行的一致性数据访问。\n\n#### 工作内存与主内存\n\n我们知道，CPU只负责运算，它将内存中的数据读取到寄存器中，CPU再取得寄存器的地址，最后执行指令。但寄存器(`CPU的零级缓存`)的读写速度比内存的读写速度快很多个数量级，为了缓冲这种速度差，引入了`高级缓存`。\n\n但加入高级缓存以后，又带来了新的问题：**缓存一致性**。如果多个缓存共享一个主内存中的变量，那么多个缓存中的数据可能不一样。需要引入协议来规范一致性问题：\n\n![image-20210327221223729](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221223729.png)\n\n工作内存通常存储在高速缓存和寄存器中，在工作内存中保存了`主内存变量的拷贝`。\n\n#### 内存间的交互操作\n\njava内存模型定义了8个操作来完成主内存和工作内存之间的交互——\n\n![image-20210327221528229](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221528229.png)\n\n- `read`：把一个变量的值从主内存传输到工作内存中\n- `load`：在 read 之后执行，把 read 得到的值放⼊工作内存的变量副本中\n- `use`：把工作内存中⼀个变量的值传递给执行引擎\n- `assign`：把一个从执行引擎接收到的值赋给工作内存的变量\n- `store`：把工作内存的一个变量的值传送到主内存中\n- `write`：在 store 之后执行，把 store 得到的值放入主内存的变量中\n- `lock`：作⽤用于主内存的变量\n\n#### 内存模型的三大特性\n\n1. **原子性：**\n\n   上面我们提到了8种对内存的操作，这些操作作用的变量在被volatile修饰时都是原子性的。但`内存模型允许java虚拟机将没有被volatile修饰的64位数据，即long,double，划分为两个32位的数据执行`，即在这种情况下，操作不是原子性的。\n\n   但int型的数据就是原子性的吗？也不尽然，对数据的操作通常不是单一的操作可以完成的，简要的说，count++就分为read,assign,write三步。这三步整合起来并不是原子性的。\n\n   那如何保证原子性呢？`直观的方式就是加锁`咯，将count++的代码块用synchronized修饰。还有其他基于同步框架的方式吗？\n\n   `AtomicInteger`就是JUC框架下的这样一种方式，那它是如何实现的呢？\n\n   ![image-20210327223155578](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327223155578.png)\n\n   显然，它应用了`CAS的自旋思想`。\n\n2. **可见性：**\n\n   可见性指的是`当一个线程修改了主内存中的值以后，其他线程可以立刻获知这个修改`，java内存模型是通过将变量修改后的值同步回主内存，在变量读取之前刷新主内存中的值来实现的。\n\n   主要有三种实现可见性的方式：\n\n   - `volatile`\n   - `synchronized`,对一个变量使用unlock之前，必须将变量的值同步回主内存；\n   - `final`,被final修饰的字段，在初始化之后，如果没有发生this逃逸，那么其他线程就能看见final字段的值。\n\n3. **有序性：**\n\n   有序性指的是：`在本线程中观察，所有操作都是有序的。在一个线程中观察另一个线程，所有操作都是无序的`。\n\n   本线程有序还好理解，另一个线程无序就有点摸不着头脑了。\n\n> 无序是因为发生了`指令重排序`，在java内存模型中，允许编译器和处理器对指令进行重排序，重排序的过程不会影响单线程程序的执行，却会影响多线程并发执行的正确性。\n>\n> volatile关键字通过添加`内存屏障`的方式来禁止指令重排，即重排序时不能把后面的指令放在内存屏障之前。\n>\n> 当然，也可以通过`sychronized`来保证有序性。\n\n> 日拱一卒，功不唐捐。\n\n------\n\n##  多线程——白银时代\n\n### 1.多线程不安全的案例\n\n多个线程在访问同一个变量时有可能出现并发错误，我们通过下面的例子来演示并发错误，并借此分析并发错误出现的原因及解决方式——\n\n```java\npackage synchonized;\n\npublic class TestMakeup {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Makeup(0, \"灰菇凉\"));\n        Thread thread1 = new Thread(new Makeup(1, \"白雪公主\"));\n        thread.start();\n        thread1.start();\n    }\n}\n\nclass LipStick{\n\n}\n\nclass Mirror{\n\n}\n\n/**\n * 两个女孩分别持有镜子与口红的锁，然后都去等待对方的资源\n */\nclass Makeup implements Runnable{\n    int choice;\n    String person;\n\n    //static表示只有一份\n    static LipStick lipStick = new LipStick();\n    static Mirror mirror = new Mirror();\n\n    public Makeup(int choice, String person) {\n        this.choice = choice;\n        this.person = person;\n    }\n\n    @Override\n    public void run() {\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    //互相请求对方所持有的的锁就会导致死锁，死锁的四个必要条件：互斥，请求与保持，不可剥夺，循环等待，\n    public void makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipStick){\n                System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n                Thread.sleep(1000);//一秒后要去获得镜子\n            }\n            synchronized (mirror){\n                System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n            }\n            /**死锁——\n             * synchronized (lipStick){\n                  System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n                     synchronized (mirror){\n                       Thread.sleep(1000);//一秒后要去获得镜子\n                       System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n                     }\n             }\n             *\n             */\n        }else{\n            synchronized (mirror){\n                System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n                Thread.sleep(2000);//2秒后要去获得口红\n            }\n            synchronized (lipStick){\n                System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n            }\n        }\n    }\n}\n\n\n```\n\n在上面的例子中，我们看到假如`双方都在持有自己锁的前提下，请求对方的锁`时。可能导致并发错误的表现之一——死锁，这里再来回顾一下形成死锁的必要条件——\n\n- `互斥：`一个资源只能被一个线程使用；\n- `循环等待：`死锁的状况不会因为时间改变而改善；\n- `请求与持有：`在没有获得请求锁的前提下，不会释放自己持有的锁。\n- `不可剥夺：`线程只能主动让出资源，不能强取；\n\n------\n\n那还有什么原因会导致并发错误呢？并发错误的表现有这样几种情况——\n\n1. 访问**共享变量**导致数据不一致；\n2. CPU还没有完成所有线程的调度，线程就已经提前结束了；\n\n那么，针对并发错误的原因，我们可以得到解决并发错误的策略——\n\n1. **互斥同步**：对发生更新的数据加锁，即java互斥同步的两种锁机制：synchronized与Lock;\n2. **final**: 直接将变量声明为 不可变的，就不存在变量了，这波曲线解决问题；\n3. **非阻塞同步**：CAS机制\n4. **不同步机制**：需要同步是因为多个线程共享一个变量，那要实现不同步，就让每个线程独享一份变量就好咯，通常解决方式有这么几种：\n   1. `栈封闭`\n   2. `线程本地存储`\n   3. `可重入代码`\n\n这里我们暂且只介绍互斥同步的解决方式，其他策略在黄金时代中会重点描述，现在混个眼熟~\n\n------\n\n### 2.synchronized\n\n#### 1.synchronized的使用场景\n\n- 修饰`代码块`\n\n  ![image-20210328100335007](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100335007.png)\n\n- 修饰`实例方法`，也就是对this对象加锁\n\n  ![image-20210328100502317](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100502317.png)\n\n- 修饰`静态方法`，即对class对象加锁\n\n  ​\t![image-20210328100915411](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100915411.png)\n\n#### 2.synchronized的基本机制\n\n我们之前谈到java内存模型有三大特性：`有序性，可见性，原子性`。而synchronized作用于存储在内存中的变量或代码块上，它除了拥有内存模型的三大特性外，还有`可重入性`，谈到可重入性首先要知道synchronized是如何实现加锁和解锁的。\n\n##### 加锁与解锁\n\n我们将**class文件反编译**可以得到：\n\n![image-20210328101501442](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328101501442.png)\n\n对应来看，加锁和解锁显然是通过**monitorenter和monitorexit**实现的。也就是说获取对象的锁，实质上就是获取对象的monitor，即**监视器**，那如何来标识线程拥有该监视器呢？synchronized在锁对象时会获得一个**计数器**，用来**标识线程获得锁的次数**，线程每重入一次锁，计数器就会加1，对应的线程每调用monitorexit退出一次锁，计数器就会减1.如果计数器减为0，则说明锁已被释放。\n\n这是线程获得锁的情况，但假如线程阻塞了呢——\n\n![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-2.png)\n\n显然，如果获取失败，线程就会进入**同步队列**，状态变更为**阻塞态**，直到锁被释放以后，同步队列中的线程才有机会获得锁。\n\n##### 可重入性原理\n\n现在来分析可重入性，就变得非常友好了。线程在重入时，`会首先判断计数器的值`，如果计数器不为0，也就是线程拥有锁，则直接进入，不需要反复获取锁。\n\n发生死锁的必要条件之一即为`循环等待`，而可重入性打破了这一原因，可见`可重入性能够有效防止死锁的出现`。\n\n##### 同步方法的底层实现\n\n同步方法区别于代码块，它会首先判断标志位**ACC_SYNCHRONIZED**,如果存在该标志位，才会去隐式的调用monitorenter与monitorexit指令。即最终都归于monitor对象。\n\n我们所熟识的锁升级，无非是调用了**ObjectMonitor对象不同的实现**，如果失败了，再调用更高级的实现即可。\n\n##### 重量锁\n\n在看ObjectMonitor的源码时，我们会发现内核函数的存在，它们分别对应**park()和unpark()**,而synchronized是JVM管理的，JVM是应用程序，处于用户态，而内核函数在内核态，`切换的过程耗费资源较低，因此得名重量锁`。\n\n再来简单回顾下内核态与用户态的切换——\n\n1. 用户态将数据存储在`寄存器`中，并保存堆栈信息；\n2. 通过`系统调用`的方式，即通过`外中断`进入内核态；\n3. `CPU取指执行`，即跳转到指定的内存位置处执行指令；\n4. `读取寄存器中的参数`，维护内核栈的堆栈信息；\n5. CPU`重置操作系统为内核态`。\n\n#### JVM中锁的优化\n\n既然用户态，内核态的切换是低效的，那我们不如**只在用户态做文章**，官方对锁的升级即是通过加函数调用，而非系统调用来实现的。首先概括性的看下图——\n\n<img src=\"https://pic2.zhimg.com/v2-79edfb4b2316d76ac653732fbdb72809_r.jpg\" alt=\"preview\" style=\"zoom:200%;\" />\n\n这张图着实有点烧脑，我们来看个简单的：\n\n![image-20210328105848069](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328105848069.png)\n\n这就是锁升级的方向咯。显然这个过程是不可逆的，我们来拆解它的每一步实现——\n\n- **偏向锁**\n\n  之前我们提到了，对象头是由Mark_Word和Klass_point组成，锁争夺也就是对monitor对象的争夺，`一旦线程持有该对象，标志位修改为1，进入偏向模式`。并将这个线程的ID记录在对象的Mark_Word中。\n\n  这个过程是使用`CAS乐观锁`来实现的，如果CAS失败，即锁对象获取失败。\n\n  偏向锁在`jdk1.6之后是默认开启`的，1.5中关闭。\n\n  ![preview](https://pic1.zhimg.com/v2-1c56b94b3f92c3aa3884f739a5e4b42c_r.jpg)\n\n  如果多个线程竞争偏向锁，那CAS乐观锁显然不那么实用了，就需要用到轻量级锁——\n\n- **轻量级锁**\n\n  轻量级锁的实现仍跟Mark_Word相关。如果对象是无锁的，JVM就会在当前线程的栈帧中创建一个叫做`锁记录(Lock Record)的空间`，用来存储锁对象`Mark_Word的拷贝`。最后将所记录的`owner字段指向当前对象`。\n\n  JVM接下来会利用CAS尝试将对象原本的`Mark_Word更新为Lock_Record的指针`。如果更新成功，改变锁的标志位，表明对象的锁已被获取，然后执行相关同步操作。\n\n  如果失败了，说明`锁可能被其他线程持有`，此时就需要继续升级锁，修改锁的状态，线程进入阻塞态。而还有一种可能，即当前`线程本身持有锁`，就需要判断当前对象的Mark_Wors是否指向当前线程的栈帧。\n\n  ![preview](https://pic3.zhimg.com/v2-a932f172d1e9ac967c213429054d8522_r.jpg)\n\n- **自旋锁**\n\n  上面提到如果修改不成功，就需要升级为自旋锁，自旋锁区别于重量锁，它如果没有竞争到锁对象，`就会不断循环，表现为CPU空转，而不是阻塞`。\n\n  空转的次数最多为10次，如果超过10次，就会升级为重量锁。\n\n------\n\n#### 锁的优缺点对比\n\n![image-20210328112941479](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328112941479.png)\n\n------\n\n### 3.lock\n\n剧情来到了互斥并发的半壁江山——lock。\n\nlock本身是一个`接口`，它提供了`更灵活的锁定操作`，即`手动的加锁与释放锁`。完全`不同的属性`，并且支持多个关联的对象`Condition`。\n\n特别地，它的实现类`ReadWriteLock`支持对共享资源的读锁。也可以使用`tryLock方法非阻塞`地获得锁。\n\n下面我们通过具体的实现类来看lock的实现机制——\n\n#### ReentrantLock\n\n![image-20210328124145535](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124145535.png)\n\nReentrantLock顾名思义，即`可重入的锁`。它的属性包含同步类的对象，该对象继承自AQS，即使用`双端队列实现的同步队列`。\n\n在来看下它的属性与方法——\n![image-20210328124815007](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124815007.png)\n\n嗯，提供了很多便捷，灵活的操作锁的方式，这里不再一一赘述，因为相比Lock的API，显然`JUC包下的API更香`~\n\n### 4.synchronized VS ReentrantLock\n\n- **重入**\n\n  `synchronized可重入`，因为加锁和解锁可以自动进程，不必担心最后释放锁。`ReentrantLock同样可以重入`，它的加锁和释放锁需要手动完成。\n\n- **实现**\n\n  `synchronied是JVM实现的`，而`ReentrantLock是JDK实现的`，也就是最终归于操作系统实现。\n\n- **性能**\n\n  jdk1.6以后对synchronied做了很多优化，。如今它们的性能平分秋色。\n\n- **功能**\n\n  ReentrantLock锁的粒度和灵活度，都明显优于synchronized.\n\n  ReentrantLock从它内部类可以看出，它有公平与非公平的同步方式之分。而`synchronized是非公平(不按时间顺序获取锁)的锁。`\n\n  ReentrantLock可以非阻塞的获取锁。且提供中断等待锁的线程机制。\n\n- **可见性**\n\n  我们知道，`synchronized的可见性是基于java内存模型的happens-before原则`，即在其他线程读取主内存的值前，主内存一定先被刷新。\n\n  而ReentrantLock的可见性是如何保障的呢？它的同步机制是基于AQS框架的，而`AQS框架的锁机制核心在于读写state变量`的值：\n\n  ![image-20210328152434820](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328152434820.png)\n\n这里简要插播一下：volatile是如何保证可见性的：\n\n> volatile基于JMM(java内存模型)的内存语义：\n>\n> 1. 当`写一个volatile变量`时，JMM会将线程本地内存中的变量刷新到主内存中；\n> 2. 当`读一个volatile变量`时，JMM会将线程对应的本地内存置为无效，然后从主内存中读取变量。\n\n那state变量既然由volatile修饰，那自然就可以保证可见性咯，当然，保证原子性是不可能的~\n\n## 多线程——黄金时代\n\n### 1.线程池\n\n#### 什么是线程池\n\n线程池的基本思想是`对象池`，当程序启动的时候，就会在内存中开辟出一块空间，来放置初始化好的线程。当需要使用线程时，就使用`线程调度器`从线程池中取出一个线程，当线程使用完后，再将它归还到线程池中。\n\n#### 使用线程池的好处\n\n- `方便管理线程`：比如延时执行，定时循环；\n- `控制线程并发数量`：如果线程数量不加控制，会大致线程占用内存过多，从而四死机；\n- `减少创建，销毁开销`：每个线程可以被重复利用，可以执行多个任务\n\n#### 线程池的主要组件\n\n![img](https://user-gold-cdn.xitu.io/2018/7/8/16477f7912b4552a?imageslim)\n\n1. `线程池管理器ThreadPool`：用于创建和管理线程池；\n2. `任务接口Task`：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，执行完的收尾工作，任务的执行状态；\n3. `工作线程workThread`：线程池中的线程，没有任务时处于等待状态；\n4. `任务队列taskQueue`：用于存放没有处理的任务，起一种`缓冲的作用`。\n\n#### ThreadPoolExecutor类解析\n\n我们可以通过ThreadPoolExecutor来创建一个线程——\n\n![image-20210328164241430](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328164241430.png)\n\n再来深入地看下这些参数的意义：\n\n1. `corePoolSize`：即线程池的基本大小，任务队列每提交一个任务，线程池就会创建一个线程，当提交的任务数大小线程池的基本大小时，就不再创建线程；\n2. `maxinumPoolSize`：即线程池允许创建的最大线程数；\n3. `KeepAliveTime`：即线程池的工作线程空闲了以后，保持存活的时间；\n4. `TImeUnit`：即线程活动保持时间的单位；\n5. `workQueue`：用来保存等待执行的阻塞队列；\n6. `threadFactory`：线程工厂，在debug和定位问题时非常有帮助；\n7. `RejectedExecutionHandler`：拒绝策略，下文会详细描述。\n\n##### 向线程池提交任务\n\n- `execute()`：无返回值，无法判断任务是否被执行成功；\n- `submit()`：返回一个future的泛型对象，通过get方法可以获得返回值。\n\n##### 线程池的关闭\n\n- `shutdown`：将线程池的状态设置为`SHUTDOWN状态`，然后中断所有没有执行任务的线程；\n- `shutdownNow`：遍历工作线程，逐个调用线程的`interrupt方法`。\n\n##### 线程池的执行流程\n\n![img](https://user-gold-cdn.xitu.io/2018/7/8/16477fc44a03d90f?imageslim)\n\n##### 四种拒绝策略\n\n1. `AbortPolicy`：丢弃任务并抛出RejectedExecutionException异常\n\n   ![\t](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171249081.png)\n\n2. `DiscardPolicy`：丢弃任务但不抛出异常\n\n   ![image-20210328171502262](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171502262.png)\n\n3. `DisCardOldSetPolicy`：丢弃队列最前面的任务，然后提交新来的任务\n\n   ![image-20210328171523558](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171523558.png)\n\n4. `CallerRunPolicy`：由调用线程处理该任务\n\n   ![image-20210328171435296](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171435296.png)\n\n#### 四种线程池\n\n- `CachedThreadPool()`:可缓冲线程池\n- `FIxedThreadPool()`:定长线程池\n- `ScheduledThreadPool()`:定时线程池\n- `SingleThreadExecutor()`:单线程化的线程池\n\n#### 为什么不推荐使用JUC的线程池\n\n1. newFixedThreadPool和newSingleThreadExecutor\n\n   创建的`任务等待队列容量过大，耗费非常多的内存`~\n\n   ![image-20210329201950011](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329201950011.png)\n\n   ![image-20210329202057662](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202057662.png)\n\n2.newScheduledThreadPool和newCachedThreadPool\n\n​\t会`创建非常多的线程`，CPU压力大~\n\n​\t![image-20210329202312593](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202312593.png)\n\n#### 线程池的参数设置\n\n参数的设置和系统的负载有着直接的关系，系统负载有这样的一些参数：\n\n- `tasks`：每秒需要处理的任务数\n- `threadtasks`：每个线程每秒可以处理的任务数\n- `responsetime`：系统允许任务的最大响应时间。\n\n下面将用这些系统负载的参数来衡量线程池的参数——\n\n##### corePoolSize\n\n假设系统每秒任务数为100 ~ 1000，每个线程每钞可处理10个任务，则需要100 / 10至1000 / 10，即10 ~ 100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据`8020原则`，因为系统每秒任务数为100 ~ 1000，`即80%情况下系统每秒任务数小于1000 * 20% = 200`，则corePoolSize可设置为`200 / 10 = 20`。\n\n##### queueCapacity\n\n任务队列的长度可以设置为：`所有核心线程每秒处理任务数 * 每个任务响应时间 = 每秒任务总响应时间`\n\n##### maxPoolSize\n\n当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程，增加的线程数取决于任务队列容量和需求。\n\n千万不能直接创建任务队列，不然容量过大，占用内存过多，对系统压力大。\n\n![image-20210329204208430](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210329204208430.png)\n\n##### keepAliveTime\n\n当`负载降低时，可以减少线程的数量`，当线程的空闲时间超过keepAliveTime，会自动释放线程。\n\n##### allowCoreThreadTimeout\n\n默认情况下核心级线程不会退出，可通过该参数设置为true,使其退出。\n\n一般经验：线程池的大小应该这样设置：\n\n1. 如果是`CPU密集型应用`，线程池大小设置为`N+1`,N指CPU的个数；\n2. 如果是`IO密集型应用`，则线程池大小设置为`2N+1`;\n\n#### 线程的五种状态\n\n![img](https://user-gold-cdn.xitu.io/2020/3/20/170f73cc0dad76a5?imageslim)\n\n#### 什么场景下怎么设置线程池\n\n- `高并发、任务执行时间短的业务`\n\n线程池线程数可以设置为CPU核数+1，**减少线程上下文的切换**\n\n- `并发不高、任务执行时间长的业务`\n\n这个需要判断执行时间是耗在哪个地方\n\n1. 假如是业务时间长集中在`IO操作上`，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目（**2 * CPU核数**），让CPU处理更多的业务。\n2. 假如是业务时间长集中在计算操作上，也就是`CPU密集型任务`，和（1）**CPU核数+1** 一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换\n\n- `并发高、业务执行时间长的业务`\n\n解决这种类型任务的关键不在于线程池而在于整体架构的设计\n\n### 2.JUC\n\n#### AQS框架\n\n我们知道JUC是一个**定义并发操作并安全处理并发**的框架。而要了解JUC包的全貌，我们首先需要定义处理`并发的组件`，也就是锁和同步器。这种功能就是由AQS所提供的。\n\nAQS的全称是`AbstractQueuedSynchronizer`，即抽象队列同步器。它是java并发用来构建锁和同步器的基础框架。它包含`先进先出的双端队列，状态量，线程持有者的引用`。\n\n![img](https://upload-images.jianshu.io/upload_images/24459569-f4323d6ace89b32d.png)\n\n这里的state是由volatile修饰的，即它满足线程间的可见性，另外，它记录了`锁的持有者`：\n\n![image-20210329223019662](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329223019662.png)\n\n当线程1想要获取monitor对象时，它的行为是这样的：\n\n![image-20210329224019027](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329224019027.png)\n\n------\n\n#### 工具类——同步器\n\n累了，不再文字描述了，把思维导图贴上来：\n\n![三大工具类-同步器](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/三大工具类-同步器.png)\n\n#### 其他组件\n\n![其他组件](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/其他组件.png)\n\n#### ThreadLocal\n\n[浅谈ThreadLocal](https://zhuanlan.zhihu.com/p/60375306)\n\n## 多线程——加餐\n\n### 1.关于多线程可行的实践\n\n- 给线程起个`有意义的名字`，这样可以方便找 Bug。\n- 缩小同步范围，从⽽而减少锁争用。例如对于 synchronized，应该`尽量使用同步块⽽而不是同步方法`。\n- 多用同步工具少用 wait() 和 notify()。首先`，CountDownLatch, CyclicBarrier, Semaphore 和Exchanger 这些同步类简化了了编码操作，⽽用 wait() 和 notify() 很难实现复杂控制流`；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不不断优化和完善。\n- 使用`BlockingQueue 实现生产者消费者问题`。多用并发集合少用同步集合，例如应该`使用 ConcurrentHashMap ⽽而不是 Hashtable`。\n- 使用`本地变量`和`不可变类`来保证线程安全。使用线程池⽽不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。\n\n------\n\n> 山高路远，静水深流.","slug":"java多线程的前世今生","published":1,"updated":"2023-09-24T09:50:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7mq002jxjcc0drs4tjd","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一个多月没写过博文了，不是没有<strong>值得记录的故事</strong>，确是静不下心。网申在即，靠目前的积淀，知识地图中缺了一大块，索性打消了网申的念头。但不免有些落寞，像极了<strong>落跑的小橘子</strong>。</p>\n<p>这个<code>时代越来越卷了</code>，但也正因如此，我才更信奉积淀的魅力，这也正是我整理心态，继续出发的缘由。</p>\n<p>这不是第一次学习多线程了，在自学时，培训班上都接触过多线程，但都只是浅尝辄止，这次咬定青山不放松，终于<strong>顿悟了一些关键的知识</strong>，恍然间柳暗花明，便有了这篇文章。</p>\n<hr>\n<h2 id=\"多线程——入门\"><a href=\"#多线程——入门\" class=\"headerlink\" title=\"多线程——入门\"></a>多线程——入门</h2><p>在操作系统中，我们了解到，<strong>多进程图像</strong>是操作系统最核心，最基础的图像。而用户通过系统调用的方式间接与操作系统交互。想象这样一种场景，我们一边放着音乐，一边浏览网页——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327092252968.png\" alt=\"image-20210327092252968\"></p>\n<p>这就是触目可及的多进程图像，显然，这两个进程之间使用的是不同的资源，不妨假设我的处理器是单核的，每一时刻只能处理一个进程，那<code>CPU就要为两个进程分配时间片</code>，然后根据调度算法切换进程，串行执行。</p>\n<p>如何切换进程呢？首先要理解进程是什么——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619000547145.png\" alt=\"image-20210619000547145\"></p>\n<p>也就是说，进程就是：<strong>指令执行序列+资源</strong>，因此直观的切换进程就是切换进程的这两部分，但资源的切换是非常浪费时间的，能不能<code>只切换指令执行序列</code>呢？聊到这，小伙伴就有了这样的猜想：指令执行序列与线程有什么关系呢？</p>\n<p>没错，<strong>指令执行序列就是线程集</strong>。我们深入到进程中找找，就会发现线程集没有我们想象中的那么遥不可及——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327094410019.png\" alt=\"image-20210327094410019\"></p>\n<p>下载听歌两不误，如此丝滑的切换，都得益于<strong>线程的并发应用</strong>。也就是多线程咯。到这里，故事才真正的拉开序幕——</p>\n<hr>\n<h3 id=\"1-进程与线程\"><a href=\"#1-进程与线程\" class=\"headerlink\" title=\"1.进程与线程\"></a>1.进程与线程</h3><p>前面提到的都是直观的印象，这里由表及内地聊聊进程与线程——</p>\n<ul>\n<li><code>进程： </code>进程是<strong>上下文切换之间的程序执行的部分</strong>，而所谓上下文，即是<code>CPU与寄存器</code>。通俗地说，也就是说进程执行的环境。在这个环境下运行着的程序即是进程。</li>\n<li><code>线程： </code>线程是<strong>轻量级的进程</strong>，这里的轻量级如何理解呢？<code>线程集</code>共享了进程的<code>上下文环境，地址空间，更为细小的CPU时间片</code>。</li>\n</ul>\n<p>对于如何更好地理解进程与线程之间的关系，有大佬已经讲的非常形象了，我们不妨站在巨人的肩膀上——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://www.zhihu.com/question/25532384\">将进程比作火车，线程比作车厢</a></li>\n</ul>\n<hr>\n<h3 id=\"2-所谓多线程\"><a href=\"#2-所谓多线程\" class=\"headerlink\" title=\"2.所谓多线程\"></a>2.所谓多线程</h3><p>在讲述多线程之前，非常有必要搞懂这几个概念——</p>\n<ul>\n<li><p><code>并发</code>：一些任务都处于可运行的状态，但只有一个任务可以被调度并执行，而具体是哪一个任务被处理仍是不确定的。</p>\n</li>\n<li><p><code>串行与并行</code></p>\n<ol>\n<li>多任务中<strong>某时刻</strong>只能有一个任务被运行，单核下皆为串行；</li>\n<li>某时刻可以有多个任务同时被执行，在多核计算机上可以实现并行；</li>\n</ol>\n</li>\n<li><p><code>阻塞与非阻塞</code>：</p>\n<ol>\n<li>以文件读取为例，应用层会调用系统内核中的IO接口，如open，close等，在请求发出以后，如果调用的是<strong>阻塞型IO</strong>，应用层被挂起，一直处于等待数据返回的状态。直到从磁盘上读取数据并返回给应用层后，应用层采用获取到的数据进行下一步操作；</li>\n<li>如果应用层调用的是<strong>非阻塞I/O</strong>，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。</li>\n</ol>\n<p>也就是说阻塞与非阻塞的区别在于<strong>发出请求后等待数据返回时的状态</strong>。</p>\n</li>\n<li><p><code>同步与异步</code>：</p>\n<ul>\n<li>阻塞与非阻塞决定了应用层等待数据返回的状态，而<strong>数据如何从系统内核返回</strong>呢？返回的方式取决于同步与异步——</li>\n<li>对于同步型的调用，应用层会不<strong>断问询系统内核</strong>，但它的动作取决于是否阻塞，数据返回给应用层后，应用层继续做其他的事情；</li>\n<li>对于异步型的调用，应用层<strong>不关心数据何时返回</strong>，此时它的动作同样却绝育是否阻塞，系统内核会主动通知应用层数据已经读取完毕并返回。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>好啦，啰嗦了这么多，也该祭出这张图了——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327104345505.png\" alt=\"image-20210327104345505\"></p>\n<p>用语言描述就是：<strong>多线程无非是多个线程处于并发的状态</strong>。</p>\n<p>片头就这么多了，暂且告一段落。如果哪天灵光一现，也会再修修补补。</p>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"关于下文\"><a href=\"#关于下文\" class=\"headerlink\" title=\"关于下文\"></a>关于下文</h2><p>借鉴王一波前辈的书名，下面的篇幅按照多线程的重要程度渐进地划分为三个阶段——</p>\n<ul>\n<li><code>青铜时代</code>：主要描述线程的基本知识，也是最不可或缺的一部分，此外，由此衍生的静态代理，lambda表达式也可先入门一手；</li>\n<li><code>白银时代</code>：这一阶段是多线程并发的问题与基本解决方案，同样也是应用与面试的一大热门。</li>\n<li><code>黄金时代</code>：简言之，这一部分是高端操作，也是面试造火箭的宠儿，但其中的机制却并不新鲜，反而有点拾操作系统思想牙髓的意思。可见，最基本，最通用的反而具有最长久的生命力，</li>\n</ul>\n<hr>\n<h2 id=\"多线程——青铜时代\"><a href=\"#多线程——青铜时代\" class=\"headerlink\" title=\"多线程——青铜时代\"></a>多线程——青铜时代</h2><h3 id=\"1-创建的三种方式\"><a href=\"#1-创建的三种方式\" class=\"headerlink\" title=\"1.创建的三种方式\"></a>1.创建的三种方式</h3><p>在java中，创建线程有3种方式，分别是继承Thread类，实现Runnable接口，实现Callable接口。而实现Runnable接口只能得到任务，<strong>任务还需要线程驱动才能执行</strong>、</p>\n<h4 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327130931773.png\" alt=\"image-20210327130931773\"></p>\n<p>首先实现Runnable接口得到Runnable实例。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CreateThread2</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">&#123;</span>\n   \n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//do something</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用Runnable实例再创建一个Thread实例，调用Thread实例的start()开启一个线程——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建实现类</span>\n    <span class=\"token class-name\">CreateThread2</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//同样调用Thread来开启线程，最终是使用runnable接口的代理来调用</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"实现Callable接口\"><a href=\"#实现Callable接口\" class=\"headerlink\" title=\"实现Callable接口\"></a>实现Callable接口</h4><p>与Runnable相比，Callable接口具有返回值。返回值用**Future<V>**封装——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * 使用Callable接口实现图片的下载\n *\n * callable的好处——\n * 1. 有返回值\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CreateThread3</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> url<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>url <span class=\"token operator\">=</span> url<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Boolean</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">WebDownload</span> webDownload <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebDownload</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            webDownload<span class=\"token punctuation\">.</span><span class=\"token function\">download</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">+</span><span class=\"token string\">\"下载成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">MalformedURLException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"图片下载异常\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ExecutionException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">CreateThread3</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://img95.699pic.com/photo/40011/0709.jpg_wh860.jpg\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"E:/1.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">CreateThread3</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://static.runoob.com/images/demo/demo4.jpg\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"E:/2.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">CreateThread3</span> t3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://seopic.699pic.com/photo/50034/6414.jpg_wh1200.jpg\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"E:/3.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//创建固定线程数的线程池</span>\n        <span class=\"token class-name\">ExecutorService</span> service <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//提交执行</span>\n        <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> r1 <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> r2 <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> r3 <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>t3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//获取结果</span>\n        <span class=\"token class-name\">Boolean</span> res1 <span class=\"token operator\">=</span> r1<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Boolean</span> res2 <span class=\"token operator\">=</span> r2<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Boolean</span> res3 <span class=\"token operator\">=</span> r3<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//关闭服务</span>\n        service<span class=\"token punctuation\">.</span><span class=\"token function\">shutdownNow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">WebDownload</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">download</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">FileUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyURLToFile</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">URL</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h4><p>继承Thread类同样需要重写run方法，但run方法却仅仅只是Thread类的冰山一角，Thread类非常庞大，它包含了<code>线程的状态，分类，并发安全</code>，不一而足：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327132338149.png\" alt=\"image-20210327132338149\"></p>\n<p>来看代码实现——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">createThread</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CreateThread1</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/**\n     * run方法线程体\n     */</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"五味杂陈\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 主线程方法体\n     * @param args\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">CreateThread1</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//可以看到调用start方法以后，主线程与run方法线程交替执行，总体先执行main主线程，也许是因为优先级较高！</span>\n        <span class=\"token comment\">//假如不是多线程，会怎样执行？</span>\n        <span class=\"token comment\">//那就应该在主线程中调用run的线程，在run线程执行完后再回到主线程，绝不会发生交替！</span>\n        <span class=\"token comment\">//线程的调度完全由CPU决定</span>\n        t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//可能会被提前终止</span>\n        t<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">200</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"陈杂味五\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当调用start以后，虚拟机将线程放入就绪队列等待被调度，线程被调度后则执行run方法。</p>\n<h4 id=\"Runnable-VS-Thread\"><a href=\"#Runnable-VS-Thread\" class=\"headerlink\" title=\"Runnable VS Thread\"></a>Runnable VS Thread</h4><p>实现接口会更好一些，因为：</p>\n<ol>\n<li>java是<code>单继承，可扩展性不好</code>，继承了Thread类就无法再继承其他类，而接口可以多实现；</li>\n<li><code>Thread类这么臃肿</code>，如果只是执行简单的线程任务，则继承Thread类显得大而无用。</li>\n</ol>\n<hr>\n<h3 id=\"2-线程的状态与属性\"><a href=\"#2-线程的状态与属性\" class=\"headerlink\" title=\"2.线程的状态与属性\"></a>2.线程的状态与属性</h3><h4 id=\"开局一张图\"><a href=\"#开局一张图\" class=\"headerlink\" title=\"开局一张图\"></a>开局一张图</h4><p><img src=\"C:\\Users\\zyz\\Desktop\\每日思维导图\\线程的状态.png\" alt=\"线程的状态\"></p>\n<p>关于状态的琐碎知识，我就不展开了，<strong>思维导图描述的更系统也更简洁这样记忆的效果更好</strong>，针对状态的切换，在网上找到一张很细致的图片——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327134912906.png\" alt=\"image-20210327134912906\"></p>\n<p>来看切换内部的机制——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327141723664.png\" alt=\"image-20210327141723664\"></p>\n<h4 id=\"一点小贴士\"><a href=\"#一点小贴士\" class=\"headerlink\" title=\"一点小贴士\"></a>一点小贴士</h4><p>在这里，我们来解释一些关于线程切换与分类中，含糊不清的知识点：</p>\n<ol>\n<li><code>进程与线程的状态基本一致</code>，一家之言；</li>\n<li><code>阻塞是一种状态，挂起是一种行为</code>，挂起的结果是阻塞；</li>\n<li>当run方法执行完后，线程则退出，变为死亡状态。而使用执行器，需要手动的关闭服务，从而关闭线程，关闭服务<code>shutDownNow</code>的底层会<code>调用interrupt方法</code>，该方法不一定是即时的，<code>它会使线程在安全的时候退出</code>,这同时也是中断的用途。</li>\n<li><code>wait会释放对象的锁，而sleep并不会</code>。也就是说线程调用wait进入阻塞状态，使用notify唤醒线程，而后进入就绪队列等待。而sleep则可以直接执行。</li>\n</ol>\n<h3 id=\"3-线程的基本机制\"><a href=\"#3-线程的基本机制\" class=\"headerlink\" title=\"3.线程的基本机制\"></a>3.线程的基本机制</h3><p>在上面的内容中，我们突兀地使用了<strong>很多看起来没有支撑的知识点</strong>。我想小伙伴们也同样会困惑，对象锁是如何实现的？它的机制是怎样的？线程这么多的状态，我们都要耳提面命的测试吗？</p>\n<p>对于这些问题，java中的多线程给出了一个基本的机制来解决——</p>\n<h4 id=\"对象锁\"><a href=\"#对象锁\" class=\"headerlink\" title=\"对象锁\"></a>对象锁</h4><p>在JVM中，对象在内存中被分成了三个区域——</p>\n<ol>\n<li><strong>对象头</strong><ol>\n<li><code>Mark_word(标记字段)</code>，默认存储<code>对象的锁标志位</code>，hashcode,分代年龄。它会根据锁的状态复用它的存储空间，也就是说，运行期间Mark_word中的信息会随着锁对象的变化而变化；</li>\n<li><code>Klass_point(类型指针)</code>：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象属于哪个类。</li>\n</ol>\n</li>\n<li><strong>实例信息</strong>：主要存放类的数据信息，父类的数据信息；</li>\n<li><strong>对齐填充</strong>：即任何一个对象，都会被按位填充，即便是空对象也是如此。</li>\n</ol>\n<p>线程拥有对象的锁标志位，即表示线程可以访问该对象。从而可以通过对对象锁的操作来实现并发安全。</p>\n<h4 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h4><p>如果程序员直接管理线程的生命周期，未免舍本逐末，太过繁琐。java为我们提供了大管家——<em><strong>Executor</strong></em>。</p>\n<p><strong>Exector会将线程的开启与运行机制分离开</strong>，简化程序员的操作。它是是JUC包下的一个类，提供了三种可选的Executor:</p>\n<ul>\n<li><code>CachedThreadPool</code>：一个任务创建一个线程；</li>\n<li><code>FixedThreadPool</code>：所有任务只能使⽤用固定⼤小的线程；</li>\n<li><code>SingleThreadExecutor</code>：相当于大小为 1 的 FixedThreadPool。</li>\n</ul>\n<p>简要看下它的使用——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建线程池</span>\n    <span class=\"token class-name\">ExecutorService</span> executorService<span class=\"token operator\">=</span><span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//执行</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>inti<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MyRunnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//关闭服务</span>\n    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"多线程——番外篇\"><a href=\"#多线程——番外篇\" class=\"headerlink\" title=\"多线程——番外篇\"></a>多线程——番外篇</h2><h3 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1.静态代理\"></a>1.静态代理</h3><blockquote>\n<p>首先，考虑有这样一种需求，项目经理要求在所有类的每一个方法运行前后加上日志，但又要求不能对已有代码做改动，怎样解决呢？</p>\n</blockquote>\n<p>我们可以创建一个代理对象，让它和目标对象实现同样的接口，这样就可以借代理对象之手调用目标对象的方法了。此外，我们还需要为这个代理对象加上日志方法，问题就迎刃而解了。</p>\n<p>从这段描述中，我们试着提取静态代理的关键：</p>\n<ul>\n<li><strong>代理对象=目标对象+加强代码</strong>；</li>\n<li>代理对象和目标对象需要<code>实现同一个接口</code>；</li>\n</ul>\n<p>那小伙伴也许会困惑，咋们不是在学习多线程吗，难道多线程中使用到了静态代理？没错，Thread类就可以看做是Runnable接口实现类的静态代理，通过下面的小例子我们来巩固一下——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StaticProxy</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n        <span class=\"token comment\">//使用lambda来开启线程</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我爱你\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//类比着看，说明线程底层使用的即是静态代理</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeddingCompany</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">You</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//将真实对象作为代理对象的参数传入</span>\n        <span class=\"token class-name\">WeddingCompany</span> weddingCompany <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeddingCompany</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">You</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        weddingCompany<span class=\"token punctuation\">.</span><span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n *都需要实现的顶层接口\n */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Marry</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 真实角色\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">You</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Marry</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"洞房花烛夜\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 代理角色，代理角色能做的事情更多\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">WeddingCompany</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Marry</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//这里是关键</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Marry</span> target<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">WeddingCompany</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Marry</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这里是真实对象做的事情</span>\n        <span class=\"token function\">after</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">after</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"结婚之后，收尾款\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"结婚之前，布置现场\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-Lambda表达式\"><a href=\"#2-Lambda表达式\" class=\"headerlink\" title=\"2.Lambda表达式\"></a>2.Lambda表达式</h3><p>首先通过下面的小例子了解下lambda的写法——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ExecutorService</span> service <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors<span class=\"token punctuation\">.</span>ExecutorService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nservice<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"肚子有点饿\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而这里的方法参数实际上应该是实现Runnable接口的任务，也就是说，<strong>lambda表达式本身就是接口的实现</strong>。它<code>扩展了匿名内部类</code>，使得写法更加简洁高效。</p>\n<p>通过下面的实例来看下lambda的成长历程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"3-java内存模型\"><a href=\"#3-java内存模型\" class=\"headerlink\" title=\"3.java内存模型\"></a>3.java内存模型</h3><p>java试图屏蔽不同硬件与操作系统之间的内存访问差异，来实现java程序在各种平台都能运行的一致性数据访问。</p>\n<h4 id=\"工作内存与主内存\"><a href=\"#工作内存与主内存\" class=\"headerlink\" title=\"工作内存与主内存\"></a>工作内存与主内存</h4><p>我们知道，CPU只负责运算，它将内存中的数据读取到寄存器中，CPU再取得寄存器的地址，最后执行指令。但寄存器(<code>CPU的零级缓存</code>)的读写速度比内存的读写速度快很多个数量级，为了缓冲这种速度差，引入了<code>高级缓存</code>。</p>\n<p>但加入高级缓存以后，又带来了新的问题：<strong>缓存一致性</strong>。如果多个缓存共享一个主内存中的变量，那么多个缓存中的数据可能不一样。需要引入协议来规范一致性问题：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221223729.png\" alt=\"image-20210327221223729\"></p>\n<p>工作内存通常存储在高速缓存和寄存器中，在工作内存中保存了<code>主内存变量的拷贝</code>。</p>\n<h4 id=\"内存间的交互操作\"><a href=\"#内存间的交互操作\" class=\"headerlink\" title=\"内存间的交互操作\"></a>内存间的交互操作</h4><p>java内存模型定义了8个操作来完成主内存和工作内存之间的交互——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221528229.png\" alt=\"image-20210327221528229\"></p>\n<ul>\n<li><code>read</code>：把一个变量的值从主内存传输到工作内存中</li>\n<li><code>load</code>：在 read 之后执行，把 read 得到的值放⼊工作内存的变量副本中</li>\n<li><code>use</code>：把工作内存中⼀个变量的值传递给执行引擎</li>\n<li><code>assign</code>：把一个从执行引擎接收到的值赋给工作内存的变量</li>\n<li><code>store</code>：把工作内存的一个变量的值传送到主内存中</li>\n<li><code>write</code>：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>\n<li><code>lock</code>：作⽤用于主内存的变量</li>\n</ul>\n<h4 id=\"内存模型的三大特性\"><a href=\"#内存模型的三大特性\" class=\"headerlink\" title=\"内存模型的三大特性\"></a>内存模型的三大特性</h4><ol>\n<li><p><strong>原子性：</strong></p>\n<p>上面我们提到了8种对内存的操作，这些操作作用的变量在被volatile修饰时都是原子性的。但<code>内存模型允许java虚拟机将没有被volatile修饰的64位数据，即long,double，划分为两个32位的数据执行</code>，即在这种情况下，操作不是原子性的。</p>\n<p>但int型的数据就是原子性的吗？也不尽然，对数据的操作通常不是单一的操作可以完成的，简要的说，count++就分为read,assign,write三步。这三步整合起来并不是原子性的。</p>\n<p>那如何保证原子性呢？<code>直观的方式就是加锁</code>咯，将count++的代码块用synchronized修饰。还有其他基于同步框架的方式吗？</p>\n<p><code>AtomicInteger</code>就是JUC框架下的这样一种方式，那它是如何实现的呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327223155578.png\" alt=\"image-20210327223155578\"></p>\n<p>显然，它应用了<code>CAS的自旋思想</code>。</p>\n</li>\n<li><p><strong>可见性：</strong></p>\n<p>可见性指的是<code>当一个线程修改了主内存中的值以后，其他线程可以立刻获知这个修改</code>，java内存模型是通过将变量修改后的值同步回主内存，在变量读取之前刷新主内存中的值来实现的。</p>\n<p>主要有三种实现可见性的方式：</p>\n<ul>\n<li><code>volatile</code></li>\n<li><code>synchronized</code>,对一个变量使用unlock之前，必须将变量的值同步回主内存；</li>\n<li><code>final</code>,被final修饰的字段，在初始化之后，如果没有发生this逃逸，那么其他线程就能看见final字段的值。</li>\n</ul>\n</li>\n<li><p><strong>有序性：</strong></p>\n<p>有序性指的是：<code>在本线程中观察，所有操作都是有序的。在一个线程中观察另一个线程，所有操作都是无序的</code>。</p>\n<p>本线程有序还好理解，另一个线程无序就有点摸不着头脑了。</p>\n</li>\n</ol>\n<blockquote>\n<p>无序是因为发生了<code>指令重排序</code>，在java内存模型中，允许编译器和处理器对指令进行重排序，重排序的过程不会影响单线程程序的执行，却会影响多线程并发执行的正确性。</p>\n<p>volatile关键字通过添加<code>内存屏障</code>的方式来禁止指令重排，即重排序时不能把后面的指令放在内存屏障之前。</p>\n<p>当然，也可以通过<code>sychronized</code>来保证有序性。</p>\n</blockquote>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"多线程——白银时代\"><a href=\"#多线程——白银时代\" class=\"headerlink\" title=\"多线程——白银时代\"></a>多线程——白银时代</h2><h3 id=\"1-多线程不安全的案例\"><a href=\"#1-多线程不安全的案例\" class=\"headerlink\" title=\"1.多线程不安全的案例\"></a>1.多线程不安全的案例</h3><p>多个线程在访问同一个变量时有可能出现并发错误，我们通过下面的例子来演示并发错误，并借此分析并发错误出现的原因及解决方式——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">synchonized</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestMakeup</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Thread</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Makeup</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"灰菇凉\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> thread1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Makeup</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"白雪公主\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LipStick</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Mirror</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 两个女孩分别持有镜子与口红的锁，然后都去等待对方的资源\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Makeup</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> choice<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">String</span> person<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//static表示只有一份</span>\n    <span class=\"token keyword\">static</span> <span class=\"token class-name\">LipStick</span> lipStick <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LipStick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token class-name\">Mirror</span> mirror <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mirror</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Makeup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> choice<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> person<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>choice <span class=\"token operator\">=</span> choice<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>person <span class=\"token operator\">=</span> person<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">makeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//互相请求对方所持有的的锁就会导致死锁，死锁的四个必要条件：互斥，请求与保持，不可剥夺，循环等待，</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">makeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>choice <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lipStick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用口红\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//一秒后要去获得镜子</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>mirror<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用镜子\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">/**死锁——\n             * synchronized (lipStick)&#123;\n                  System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n                     synchronized (mirror)&#123;\n                       Thread.sleep(1000);//一秒后要去获得镜子\n                       System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n                     &#125;\n             &#125;\n             *\n             */</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>mirror<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用镜子\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//2秒后要去获得口红</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lipStick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用口红\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上面的例子中，我们看到假如<code>双方都在持有自己锁的前提下，请求对方的锁</code>时。可能导致并发错误的表现之一——死锁，这里再来回顾一下形成死锁的必要条件——</p>\n<ul>\n<li><code>互斥：</code>一个资源只能被一个线程使用；</li>\n<li><code>循环等待：</code>死锁的状况不会因为时间改变而改善；</li>\n<li><code>请求与持有：</code>在没有获得请求锁的前提下，不会释放自己持有的锁。</li>\n<li><code>不可剥夺：</code>线程只能主动让出资源，不能强取；</li>\n</ul>\n<hr>\n<p>那还有什么原因会导致并发错误呢？并发错误的表现有这样几种情况——</p>\n<ol>\n<li>访问<strong>共享变量</strong>导致数据不一致；</li>\n<li>CPU还没有完成所有线程的调度，线程就已经提前结束了；</li>\n</ol>\n<p>那么，针对并发错误的原因，我们可以得到解决并发错误的策略——</p>\n<ol>\n<li><strong>互斥同步</strong>：对发生更新的数据加锁，即java互斥同步的两种锁机制：synchronized与Lock;</li>\n<li><strong>final</strong>: 直接将变量声明为 不可变的，就不存在变量了，这波曲线解决问题；</li>\n<li><strong>非阻塞同步</strong>：CAS机制</li>\n<li><strong>不同步机制</strong>：需要同步是因为多个线程共享一个变量，那要实现不同步，就让每个线程独享一份变量就好咯，通常解决方式有这么几种：<ol>\n<li><code>栈封闭</code></li>\n<li><code>线程本地存储</code></li>\n<li><code>可重入代码</code></li>\n</ol>\n</li>\n</ol>\n<p>这里我们暂且只介绍互斥同步的解决方式，其他策略在黄金时代中会重点描述，现在混个眼熟~</p>\n<hr>\n<h3 id=\"2-synchronized\"><a href=\"#2-synchronized\" class=\"headerlink\" title=\"2.synchronized\"></a>2.synchronized</h3><h4 id=\"1-synchronized的使用场景\"><a href=\"#1-synchronized的使用场景\" class=\"headerlink\" title=\"1.synchronized的使用场景\"></a>1.synchronized的使用场景</h4><ul>\n<li><p>修饰<code>代码块</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100335007.png\" alt=\"image-20210328100335007\"></p>\n</li>\n<li><p>修饰<code>实例方法</code>，也就是对this对象加锁</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100502317.png\" alt=\"image-20210328100502317\"></p>\n</li>\n<li><p>修饰<code>静态方法</code>，即对class对象加锁</p>\n<p>​    <img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100915411.png\" alt=\"image-20210328100915411\"></p>\n</li>\n</ul>\n<h4 id=\"2-synchronized的基本机制\"><a href=\"#2-synchronized的基本机制\" class=\"headerlink\" title=\"2.synchronized的基本机制\"></a>2.synchronized的基本机制</h4><p>我们之前谈到java内存模型有三大特性：<code>有序性，可见性，原子性</code>。而synchronized作用于存储在内存中的变量或代码块上，它除了拥有内存模型的三大特性外，还有<code>可重入性</code>，谈到可重入性首先要知道synchronized是如何实现加锁和解锁的。</p>\n<h5 id=\"加锁与解锁\"><a href=\"#加锁与解锁\" class=\"headerlink\" title=\"加锁与解锁\"></a>加锁与解锁</h5><p>我们将<strong>class文件反编译</strong>可以得到：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328101501442.png\" alt=\"image-20210328101501442\"></p>\n<p>对应来看，加锁和解锁显然是通过<strong>monitorenter和monitorexit</strong>实现的。也就是说获取对象的锁，实质上就是获取对象的monitor，即<strong>监视器</strong>，那如何来标识线程拥有该监视器呢？synchronized在锁对象时会获得一个<strong>计数器</strong>，用来<strong>标识线程获得锁的次数</strong>，线程每重入一次锁，计数器就会加1，对应的线程每调用monitorexit退出一次锁，计数器就会减1.如果计数器减为0，则说明锁已被释放。</p>\n<p>这是线程获得锁的情况，但假如线程阻塞了呢——</p>\n<p><img src=\"https://pdai.tech/_images/thread/java-thread-x-key-schronized-2.png\" alt=\"img\"></p>\n<p>显然，如果获取失败，线程就会进入<strong>同步队列</strong>，状态变更为<strong>阻塞态</strong>，直到锁被释放以后，同步队列中的线程才有机会获得锁。</p>\n<h5 id=\"可重入性原理\"><a href=\"#可重入性原理\" class=\"headerlink\" title=\"可重入性原理\"></a>可重入性原理</h5><p>现在来分析可重入性，就变得非常友好了。线程在重入时，<code>会首先判断计数器的值</code>，如果计数器不为0，也就是线程拥有锁，则直接进入，不需要反复获取锁。</p>\n<p>发生死锁的必要条件之一即为<code>循环等待</code>，而可重入性打破了这一原因，可见<code>可重入性能够有效防止死锁的出现</code>。</p>\n<h5 id=\"同步方法的底层实现\"><a href=\"#同步方法的底层实现\" class=\"headerlink\" title=\"同步方法的底层实现\"></a>同步方法的底层实现</h5><p>同步方法区别于代码块，它会首先判断标志位<strong>ACC_SYNCHRONIZED</strong>,如果存在该标志位，才会去隐式的调用monitorenter与monitorexit指令。即最终都归于monitor对象。</p>\n<p>我们所熟识的锁升级，无非是调用了<strong>ObjectMonitor对象不同的实现</strong>，如果失败了，再调用更高级的实现即可。</p>\n<h5 id=\"重量锁\"><a href=\"#重量锁\" class=\"headerlink\" title=\"重量锁\"></a>重量锁</h5><p>在看ObjectMonitor的源码时，我们会发现内核函数的存在，它们分别对应<strong>park()和unpark()</strong>,而synchronized是JVM管理的，JVM是应用程序，处于用户态，而内核函数在内核态，<code>切换的过程耗费资源较低，因此得名重量锁</code>。</p>\n<p>再来简单回顾下内核态与用户态的切换——</p>\n<ol>\n<li>用户态将数据存储在<code>寄存器</code>中，并保存堆栈信息；</li>\n<li>通过<code>系统调用</code>的方式，即通过<code>外中断</code>进入内核态；</li>\n<li><code>CPU取指执行</code>，即跳转到指定的内存位置处执行指令；</li>\n<li><code>读取寄存器中的参数</code>，维护内核栈的堆栈信息；</li>\n<li>CPU<code>重置操作系统为内核态</code>。</li>\n</ol>\n<h4 id=\"JVM中锁的优化\"><a href=\"#JVM中锁的优化\" class=\"headerlink\" title=\"JVM中锁的优化\"></a>JVM中锁的优化</h4><p>既然用户态，内核态的切换是低效的，那我们不如<strong>只在用户态做文章</strong>，官方对锁的升级即是通过加函数调用，而非系统调用来实现的。首先概括性的看下图——</p>\n<img src=\"https://pic2.zhimg.com/v2-79edfb4b2316d76ac653732fbdb72809_r.jpg\" alt=\"preview\" style=\"zoom:200%;\" />\n\n<p>这张图着实有点烧脑，我们来看个简单的：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328105848069.png\" alt=\"image-20210328105848069\"></p>\n<p>这就是锁升级的方向咯。显然这个过程是不可逆的，我们来拆解它的每一步实现——</p>\n<ul>\n<li><p><strong>偏向锁</strong></p>\n<p>之前我们提到了，对象头是由Mark_Word和Klass_point组成，锁争夺也就是对monitor对象的争夺，<code>一旦线程持有该对象，标志位修改为1，进入偏向模式</code>。并将这个线程的ID记录在对象的Mark_Word中。</p>\n<p>这个过程是使用<code>CAS乐观锁</code>来实现的，如果CAS失败，即锁对象获取失败。</p>\n<p>偏向锁在<code>jdk1.6之后是默认开启</code>的，1.5中关闭。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-1c56b94b3f92c3aa3884f739a5e4b42c_r.jpg\" alt=\"preview\"></p>\n<p>如果多个线程竞争偏向锁，那CAS乐观锁显然不那么实用了，就需要用到轻量级锁——</p>\n</li>\n<li><p><strong>轻量级锁</strong></p>\n<p>轻量级锁的实现仍跟Mark_Word相关。如果对象是无锁的，JVM就会在当前线程的栈帧中创建一个叫做<code>锁记录(Lock Record)的空间</code>，用来存储锁对象<code>Mark_Word的拷贝</code>。最后将所记录的<code>owner字段指向当前对象</code>。</p>\n<p>JVM接下来会利用CAS尝试将对象原本的<code>Mark_Word更新为Lock_Record的指针</code>。如果更新成功，改变锁的标志位，表明对象的锁已被获取，然后执行相关同步操作。</p>\n<p>如果失败了，说明<code>锁可能被其他线程持有</code>，此时就需要继续升级锁，修改锁的状态，线程进入阻塞态。而还有一种可能，即当前<code>线程本身持有锁</code>，就需要判断当前对象的Mark_Wors是否指向当前线程的栈帧。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-a932f172d1e9ac967c213429054d8522_r.jpg\" alt=\"preview\"></p>\n</li>\n<li><p><strong>自旋锁</strong></p>\n<p>上面提到如果修改不成功，就需要升级为自旋锁，自旋锁区别于重量锁，它如果没有竞争到锁对象，<code>就会不断循环，表现为CPU空转，而不是阻塞</code>。</p>\n<p>空转的次数最多为10次，如果超过10次，就会升级为重量锁。</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"锁的优缺点对比\"><a href=\"#锁的优缺点对比\" class=\"headerlink\" title=\"锁的优缺点对比\"></a>锁的优缺点对比</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328112941479.png\" alt=\"image-20210328112941479\"></p>\n<hr>\n<h3 id=\"3-lock\"><a href=\"#3-lock\" class=\"headerlink\" title=\"3.lock\"></a>3.lock</h3><p>剧情来到了互斥并发的半壁江山——lock。</p>\n<p>lock本身是一个<code>接口</code>，它提供了<code>更灵活的锁定操作</code>，即<code>手动的加锁与释放锁</code>。完全<code>不同的属性</code>，并且支持多个关联的对象<code>Condition</code>。</p>\n<p>特别地，它的实现类<code>ReadWriteLock</code>支持对共享资源的读锁。也可以使用<code>tryLock方法非阻塞</code>地获得锁。</p>\n<p>下面我们通过具体的实现类来看lock的实现机制——</p>\n<h4 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124145535.png\" alt=\"image-20210328124145535\"></p>\n<p>ReentrantLock顾名思义，即<code>可重入的锁</code>。它的属性包含同步类的对象，该对象继承自AQS，即使用<code>双端队列实现的同步队列</code>。</p>\n<p>在来看下它的属性与方法——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124815007.png\" alt=\"image-20210328124815007\"></p>\n<p>嗯，提供了很多便捷，灵活的操作锁的方式，这里不再一一赘述，因为相比Lock的API，显然<code>JUC包下的API更香</code>~</p>\n<h3 id=\"4-synchronized-VS-ReentrantLock\"><a href=\"#4-synchronized-VS-ReentrantLock\" class=\"headerlink\" title=\"4.synchronized VS ReentrantLock\"></a>4.synchronized VS ReentrantLock</h3><ul>\n<li><p><strong>重入</strong></p>\n<p><code>synchronized可重入</code>，因为加锁和解锁可以自动进程，不必担心最后释放锁。<code>ReentrantLock同样可以重入</code>，它的加锁和释放锁需要手动完成。</p>\n</li>\n<li><p><strong>实现</strong></p>\n<p><code>synchronied是JVM实现的</code>，而<code>ReentrantLock是JDK实现的</code>，也就是最终归于操作系统实现。</p>\n</li>\n<li><p><strong>性能</strong></p>\n<p>jdk1.6以后对synchronied做了很多优化，。如今它们的性能平分秋色。</p>\n</li>\n<li><p><strong>功能</strong></p>\n<p>ReentrantLock锁的粒度和灵活度，都明显优于synchronized.</p>\n<p>ReentrantLock从它内部类可以看出，它有公平与非公平的同步方式之分。而<code>synchronized是非公平(不按时间顺序获取锁)的锁。</code></p>\n<p>ReentrantLock可以非阻塞的获取锁。且提供中断等待锁的线程机制。</p>\n</li>\n<li><p><strong>可见性</strong></p>\n<p>我们知道，<code>synchronized的可见性是基于java内存模型的happens-before原则</code>，即在其他线程读取主内存的值前，主内存一定先被刷新。</p>\n<p>而ReentrantLock的可见性是如何保障的呢？它的同步机制是基于AQS框架的，而<code>AQS框架的锁机制核心在于读写state变量</code>的值：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328152434820.png\" alt=\"image-20210328152434820\"></p>\n</li>\n</ul>\n<p>这里简要插播一下：volatile是如何保证可见性的：</p>\n<blockquote>\n<p>volatile基于JMM(java内存模型)的内存语义：</p>\n<ol>\n<li>当<code>写一个volatile变量</code>时，JMM会将线程本地内存中的变量刷新到主内存中；</li>\n<li>当<code>读一个volatile变量</code>时，JMM会将线程对应的本地内存置为无效，然后从主内存中读取变量。</li>\n</ol>\n</blockquote>\n<p>那state变量既然由volatile修饰，那自然就可以保证可见性咯，当然，保证原子性是不可能的~</p>\n<h2 id=\"多线程——黄金时代\"><a href=\"#多线程——黄金时代\" class=\"headerlink\" title=\"多线程——黄金时代\"></a>多线程——黄金时代</h2><h3 id=\"1-线程池\"><a href=\"#1-线程池\" class=\"headerlink\" title=\"1.线程池\"></a>1.线程池</h3><h4 id=\"什么是线程池\"><a href=\"#什么是线程池\" class=\"headerlink\" title=\"什么是线程池\"></a>什么是线程池</h4><p>线程池的基本思想是<code>对象池</code>，当程序启动的时候，就会在内存中开辟出一块空间，来放置初始化好的线程。当需要使用线程时，就使用<code>线程调度器</code>从线程池中取出一个线程，当线程使用完后，再将它归还到线程池中。</p>\n<h4 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h4><ul>\n<li><code>方便管理线程</code>：比如延时执行，定时循环；</li>\n<li><code>控制线程并发数量</code>：如果线程数量不加控制，会大致线程占用内存过多，从而四死机；</li>\n<li><code>减少创建，销毁开销</code>：每个线程可以被重复利用，可以执行多个任务</li>\n</ul>\n<h4 id=\"线程池的主要组件\"><a href=\"#线程池的主要组件\" class=\"headerlink\" title=\"线程池的主要组件\"></a>线程池的主要组件</h4><p><img src=\"https://user-gold-cdn.xitu.io/2018/7/8/16477f7912b4552a?imageslim\" alt=\"img\"></p>\n<ol>\n<li><code>线程池管理器ThreadPool</code>：用于创建和管理线程池；</li>\n<li><code>任务接口Task</code>：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，执行完的收尾工作，任务的执行状态；</li>\n<li><code>工作线程workThread</code>：线程池中的线程，没有任务时处于等待状态；</li>\n<li><code>任务队列taskQueue</code>：用于存放没有处理的任务，起一种<code>缓冲的作用</code>。</li>\n</ol>\n<h4 id=\"ThreadPoolExecutor类解析\"><a href=\"#ThreadPoolExecutor类解析\" class=\"headerlink\" title=\"ThreadPoolExecutor类解析\"></a>ThreadPoolExecutor类解析</h4><p>我们可以通过ThreadPoolExecutor来创建一个线程——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328164241430.png\" alt=\"image-20210328164241430\"></p>\n<p>再来深入地看下这些参数的意义：</p>\n<ol>\n<li><code>corePoolSize</code>：即线程池的基本大小，任务队列每提交一个任务，线程池就会创建一个线程，当提交的任务数大小线程池的基本大小时，就不再创建线程；</li>\n<li><code>maxinumPoolSize</code>：即线程池允许创建的最大线程数；</li>\n<li><code>KeepAliveTime</code>：即线程池的工作线程空闲了以后，保持存活的时间；</li>\n<li><code>TImeUnit</code>：即线程活动保持时间的单位；</li>\n<li><code>workQueue</code>：用来保存等待执行的阻塞队列；</li>\n<li><code>threadFactory</code>：线程工厂，在debug和定位问题时非常有帮助；</li>\n<li><code>RejectedExecutionHandler</code>：拒绝策略，下文会详细描述。</li>\n</ol>\n<h5 id=\"向线程池提交任务\"><a href=\"#向线程池提交任务\" class=\"headerlink\" title=\"向线程池提交任务\"></a>向线程池提交任务</h5><ul>\n<li><code>execute()</code>：无返回值，无法判断任务是否被执行成功；</li>\n<li><code>submit()</code>：返回一个future的泛型对象，通过get方法可以获得返回值。</li>\n</ul>\n<h5 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h5><ul>\n<li><code>shutdown</code>：将线程池的状态设置为<code>SHUTDOWN状态</code>，然后中断所有没有执行任务的线程；</li>\n<li><code>shutdownNow</code>：遍历工作线程，逐个调用线程的<code>interrupt方法</code>。</li>\n</ul>\n<h5 id=\"线程池的执行流程\"><a href=\"#线程池的执行流程\" class=\"headerlink\" title=\"线程池的执行流程\"></a>线程池的执行流程</h5><p><img src=\"https://user-gold-cdn.xitu.io/2018/7/8/16477fc44a03d90f?imageslim\" alt=\"img\"></p>\n<h5 id=\"四种拒绝策略\"><a href=\"#四种拒绝策略\" class=\"headerlink\" title=\"四种拒绝策略\"></a>四种拒绝策略</h5><ol>\n<li><p><code>AbortPolicy</code>：丢弃任务并抛出RejectedExecutionException异常</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171249081.png\" alt=\"    \"></p>\n</li>\n<li><p><code>DiscardPolicy</code>：丢弃任务但不抛出异常</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171502262.png\" alt=\"image-20210328171502262\"></p>\n</li>\n<li><p><code>DisCardOldSetPolicy</code>：丢弃队列最前面的任务，然后提交新来的任务</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171523558.png\" alt=\"image-20210328171523558\"></p>\n</li>\n<li><p><code>CallerRunPolicy</code>：由调用线程处理该任务</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171435296.png\" alt=\"image-20210328171435296\"></p>\n</li>\n</ol>\n<h4 id=\"四种线程池\"><a href=\"#四种线程池\" class=\"headerlink\" title=\"四种线程池\"></a>四种线程池</h4><ul>\n<li><code>CachedThreadPool()</code>:可缓冲线程池</li>\n<li><code>FIxedThreadPool()</code>:定长线程池</li>\n<li><code>ScheduledThreadPool()</code>:定时线程池</li>\n<li><code>SingleThreadExecutor()</code>:单线程化的线程池</li>\n</ul>\n<h4 id=\"为什么不推荐使用JUC的线程池\"><a href=\"#为什么不推荐使用JUC的线程池\" class=\"headerlink\" title=\"为什么不推荐使用JUC的线程池\"></a>为什么不推荐使用JUC的线程池</h4><ol>\n<li><p>newFixedThreadPool和newSingleThreadExecutor</p>\n<p>创建的<code>任务等待队列容量过大，耗费非常多的内存</code>~</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329201950011.png\" alt=\"image-20210329201950011\"></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202057662.png\" alt=\"image-20210329202057662\"></p>\n</li>\n</ol>\n<p>2.newScheduledThreadPool和newCachedThreadPool</p>\n<p>​    会<code>创建非常多的线程</code>，CPU压力大~</p>\n<p>​    <img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202312593.png\" alt=\"image-20210329202312593\"></p>\n<h4 id=\"线程池的参数设置\"><a href=\"#线程池的参数设置\" class=\"headerlink\" title=\"线程池的参数设置\"></a>线程池的参数设置</h4><p>参数的设置和系统的负载有着直接的关系，系统负载有这样的一些参数：</p>\n<ul>\n<li><code>tasks</code>：每秒需要处理的任务数</li>\n<li><code>threadtasks</code>：每个线程每秒可以处理的任务数</li>\n<li><code>responsetime</code>：系统允许任务的最大响应时间。</li>\n</ul>\n<p>下面将用这些系统负载的参数来衡量线程池的参数——</p>\n<h5 id=\"corePoolSize\"><a href=\"#corePoolSize\" class=\"headerlink\" title=\"corePoolSize\"></a>corePoolSize</h5><p>假设系统每秒任务数为100 ~ 1000，每个线程每钞可处理10个任务，则需要100 / 10至1000 / 10，即10 ~ 100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据<code>8020原则</code>，因为系统每秒任务数为100 ~ 1000，<code>即80%情况下系统每秒任务数小于1000 * 20% = 200</code>，则corePoolSize可设置为<code>200 / 10 = 20</code>。</p>\n<h5 id=\"queueCapacity\"><a href=\"#queueCapacity\" class=\"headerlink\" title=\"queueCapacity\"></a>queueCapacity</h5><p>任务队列的长度可以设置为：<code>所有核心线程每秒处理任务数 * 每个任务响应时间 = 每秒任务总响应时间</code></p>\n<h5 id=\"maxPoolSize\"><a href=\"#maxPoolSize\" class=\"headerlink\" title=\"maxPoolSize\"></a>maxPoolSize</h5><p>当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程，增加的线程数取决于任务队列容量和需求。</p>\n<p>千万不能直接创建任务队列，不然容量过大，占用内存过多，对系统压力大。</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210329204208430.png\" alt=\"image-20210329204208430\"></p>\n<h5 id=\"keepAliveTime\"><a href=\"#keepAliveTime\" class=\"headerlink\" title=\"keepAliveTime\"></a>keepAliveTime</h5><p>当<code>负载降低时，可以减少线程的数量</code>，当线程的空闲时间超过keepAliveTime，会自动释放线程。</p>\n<h5 id=\"allowCoreThreadTimeout\"><a href=\"#allowCoreThreadTimeout\" class=\"headerlink\" title=\"allowCoreThreadTimeout\"></a>allowCoreThreadTimeout</h5><p>默认情况下核心级线程不会退出，可通过该参数设置为true,使其退出。</p>\n<p>一般经验：线程池的大小应该这样设置：</p>\n<ol>\n<li>如果是<code>CPU密集型应用</code>，线程池大小设置为<code>N+1</code>,N指CPU的个数；</li>\n<li>如果是<code>IO密集型应用</code>，则线程池大小设置为<code>2N+1</code>;</li>\n</ol>\n<h4 id=\"线程的五种状态\"><a href=\"#线程的五种状态\" class=\"headerlink\" title=\"线程的五种状态\"></a>线程的五种状态</h4><p><img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f73cc0dad76a5?imageslim\" alt=\"img\"></p>\n<h4 id=\"什么场景下怎么设置线程池\"><a href=\"#什么场景下怎么设置线程池\" class=\"headerlink\" title=\"什么场景下怎么设置线程池\"></a>什么场景下怎么设置线程池</h4><ul>\n<li><code>高并发、任务执行时间短的业务</code></li>\n</ul>\n<p>线程池线程数可以设置为CPU核数+1，<strong>减少线程上下文的切换</strong></p>\n<ul>\n<li><code>并发不高、任务执行时间长的业务</code></li>\n</ul>\n<p>这个需要判断执行时间是耗在哪个地方</p>\n<ol>\n<li>假如是业务时间长集中在<code>IO操作上</code>，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目（<strong>2 * CPU核数</strong>），让CPU处理更多的业务。</li>\n<li>假如是业务时间长集中在计算操作上，也就是<code>CPU密集型任务</code>，和（1）<strong>CPU核数+1</strong> 一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li>\n</ol>\n<ul>\n<li><code>并发高、业务执行时间长的业务</code></li>\n</ul>\n<p>解决这种类型任务的关键不在于线程池而在于整体架构的设计</p>\n<h3 id=\"2-JUC\"><a href=\"#2-JUC\" class=\"headerlink\" title=\"2.JUC\"></a>2.JUC</h3><h4 id=\"AQS框架\"><a href=\"#AQS框架\" class=\"headerlink\" title=\"AQS框架\"></a>AQS框架</h4><p>我们知道JUC是一个<strong>定义并发操作并安全处理并发</strong>的框架。而要了解JUC包的全貌，我们首先需要定义处理<code>并发的组件</code>，也就是锁和同步器。这种功能就是由AQS所提供的。</p>\n<p>AQS的全称是<code>AbstractQueuedSynchronizer</code>，即抽象队列同步器。它是java并发用来构建锁和同步器的基础框架。它包含<code>先进先出的双端队列，状态量，线程持有者的引用</code>。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/24459569-f4323d6ace89b32d.png\" alt=\"img\"></p>\n<p>这里的state是由volatile修饰的，即它满足线程间的可见性，另外，它记录了<code>锁的持有者</code>：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329223019662.png\" alt=\"image-20210329223019662\"></p>\n<p>当线程1想要获取monitor对象时，它的行为是这样的：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329224019027.png\" alt=\"image-20210329224019027\"></p>\n<hr>\n<h4 id=\"工具类——同步器\"><a href=\"#工具类——同步器\" class=\"headerlink\" title=\"工具类——同步器\"></a>工具类——同步器</h4><p>累了，不再文字描述了，把思维导图贴上来：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/%E4%B8%89%E5%A4%A7%E5%B7%A5%E5%85%B7%E7%B1%BB-%E5%90%8C%E6%AD%A5%E5%99%A8.png\" alt=\"三大工具类-同步器\"></p>\n<h4 id=\"其他组件\"><a href=\"#其他组件\" class=\"headerlink\" title=\"其他组件\"></a>其他组件</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6.png\" alt=\"其他组件\"></p>\n<h4 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h4><p><a href=\"https://zhuanlan.zhihu.com/p/60375306\">浅谈ThreadLocal</a></p>\n<h2 id=\"多线程——加餐\"><a href=\"#多线程——加餐\" class=\"headerlink\" title=\"多线程——加餐\"></a>多线程——加餐</h2><h3 id=\"1-关于多线程可行的实践\"><a href=\"#1-关于多线程可行的实践\" class=\"headerlink\" title=\"1.关于多线程可行的实践\"></a>1.关于多线程可行的实践</h3><ul>\n<li>给线程起个<code>有意义的名字</code>，这样可以方便找 Bug。</li>\n<li>缩小同步范围，从⽽而减少锁争用。例如对于 synchronized，应该<code>尽量使用同步块⽽而不是同步方法</code>。</li>\n<li>多用同步工具少用 wait() 和 notify()。首先<code>，CountDownLatch, CyclicBarrier, Semaphore 和Exchanger 这些同步类简化了了编码操作，⽽用 wait() 和 notify() 很难实现复杂控制流</code>；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不不断优化和完善。</li>\n<li>使用<code>BlockingQueue 实现生产者消费者问题</code>。多用并发集合少用同步集合，例如应该<code>使用 ConcurrentHashMap ⽽而不是 Hashtable</code>。</li>\n<li>使用<code>本地变量</code>和<code>不可变类</code>来保证线程安全。使用线程池⽽不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>\n</ul>\n<hr>\n<blockquote>\n<p>山高路远，静水深流.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一个多月没写过博文了，不是没有<strong>值得记录的故事</strong>，确是静不下心。网申在即，靠目前的积淀，知识地图中缺了一大块，索性打消了网申的念头。但不免有些落寞，像极了<strong>落跑的小橘子</strong>。</p>\n<p>这个<code>时代越来越卷了</code>，但也正因如此，我才更信奉积淀的魅力，这也正是我整理心态，继续出发的缘由。</p>\n<p>这不是第一次学习多线程了，在自学时，培训班上都接触过多线程，但都只是浅尝辄止，这次咬定青山不放松，终于<strong>顿悟了一些关键的知识</strong>，恍然间柳暗花明，便有了这篇文章。</p>\n<hr>\n<h2 id=\"多线程——入门\"><a href=\"#多线程——入门\" class=\"headerlink\" title=\"多线程——入门\"></a>多线程——入门</h2><p>在操作系统中，我们了解到，<strong>多进程图像</strong>是操作系统最核心，最基础的图像。而用户通过系统调用的方式间接与操作系统交互。想象这样一种场景，我们一边放着音乐，一边浏览网页——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327092252968.png\" alt=\"image-20210327092252968\"></p>\n<p>这就是触目可及的多进程图像，显然，这两个进程之间使用的是不同的资源，不妨假设我的处理器是单核的，每一时刻只能处理一个进程，那<code>CPU就要为两个进程分配时间片</code>，然后根据调度算法切换进程，串行执行。</p>\n<p>如何切换进程呢？首先要理解进程是什么——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619000547145.png\" alt=\"image-20210619000547145\"></p>\n<p>也就是说，进程就是：<strong>指令执行序列+资源</strong>，因此直观的切换进程就是切换进程的这两部分，但资源的切换是非常浪费时间的，能不能<code>只切换指令执行序列</code>呢？聊到这，小伙伴就有了这样的猜想：指令执行序列与线程有什么关系呢？</p>\n<p>没错，<strong>指令执行序列就是线程集</strong>。我们深入到进程中找找，就会发现线程集没有我们想象中的那么遥不可及——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327094410019.png\" alt=\"image-20210327094410019\"></p>\n<p>下载听歌两不误，如此丝滑的切换，都得益于<strong>线程的并发应用</strong>。也就是多线程咯。到这里，故事才真正的拉开序幕——</p>\n<hr>\n<h3 id=\"1-进程与线程\"><a href=\"#1-进程与线程\" class=\"headerlink\" title=\"1.进程与线程\"></a>1.进程与线程</h3><p>前面提到的都是直观的印象，这里由表及内地聊聊进程与线程——</p>\n<ul>\n<li><code>进程： </code>进程是<strong>上下文切换之间的程序执行的部分</strong>，而所谓上下文，即是<code>CPU与寄存器</code>。通俗地说，也就是说进程执行的环境。在这个环境下运行着的程序即是进程。</li>\n<li><code>线程： </code>线程是<strong>轻量级的进程</strong>，这里的轻量级如何理解呢？<code>线程集</code>共享了进程的<code>上下文环境，地址空间，更为细小的CPU时间片</code>。</li>\n</ul>\n<p>对于如何更好地理解进程与线程之间的关系，有大佬已经讲的非常形象了，我们不妨站在巨人的肩膀上——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://www.zhihu.com/question/25532384\">将进程比作火车，线程比作车厢</a></li>\n</ul>\n<hr>\n<h3 id=\"2-所谓多线程\"><a href=\"#2-所谓多线程\" class=\"headerlink\" title=\"2.所谓多线程\"></a>2.所谓多线程</h3><p>在讲述多线程之前，非常有必要搞懂这几个概念——</p>\n<ul>\n<li><p><code>并发</code>：一些任务都处于可运行的状态，但只有一个任务可以被调度并执行，而具体是哪一个任务被处理仍是不确定的。</p>\n</li>\n<li><p><code>串行与并行</code></p>\n<ol>\n<li>多任务中<strong>某时刻</strong>只能有一个任务被运行，单核下皆为串行；</li>\n<li>某时刻可以有多个任务同时被执行，在多核计算机上可以实现并行；</li>\n</ol>\n</li>\n<li><p><code>阻塞与非阻塞</code>：</p>\n<ol>\n<li>以文件读取为例，应用层会调用系统内核中的IO接口，如open，close等，在请求发出以后，如果调用的是<strong>阻塞型IO</strong>，应用层被挂起，一直处于等待数据返回的状态。直到从磁盘上读取数据并返回给应用层后，应用层采用获取到的数据进行下一步操作；</li>\n<li>如果应用层调用的是<strong>非阻塞I/O</strong>，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。</li>\n</ol>\n<p>也就是说阻塞与非阻塞的区别在于<strong>发出请求后等待数据返回时的状态</strong>。</p>\n</li>\n<li><p><code>同步与异步</code>：</p>\n<ul>\n<li>阻塞与非阻塞决定了应用层等待数据返回的状态，而<strong>数据如何从系统内核返回</strong>呢？返回的方式取决于同步与异步——</li>\n<li>对于同步型的调用，应用层会不<strong>断问询系统内核</strong>，但它的动作取决于是否阻塞，数据返回给应用层后，应用层继续做其他的事情；</li>\n<li>对于异步型的调用，应用层<strong>不关心数据何时返回</strong>，此时它的动作同样却绝育是否阻塞，系统内核会主动通知应用层数据已经读取完毕并返回。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>好啦，啰嗦了这么多，也该祭出这张图了——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327104345505.png\" alt=\"image-20210327104345505\"></p>\n<p>用语言描述就是：<strong>多线程无非是多个线程处于并发的状态</strong>。</p>\n<p>片头就这么多了，暂且告一段落。如果哪天灵光一现，也会再修修补补。</p>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"关于下文\"><a href=\"#关于下文\" class=\"headerlink\" title=\"关于下文\"></a>关于下文</h2><p>借鉴王一波前辈的书名，下面的篇幅按照多线程的重要程度渐进地划分为三个阶段——</p>\n<ul>\n<li><code>青铜时代</code>：主要描述线程的基本知识，也是最不可或缺的一部分，此外，由此衍生的静态代理，lambda表达式也可先入门一手；</li>\n<li><code>白银时代</code>：这一阶段是多线程并发的问题与基本解决方案，同样也是应用与面试的一大热门。</li>\n<li><code>黄金时代</code>：简言之，这一部分是高端操作，也是面试造火箭的宠儿，但其中的机制却并不新鲜，反而有点拾操作系统思想牙髓的意思。可见，最基本，最通用的反而具有最长久的生命力，</li>\n</ul>\n<hr>\n<h2 id=\"多线程——青铜时代\"><a href=\"#多线程——青铜时代\" class=\"headerlink\" title=\"多线程——青铜时代\"></a>多线程——青铜时代</h2><h3 id=\"1-创建的三种方式\"><a href=\"#1-创建的三种方式\" class=\"headerlink\" title=\"1.创建的三种方式\"></a>1.创建的三种方式</h3><p>在java中，创建线程有3种方式，分别是继承Thread类，实现Runnable接口，实现Callable接口。而实现Runnable接口只能得到任务，<strong>任务还需要线程驱动才能执行</strong>、</p>\n<h4 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327130931773.png\" alt=\"image-20210327130931773\"></p>\n<p>首先实现Runnable接口得到Runnable实例。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CreateThread2</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">&#123;</span>\n   \n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//do something</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用Runnable实例再创建一个Thread实例，调用Thread实例的start()开启一个线程——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建实现类</span>\n    <span class=\"token class-name\">CreateThread2</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//同样调用Thread来开启线程，最终是使用runnable接口的代理来调用</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"实现Callable接口\"><a href=\"#实现Callable接口\" class=\"headerlink\" title=\"实现Callable接口\"></a>实现Callable接口</h4><p>与Runnable相比，Callable接口具有返回值。返回值用**Future<V>**封装——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * 使用Callable接口实现图片的下载\n *\n * callable的好处——\n * 1. 有返回值\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CreateThread3</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> url<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>url <span class=\"token operator\">=</span> url<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Boolean</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">WebDownload</span> webDownload <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebDownload</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            webDownload<span class=\"token punctuation\">.</span><span class=\"token function\">download</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">+</span><span class=\"token string\">\"下载成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">MalformedURLException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"图片下载异常\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ExecutionException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">CreateThread3</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://img95.699pic.com/photo/40011/0709.jpg_wh860.jpg\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"E:/1.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">CreateThread3</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://static.runoob.com/images/demo/demo4.jpg\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"E:/2.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">CreateThread3</span> t3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://seopic.699pic.com/photo/50034/6414.jpg_wh1200.jpg\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"E:/3.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//创建固定线程数的线程池</span>\n        <span class=\"token class-name\">ExecutorService</span> service <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//提交执行</span>\n        <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> r1 <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> r2 <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> r3 <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>t3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//获取结果</span>\n        <span class=\"token class-name\">Boolean</span> res1 <span class=\"token operator\">=</span> r1<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Boolean</span> res2 <span class=\"token operator\">=</span> r2<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Boolean</span> res3 <span class=\"token operator\">=</span> r3<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//关闭服务</span>\n        service<span class=\"token punctuation\">.</span><span class=\"token function\">shutdownNow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">WebDownload</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">download</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">FileUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyURLToFile</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">URL</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h4><p>继承Thread类同样需要重写run方法，但run方法却仅仅只是Thread类的冰山一角，Thread类非常庞大，它包含了<code>线程的状态，分类，并发安全</code>，不一而足：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327132338149.png\" alt=\"image-20210327132338149\"></p>\n<p>来看代码实现——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">createThread</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CreateThread1</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/**\n     * run方法线程体\n     */</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"五味杂陈\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 主线程方法体\n     * @param args\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">CreateThread1</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CreateThread1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//可以看到调用start方法以后，主线程与run方法线程交替执行，总体先执行main主线程，也许是因为优先级较高！</span>\n        <span class=\"token comment\">//假如不是多线程，会怎样执行？</span>\n        <span class=\"token comment\">//那就应该在主线程中调用run的线程，在run线程执行完后再回到主线程，绝不会发生交替！</span>\n        <span class=\"token comment\">//线程的调度完全由CPU决定</span>\n        t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//可能会被提前终止</span>\n        t<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">200</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"陈杂味五\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当调用start以后，虚拟机将线程放入就绪队列等待被调度，线程被调度后则执行run方法。</p>\n<h4 id=\"Runnable-VS-Thread\"><a href=\"#Runnable-VS-Thread\" class=\"headerlink\" title=\"Runnable VS Thread\"></a>Runnable VS Thread</h4><p>实现接口会更好一些，因为：</p>\n<ol>\n<li>java是<code>单继承，可扩展性不好</code>，继承了Thread类就无法再继承其他类，而接口可以多实现；</li>\n<li><code>Thread类这么臃肿</code>，如果只是执行简单的线程任务，则继承Thread类显得大而无用。</li>\n</ol>\n<hr>\n<h3 id=\"2-线程的状态与属性\"><a href=\"#2-线程的状态与属性\" class=\"headerlink\" title=\"2.线程的状态与属性\"></a>2.线程的状态与属性</h3><h4 id=\"开局一张图\"><a href=\"#开局一张图\" class=\"headerlink\" title=\"开局一张图\"></a>开局一张图</h4><p><img src=\"C:\\Users\\zyz\\Desktop\\每日思维导图\\线程的状态.png\" alt=\"线程的状态\"></p>\n<p>关于状态的琐碎知识，我就不展开了，<strong>思维导图描述的更系统也更简洁这样记忆的效果更好</strong>，针对状态的切换，在网上找到一张很细致的图片——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327134912906.png\" alt=\"image-20210327134912906\"></p>\n<p>来看切换内部的机制——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327141723664.png\" alt=\"image-20210327141723664\"></p>\n<h4 id=\"一点小贴士\"><a href=\"#一点小贴士\" class=\"headerlink\" title=\"一点小贴士\"></a>一点小贴士</h4><p>在这里，我们来解释一些关于线程切换与分类中，含糊不清的知识点：</p>\n<ol>\n<li><code>进程与线程的状态基本一致</code>，一家之言；</li>\n<li><code>阻塞是一种状态，挂起是一种行为</code>，挂起的结果是阻塞；</li>\n<li>当run方法执行完后，线程则退出，变为死亡状态。而使用执行器，需要手动的关闭服务，从而关闭线程，关闭服务<code>shutDownNow</code>的底层会<code>调用interrupt方法</code>，该方法不一定是即时的，<code>它会使线程在安全的时候退出</code>,这同时也是中断的用途。</li>\n<li><code>wait会释放对象的锁，而sleep并不会</code>。也就是说线程调用wait进入阻塞状态，使用notify唤醒线程，而后进入就绪队列等待。而sleep则可以直接执行。</li>\n</ol>\n<h3 id=\"3-线程的基本机制\"><a href=\"#3-线程的基本机制\" class=\"headerlink\" title=\"3.线程的基本机制\"></a>3.线程的基本机制</h3><p>在上面的内容中，我们突兀地使用了<strong>很多看起来没有支撑的知识点</strong>。我想小伙伴们也同样会困惑，对象锁是如何实现的？它的机制是怎样的？线程这么多的状态，我们都要耳提面命的测试吗？</p>\n<p>对于这些问题，java中的多线程给出了一个基本的机制来解决——</p>\n<h4 id=\"对象锁\"><a href=\"#对象锁\" class=\"headerlink\" title=\"对象锁\"></a>对象锁</h4><p>在JVM中，对象在内存中被分成了三个区域——</p>\n<ol>\n<li><strong>对象头</strong><ol>\n<li><code>Mark_word(标记字段)</code>，默认存储<code>对象的锁标志位</code>，hashcode,分代年龄。它会根据锁的状态复用它的存储空间，也就是说，运行期间Mark_word中的信息会随着锁对象的变化而变化；</li>\n<li><code>Klass_point(类型指针)</code>：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象属于哪个类。</li>\n</ol>\n</li>\n<li><strong>实例信息</strong>：主要存放类的数据信息，父类的数据信息；</li>\n<li><strong>对齐填充</strong>：即任何一个对象，都会被按位填充，即便是空对象也是如此。</li>\n</ol>\n<p>线程拥有对象的锁标志位，即表示线程可以访问该对象。从而可以通过对对象锁的操作来实现并发安全。</p>\n<h4 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h4><p>如果程序员直接管理线程的生命周期，未免舍本逐末，太过繁琐。java为我们提供了大管家——<em><strong>Executor</strong></em>。</p>\n<p><strong>Exector会将线程的开启与运行机制分离开</strong>，简化程序员的操作。它是是JUC包下的一个类，提供了三种可选的Executor:</p>\n<ul>\n<li><code>CachedThreadPool</code>：一个任务创建一个线程；</li>\n<li><code>FixedThreadPool</code>：所有任务只能使⽤用固定⼤小的线程；</li>\n<li><code>SingleThreadExecutor</code>：相当于大小为 1 的 FixedThreadPool。</li>\n</ul>\n<p>简要看下它的使用——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//创建线程池</span>\n    <span class=\"token class-name\">ExecutorService</span> executorService<span class=\"token operator\">=</span><span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//执行</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>inti<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MyRunnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//关闭服务</span>\n    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"多线程——番外篇\"><a href=\"#多线程——番外篇\" class=\"headerlink\" title=\"多线程——番外篇\"></a>多线程——番外篇</h2><h3 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1.静态代理\"></a>1.静态代理</h3><blockquote>\n<p>首先，考虑有这样一种需求，项目经理要求在所有类的每一个方法运行前后加上日志，但又要求不能对已有代码做改动，怎样解决呢？</p>\n</blockquote>\n<p>我们可以创建一个代理对象，让它和目标对象实现同样的接口，这样就可以借代理对象之手调用目标对象的方法了。此外，我们还需要为这个代理对象加上日志方法，问题就迎刃而解了。</p>\n<p>从这段描述中，我们试着提取静态代理的关键：</p>\n<ul>\n<li><strong>代理对象=目标对象+加强代码</strong>；</li>\n<li>代理对象和目标对象需要<code>实现同一个接口</code>；</li>\n</ul>\n<p>那小伙伴也许会困惑，咋们不是在学习多线程吗，难道多线程中使用到了静态代理？没错，Thread类就可以看做是Runnable接口实现类的静态代理，通过下面的小例子我们来巩固一下——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StaticProxy</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n        <span class=\"token comment\">//使用lambda来开启线程</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我爱你\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//类比着看，说明线程底层使用的即是静态代理</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeddingCompany</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">You</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//将真实对象作为代理对象的参数传入</span>\n        <span class=\"token class-name\">WeddingCompany</span> weddingCompany <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeddingCompany</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">You</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        weddingCompany<span class=\"token punctuation\">.</span><span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n *都需要实现的顶层接口\n */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Marry</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 真实角色\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">You</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Marry</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"洞房花烛夜\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 代理角色，代理角色能做的事情更多\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">WeddingCompany</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Marry</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//这里是关键</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Marry</span> target<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">WeddingCompany</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Marry</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">happyMarry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这里是真实对象做的事情</span>\n        <span class=\"token function\">after</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">after</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"结婚之后，收尾款\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"结婚之前，布置现场\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-Lambda表达式\"><a href=\"#2-Lambda表达式\" class=\"headerlink\" title=\"2.Lambda表达式\"></a>2.Lambda表达式</h3><p>首先通过下面的小例子了解下lambda的写法——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ExecutorService</span> service <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors<span class=\"token punctuation\">.</span>ExecutorService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nservice<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"肚子有点饿\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而这里的方法参数实际上应该是实现Runnable接口的任务，也就是说，<strong>lambda表达式本身就是接口的实现</strong>。它<code>扩展了匿名内部类</code>，使得写法更加简洁高效。</p>\n<p>通过下面的实例来看下lambda的成长历程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"3-java内存模型\"><a href=\"#3-java内存模型\" class=\"headerlink\" title=\"3.java内存模型\"></a>3.java内存模型</h3><p>java试图屏蔽不同硬件与操作系统之间的内存访问差异，来实现java程序在各种平台都能运行的一致性数据访问。</p>\n<h4 id=\"工作内存与主内存\"><a href=\"#工作内存与主内存\" class=\"headerlink\" title=\"工作内存与主内存\"></a>工作内存与主内存</h4><p>我们知道，CPU只负责运算，它将内存中的数据读取到寄存器中，CPU再取得寄存器的地址，最后执行指令。但寄存器(<code>CPU的零级缓存</code>)的读写速度比内存的读写速度快很多个数量级，为了缓冲这种速度差，引入了<code>高级缓存</code>。</p>\n<p>但加入高级缓存以后，又带来了新的问题：<strong>缓存一致性</strong>。如果多个缓存共享一个主内存中的变量，那么多个缓存中的数据可能不一样。需要引入协议来规范一致性问题：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221223729.png\" alt=\"image-20210327221223729\"></p>\n<p>工作内存通常存储在高速缓存和寄存器中，在工作内存中保存了<code>主内存变量的拷贝</code>。</p>\n<h4 id=\"内存间的交互操作\"><a href=\"#内存间的交互操作\" class=\"headerlink\" title=\"内存间的交互操作\"></a>内存间的交互操作</h4><p>java内存模型定义了8个操作来完成主内存和工作内存之间的交互——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327221528229.png\" alt=\"image-20210327221528229\"></p>\n<ul>\n<li><code>read</code>：把一个变量的值从主内存传输到工作内存中</li>\n<li><code>load</code>：在 read 之后执行，把 read 得到的值放⼊工作内存的变量副本中</li>\n<li><code>use</code>：把工作内存中⼀个变量的值传递给执行引擎</li>\n<li><code>assign</code>：把一个从执行引擎接收到的值赋给工作内存的变量</li>\n<li><code>store</code>：把工作内存的一个变量的值传送到主内存中</li>\n<li><code>write</code>：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>\n<li><code>lock</code>：作⽤用于主内存的变量</li>\n</ul>\n<h4 id=\"内存模型的三大特性\"><a href=\"#内存模型的三大特性\" class=\"headerlink\" title=\"内存模型的三大特性\"></a>内存模型的三大特性</h4><ol>\n<li><p><strong>原子性：</strong></p>\n<p>上面我们提到了8种对内存的操作，这些操作作用的变量在被volatile修饰时都是原子性的。但<code>内存模型允许java虚拟机将没有被volatile修饰的64位数据，即long,double，划分为两个32位的数据执行</code>，即在这种情况下，操作不是原子性的。</p>\n<p>但int型的数据就是原子性的吗？也不尽然，对数据的操作通常不是单一的操作可以完成的，简要的说，count++就分为read,assign,write三步。这三步整合起来并不是原子性的。</p>\n<p>那如何保证原子性呢？<code>直观的方式就是加锁</code>咯，将count++的代码块用synchronized修饰。还有其他基于同步框架的方式吗？</p>\n<p><code>AtomicInteger</code>就是JUC框架下的这样一种方式，那它是如何实现的呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210327223155578.png\" alt=\"image-20210327223155578\"></p>\n<p>显然，它应用了<code>CAS的自旋思想</code>。</p>\n</li>\n<li><p><strong>可见性：</strong></p>\n<p>可见性指的是<code>当一个线程修改了主内存中的值以后，其他线程可以立刻获知这个修改</code>，java内存模型是通过将变量修改后的值同步回主内存，在变量读取之前刷新主内存中的值来实现的。</p>\n<p>主要有三种实现可见性的方式：</p>\n<ul>\n<li><code>volatile</code></li>\n<li><code>synchronized</code>,对一个变量使用unlock之前，必须将变量的值同步回主内存；</li>\n<li><code>final</code>,被final修饰的字段，在初始化之后，如果没有发生this逃逸，那么其他线程就能看见final字段的值。</li>\n</ul>\n</li>\n<li><p><strong>有序性：</strong></p>\n<p>有序性指的是：<code>在本线程中观察，所有操作都是有序的。在一个线程中观察另一个线程，所有操作都是无序的</code>。</p>\n<p>本线程有序还好理解，另一个线程无序就有点摸不着头脑了。</p>\n</li>\n</ol>\n<blockquote>\n<p>无序是因为发生了<code>指令重排序</code>，在java内存模型中，允许编译器和处理器对指令进行重排序，重排序的过程不会影响单线程程序的执行，却会影响多线程并发执行的正确性。</p>\n<p>volatile关键字通过添加<code>内存屏障</code>的方式来禁止指令重排，即重排序时不能把后面的指令放在内存屏障之前。</p>\n<p>当然，也可以通过<code>sychronized</code>来保证有序性。</p>\n</blockquote>\n<blockquote>\n<p>日拱一卒，功不唐捐。</p>\n</blockquote>\n<hr>\n<h2 id=\"多线程——白银时代\"><a href=\"#多线程——白银时代\" class=\"headerlink\" title=\"多线程——白银时代\"></a>多线程——白银时代</h2><h3 id=\"1-多线程不安全的案例\"><a href=\"#1-多线程不安全的案例\" class=\"headerlink\" title=\"1.多线程不安全的案例\"></a>1.多线程不安全的案例</h3><p>多个线程在访问同一个变量时有可能出现并发错误，我们通过下面的例子来演示并发错误，并借此分析并发错误出现的原因及解决方式——</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">synchonized</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestMakeup</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Thread</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Makeup</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"灰菇凉\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> thread1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Makeup</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"白雪公主\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LipStick</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Mirror</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 两个女孩分别持有镜子与口红的锁，然后都去等待对方的资源\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Makeup</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> choice<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">String</span> person<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//static表示只有一份</span>\n    <span class=\"token keyword\">static</span> <span class=\"token class-name\">LipStick</span> lipStick <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LipStick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token class-name\">Mirror</span> mirror <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mirror</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Makeup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> choice<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> person<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>choice <span class=\"token operator\">=</span> choice<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>person <span class=\"token operator\">=</span> person<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">makeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//互相请求对方所持有的的锁就会导致死锁，死锁的四个必要条件：互斥，请求与保持，不可剥夺，循环等待，</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">makeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>choice <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lipStick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用口红\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//一秒后要去获得镜子</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>mirror<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用镜子\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token comment\">/**死锁——\n             * synchronized (lipStick)&#123;\n                  System.out.println(Thread.currentThread().getName()+\"正在使用口红\");\n                     synchronized (mirror)&#123;\n                       Thread.sleep(1000);//一秒后要去获得镜子\n                       System.out.println(Thread.currentThread().getName()+\"正在使用镜子\");\n                     &#125;\n             &#125;\n             *\n             */</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>mirror<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用镜子\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//2秒后要去获得口红</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lipStick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在使用口红\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上面的例子中，我们看到假如<code>双方都在持有自己锁的前提下，请求对方的锁</code>时。可能导致并发错误的表现之一——死锁，这里再来回顾一下形成死锁的必要条件——</p>\n<ul>\n<li><code>互斥：</code>一个资源只能被一个线程使用；</li>\n<li><code>循环等待：</code>死锁的状况不会因为时间改变而改善；</li>\n<li><code>请求与持有：</code>在没有获得请求锁的前提下，不会释放自己持有的锁。</li>\n<li><code>不可剥夺：</code>线程只能主动让出资源，不能强取；</li>\n</ul>\n<hr>\n<p>那还有什么原因会导致并发错误呢？并发错误的表现有这样几种情况——</p>\n<ol>\n<li>访问<strong>共享变量</strong>导致数据不一致；</li>\n<li>CPU还没有完成所有线程的调度，线程就已经提前结束了；</li>\n</ol>\n<p>那么，针对并发错误的原因，我们可以得到解决并发错误的策略——</p>\n<ol>\n<li><strong>互斥同步</strong>：对发生更新的数据加锁，即java互斥同步的两种锁机制：synchronized与Lock;</li>\n<li><strong>final</strong>: 直接将变量声明为 不可变的，就不存在变量了，这波曲线解决问题；</li>\n<li><strong>非阻塞同步</strong>：CAS机制</li>\n<li><strong>不同步机制</strong>：需要同步是因为多个线程共享一个变量，那要实现不同步，就让每个线程独享一份变量就好咯，通常解决方式有这么几种：<ol>\n<li><code>栈封闭</code></li>\n<li><code>线程本地存储</code></li>\n<li><code>可重入代码</code></li>\n</ol>\n</li>\n</ol>\n<p>这里我们暂且只介绍互斥同步的解决方式，其他策略在黄金时代中会重点描述，现在混个眼熟~</p>\n<hr>\n<h3 id=\"2-synchronized\"><a href=\"#2-synchronized\" class=\"headerlink\" title=\"2.synchronized\"></a>2.synchronized</h3><h4 id=\"1-synchronized的使用场景\"><a href=\"#1-synchronized的使用场景\" class=\"headerlink\" title=\"1.synchronized的使用场景\"></a>1.synchronized的使用场景</h4><ul>\n<li><p>修饰<code>代码块</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100335007.png\" alt=\"image-20210328100335007\"></p>\n</li>\n<li><p>修饰<code>实例方法</code>，也就是对this对象加锁</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100502317.png\" alt=\"image-20210328100502317\"></p>\n</li>\n<li><p>修饰<code>静态方法</code>，即对class对象加锁</p>\n<p>​    <img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328100915411.png\" alt=\"image-20210328100915411\"></p>\n</li>\n</ul>\n<h4 id=\"2-synchronized的基本机制\"><a href=\"#2-synchronized的基本机制\" class=\"headerlink\" title=\"2.synchronized的基本机制\"></a>2.synchronized的基本机制</h4><p>我们之前谈到java内存模型有三大特性：<code>有序性，可见性，原子性</code>。而synchronized作用于存储在内存中的变量或代码块上，它除了拥有内存模型的三大特性外，还有<code>可重入性</code>，谈到可重入性首先要知道synchronized是如何实现加锁和解锁的。</p>\n<h5 id=\"加锁与解锁\"><a href=\"#加锁与解锁\" class=\"headerlink\" title=\"加锁与解锁\"></a>加锁与解锁</h5><p>我们将<strong>class文件反编译</strong>可以得到：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328101501442.png\" alt=\"image-20210328101501442\"></p>\n<p>对应来看，加锁和解锁显然是通过<strong>monitorenter和monitorexit</strong>实现的。也就是说获取对象的锁，实质上就是获取对象的monitor，即<strong>监视器</strong>，那如何来标识线程拥有该监视器呢？synchronized在锁对象时会获得一个<strong>计数器</strong>，用来<strong>标识线程获得锁的次数</strong>，线程每重入一次锁，计数器就会加1，对应的线程每调用monitorexit退出一次锁，计数器就会减1.如果计数器减为0，则说明锁已被释放。</p>\n<p>这是线程获得锁的情况，但假如线程阻塞了呢——</p>\n<p><img src=\"https://pdai.tech/_images/thread/java-thread-x-key-schronized-2.png\" alt=\"img\"></p>\n<p>显然，如果获取失败，线程就会进入<strong>同步队列</strong>，状态变更为<strong>阻塞态</strong>，直到锁被释放以后，同步队列中的线程才有机会获得锁。</p>\n<h5 id=\"可重入性原理\"><a href=\"#可重入性原理\" class=\"headerlink\" title=\"可重入性原理\"></a>可重入性原理</h5><p>现在来分析可重入性，就变得非常友好了。线程在重入时，<code>会首先判断计数器的值</code>，如果计数器不为0，也就是线程拥有锁，则直接进入，不需要反复获取锁。</p>\n<p>发生死锁的必要条件之一即为<code>循环等待</code>，而可重入性打破了这一原因，可见<code>可重入性能够有效防止死锁的出现</code>。</p>\n<h5 id=\"同步方法的底层实现\"><a href=\"#同步方法的底层实现\" class=\"headerlink\" title=\"同步方法的底层实现\"></a>同步方法的底层实现</h5><p>同步方法区别于代码块，它会首先判断标志位<strong>ACC_SYNCHRONIZED</strong>,如果存在该标志位，才会去隐式的调用monitorenter与monitorexit指令。即最终都归于monitor对象。</p>\n<p>我们所熟识的锁升级，无非是调用了<strong>ObjectMonitor对象不同的实现</strong>，如果失败了，再调用更高级的实现即可。</p>\n<h5 id=\"重量锁\"><a href=\"#重量锁\" class=\"headerlink\" title=\"重量锁\"></a>重量锁</h5><p>在看ObjectMonitor的源码时，我们会发现内核函数的存在，它们分别对应<strong>park()和unpark()</strong>,而synchronized是JVM管理的，JVM是应用程序，处于用户态，而内核函数在内核态，<code>切换的过程耗费资源较低，因此得名重量锁</code>。</p>\n<p>再来简单回顾下内核态与用户态的切换——</p>\n<ol>\n<li>用户态将数据存储在<code>寄存器</code>中，并保存堆栈信息；</li>\n<li>通过<code>系统调用</code>的方式，即通过<code>外中断</code>进入内核态；</li>\n<li><code>CPU取指执行</code>，即跳转到指定的内存位置处执行指令；</li>\n<li><code>读取寄存器中的参数</code>，维护内核栈的堆栈信息；</li>\n<li>CPU<code>重置操作系统为内核态</code>。</li>\n</ol>\n<h4 id=\"JVM中锁的优化\"><a href=\"#JVM中锁的优化\" class=\"headerlink\" title=\"JVM中锁的优化\"></a>JVM中锁的优化</h4><p>既然用户态，内核态的切换是低效的，那我们不如<strong>只在用户态做文章</strong>，官方对锁的升级即是通过加函数调用，而非系统调用来实现的。首先概括性的看下图——</p>\n<img src=\"https://pic2.zhimg.com/v2-79edfb4b2316d76ac653732fbdb72809_r.jpg\" alt=\"preview\" style=\"zoom:200%;\" />\n\n<p>这张图着实有点烧脑，我们来看个简单的：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328105848069.png\" alt=\"image-20210328105848069\"></p>\n<p>这就是锁升级的方向咯。显然这个过程是不可逆的，我们来拆解它的每一步实现——</p>\n<ul>\n<li><p><strong>偏向锁</strong></p>\n<p>之前我们提到了，对象头是由Mark_Word和Klass_point组成，锁争夺也就是对monitor对象的争夺，<code>一旦线程持有该对象，标志位修改为1，进入偏向模式</code>。并将这个线程的ID记录在对象的Mark_Word中。</p>\n<p>这个过程是使用<code>CAS乐观锁</code>来实现的，如果CAS失败，即锁对象获取失败。</p>\n<p>偏向锁在<code>jdk1.6之后是默认开启</code>的，1.5中关闭。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-1c56b94b3f92c3aa3884f739a5e4b42c_r.jpg\" alt=\"preview\"></p>\n<p>如果多个线程竞争偏向锁，那CAS乐观锁显然不那么实用了，就需要用到轻量级锁——</p>\n</li>\n<li><p><strong>轻量级锁</strong></p>\n<p>轻量级锁的实现仍跟Mark_Word相关。如果对象是无锁的，JVM就会在当前线程的栈帧中创建一个叫做<code>锁记录(Lock Record)的空间</code>，用来存储锁对象<code>Mark_Word的拷贝</code>。最后将所记录的<code>owner字段指向当前对象</code>。</p>\n<p>JVM接下来会利用CAS尝试将对象原本的<code>Mark_Word更新为Lock_Record的指针</code>。如果更新成功，改变锁的标志位，表明对象的锁已被获取，然后执行相关同步操作。</p>\n<p>如果失败了，说明<code>锁可能被其他线程持有</code>，此时就需要继续升级锁，修改锁的状态，线程进入阻塞态。而还有一种可能，即当前<code>线程本身持有锁</code>，就需要判断当前对象的Mark_Wors是否指向当前线程的栈帧。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-a932f172d1e9ac967c213429054d8522_r.jpg\" alt=\"preview\"></p>\n</li>\n<li><p><strong>自旋锁</strong></p>\n<p>上面提到如果修改不成功，就需要升级为自旋锁，自旋锁区别于重量锁，它如果没有竞争到锁对象，<code>就会不断循环，表现为CPU空转，而不是阻塞</code>。</p>\n<p>空转的次数最多为10次，如果超过10次，就会升级为重量锁。</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"锁的优缺点对比\"><a href=\"#锁的优缺点对比\" class=\"headerlink\" title=\"锁的优缺点对比\"></a>锁的优缺点对比</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328112941479.png\" alt=\"image-20210328112941479\"></p>\n<hr>\n<h3 id=\"3-lock\"><a href=\"#3-lock\" class=\"headerlink\" title=\"3.lock\"></a>3.lock</h3><p>剧情来到了互斥并发的半壁江山——lock。</p>\n<p>lock本身是一个<code>接口</code>，它提供了<code>更灵活的锁定操作</code>，即<code>手动的加锁与释放锁</code>。完全<code>不同的属性</code>，并且支持多个关联的对象<code>Condition</code>。</p>\n<p>特别地，它的实现类<code>ReadWriteLock</code>支持对共享资源的读锁。也可以使用<code>tryLock方法非阻塞</code>地获得锁。</p>\n<p>下面我们通过具体的实现类来看lock的实现机制——</p>\n<h4 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124145535.png\" alt=\"image-20210328124145535\"></p>\n<p>ReentrantLock顾名思义，即<code>可重入的锁</code>。它的属性包含同步类的对象，该对象继承自AQS，即使用<code>双端队列实现的同步队列</code>。</p>\n<p>在来看下它的属性与方法——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328124815007.png\" alt=\"image-20210328124815007\"></p>\n<p>嗯，提供了很多便捷，灵活的操作锁的方式，这里不再一一赘述，因为相比Lock的API，显然<code>JUC包下的API更香</code>~</p>\n<h3 id=\"4-synchronized-VS-ReentrantLock\"><a href=\"#4-synchronized-VS-ReentrantLock\" class=\"headerlink\" title=\"4.synchronized VS ReentrantLock\"></a>4.synchronized VS ReentrantLock</h3><ul>\n<li><p><strong>重入</strong></p>\n<p><code>synchronized可重入</code>，因为加锁和解锁可以自动进程，不必担心最后释放锁。<code>ReentrantLock同样可以重入</code>，它的加锁和释放锁需要手动完成。</p>\n</li>\n<li><p><strong>实现</strong></p>\n<p><code>synchronied是JVM实现的</code>，而<code>ReentrantLock是JDK实现的</code>，也就是最终归于操作系统实现。</p>\n</li>\n<li><p><strong>性能</strong></p>\n<p>jdk1.6以后对synchronied做了很多优化，。如今它们的性能平分秋色。</p>\n</li>\n<li><p><strong>功能</strong></p>\n<p>ReentrantLock锁的粒度和灵活度，都明显优于synchronized.</p>\n<p>ReentrantLock从它内部类可以看出，它有公平与非公平的同步方式之分。而<code>synchronized是非公平(不按时间顺序获取锁)的锁。</code></p>\n<p>ReentrantLock可以非阻塞的获取锁。且提供中断等待锁的线程机制。</p>\n</li>\n<li><p><strong>可见性</strong></p>\n<p>我们知道，<code>synchronized的可见性是基于java内存模型的happens-before原则</code>，即在其他线程读取主内存的值前，主内存一定先被刷新。</p>\n<p>而ReentrantLock的可见性是如何保障的呢？它的同步机制是基于AQS框架的，而<code>AQS框架的锁机制核心在于读写state变量</code>的值：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328152434820.png\" alt=\"image-20210328152434820\"></p>\n</li>\n</ul>\n<p>这里简要插播一下：volatile是如何保证可见性的：</p>\n<blockquote>\n<p>volatile基于JMM(java内存模型)的内存语义：</p>\n<ol>\n<li>当<code>写一个volatile变量</code>时，JMM会将线程本地内存中的变量刷新到主内存中；</li>\n<li>当<code>读一个volatile变量</code>时，JMM会将线程对应的本地内存置为无效，然后从主内存中读取变量。</li>\n</ol>\n</blockquote>\n<p>那state变量既然由volatile修饰，那自然就可以保证可见性咯，当然，保证原子性是不可能的~</p>\n<h2 id=\"多线程——黄金时代\"><a href=\"#多线程——黄金时代\" class=\"headerlink\" title=\"多线程——黄金时代\"></a>多线程——黄金时代</h2><h3 id=\"1-线程池\"><a href=\"#1-线程池\" class=\"headerlink\" title=\"1.线程池\"></a>1.线程池</h3><h4 id=\"什么是线程池\"><a href=\"#什么是线程池\" class=\"headerlink\" title=\"什么是线程池\"></a>什么是线程池</h4><p>线程池的基本思想是<code>对象池</code>，当程序启动的时候，就会在内存中开辟出一块空间，来放置初始化好的线程。当需要使用线程时，就使用<code>线程调度器</code>从线程池中取出一个线程，当线程使用完后，再将它归还到线程池中。</p>\n<h4 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h4><ul>\n<li><code>方便管理线程</code>：比如延时执行，定时循环；</li>\n<li><code>控制线程并发数量</code>：如果线程数量不加控制，会大致线程占用内存过多，从而四死机；</li>\n<li><code>减少创建，销毁开销</code>：每个线程可以被重复利用，可以执行多个任务</li>\n</ul>\n<h4 id=\"线程池的主要组件\"><a href=\"#线程池的主要组件\" class=\"headerlink\" title=\"线程池的主要组件\"></a>线程池的主要组件</h4><p><img src=\"https://user-gold-cdn.xitu.io/2018/7/8/16477f7912b4552a?imageslim\" alt=\"img\"></p>\n<ol>\n<li><code>线程池管理器ThreadPool</code>：用于创建和管理线程池；</li>\n<li><code>任务接口Task</code>：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，执行完的收尾工作，任务的执行状态；</li>\n<li><code>工作线程workThread</code>：线程池中的线程，没有任务时处于等待状态；</li>\n<li><code>任务队列taskQueue</code>：用于存放没有处理的任务，起一种<code>缓冲的作用</code>。</li>\n</ol>\n<h4 id=\"ThreadPoolExecutor类解析\"><a href=\"#ThreadPoolExecutor类解析\" class=\"headerlink\" title=\"ThreadPoolExecutor类解析\"></a>ThreadPoolExecutor类解析</h4><p>我们可以通过ThreadPoolExecutor来创建一个线程——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328164241430.png\" alt=\"image-20210328164241430\"></p>\n<p>再来深入地看下这些参数的意义：</p>\n<ol>\n<li><code>corePoolSize</code>：即线程池的基本大小，任务队列每提交一个任务，线程池就会创建一个线程，当提交的任务数大小线程池的基本大小时，就不再创建线程；</li>\n<li><code>maxinumPoolSize</code>：即线程池允许创建的最大线程数；</li>\n<li><code>KeepAliveTime</code>：即线程池的工作线程空闲了以后，保持存活的时间；</li>\n<li><code>TImeUnit</code>：即线程活动保持时间的单位；</li>\n<li><code>workQueue</code>：用来保存等待执行的阻塞队列；</li>\n<li><code>threadFactory</code>：线程工厂，在debug和定位问题时非常有帮助；</li>\n<li><code>RejectedExecutionHandler</code>：拒绝策略，下文会详细描述。</li>\n</ol>\n<h5 id=\"向线程池提交任务\"><a href=\"#向线程池提交任务\" class=\"headerlink\" title=\"向线程池提交任务\"></a>向线程池提交任务</h5><ul>\n<li><code>execute()</code>：无返回值，无法判断任务是否被执行成功；</li>\n<li><code>submit()</code>：返回一个future的泛型对象，通过get方法可以获得返回值。</li>\n</ul>\n<h5 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h5><ul>\n<li><code>shutdown</code>：将线程池的状态设置为<code>SHUTDOWN状态</code>，然后中断所有没有执行任务的线程；</li>\n<li><code>shutdownNow</code>：遍历工作线程，逐个调用线程的<code>interrupt方法</code>。</li>\n</ul>\n<h5 id=\"线程池的执行流程\"><a href=\"#线程池的执行流程\" class=\"headerlink\" title=\"线程池的执行流程\"></a>线程池的执行流程</h5><p><img src=\"https://user-gold-cdn.xitu.io/2018/7/8/16477fc44a03d90f?imageslim\" alt=\"img\"></p>\n<h5 id=\"四种拒绝策略\"><a href=\"#四种拒绝策略\" class=\"headerlink\" title=\"四种拒绝策略\"></a>四种拒绝策略</h5><ol>\n<li><p><code>AbortPolicy</code>：丢弃任务并抛出RejectedExecutionException异常</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171249081.png\" alt=\"    \"></p>\n</li>\n<li><p><code>DiscardPolicy</code>：丢弃任务但不抛出异常</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171502262.png\" alt=\"image-20210328171502262\"></p>\n</li>\n<li><p><code>DisCardOldSetPolicy</code>：丢弃队列最前面的任务，然后提交新来的任务</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171523558.png\" alt=\"image-20210328171523558\"></p>\n</li>\n<li><p><code>CallerRunPolicy</code>：由调用线程处理该任务</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210328171435296.png\" alt=\"image-20210328171435296\"></p>\n</li>\n</ol>\n<h4 id=\"四种线程池\"><a href=\"#四种线程池\" class=\"headerlink\" title=\"四种线程池\"></a>四种线程池</h4><ul>\n<li><code>CachedThreadPool()</code>:可缓冲线程池</li>\n<li><code>FIxedThreadPool()</code>:定长线程池</li>\n<li><code>ScheduledThreadPool()</code>:定时线程池</li>\n<li><code>SingleThreadExecutor()</code>:单线程化的线程池</li>\n</ul>\n<h4 id=\"为什么不推荐使用JUC的线程池\"><a href=\"#为什么不推荐使用JUC的线程池\" class=\"headerlink\" title=\"为什么不推荐使用JUC的线程池\"></a>为什么不推荐使用JUC的线程池</h4><ol>\n<li><p>newFixedThreadPool和newSingleThreadExecutor</p>\n<p>创建的<code>任务等待队列容量过大，耗费非常多的内存</code>~</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329201950011.png\" alt=\"image-20210329201950011\"></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202057662.png\" alt=\"image-20210329202057662\"></p>\n</li>\n</ol>\n<p>2.newScheduledThreadPool和newCachedThreadPool</p>\n<p>​    会<code>创建非常多的线程</code>，CPU压力大~</p>\n<p>​    <img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329202312593.png\" alt=\"image-20210329202312593\"></p>\n<h4 id=\"线程池的参数设置\"><a href=\"#线程池的参数设置\" class=\"headerlink\" title=\"线程池的参数设置\"></a>线程池的参数设置</h4><p>参数的设置和系统的负载有着直接的关系，系统负载有这样的一些参数：</p>\n<ul>\n<li><code>tasks</code>：每秒需要处理的任务数</li>\n<li><code>threadtasks</code>：每个线程每秒可以处理的任务数</li>\n<li><code>responsetime</code>：系统允许任务的最大响应时间。</li>\n</ul>\n<p>下面将用这些系统负载的参数来衡量线程池的参数——</p>\n<h5 id=\"corePoolSize\"><a href=\"#corePoolSize\" class=\"headerlink\" title=\"corePoolSize\"></a>corePoolSize</h5><p>假设系统每秒任务数为100 ~ 1000，每个线程每钞可处理10个任务，则需要100 / 10至1000 / 10，即10 ~ 100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据<code>8020原则</code>，因为系统每秒任务数为100 ~ 1000，<code>即80%情况下系统每秒任务数小于1000 * 20% = 200</code>，则corePoolSize可设置为<code>200 / 10 = 20</code>。</p>\n<h5 id=\"queueCapacity\"><a href=\"#queueCapacity\" class=\"headerlink\" title=\"queueCapacity\"></a>queueCapacity</h5><p>任务队列的长度可以设置为：<code>所有核心线程每秒处理任务数 * 每个任务响应时间 = 每秒任务总响应时间</code></p>\n<h5 id=\"maxPoolSize\"><a href=\"#maxPoolSize\" class=\"headerlink\" title=\"maxPoolSize\"></a>maxPoolSize</h5><p>当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程，增加的线程数取决于任务队列容量和需求。</p>\n<p>千万不能直接创建任务队列，不然容量过大，占用内存过多，对系统压力大。</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210329204208430.png\" alt=\"image-20210329204208430\"></p>\n<h5 id=\"keepAliveTime\"><a href=\"#keepAliveTime\" class=\"headerlink\" title=\"keepAliveTime\"></a>keepAliveTime</h5><p>当<code>负载降低时，可以减少线程的数量</code>，当线程的空闲时间超过keepAliveTime，会自动释放线程。</p>\n<h5 id=\"allowCoreThreadTimeout\"><a href=\"#allowCoreThreadTimeout\" class=\"headerlink\" title=\"allowCoreThreadTimeout\"></a>allowCoreThreadTimeout</h5><p>默认情况下核心级线程不会退出，可通过该参数设置为true,使其退出。</p>\n<p>一般经验：线程池的大小应该这样设置：</p>\n<ol>\n<li>如果是<code>CPU密集型应用</code>，线程池大小设置为<code>N+1</code>,N指CPU的个数；</li>\n<li>如果是<code>IO密集型应用</code>，则线程池大小设置为<code>2N+1</code>;</li>\n</ol>\n<h4 id=\"线程的五种状态\"><a href=\"#线程的五种状态\" class=\"headerlink\" title=\"线程的五种状态\"></a>线程的五种状态</h4><p><img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f73cc0dad76a5?imageslim\" alt=\"img\"></p>\n<h4 id=\"什么场景下怎么设置线程池\"><a href=\"#什么场景下怎么设置线程池\" class=\"headerlink\" title=\"什么场景下怎么设置线程池\"></a>什么场景下怎么设置线程池</h4><ul>\n<li><code>高并发、任务执行时间短的业务</code></li>\n</ul>\n<p>线程池线程数可以设置为CPU核数+1，<strong>减少线程上下文的切换</strong></p>\n<ul>\n<li><code>并发不高、任务执行时间长的业务</code></li>\n</ul>\n<p>这个需要判断执行时间是耗在哪个地方</p>\n<ol>\n<li>假如是业务时间长集中在<code>IO操作上</code>，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目（<strong>2 * CPU核数</strong>），让CPU处理更多的业务。</li>\n<li>假如是业务时间长集中在计算操作上，也就是<code>CPU密集型任务</code>，和（1）<strong>CPU核数+1</strong> 一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li>\n</ol>\n<ul>\n<li><code>并发高、业务执行时间长的业务</code></li>\n</ul>\n<p>解决这种类型任务的关键不在于线程池而在于整体架构的设计</p>\n<h3 id=\"2-JUC\"><a href=\"#2-JUC\" class=\"headerlink\" title=\"2.JUC\"></a>2.JUC</h3><h4 id=\"AQS框架\"><a href=\"#AQS框架\" class=\"headerlink\" title=\"AQS框架\"></a>AQS框架</h4><p>我们知道JUC是一个<strong>定义并发操作并安全处理并发</strong>的框架。而要了解JUC包的全貌，我们首先需要定义处理<code>并发的组件</code>，也就是锁和同步器。这种功能就是由AQS所提供的。</p>\n<p>AQS的全称是<code>AbstractQueuedSynchronizer</code>，即抽象队列同步器。它是java并发用来构建锁和同步器的基础框架。它包含<code>先进先出的双端队列，状态量，线程持有者的引用</code>。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/24459569-f4323d6ace89b32d.png\" alt=\"img\"></p>\n<p>这里的state是由volatile修饰的，即它满足线程间的可见性，另外，它记录了<code>锁的持有者</code>：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329223019662.png\" alt=\"image-20210329223019662\"></p>\n<p>当线程1想要获取monitor对象时，它的行为是这样的：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210329224019027.png\" alt=\"image-20210329224019027\"></p>\n<hr>\n<h4 id=\"工具类——同步器\"><a href=\"#工具类——同步器\" class=\"headerlink\" title=\"工具类——同步器\"></a>工具类——同步器</h4><p>累了，不再文字描述了，把思维导图贴上来：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/%E4%B8%89%E5%A4%A7%E5%B7%A5%E5%85%B7%E7%B1%BB-%E5%90%8C%E6%AD%A5%E5%99%A8.png\" alt=\"三大工具类-同步器\"></p>\n<h4 id=\"其他组件\"><a href=\"#其他组件\" class=\"headerlink\" title=\"其他组件\"></a>其他组件</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6.png\" alt=\"其他组件\"></p>\n<h4 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h4><p><a href=\"https://zhuanlan.zhihu.com/p/60375306\">浅谈ThreadLocal</a></p>\n<h2 id=\"多线程——加餐\"><a href=\"#多线程——加餐\" class=\"headerlink\" title=\"多线程——加餐\"></a>多线程——加餐</h2><h3 id=\"1-关于多线程可行的实践\"><a href=\"#1-关于多线程可行的实践\" class=\"headerlink\" title=\"1.关于多线程可行的实践\"></a>1.关于多线程可行的实践</h3><ul>\n<li>给线程起个<code>有意义的名字</code>，这样可以方便找 Bug。</li>\n<li>缩小同步范围，从⽽而减少锁争用。例如对于 synchronized，应该<code>尽量使用同步块⽽而不是同步方法</code>。</li>\n<li>多用同步工具少用 wait() 和 notify()。首先<code>，CountDownLatch, CyclicBarrier, Semaphore 和Exchanger 这些同步类简化了了编码操作，⽽用 wait() 和 notify() 很难实现复杂控制流</code>；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不不断优化和完善。</li>\n<li>使用<code>BlockingQueue 实现生产者消费者问题</code>。多用并发集合少用同步集合，例如应该<code>使用 ConcurrentHashMap ⽽而不是 Hashtable</code>。</li>\n<li>使用<code>本地变量</code>和<code>不可变类</code>来保证线程安全。使用线程池⽽不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>\n</ul>\n<hr>\n<blockquote>\n<p>山高路远，静水深流.</p>\n</blockquote>\n"},{"title":"计算机网络传输层","top":true,"cover":true,"toc":true,"mathjax":true,"date":"2021-07-12T03:52:37.000Z","password":null,"summary":null,"_content":"\n## 1.1 概述和传输层服务\n\n传输层位于应用层与网络层之间，起着承上启下的重要作用。概括的说，**传输层协议为运行在不同主机上的进程提供逻辑通信的功能**。而从TCP/IP协议族的组成来看，它向上使**进程间的通信成为可能**，向下**加强了网络层提供的尽力而为式**的服务。那具体传输层如何使用服务，并在此基础上加强，最后提供服务的呢？我们还需要继续勾勒这个蓝图：\n\n在此之前，首先来看书中给出的例子——\n\n有两个关系不错的家庭A和B，家庭A的5位家庭成员都会向家庭B的5位家庭成员写信。写好信后交由邮递公司将其送到家庭B的信箱中，家庭B的长子再将信从信箱中取出交给弟弟妹妹们。我们来对这个例子做一个类比：\n\n两个家庭可以看做两个主机，弟弟妹妹们可以看做是应用进程，长子可以看做是传输层协议，邮递服务可以认为是网络层提供的服务，应用层的报文即是信的内容。\n\n从这个案例中，我们可以提取出一些**有趣的信息**——\n\n- 邮件服务有可能出现纰漏，比如会传错，丢失等，即`网络层传输的是不可靠的服务，它不对分组做有效力的保证`。\n- 邮箱里的信件是乱序的，但通过长子来传递到弟弟妹妹的信件却是有序的，即`传输层协议会对可靠性做保证，而其应用的机制则是RDT原理`。\n- 长子不需要跑去邮局取信件，而只需要定期检查邮箱就行啦。即传输层协议被定义在端系统，还是那句话，`网络核心的功能其实是在网络边沿实现的`。\n- 如果邮局没有在规定时间内传递邮件，那在此期间在家里就不可能取到信件。即`传输层的服务明显受限于网络层提供的服务`。\n- 如果邮箱中有很多信件，长子可以选择性的先取出一些邮件。即`传输层提供流量管理和拥塞控制的服务`。\n- 长子在取邮件时，首先需要需要拆开信封，再取出信件。即`目标端可以实现解复用`。\n\n除了上面将传输层当做**整体**看待来分析它的特点与实现以外，我们还需要将传输层拆解，广为人知的是，传输层提供TCP和UDP两个协议，\n\n`TCP`：TCP提供的服务是可靠的，保序的，有拥塞控制，流量管理机制的，面向连接的，涉及复用与解复用，数据以**字节流**的形式传输。\n\n`UDP`:   UDP提供的服务是不可靠的，不保序的，不面向连接的，数据以**数据报**的形式传输。\n\n蓝图已经画就，我们来用笔墨筑起传输层的万丈高楼——\n\n## 1.2 多路复用与解复用\n\n我们在PC上可以同时运行QQ,网易云.它们是从属于不同的进程，所以当传输层向上层传输信息时，需要标识给哪一个进程，也就是需要使用**Socket来标识一个进程**，那向上传输的内容，除了Socket，显然还需要有报文。**报文中包含传输层的首部字段和MSG**。这里的描述其实就是解复用的过程，显然，我们在之前已经接触过。下面我们更具体地描述传输层的复用与解复用。\n\n- `复用：`在源主机从不同的套接字中收集数据块，并**为每个数据块封装首部信息**，生成报文段，最终将报文段交付于网络层。\n- `解复用：`将传输层报文段中的数据交付给应用进程的过程\n\n也就是说，传输层的多路复用与解复用实现的就是`将主机到主机的交付服务延伸到应用程序到应用程序之间`，它关注的问题无非是**将报文传给谁，报文中都包括什么**。\n\n\n![image-20210707210324385](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210324385.png)\n\n可以看出，复用与解复用的核心是通过套接字来完成的。而通过上一章节的知识，我们知道TCP和UDP的套接字所引用的信息是不一样的。我们分情况来看——\n\n### 无连接的多路复用与解复用\n\n我们通过图解来解析UDP多路复用的过程——\n\n![image-20210707210337051](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210337051.png)\n\n`饮`：主机A中的传输层创建一个传输层报文，**报文包含应用程序数据，源端口号19157，目的端口号46428和其他两个值**。接着，传输层将该报文段传输给**网络层**，网络层再将报文段封装到一个**IP数据报**中，并通过网络链路交付给接收主机。\n\n`啄`：接收主机传输层检查该报文段中的**目的端口号46428**，并将该报文段交付给端口号46428所**标识的套接字**。\n\n这里有一点可能会引起**困惑**的地方：socket是如何参与这个过程的。首先明确的是，**socket是不被包含在报文段中的**。UDP的Socket包含目的IP，目的端口号，它仅用于处理源端口或者目标端口的**识别**，即**层间接口**。但报文是实际参与通信过程的。这里的socket就像是一个**开门的钥匙**。\n\n### 面向连接的多路复用与解复用\n\n同样的，开局一张图——\n\n![image-20210707224235450](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224235450.png)\n\n区别于UDP，TCP的socket所引用的信息是一个四元组，即——\n\n![image-20210707224252958](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224252958.png)\n\n额，PID就不用管了，当一个报文段被交付给应用进程时，它需要使用四元组的socket来判别报文段应该被交付给具体哪一个应用进程。\n\n如果我们要求在传输层上只实现**必要的最简单协议**，那UDP完成符合这样的要求。UDP的全称是**用户数据报协议**。它仅在网络层的基础上提供**必要的复用，解复用，以及简单的校验和**。这使得它的功能基本上和网络层一致。\n\n我们知道，网络层提供的服务是不可靠的，所以使用UDP的传输层提供的服务同样不可靠。这意味着它不需要握手，即不面向连接。数据有可能发生乱序，重复。而假设发生了这种错误，客户端如何处理呢？它会直接**丢弃**。\n\n这种简洁的设计会有它的用武之地吗？当然，**简洁也是一种优雅**，它简单所以头部信息少，传输快，它不需要建立连接，也自然没必要维护连接的状态。甚至一些应用是在UDP的协议上构建的——\n\n![image-20210707224304322](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224304322.png)\n\n那这是否意味着基于UDP的应用是不可靠的呢？不完全是，**在应用程序做可靠传输的处理**是一种可选的方式。\n\n我们再来拨云见日地看看UDP的报文结构：\n\n![image-20210707224316644](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224316644.png)\n\n值得一提的是UDP仍然提供了必要的简单检错机制，即**校验和**，来看校验和的原理——\n\n![image-20210707224330412](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224330412.png)\n\n即我们在源端得到测试的和，如果有进位，则再回卷得到和。数据报传输到目标端以后，目标端将**校验和的反码与源端得到的校验和相加**，如果相加为全1，则校验通过，反之不通过。\n\n## 1.4 重点：可靠数据传输原理\n\n### 问题描述\n\n可靠数据传输是一个**一般性的问题**，它不仅在传输层使用这个机制，在网络层和应用层也可以实现。而下一个小节中我们将以最通用的传输层为例介绍可靠数据传输协议RDT。\n\n在编程时，我们通常使用这样的思维：即`首先将具体问题转化为抽象的数学问题，再使用编程语言将数学问题实现`，在学习rdt时，这种思路同样适用。\n\n首先来看可靠数据传输面临的场景：对于应用层来说，传输层通过可靠数据传输的机制，并使用**可靠的信道**来向应用层提供服务——\n\n![image-20210707224342304](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224342304.png)\n\n\n\n`那这个可靠的服务是如何实现的呢`？显然是通过调用下层服务。从而对本层服务做加强来实现的，我们将这一过程**抽象成原语实现**，我们将这些原语具体描述，他们发挥着这样的功能——\n\n- `rdt_send:`被上层调用，将数据交付给下层的发送方实体。\n- `udt_send:`被rdt调用，将分组通过不可靠的信道发送给接收方。\n- `rdt_rcv:`分组到达接收方时被调用。\n- `deliver_data:`被rdt调用，将数据交付给上层。\n\n我们需要通过rdt来实现**发送方和接收方动作的抽象**，但这种抽象是基于不可靠的信道，它可能会发生**乱序，重复，篡改**等问题，直接给出解决方案着实有点难为人。所以这里引入了一种处理复杂问题的思路，即**渐进式解决**。\n\n`具体的说，我们一层层地去掉那些美好的假设，然后在一个可行方案的基础上逐渐完善`。我们的任务仅仅是实现一个能够完成必要功能的rdt协议，所以双向传输可以简化为单向传输，此外，给出有助于解决问题的通用模型也势在必行。也就是有限状态机FSM，在学习数字系统设计时，接触过使用**FSM描述的空调状态机**。不想除了考试，居然还能有缘再见。在课堂终于学到有用的知识了。。。\n\nFSM是这样设计的：\n\n![image-20210707224353943](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224353943.png)\n\n至此，前置知识就完结了，故事的大幕就此拉开——\n\n### rdt1.0\n\n这里`假设信道完全可靠`，它没有比特出错，甚至不会分组丢失，此时的rdt协议,恕我说句：工具人~。\n\n用状态机来描述一下此时的发送方与接收方——\n\n![image-20210707224406899](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224406899.png)\n\n这个显然还没有复杂度需要详细描述的地步，next~\n\n### rdt2.0\n\n在2.0版本，我们就要抛弃掉一些幻想，这时候的信道不那么可靠，它可能会发生`比特的错误`。之前在聊UDP时谈及UDP报文结构中使用校验和来做差错检测，当然TCP也有这个机制。检测出来后，怎么更正呢？自然是重发，那`如何标识出错的状态`呢？\n\n这就需要引入`标记量`。假如接受方检测到比特出错，就发送显示的发送错误标志，也就是`NAK`，俗称：反向谢谢；而当检测后发送无误，就发送显示的发送正确标志，这回是正向的谢谢：`ACK`。\n\n同样的，向量机描述——\n\n![image-20210707224420197](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224420197.png)\n\n这时，状态机已经没那么友好了，我们简要描述一下——\n\n- `发送方：`当rdt接收到应用层的数据后，将`数据与校验和组成传输报文`通过不可靠的信道发送给接收方，然后发送方等待接收方的回应。当等待到的是ACK时，继续等待上层调用。\n- `接收方：`接收方接收来自不可靠信道的数据，然后`做校验`，当校验出错时发送NAK,校验正确时发送ACK。\n\n### rdt2.1\n\n咦，怎么又出现了2.1，自然是因为2.0实在不堪大用。2.0版本的确相比1.0版本迈出了一大步，但它本身存在致命的缺陷，也就是**ACK,NAK本身也有可能发送错误**。rdt的机制应该也必须是健壮的，所以当接收到不可识别的信息时**有必要重发数据包**。所以对数据包的标识就这么顺水推舟的发生了.即**对分组加序号**。但这里只使用1位，即2种可能结果标识正在处理的分组。这是因为目前仍处于**STOP AND WAIT阶段**，一次发送一个数据包，用0和1来标识要处理的数据包就行啦。但如何处理重复呢？**丢弃**发送时间较早那个的数据包。\n\n#### 接收方处理出错的ACK/NAK\n\n老规矩——\n\n![image-20210707224431777](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224431777.png)\n\n这时接收方在2.0版本的基础上增加了对分组序号的识别，再来看发送方的处理——\n\n![image-20210707224444037](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224444037.png)\n\n看似很复杂，但实则只是穷举了对于不同分组的类似处理，毕竟只需要考虑两个分组，可以任性地穷举。来看下具体的场景——\n\n![image-20210223150554157](http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210223150554157.png)\n\n### rdt2.2\n\n2.2版本本质上和2.1版本并无二致，但出于简洁的考虑，只使用ACK，而不用NAK。那具体怎么操作的呢？\n\n假设有这样一个场景——\n\n> 发送方发送**数据包1**，接收方检测出错了，所以发送**ACK0**给发送方。发送方默念一句你丫的，然后重新发送数据包1.双方继续和谐地传递着数据包。\n\n![image-20210707224454789](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224454789.png)\n\n一看就会的图解——\n\n![image-20210707224504993](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224504993.png)\n\n这里不再给出状态机描述，它的确适合转换为编程语言。但与人交互还是上图更友好些。\n\n### rdt3.0\n\n解决了乱序，比特出错。仍旧还有**分组丢失**的问题，如果按照rdt2.2机制，分组丢失后发送方接收方都鸦雀无声，陷入了**死锁，浪费CPU资源**。所以需要加入**超时重传机制**。\n\n即当分组发送出去后，计时器开始倒计时，如果计数到0还没有收到响应，那就重传。机制的核心在于**计时的确定**，**网络状态是很难预测**的，它的拥堵状况可以类似于高斯分布，我们需要使用数学中概率论的知识尽可能确定时间。当然，一个相对准确的计时器还需要**相当长的路要走**。\n\n诚然，凡事讲究善始如终，此处应有状态机——\n\n![image-20210707224518042](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224518042.png)\n\n1. 首先发送方等待应用层调用，传输层组织好报文结构后，通过不可靠的信道将分组0传输给接收方，并启动超时定时器；\n2. 状态切换到等待ACK0的响应，如果超时或出错(ACK1)，则重传，如果接收到ACK0，状态切换至等待应用层调用1；\n3. 偷懒一手，同上。\n\n------\n\n至此，rdt3.0已经是用于传输单个分组的无懈可击的协议，但在信道带宽大的情况下，rdt3.0的性能非常感人。这就好比八车道的高速公路全程只准跑一辆自行车。这显然很难以忍受，所以如何一次性发送多个分组而无须等待确认是必须要解决的问题。\n\n![image-20210707224528848](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224528848.png)\n\n我们将这种发送多个分组可以看做是填充到一条流水线中。因此解决这个问题的机制被称为**流水线协议**。流水线协议在rdt3.0基础上增加了**传输分组的粒度**。但它同时带来的问题可一点也不少——\n\n- 分组的序号显然只用0和1是不够的，必须**扩大分组序号的范围**，来唯一地标识一个分组；\n- 分组传输与接收的速率不一致，需要在接收方增加**缓存机制**，此外，发送方在发送分组以后可能处于两种状态：`等待确认,确认完成`。所以发送方的分组需要分区，即发送方也需要缓存机制；\n- 当分组出现损坏，丢失，延迟时如何处理呢？根据场景有两种可选的方式：`GBN(回退N步)和SR(选择重传)`.\n\n------\n\n这两种处理差错的方式又都是基于**通用的滑动窗口**来实现的，滑动窗口是在**缓冲区的基础上**运作的，我们先来了解发送缓冲区及接收缓冲区——\n\n- `发送缓冲区：`缓冲区即是内存中的一块区域，它有大小属性，这里的发送缓冲区大小可以为1，即RDT3.0,当大小>1时，即为流水线协议。这里的发送缓冲区用于**存放已发送未确认的分组**，以便用于检错重发或超时重传。\n- `接收缓冲区：`是为了解决分组在信道中传输的速率与接收方接收的**速率不一致**的问题所引入的。它的大小为1时即为RDT3.0,当发送缓冲区大小>1时，接收缓冲区可以为1，此时为GBN协议，如果接收缓冲区>1,则为SR协议。\n\n那如何表示缓冲区动态传输的过程呢？这就需要引入滑动窗口——\n\n### 发送窗口\n\n滑动窗口用来表示`发送缓冲区的范围`，即实际的`已发送未确认的分组个数`，我们通过图解来认识这个动态的过程——\n\n![image-20210707224540604](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224540604.png)\n\n此时，没有分组发送，缓冲区大小N=5，滑动窗口前沿=后沿，窗口大小=前沿-后沿=0。\n\n![image-20210707224551296](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224551296.png)\n\n接着，一个分组被发送，前沿移动一位，滑动窗口大小=前沿-后沿=1.此时分组0处于已发送未确认状态。\n\n![image-20210707224601189](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224601189.png)\n\n此时，5个分组都被发送，缓冲区已满，滑动窗口大小=前沿-后沿=5=缓冲区大小。\n\n------\n\n这个过程我们是假设没有分组收到确认，现在我们打开潘多拉魔盒，认为已经有分组已经收到确认，情况就有所不同了——\n!![image-20210707224616355](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224616355.png)\n\n这时，`分组0得到确认，窗口后沿移动`，此时前沿仍然指向最后一个进入缓冲区的已发送未确认分组。\n\n![image-20210707224627690](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224627690.png)\n\n然后，分组1也得到确认，窗口后沿移动。有两个分组5,6被发送，进入缓冲区等待确认。窗口前沿移动到6的位置。\n\n------\n\n### 接收窗口\n\n发送窗口告一段落，来类比地看接收窗口，接收窗口可以控制哪些分组可以接收：\n\n- `收到的分组序号落在接收窗口内可以接受`；\n- 落在接收窗口外，则丢弃。\n\n此外，接收窗口根据出错的概率分为两种情况，对应两种协议——\n\n#### GBN\n\n接收窗口的尺寸等于1，即`只能顺序接收`：\n\n![image-20210707224639851](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224639851.png)\n\n接收窗口首先在分组0的位置，此时只有分组0的会被接收，如果接收到的是分组1，则丢弃。假设接收方接收到分组n,则表示小于等于分组n的所有分组都已经被接收，即**累计式确认**。\n\n#### SR\n\n接收窗口的尺寸大于1，可以乱序接收：\n\n![image-20210707224650324](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224650324.png)\n\n起初，接收窗口中有分组0,1,2,3.收到分组0,1后，接收窗口向前滑动。但如果分组没有按序到来，会发生什么呢？\n\n![image-20210707224701886](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224701886.png)\n\n可以看到，当高序号的分组到来后`，仍旧将其缓存，但并不移动滑动窗口`，只有当低序号的分组到来后，窗口才会整体后移——\n\n![image-20210707224711512](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224711512.png)\n\n最后，可以总结出SR协议为非累积式接收。\n\n------\n\n#### 正常情况下的窗口互动\n\n![image-20210707224721902](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224721902.png)\n\n#### 异常情况下的窗口互动\n\n![image-20210707224736296](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224736296.png)\n\n\n\n![image-20210707224827566](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224827566.png)\n\n\n\n#### 用FSM描述的GBN\n\n1. 发送方\n\n   首先声明这些变量代表的含义：`N为窗口长度，base为窗口后沿，nextseqnum为满足发送条件但因缓冲区已满没有发送的分组序号`，\n\n![image-20210707224840765](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224840765.png)\n\n2. 接收方\n\n   ![image-20210707224850680](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224850680.png)\n\n#### 运行中的SR\n\n![image-20210707224903011](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224903011.png)\n\n### 总结\n\nGBN适用于`出错率低`的场景，`而链路容量大，回退代价高`的场景则是SR更优。\n\n![image-20210707224915038](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224915038.png)\n\n## 1.5 面向连接的传输——TCP\n\n在对TCP有大致的纹路了解后，我们进入TCP正式的探索。本着结构决定功能的特点，从TCP的段结构起笔，渲染TCP的可靠数据传输，进而浓墨于流量控制机制，最终落笔于连接管理。\n\n`TCP提供的是点到点，可靠的，管道化的，按序的字节流，拥有流量控制机制，面向连接的服务。`\n\n### 段结构\n\nTCP的报文段由一个**首部字段和数据字段**构成，数据字段即是应用层的数据，那这部分数据是源数据根据怎样的规则划分的呢？这里引入**最大报文段长度MSS**的概念。TCP会将要传输的文件分为若干个MSS。**MSS的长度**通常由**本地发送主机发送的最大链路层帧长度**来设置。在确定数据部分后，TCP为每个客户端数据配上一个**TCP首部**，从而形成多个TCP报文段。\n\n![image-20210707224931500](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224931500.png)\n\n具体来看每个字段：\n\n- `源端口号：`TCP提供的是进程之间的逻辑通信，而标识进程的即是端口号，标识源端口号就相当于给出了数据**复用**的路径。\n\n- `目的端口号：`同样的，只有给出目的端口号，在接收方才能完成**解复用**的工作。\n\n- `序号：`TCP把数据看做一个**无结构，有序的字节流**。而为了来标识每个报文段(`MSS`)的首字节在整个字节流中的位置，或者说偏移量，就引入了序号的概念。该序号的范围为**2的32次方**，可见冲突的几率比我中彩票还低~\n\n  ![image-20210707225012629](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225012629.png)\n\n- `确认号：`在可靠数据传输中，我们使用ACK来作为确认字段，但ACK只能表示接收方对接收到数据的回应，而实际的传输是全双工，且高并发的。所以接收方的确认号将**确认与下一次传输的数据相结合**作为确认号。也就是说，假设确认号为2000,即表示**期望收到的下一个字节的序号**，这里给出的序号同样也具有**GBN累计确认**的意义。\n\n  我们试着使用序号与确认号来描述简化的传输过程——\n\n  ![image-20210707225024780](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225024780.png)\n\n  即主机A发送序号42及对于序号79的确认，主机B收到后，发送对于序号42的确认，即ACK=43，且发送主机A期望的79，即seq=79.\n\n- `接收窗口：`该字段用于**流量控制**，即指示接收方愿意接受的字节数量，在抓包的时候任一数据发送源都会使用**Win字段**来告诉另一方自己接收窗口的大小。\n\n- `CRC校验和：`在UDP部分谈及过，用于**检错**。\n\n而从进程通信的`流程框架`来看，TCP报文段又会经历怎样的**复用与解复用**呢——\n\n在形成报文段以后，这些报文段被下传给网络层，网络层将其分别封装在**网络层IP数据报**中，接着被发送到网络中，TCP在另一端接收报文段，该报文段被放在该**TCP连接的接收缓存**中，应用程序从缓存中读取数据流。\n\n### 可靠数据传输\n\n了解了确认号与序号，可靠数据传输的纹路已经逐渐明晰。在学习通用的rdt时，我们谈及当一个分组丢失时，超时重传机制是有必要的，这在TCP的机制中同样适用。但在TCP的机制中，我们需要将超时重传的机制具象化，即真正高效地使用。\n\n如何来估计超时重传的往返时间？**定时器RTO**应该设置多长时间？是否需要为每一个分组都设置一个定时器呢？我们来渐进式地解答——\n\n1. 显然，定时器设置的时间应该是**大于往返时间RTT**的，所以我们可以随机地选取某一个RTT作为**SampleRTT**,但由于路由器的拥塞和网络负载均衡的特点，SampleRTT波动是很大的，所以为了更趋近于真实RTT，我们引入SampleRTT的均值EstimatedRTT。通过这两个标量，可以近似得到这样的公式：\n   $$\n   EstimatedRTT=（1-a）•EstimatedRTT+a•SampleRTT\n   $$\n   这里的a推荐值为**0.125**，将通过公式得到的均值称为之**指数加权移动平均**。\n\n2. 这里直接给出公式——\n   $$\n   Timeoutinterval=EstinMrtedRTT+4•DevRTT\n   $$\n   这里的DevRTT是为了解决波动问题，而引入的一个SampleRTT与EstimatedRTT之间差值。\n\n3. TCP并不会为每个分组都维护一个定时器，因为高并发的发送维护定时器的代价是很大的，因此TCP使用了**单一重传定时器机制**。即只为**发送缓冲区中最古老的已发送未确认分组**维护定时器。\n\n至此，TCP可靠数据传输的自肖像已经变得丰满起来。我们不妨在已经构建框架的前提下给出一个最简化的TCP发送方——\n![image-20210707225039262](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225039262.png))\n\n即当超时定时器触发以后，发送方会传输**至今没有得到确认的最小序号分组**。即这里的机制又是类似于**选择性重发SR**。在重发后，超时定时器又会与当前没有得到确认的最小序号分组相关联。此外，还有一种情况，即缓冲区为空，即所有的分组都已得到确认，此时需要重启定时器。\n\n通过下图来看简要的交互：\n\n![image-20210707225051029](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225051029.png)\n\n另外，我们来穷举关于ACK的几种情况及相应的处理方式——\n\n| **接收方事件**                                         | **TCP接收方动作**                            |\n| ------------------------------------------------------ | -------------------------------------------- |\n| 所期望序号的报文段按序到达，期望序号之前的都已得到确认 | 延迟的ACK，即对另一个按序报文段最多等待500ms |\n| 有期望序号的报文段到达，另一个按需报文段等待发送ACK    | 立即发送单个累积ACK，以确认两个按序报文段    |\n| 比期望序号大的报文段乱序到达，检测到数据流的间隔       | 立即发送重复ACK，指明下一个期待字节的序号    |\n| 能部分或者完全填充接收数据间隔的报文段到达             | 若该报文段起始于间隔的低端，则立即发送ACK    |\n\n这个简化的TCP交互是默认不存在重复确认的，但实际上重复确认的情况是有可能出现的，TCP针对这种情况也给出了**快速重传机制**。\n\n收到**重复确认**往往是因为**定时器设置的太大**，接收方没有收到某个分组，但在定时器时间内仍会收到乱序到达的其他分组，这时接收方就会发送冗余分组，当发送方接收到**三个冗余确认**后，就会在定时期间**重传最小序号的报文段**。\n\n![image-20210707225101991](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225101991.png)\n\n再来看下快速重传的伪代码——\n\n![image-20210707225112511](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225112511.png)\n\n即接收方收到ACK，判断ACK与窗口后沿的关系，假如**ACK大于窗口后沿，则将窗口后沿滑动**，将**定时器与新的报文段关联**。否则，也就是ACK重复的情况，则记录ACK重复的个数，当其等于3时，触发快速重传机制。\n\n### 流量管理\n\n传输层在将数据解复用以后，不是直接交付给应用程序使用，而是将其放置在**接收缓冲区**内，上层应用再**从缓冲区中读取数据**。但当从发送方发送来的数据太多就有可能**淹没接收缓冲区**，导致报文段丢失，因此，约定发送方的发送速率与接收方的接收速率是必须的，这种**为了匹配速率的机制就称为流量控制**。\n\n流量控制机制是通过互相告知缓冲区可用空间来实现的。那如何告知呢？即是通过接收方向发送方发送的报文段中的**rwnd字段**，它表示了**接收缓冲区中可用的空间**。\n\n![image-20210707225128655](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225128655.png)\n\n我们将rwnd再具象化，即它是通过什么来实现的呢？接收窗口！！！但这里的接收窗口和rdt中的接收窗口还是有所区别的。为了量化接收窗口的大小，我们还需要引入两个变量：\n\n- `LastByteRead`:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。\n- `LastByteRcvd`:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。\n\n那么接收窗口就可以表示为：\n$$\nrwnd=RcvBuffer-[LastByteRcvd-LastByteRead]\n$$\n\n### 连接管理\n\n我们来深入了解如何建立和拆除一个TCP连接，首先，我们需要建立一些共识，也就是连接都需要做什么？\n\n在socketAPI的编程中，我们需要维护两个套接字，即连接是针对双方而言的，**每一端可以看做维护一个半连接**，所以在建立TCP连接时，两端都有**告诉对方我要建立连接**的诉求。除此之外，还需要**为连接配置资源**，因为连接就意味着马上会有数据传输，所以**缓冲区自然是需要**的，此外，**序号和确认号也是必选项**咯。\n\n### 三次握手\n\n好啦，实际地去建立连接时，首先先入为主的想法是两次握手——\n\n![image-20210707225141658](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225141658.png)\n\n但两次握手面临着很多问题：\n\n- 假如接收方的确认超时了，此时发送方会重发连接建立请求。但我们注意到**接收方的机制简言之就是收到连接请求则同意建立**。也就是说，虽然确认超时了，但接收方仍会维护一个**半连接的状态**及对应的资源。\n- 在上面状况的基础上，假如发送方接收到确认后，发送数据data，而接收data的接收方的状态为新的连接，那么此时**新的连接接收的是老连接的数据**。\n\n这些问题的症结本质上是**半连接的孤立**，那么如果**在双方半连接的基础上增加两个半连接的交互**，那问题就迎刃而解了。三次握手就是基于这样的思想实现的。我们来详细剖析三次握手的详细过程——\n\n1. `第一次握手：`客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中**不包含应用层数据**。但是在报文段的首部中的一个标志位（即**SYN**比特）**被置为1**。因此，这个特殊报文段被称为**SYN报文段**。另外，客户会**随机地选择一个初始序号**（client_isn）,并将此编号放置于该起始的TCPSYN报文段的序号字段中。\n\n2. `第二次握手：`服务器会从该数据报中提取出SYN报文段，为该TCP连接**分配TCP缓存和变量**，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段**也不包含应用层数据**。但是，在报文段的首部却包含**3个重要的信息**。\n\n   1. SYN比特被置为1。\n   2. TCP报文段首部的确认号字段被置为**client_isn+I**\n   3. 服务器选择自己的初始序号（**serverjsn**）,并将其放置到TCP报文段首部的序号字段中。这个允许连接的报文段实际上表明了：**“我收到了你发起建立连接的SYN分组，该分组带有初始序号clientjsno我同意建立该连接。我自己的初始序号是serverjsnon**\n\n   该允许连接的报文段被称为**SYNACK报文段**.\n\n3. `第三次握手:`在收到ACK报文段后，客户也要给该连接**分配缓存和变**量。客户主机则向服务器发送另外一个报文段；这最后一个报文段**对服务器的允许连接的报文段进行了确认**（该客户通过**将值serverjsn+1放置到TCP报文段首部的确认字段**中来完成此项工作）。因为连接已经建立了，所以该**SYN比特被置为0**。该三次握手的第三个阶段可以在报文段**负载中携带客户到服务器的数据**。\n\n![image-20210707225201937](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225201937.png)\n\n嗯，熟悉的FSM环节——\n\n![image-20210707225214552](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225214552.png)\n\n\n\n\n\n------\n\n\n\n### 四次挥手\n\n天下没有不散的宴席。TCP连接也不能免俗。相比于三次握手，四次挥手还是水到渠成的，双端都可以主动发起断开连接的请求，然后**双方断开自己维护的半连接**即可，同样的，我们来复现这个过程——\n\n1. 客户端进程向服务器进程发送一个特殊的报文段，该报文段中首部标志位**FIN置1**；\n2. 服务器接收该报文段后，**其ACK比特置1**.\n3. 反向同理。\n\n![image-20210707225225357](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225225357.png)\n\n## 1.6 拥塞控制原理\n\n------\n\n### 前言\n\n在rdt可靠数据传输机制中，分组丢失是不可避免的，而**分组丢失的原因通常是由网络拥塞**，当路由器的缓存被占满后，后来者将会别抛弃，本质上说这种状况是因为网络是不可控的，很难从端系统获知网络的状况，但发送方又本着`多多益善`的方式在加剧网络的恶化。\n\n为了避免网络拥塞，TCP使用了怎样的机制，这种处理机制出发点是什么，它针对性地解决了哪些问题，如此种种。要解决这些问题，我们仍要铺好第一块砖石——\n\n`网络拥塞的定义`：太多的数据需要网络传输，超过了网络的处理能力。\n\n### 拥塞原因与表现\n\n这里我们仍使用渐进式分析问题的思想，一个不会发生分组丢失的网络是怎样的呢？\n\n- `路由器缓存无限大`\n- `端系统可以了解网络的状况并作出调整。`\n\n- `所有分组都可以不超时的到达，所以不需要重传`\n\n先来看路由器缓存，假设路由器缓存无限大，那分组就不会被丢弃。这时假设有两个发送端通过一条链路(带宽为R)发送数据，那么它的吞吐量和延时表现为这样——\n\n![image-20210707225238081](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225238081.png)\n\n可见，即便在理想状态下，当超出链路的承载能力后，`流量强度变大，排队延时激增`。硬件条件这是不可逾越的天花板。所以我们很难控制不发生拥塞，而要从拥塞发生后的处理技巧入手。\n\n接着，我们去掉缓存无限的假设，这时分组丢失就变得无可避免，分组丢失就意味着重传，而`重传导致链路中重复的分组`，也就是不必要的分组增多，直接使得`发送方比接收方更高的发送速率`，导致本就不宽裕的链路带宽更显的捉襟见肘。另外，超时重传作用的结果也是一样的。\n\n最后，我们设想在类似`进程发生死锁`的一种情景，每个发送方占用着别的发送方需要的链路带宽，而别的进程也占用着自己需要的链路带宽，如果人的欲望一般，我们知道这条路是错的，但贪念仍在驱使着躯干向前。\n\n### 拥塞控制的方式\n\n针对上面的状况，一般采用两种控制拥塞的方法——\n\n- `端对端的拥塞控制：`TCP就使用这种策略。端系统根据`延迟和丢失事件`推断是否有拥塞。\n- `网络辅助的拥塞控制：`路由器通过`置位`的方式显示的告诉发送端可以采用的速率。\n\n来通过实际的**ATM ABR场景**认识下这两种方式是怎样实际运转的：\n\n我们知道，在网络中传输的数据粒度是有区别的，专线更多使用线路交换的方式，而通用的则是分组交换的方式，这种在银行中大行其道的ATM ABR线路则使用数据粒度`介于线路交换和分组交换的粒度大小`，更具体地说，它传输的最小单元是`53个的比特`。\n\n**ABR(available bit rate)**提供的是弹性服务，它可以`根据网络的负载实时调整发送速率`。如果发送方路径轻载，则发送方就使用尽可能多地利用贷款。如果发送方路径阻塞，发送方限制速率至一个最小保障速率。\n\n那网络中的拥塞状况是如何被获知的呢？通过RM信元，即**资源管理信元**。\n\n它由发送端发送，在数据信元中间隔插入，通过该信元特定的比特位来作为网络辅助，这种行之有效的比特位分别是：\n\n- `NI bit:`即no increase in rate。\n- `CI bit:`即congestion indication拥塞指示。\n\n发送方发送的RM信元被接收方返回，`接收方仅用作中转`使用。另外，之前谈及信元可以返回给发送方最小发送速率，这是如何实现的呢？\n\n通过RM信元中的2个字节`ER(explicit rate)字段`.拥塞的交换机会降低ER的值，最终返回给发送方。\n\n------\n\n## 1.7 TCP拥塞\n\n在上一小节中，我们聊了通用的拥塞控制机制，也就是：**端系统处理**，**网络辅助的拥塞控制**。同时对网络辅助的案例做了简单描述，这一小节，我们将展开讲述在端系统如何处理拥塞。\n\n更具体地说，是**TCP的拥塞控制机制**。而在开始之前，我们先解决一个前置问题：TCP`为什么不在网络核心通过使用辅助信元的方式实现拥塞控制`。其实，纵观整个网络架构，复杂性都是在传输层及其以上提供的，也就是说，`网络层不会向上层应用提供显式的拥塞控制机制`。\n\n那TCP的拥塞控制机制是怎样实现的呢？不着急，本着先有问题，再有方案的思路，我们先来回答TCP拥塞机制面临的**三大问题**——\n\n- `如何感知到拥塞`\n\n  网络拥塞的最终结果是分组丢失，而导致分组丢失的原因却有一些区别——\n\n  1. 假如到达路由器的分组过多导致缓冲区已满，**分组就会被丢弃**。此外，有可能分组在传输时比特反转，接收方认不出来这是啥，那也会将其丢弃。这两种情况的直观表现都是超时，这种`拥塞情节严重`，发送方明显被动。\n  2. 当发送方连续收到4个ACK信号，也就是**3个冗余ACK**时，就会触发快速重传机制，这时还没有超时，发送方主动出手降低损失，姑且称其`轻微拥塞`。\n\n- `如何对速率做调整`\n\n  那明确了问题，如何针对两种拥塞做出发送速率的调整呢？在**RDT**中，我们引入`接收窗口rwnd`来限制接收分组，这里我们也采用类似的机制，引入`拥塞窗口cwnd`。类比接收窗口表示能够接收分组的上限，拥塞窗口表示的即是——\n\n  ![image-20210707225253295](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225253295.png)\n\n  是不是似曾相识，发送窗口表示的是**实际的**已发送未确认的分组数量。而拥塞窗口就如同在对发送窗口做**动态调整**，除此之外，别无二致。那确定了拥塞窗口的值，发送方的发送速率也可以得出来——\n\n  ![image-20210707225302111](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225302111.png)\n\n  \n\n- `通过怎样的算法对速率做调整：`\n\n有了衡量拥塞的标志，接下来就需要通过拥塞状况触发动态调整啦，这里的动态调整，就是广受赞誉的**TCP拥塞控制算法**。\n\n该算法分为三部分：慢启动，拥塞避免，快速恢复。我们详细来聊聊——\n\n- `慢启动：`\n\n  TCP会将cwnd的值`初始化为一个2/3/4MSS`(具体由MSS的大小决定)的值，但显然，这点速率是不够打的，所以当分组首次被确认后，会以`指数级的增长趋势`尽快加速，直至超时后打回原形，也就是1个MSS.这时，TCP还会维护一个**慢启动阈值**，也就是警戒值，它的值为**cwnd(max)/2**，接着，开始下一次拥塞控制，当cwnd的值指数增加至慢启动阈值后，不再鲁莽地指数级增长，而是维持`线性增长`。\n\n  ![image-20210707225311975](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225311975.png)\n\n  这种线性增长的机制就是拥塞避免——\n\n- `拥塞避免：`\n\n  那拥塞避免什么时候结束呢？和慢启动一样，拥塞避免阶段在触发超时后会重新开始SS慢启动阶段,这时，慢启动的阈值也势必会更新。\n\n  再来讨论下发送方收到**3个冗余ACK**的状况——\n\n  它的处理机制显然没必要像拥塞时那么剧烈，只需要在触发快速重传后，记录慢启动阈值，然后`直接从阈值开始线性增加`进入快速恢复阶段——\n\n- `快速恢复：`\n\n  所谓的快速恢复无非是针对两种拥塞状况的不同种处理，在上面已经提及，就不再赘述。\n\n  1. 超时重传：RFC建议将拥塞窗口降至1个MSS，而由慢启动过渡至拥塞窗口的值就有讲究了，应该调整至没别确认的数据量的1/2,但不能小于两个MSS\n  2. 快速恢复：不会处理拥塞窗口的值；\n\n接下来就是小总结环节——\n\n![image-20210707225324365](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225324365.png)\n\n再将两种情况汇总，就有了下图——\n\n![image-20210304182714108](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210304182714108.png)\n\n\n\n### TCP吞吐量\n\n这里我们取快速恢复阶段的数据量均值作为参考(慢启动指数级的增加实则很快，也导致实际传输的流量不多)，即——\n$$\n一条连接的平均吞吐量=3/4*W/RTT\n$$\n另外也给出在`经过高带宽TCP，且丢包率为L的情况`下，吞吐量的描述——\n$$\n一条连接的平均吞吐量：1.22*MSS/RTT/根号下2\n$$\n\n### TCP公平性\n\n太饿了，去吃饭，偷懒一手——\n\n![image-20210707225338648](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225338648.png)\n\n也就是多个TCP连接时，网络状况会趋向于`带宽均分`。\n\n而如果一个链路中既有使用TCP的服务，也有使用UDP的服务，那对于TCP是不友好的，因为`UDP百无禁忌`，它没有拥塞控制机制，如果有可能，UDP会一点点的蚕食掉带宽，而最终导致更恶劣的后果，可见，**不限制贪欲最终会陷入恶性循环**。但这种机制也并非一无是处，流媒体就表示这是我的菜，因为`音视频应用起码泵出数据的速率是恒定`的，即便数据会丢失。\n\n------\n\n## 抓包番外\n\n### 简单的代价——UDP\n\n\n\n### DNS那些事\n\n![image-20210506232028231](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232028231.png)\n\nDNS常用的**应用场景**有两种：\n\n- `CNMAE:`即将一个域名映射到另一个域名，\n\n  ![image-20210506234636802](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234636802.png)\n\n- `A：`请求获取域名对应的IP地址\n\n  ![image-20210506234517700](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234517700.png)\n\n当DNS在缓存中没有找到要查询的记录后，就会发起**DNS查询**，查询有两种：递归查询，迭代查询。假如我们向一个`不权威的DNS服务器发起递归查询请求`，我们只会与这个不权威的DNS服务器交互，而`无从得知它的查询结果是否可靠`。迭代查询则会相对安全一些，因为客户端首先会查到根服务器的地址，再从根服务器查到权威服务器，然后从权威服务器查询。。。直到返回想要的结果。\n\n它的**响应**一般包含这些字段：\n\n![image-20210506235701873](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235701873.png)\n\n再来聊一些生僻的：**DNS循环工作模式**——\n\n假如某个网站有10台Web服务器，管理员可以在DNS创建10个同名记录指向这些服务器的IP，由于不同客户端查到的结果顺序不同，而且一般会选用结果中的第一个IP，所以大量客户端就会被均衡的分配到10台Web服务器上，也就是`负载均衡`咯。\n\n再来说说**DNS的缺点**，为人所知的`DNS放大攻击`就是缺陷之一，假如有这样的场景：我们由包发出去的请求只有少许字节，但收到的回复却高达几千字节，这种情况非常值得我们警惕。\n\n### 老生常谈的TCP\n\n![image-20210506235956824](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235956824.png)\n\n这个包抓的还是`恰如其分`的，它完美的涵盖了三次握手与四次挥手的7个包，同时出现的`乱序问题`也印证了TCP的强大之处。接下来我们分别从三次握手和四次挥手来分析它的细节——\n\n**三次握手**：\n\n- `SYN报文段`\n\n  在这个帧中，包含了Seq,Win，Len等字段，显然`Seq表示随机选择的报文段的初始字节偏移量`，而Win就比较有意思了，我们可能更熟悉它的另一个名称：rwnd，也就是说`Win就是接收窗口的大小`，只不过描述字段有区别，至于Len字段，见名知意，它描述了报文段的长度，但这并不包含报文头部的长度，所以`Len为0只能说明没有数据传输`。\n\n- `SYN/ACK报文段：`\n\n![image-20210507092224812](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507092224812.png)\n\n显然，TCP报文段（一个MSS长度）的`头部包含32个字节`，而我们常说的`XX报文段其实就是通过置位来标识`的。\n\n- `ACK报文段`\n\n  ![image-20210507093012217](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093012217.png)\n\n  我们试图再发现一些新颖的事物，在这个窗口我们看到`一个包被接口过滤器（网口）收到的完整过程`，它依次经历了物理层，数据链路层，网际层，传输层。\n\n**四次握手**\n\n- `SYN/ACK报文段：`\n\n  ![image-20210507093632419](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093632419.png)\n\n  显然，在发送该报文段后`不再发送数据，但仍然可以接收数据`。\n\n- `ACK报文段`\n\n  ![image-20210507093904412](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093904412.png)\n\n  显然，ACK包乱序了，但它仍可以被接收，这依赖于`TCP的累计确认`，也就是说TCP只关心发送的最古老的的那个包有没有被收到，如果`有乱序的包到达，它会将其放置在接收窗口而不给与确认`，在收到最古老的的那个包后，它会接收该包并累计确认，应用层再从接收窗口中读取这些包。\n\n最后再来看一个非常有用的命令：**netstat**\n\n![image-20210507095047707](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507095047707.png)\n\n这是我使用netstat命令陈列出来的TCP连接状态，我们发现有这样几种状态：\n\n1. TIME_WAIT:\n\n   TIME_WAIT又称`2MSL状态`(报文段最大存活时间)，被动关闭方在收到FIN并回复ACK后会进入该状态，它的作用主要有两个：\n\n   1. 允许老的重复报文分组在网络中消逝，`避免新连接接收老连接的数据`。\n\n   2. 保证TCP全双工连接的正确关闭，`避免RST拒绝服务`。\n\n2. ESTABLISHED:\n\n   表示`数据传输正在进行`\n\n3. CLOSE_WAIT\n\n   正常状态，会`很快转化为LAST_WAIT`,只出现在被动关闭方。\n\n### 历久弥新的HTTP\n\n![image-20210506232400891](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232400891.png)\n\n------\n\n> 山高路远，静水深流","source":"_posts/计算机网络传输层.md","raw":"---\ntitle: 计算机网络传输层\ntop: true\ncover: true\ntoc: true\nmathjax: true\ndate: 2021-07-12 11:52:37\npassword:\nsummary:\ncategories:\ntags: \n\t- 计算机网络\n\t- 抓包\n\t- 通用模式\n---\n\n## 1.1 概述和传输层服务\n\n传输层位于应用层与网络层之间，起着承上启下的重要作用。概括的说，**传输层协议为运行在不同主机上的进程提供逻辑通信的功能**。而从TCP/IP协议族的组成来看，它向上使**进程间的通信成为可能**，向下**加强了网络层提供的尽力而为式**的服务。那具体传输层如何使用服务，并在此基础上加强，最后提供服务的呢？我们还需要继续勾勒这个蓝图：\n\n在此之前，首先来看书中给出的例子——\n\n有两个关系不错的家庭A和B，家庭A的5位家庭成员都会向家庭B的5位家庭成员写信。写好信后交由邮递公司将其送到家庭B的信箱中，家庭B的长子再将信从信箱中取出交给弟弟妹妹们。我们来对这个例子做一个类比：\n\n两个家庭可以看做两个主机，弟弟妹妹们可以看做是应用进程，长子可以看做是传输层协议，邮递服务可以认为是网络层提供的服务，应用层的报文即是信的内容。\n\n从这个案例中，我们可以提取出一些**有趣的信息**——\n\n- 邮件服务有可能出现纰漏，比如会传错，丢失等，即`网络层传输的是不可靠的服务，它不对分组做有效力的保证`。\n- 邮箱里的信件是乱序的，但通过长子来传递到弟弟妹妹的信件却是有序的，即`传输层协议会对可靠性做保证，而其应用的机制则是RDT原理`。\n- 长子不需要跑去邮局取信件，而只需要定期检查邮箱就行啦。即传输层协议被定义在端系统，还是那句话，`网络核心的功能其实是在网络边沿实现的`。\n- 如果邮局没有在规定时间内传递邮件，那在此期间在家里就不可能取到信件。即`传输层的服务明显受限于网络层提供的服务`。\n- 如果邮箱中有很多信件，长子可以选择性的先取出一些邮件。即`传输层提供流量管理和拥塞控制的服务`。\n- 长子在取邮件时，首先需要需要拆开信封，再取出信件。即`目标端可以实现解复用`。\n\n除了上面将传输层当做**整体**看待来分析它的特点与实现以外，我们还需要将传输层拆解，广为人知的是，传输层提供TCP和UDP两个协议，\n\n`TCP`：TCP提供的服务是可靠的，保序的，有拥塞控制，流量管理机制的，面向连接的，涉及复用与解复用，数据以**字节流**的形式传输。\n\n`UDP`:   UDP提供的服务是不可靠的，不保序的，不面向连接的，数据以**数据报**的形式传输。\n\n蓝图已经画就，我们来用笔墨筑起传输层的万丈高楼——\n\n## 1.2 多路复用与解复用\n\n我们在PC上可以同时运行QQ,网易云.它们是从属于不同的进程，所以当传输层向上层传输信息时，需要标识给哪一个进程，也就是需要使用**Socket来标识一个进程**，那向上传输的内容，除了Socket，显然还需要有报文。**报文中包含传输层的首部字段和MSG**。这里的描述其实就是解复用的过程，显然，我们在之前已经接触过。下面我们更具体地描述传输层的复用与解复用。\n\n- `复用：`在源主机从不同的套接字中收集数据块，并**为每个数据块封装首部信息**，生成报文段，最终将报文段交付于网络层。\n- `解复用：`将传输层报文段中的数据交付给应用进程的过程\n\n也就是说，传输层的多路复用与解复用实现的就是`将主机到主机的交付服务延伸到应用程序到应用程序之间`，它关注的问题无非是**将报文传给谁，报文中都包括什么**。\n\n\n![image-20210707210324385](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210324385.png)\n\n可以看出，复用与解复用的核心是通过套接字来完成的。而通过上一章节的知识，我们知道TCP和UDP的套接字所引用的信息是不一样的。我们分情况来看——\n\n### 无连接的多路复用与解复用\n\n我们通过图解来解析UDP多路复用的过程——\n\n![image-20210707210337051](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210337051.png)\n\n`饮`：主机A中的传输层创建一个传输层报文，**报文包含应用程序数据，源端口号19157，目的端口号46428和其他两个值**。接着，传输层将该报文段传输给**网络层**，网络层再将报文段封装到一个**IP数据报**中，并通过网络链路交付给接收主机。\n\n`啄`：接收主机传输层检查该报文段中的**目的端口号46428**，并将该报文段交付给端口号46428所**标识的套接字**。\n\n这里有一点可能会引起**困惑**的地方：socket是如何参与这个过程的。首先明确的是，**socket是不被包含在报文段中的**。UDP的Socket包含目的IP，目的端口号，它仅用于处理源端口或者目标端口的**识别**，即**层间接口**。但报文是实际参与通信过程的。这里的socket就像是一个**开门的钥匙**。\n\n### 面向连接的多路复用与解复用\n\n同样的，开局一张图——\n\n![image-20210707224235450](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224235450.png)\n\n区别于UDP，TCP的socket所引用的信息是一个四元组，即——\n\n![image-20210707224252958](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224252958.png)\n\n额，PID就不用管了，当一个报文段被交付给应用进程时，它需要使用四元组的socket来判别报文段应该被交付给具体哪一个应用进程。\n\n如果我们要求在传输层上只实现**必要的最简单协议**，那UDP完成符合这样的要求。UDP的全称是**用户数据报协议**。它仅在网络层的基础上提供**必要的复用，解复用，以及简单的校验和**。这使得它的功能基本上和网络层一致。\n\n我们知道，网络层提供的服务是不可靠的，所以使用UDP的传输层提供的服务同样不可靠。这意味着它不需要握手，即不面向连接。数据有可能发生乱序，重复。而假设发生了这种错误，客户端如何处理呢？它会直接**丢弃**。\n\n这种简洁的设计会有它的用武之地吗？当然，**简洁也是一种优雅**，它简单所以头部信息少，传输快，它不需要建立连接，也自然没必要维护连接的状态。甚至一些应用是在UDP的协议上构建的——\n\n![image-20210707224304322](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224304322.png)\n\n那这是否意味着基于UDP的应用是不可靠的呢？不完全是，**在应用程序做可靠传输的处理**是一种可选的方式。\n\n我们再来拨云见日地看看UDP的报文结构：\n\n![image-20210707224316644](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224316644.png)\n\n值得一提的是UDP仍然提供了必要的简单检错机制，即**校验和**，来看校验和的原理——\n\n![image-20210707224330412](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224330412.png)\n\n即我们在源端得到测试的和，如果有进位，则再回卷得到和。数据报传输到目标端以后，目标端将**校验和的反码与源端得到的校验和相加**，如果相加为全1，则校验通过，反之不通过。\n\n## 1.4 重点：可靠数据传输原理\n\n### 问题描述\n\n可靠数据传输是一个**一般性的问题**，它不仅在传输层使用这个机制，在网络层和应用层也可以实现。而下一个小节中我们将以最通用的传输层为例介绍可靠数据传输协议RDT。\n\n在编程时，我们通常使用这样的思维：即`首先将具体问题转化为抽象的数学问题，再使用编程语言将数学问题实现`，在学习rdt时，这种思路同样适用。\n\n首先来看可靠数据传输面临的场景：对于应用层来说，传输层通过可靠数据传输的机制，并使用**可靠的信道**来向应用层提供服务——\n\n![image-20210707224342304](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224342304.png)\n\n\n\n`那这个可靠的服务是如何实现的呢`？显然是通过调用下层服务。从而对本层服务做加强来实现的，我们将这一过程**抽象成原语实现**，我们将这些原语具体描述，他们发挥着这样的功能——\n\n- `rdt_send:`被上层调用，将数据交付给下层的发送方实体。\n- `udt_send:`被rdt调用，将分组通过不可靠的信道发送给接收方。\n- `rdt_rcv:`分组到达接收方时被调用。\n- `deliver_data:`被rdt调用，将数据交付给上层。\n\n我们需要通过rdt来实现**发送方和接收方动作的抽象**，但这种抽象是基于不可靠的信道，它可能会发生**乱序，重复，篡改**等问题，直接给出解决方案着实有点难为人。所以这里引入了一种处理复杂问题的思路，即**渐进式解决**。\n\n`具体的说，我们一层层地去掉那些美好的假设，然后在一个可行方案的基础上逐渐完善`。我们的任务仅仅是实现一个能够完成必要功能的rdt协议，所以双向传输可以简化为单向传输，此外，给出有助于解决问题的通用模型也势在必行。也就是有限状态机FSM，在学习数字系统设计时，接触过使用**FSM描述的空调状态机**。不想除了考试，居然还能有缘再见。在课堂终于学到有用的知识了。。。\n\nFSM是这样设计的：\n\n![image-20210707224353943](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224353943.png)\n\n至此，前置知识就完结了，故事的大幕就此拉开——\n\n### rdt1.0\n\n这里`假设信道完全可靠`，它没有比特出错，甚至不会分组丢失，此时的rdt协议,恕我说句：工具人~。\n\n用状态机来描述一下此时的发送方与接收方——\n\n![image-20210707224406899](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224406899.png)\n\n这个显然还没有复杂度需要详细描述的地步，next~\n\n### rdt2.0\n\n在2.0版本，我们就要抛弃掉一些幻想，这时候的信道不那么可靠，它可能会发生`比特的错误`。之前在聊UDP时谈及UDP报文结构中使用校验和来做差错检测，当然TCP也有这个机制。检测出来后，怎么更正呢？自然是重发，那`如何标识出错的状态`呢？\n\n这就需要引入`标记量`。假如接受方检测到比特出错，就发送显示的发送错误标志，也就是`NAK`，俗称：反向谢谢；而当检测后发送无误，就发送显示的发送正确标志，这回是正向的谢谢：`ACK`。\n\n同样的，向量机描述——\n\n![image-20210707224420197](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224420197.png)\n\n这时，状态机已经没那么友好了，我们简要描述一下——\n\n- `发送方：`当rdt接收到应用层的数据后，将`数据与校验和组成传输报文`通过不可靠的信道发送给接收方，然后发送方等待接收方的回应。当等待到的是ACK时，继续等待上层调用。\n- `接收方：`接收方接收来自不可靠信道的数据，然后`做校验`，当校验出错时发送NAK,校验正确时发送ACK。\n\n### rdt2.1\n\n咦，怎么又出现了2.1，自然是因为2.0实在不堪大用。2.0版本的确相比1.0版本迈出了一大步，但它本身存在致命的缺陷，也就是**ACK,NAK本身也有可能发送错误**。rdt的机制应该也必须是健壮的，所以当接收到不可识别的信息时**有必要重发数据包**。所以对数据包的标识就这么顺水推舟的发生了.即**对分组加序号**。但这里只使用1位，即2种可能结果标识正在处理的分组。这是因为目前仍处于**STOP AND WAIT阶段**，一次发送一个数据包，用0和1来标识要处理的数据包就行啦。但如何处理重复呢？**丢弃**发送时间较早那个的数据包。\n\n#### 接收方处理出错的ACK/NAK\n\n老规矩——\n\n![image-20210707224431777](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224431777.png)\n\n这时接收方在2.0版本的基础上增加了对分组序号的识别，再来看发送方的处理——\n\n![image-20210707224444037](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224444037.png)\n\n看似很复杂，但实则只是穷举了对于不同分组的类似处理，毕竟只需要考虑两个分组，可以任性地穷举。来看下具体的场景——\n\n![image-20210223150554157](http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210223150554157.png)\n\n### rdt2.2\n\n2.2版本本质上和2.1版本并无二致，但出于简洁的考虑，只使用ACK，而不用NAK。那具体怎么操作的呢？\n\n假设有这样一个场景——\n\n> 发送方发送**数据包1**，接收方检测出错了，所以发送**ACK0**给发送方。发送方默念一句你丫的，然后重新发送数据包1.双方继续和谐地传递着数据包。\n\n![image-20210707224454789](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224454789.png)\n\n一看就会的图解——\n\n![image-20210707224504993](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224504993.png)\n\n这里不再给出状态机描述，它的确适合转换为编程语言。但与人交互还是上图更友好些。\n\n### rdt3.0\n\n解决了乱序，比特出错。仍旧还有**分组丢失**的问题，如果按照rdt2.2机制，分组丢失后发送方接收方都鸦雀无声，陷入了**死锁，浪费CPU资源**。所以需要加入**超时重传机制**。\n\n即当分组发送出去后，计时器开始倒计时，如果计数到0还没有收到响应，那就重传。机制的核心在于**计时的确定**，**网络状态是很难预测**的，它的拥堵状况可以类似于高斯分布，我们需要使用数学中概率论的知识尽可能确定时间。当然，一个相对准确的计时器还需要**相当长的路要走**。\n\n诚然，凡事讲究善始如终，此处应有状态机——\n\n![image-20210707224518042](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224518042.png)\n\n1. 首先发送方等待应用层调用，传输层组织好报文结构后，通过不可靠的信道将分组0传输给接收方，并启动超时定时器；\n2. 状态切换到等待ACK0的响应，如果超时或出错(ACK1)，则重传，如果接收到ACK0，状态切换至等待应用层调用1；\n3. 偷懒一手，同上。\n\n------\n\n至此，rdt3.0已经是用于传输单个分组的无懈可击的协议，但在信道带宽大的情况下，rdt3.0的性能非常感人。这就好比八车道的高速公路全程只准跑一辆自行车。这显然很难以忍受，所以如何一次性发送多个分组而无须等待确认是必须要解决的问题。\n\n![image-20210707224528848](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224528848.png)\n\n我们将这种发送多个分组可以看做是填充到一条流水线中。因此解决这个问题的机制被称为**流水线协议**。流水线协议在rdt3.0基础上增加了**传输分组的粒度**。但它同时带来的问题可一点也不少——\n\n- 分组的序号显然只用0和1是不够的，必须**扩大分组序号的范围**，来唯一地标识一个分组；\n- 分组传输与接收的速率不一致，需要在接收方增加**缓存机制**，此外，发送方在发送分组以后可能处于两种状态：`等待确认,确认完成`。所以发送方的分组需要分区，即发送方也需要缓存机制；\n- 当分组出现损坏，丢失，延迟时如何处理呢？根据场景有两种可选的方式：`GBN(回退N步)和SR(选择重传)`.\n\n------\n\n这两种处理差错的方式又都是基于**通用的滑动窗口**来实现的，滑动窗口是在**缓冲区的基础上**运作的，我们先来了解发送缓冲区及接收缓冲区——\n\n- `发送缓冲区：`缓冲区即是内存中的一块区域，它有大小属性，这里的发送缓冲区大小可以为1，即RDT3.0,当大小>1时，即为流水线协议。这里的发送缓冲区用于**存放已发送未确认的分组**，以便用于检错重发或超时重传。\n- `接收缓冲区：`是为了解决分组在信道中传输的速率与接收方接收的**速率不一致**的问题所引入的。它的大小为1时即为RDT3.0,当发送缓冲区大小>1时，接收缓冲区可以为1，此时为GBN协议，如果接收缓冲区>1,则为SR协议。\n\n那如何表示缓冲区动态传输的过程呢？这就需要引入滑动窗口——\n\n### 发送窗口\n\n滑动窗口用来表示`发送缓冲区的范围`，即实际的`已发送未确认的分组个数`，我们通过图解来认识这个动态的过程——\n\n![image-20210707224540604](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224540604.png)\n\n此时，没有分组发送，缓冲区大小N=5，滑动窗口前沿=后沿，窗口大小=前沿-后沿=0。\n\n![image-20210707224551296](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224551296.png)\n\n接着，一个分组被发送，前沿移动一位，滑动窗口大小=前沿-后沿=1.此时分组0处于已发送未确认状态。\n\n![image-20210707224601189](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224601189.png)\n\n此时，5个分组都被发送，缓冲区已满，滑动窗口大小=前沿-后沿=5=缓冲区大小。\n\n------\n\n这个过程我们是假设没有分组收到确认，现在我们打开潘多拉魔盒，认为已经有分组已经收到确认，情况就有所不同了——\n!![image-20210707224616355](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224616355.png)\n\n这时，`分组0得到确认，窗口后沿移动`，此时前沿仍然指向最后一个进入缓冲区的已发送未确认分组。\n\n![image-20210707224627690](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224627690.png)\n\n然后，分组1也得到确认，窗口后沿移动。有两个分组5,6被发送，进入缓冲区等待确认。窗口前沿移动到6的位置。\n\n------\n\n### 接收窗口\n\n发送窗口告一段落，来类比地看接收窗口，接收窗口可以控制哪些分组可以接收：\n\n- `收到的分组序号落在接收窗口内可以接受`；\n- 落在接收窗口外，则丢弃。\n\n此外，接收窗口根据出错的概率分为两种情况，对应两种协议——\n\n#### GBN\n\n接收窗口的尺寸等于1，即`只能顺序接收`：\n\n![image-20210707224639851](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224639851.png)\n\n接收窗口首先在分组0的位置，此时只有分组0的会被接收，如果接收到的是分组1，则丢弃。假设接收方接收到分组n,则表示小于等于分组n的所有分组都已经被接收，即**累计式确认**。\n\n#### SR\n\n接收窗口的尺寸大于1，可以乱序接收：\n\n![image-20210707224650324](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224650324.png)\n\n起初，接收窗口中有分组0,1,2,3.收到分组0,1后，接收窗口向前滑动。但如果分组没有按序到来，会发生什么呢？\n\n![image-20210707224701886](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224701886.png)\n\n可以看到，当高序号的分组到来后`，仍旧将其缓存，但并不移动滑动窗口`，只有当低序号的分组到来后，窗口才会整体后移——\n\n![image-20210707224711512](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224711512.png)\n\n最后，可以总结出SR协议为非累积式接收。\n\n------\n\n#### 正常情况下的窗口互动\n\n![image-20210707224721902](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224721902.png)\n\n#### 异常情况下的窗口互动\n\n![image-20210707224736296](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224736296.png)\n\n\n\n![image-20210707224827566](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224827566.png)\n\n\n\n#### 用FSM描述的GBN\n\n1. 发送方\n\n   首先声明这些变量代表的含义：`N为窗口长度，base为窗口后沿，nextseqnum为满足发送条件但因缓冲区已满没有发送的分组序号`，\n\n![image-20210707224840765](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224840765.png)\n\n2. 接收方\n\n   ![image-20210707224850680](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224850680.png)\n\n#### 运行中的SR\n\n![image-20210707224903011](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224903011.png)\n\n### 总结\n\nGBN适用于`出错率低`的场景，`而链路容量大，回退代价高`的场景则是SR更优。\n\n![image-20210707224915038](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224915038.png)\n\n## 1.5 面向连接的传输——TCP\n\n在对TCP有大致的纹路了解后，我们进入TCP正式的探索。本着结构决定功能的特点，从TCP的段结构起笔，渲染TCP的可靠数据传输，进而浓墨于流量控制机制，最终落笔于连接管理。\n\n`TCP提供的是点到点，可靠的，管道化的，按序的字节流，拥有流量控制机制，面向连接的服务。`\n\n### 段结构\n\nTCP的报文段由一个**首部字段和数据字段**构成，数据字段即是应用层的数据，那这部分数据是源数据根据怎样的规则划分的呢？这里引入**最大报文段长度MSS**的概念。TCP会将要传输的文件分为若干个MSS。**MSS的长度**通常由**本地发送主机发送的最大链路层帧长度**来设置。在确定数据部分后，TCP为每个客户端数据配上一个**TCP首部**，从而形成多个TCP报文段。\n\n![image-20210707224931500](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224931500.png)\n\n具体来看每个字段：\n\n- `源端口号：`TCP提供的是进程之间的逻辑通信，而标识进程的即是端口号，标识源端口号就相当于给出了数据**复用**的路径。\n\n- `目的端口号：`同样的，只有给出目的端口号，在接收方才能完成**解复用**的工作。\n\n- `序号：`TCP把数据看做一个**无结构，有序的字节流**。而为了来标识每个报文段(`MSS`)的首字节在整个字节流中的位置，或者说偏移量，就引入了序号的概念。该序号的范围为**2的32次方**，可见冲突的几率比我中彩票还低~\n\n  ![image-20210707225012629](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225012629.png)\n\n- `确认号：`在可靠数据传输中，我们使用ACK来作为确认字段，但ACK只能表示接收方对接收到数据的回应，而实际的传输是全双工，且高并发的。所以接收方的确认号将**确认与下一次传输的数据相结合**作为确认号。也就是说，假设确认号为2000,即表示**期望收到的下一个字节的序号**，这里给出的序号同样也具有**GBN累计确认**的意义。\n\n  我们试着使用序号与确认号来描述简化的传输过程——\n\n  ![image-20210707225024780](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225024780.png)\n\n  即主机A发送序号42及对于序号79的确认，主机B收到后，发送对于序号42的确认，即ACK=43，且发送主机A期望的79，即seq=79.\n\n- `接收窗口：`该字段用于**流量控制**，即指示接收方愿意接受的字节数量，在抓包的时候任一数据发送源都会使用**Win字段**来告诉另一方自己接收窗口的大小。\n\n- `CRC校验和：`在UDP部分谈及过，用于**检错**。\n\n而从进程通信的`流程框架`来看，TCP报文段又会经历怎样的**复用与解复用**呢——\n\n在形成报文段以后，这些报文段被下传给网络层，网络层将其分别封装在**网络层IP数据报**中，接着被发送到网络中，TCP在另一端接收报文段，该报文段被放在该**TCP连接的接收缓存**中，应用程序从缓存中读取数据流。\n\n### 可靠数据传输\n\n了解了确认号与序号，可靠数据传输的纹路已经逐渐明晰。在学习通用的rdt时，我们谈及当一个分组丢失时，超时重传机制是有必要的，这在TCP的机制中同样适用。但在TCP的机制中，我们需要将超时重传的机制具象化，即真正高效地使用。\n\n如何来估计超时重传的往返时间？**定时器RTO**应该设置多长时间？是否需要为每一个分组都设置一个定时器呢？我们来渐进式地解答——\n\n1. 显然，定时器设置的时间应该是**大于往返时间RTT**的，所以我们可以随机地选取某一个RTT作为**SampleRTT**,但由于路由器的拥塞和网络负载均衡的特点，SampleRTT波动是很大的，所以为了更趋近于真实RTT，我们引入SampleRTT的均值EstimatedRTT。通过这两个标量，可以近似得到这样的公式：\n   $$\n   EstimatedRTT=（1-a）•EstimatedRTT+a•SampleRTT\n   $$\n   这里的a推荐值为**0.125**，将通过公式得到的均值称为之**指数加权移动平均**。\n\n2. 这里直接给出公式——\n   $$\n   Timeoutinterval=EstinMrtedRTT+4•DevRTT\n   $$\n   这里的DevRTT是为了解决波动问题，而引入的一个SampleRTT与EstimatedRTT之间差值。\n\n3. TCP并不会为每个分组都维护一个定时器，因为高并发的发送维护定时器的代价是很大的，因此TCP使用了**单一重传定时器机制**。即只为**发送缓冲区中最古老的已发送未确认分组**维护定时器。\n\n至此，TCP可靠数据传输的自肖像已经变得丰满起来。我们不妨在已经构建框架的前提下给出一个最简化的TCP发送方——\n![image-20210707225039262](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225039262.png))\n\n即当超时定时器触发以后，发送方会传输**至今没有得到确认的最小序号分组**。即这里的机制又是类似于**选择性重发SR**。在重发后，超时定时器又会与当前没有得到确认的最小序号分组相关联。此外，还有一种情况，即缓冲区为空，即所有的分组都已得到确认，此时需要重启定时器。\n\n通过下图来看简要的交互：\n\n![image-20210707225051029](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225051029.png)\n\n另外，我们来穷举关于ACK的几种情况及相应的处理方式——\n\n| **接收方事件**                                         | **TCP接收方动作**                            |\n| ------------------------------------------------------ | -------------------------------------------- |\n| 所期望序号的报文段按序到达，期望序号之前的都已得到确认 | 延迟的ACK，即对另一个按序报文段最多等待500ms |\n| 有期望序号的报文段到达，另一个按需报文段等待发送ACK    | 立即发送单个累积ACK，以确认两个按序报文段    |\n| 比期望序号大的报文段乱序到达，检测到数据流的间隔       | 立即发送重复ACK，指明下一个期待字节的序号    |\n| 能部分或者完全填充接收数据间隔的报文段到达             | 若该报文段起始于间隔的低端，则立即发送ACK    |\n\n这个简化的TCP交互是默认不存在重复确认的，但实际上重复确认的情况是有可能出现的，TCP针对这种情况也给出了**快速重传机制**。\n\n收到**重复确认**往往是因为**定时器设置的太大**，接收方没有收到某个分组，但在定时器时间内仍会收到乱序到达的其他分组，这时接收方就会发送冗余分组，当发送方接收到**三个冗余确认**后，就会在定时期间**重传最小序号的报文段**。\n\n![image-20210707225101991](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225101991.png)\n\n再来看下快速重传的伪代码——\n\n![image-20210707225112511](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225112511.png)\n\n即接收方收到ACK，判断ACK与窗口后沿的关系，假如**ACK大于窗口后沿，则将窗口后沿滑动**，将**定时器与新的报文段关联**。否则，也就是ACK重复的情况，则记录ACK重复的个数，当其等于3时，触发快速重传机制。\n\n### 流量管理\n\n传输层在将数据解复用以后，不是直接交付给应用程序使用，而是将其放置在**接收缓冲区**内，上层应用再**从缓冲区中读取数据**。但当从发送方发送来的数据太多就有可能**淹没接收缓冲区**，导致报文段丢失，因此，约定发送方的发送速率与接收方的接收速率是必须的，这种**为了匹配速率的机制就称为流量控制**。\n\n流量控制机制是通过互相告知缓冲区可用空间来实现的。那如何告知呢？即是通过接收方向发送方发送的报文段中的**rwnd字段**，它表示了**接收缓冲区中可用的空间**。\n\n![image-20210707225128655](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225128655.png)\n\n我们将rwnd再具象化，即它是通过什么来实现的呢？接收窗口！！！但这里的接收窗口和rdt中的接收窗口还是有所区别的。为了量化接收窗口的大小，我们还需要引入两个变量：\n\n- `LastByteRead`:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。\n- `LastByteRcvd`:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。\n\n那么接收窗口就可以表示为：\n$$\nrwnd=RcvBuffer-[LastByteRcvd-LastByteRead]\n$$\n\n### 连接管理\n\n我们来深入了解如何建立和拆除一个TCP连接，首先，我们需要建立一些共识，也就是连接都需要做什么？\n\n在socketAPI的编程中，我们需要维护两个套接字，即连接是针对双方而言的，**每一端可以看做维护一个半连接**，所以在建立TCP连接时，两端都有**告诉对方我要建立连接**的诉求。除此之外，还需要**为连接配置资源**，因为连接就意味着马上会有数据传输，所以**缓冲区自然是需要**的，此外，**序号和确认号也是必选项**咯。\n\n### 三次握手\n\n好啦，实际地去建立连接时，首先先入为主的想法是两次握手——\n\n![image-20210707225141658](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225141658.png)\n\n但两次握手面临着很多问题：\n\n- 假如接收方的确认超时了，此时发送方会重发连接建立请求。但我们注意到**接收方的机制简言之就是收到连接请求则同意建立**。也就是说，虽然确认超时了，但接收方仍会维护一个**半连接的状态**及对应的资源。\n- 在上面状况的基础上，假如发送方接收到确认后，发送数据data，而接收data的接收方的状态为新的连接，那么此时**新的连接接收的是老连接的数据**。\n\n这些问题的症结本质上是**半连接的孤立**，那么如果**在双方半连接的基础上增加两个半连接的交互**，那问题就迎刃而解了。三次握手就是基于这样的思想实现的。我们来详细剖析三次握手的详细过程——\n\n1. `第一次握手：`客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中**不包含应用层数据**。但是在报文段的首部中的一个标志位（即**SYN**比特）**被置为1**。因此，这个特殊报文段被称为**SYN报文段**。另外，客户会**随机地选择一个初始序号**（client_isn）,并将此编号放置于该起始的TCPSYN报文段的序号字段中。\n\n2. `第二次握手：`服务器会从该数据报中提取出SYN报文段，为该TCP连接**分配TCP缓存和变量**，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段**也不包含应用层数据**。但是，在报文段的首部却包含**3个重要的信息**。\n\n   1. SYN比特被置为1。\n   2. TCP报文段首部的确认号字段被置为**client_isn+I**\n   3. 服务器选择自己的初始序号（**serverjsn**）,并将其放置到TCP报文段首部的序号字段中。这个允许连接的报文段实际上表明了：**“我收到了你发起建立连接的SYN分组，该分组带有初始序号clientjsno我同意建立该连接。我自己的初始序号是serverjsnon**\n\n   该允许连接的报文段被称为**SYNACK报文段**.\n\n3. `第三次握手:`在收到ACK报文段后，客户也要给该连接**分配缓存和变**量。客户主机则向服务器发送另外一个报文段；这最后一个报文段**对服务器的允许连接的报文段进行了确认**（该客户通过**将值serverjsn+1放置到TCP报文段首部的确认字段**中来完成此项工作）。因为连接已经建立了，所以该**SYN比特被置为0**。该三次握手的第三个阶段可以在报文段**负载中携带客户到服务器的数据**。\n\n![image-20210707225201937](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225201937.png)\n\n嗯，熟悉的FSM环节——\n\n![image-20210707225214552](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225214552.png)\n\n\n\n\n\n------\n\n\n\n### 四次挥手\n\n天下没有不散的宴席。TCP连接也不能免俗。相比于三次握手，四次挥手还是水到渠成的，双端都可以主动发起断开连接的请求，然后**双方断开自己维护的半连接**即可，同样的，我们来复现这个过程——\n\n1. 客户端进程向服务器进程发送一个特殊的报文段，该报文段中首部标志位**FIN置1**；\n2. 服务器接收该报文段后，**其ACK比特置1**.\n3. 反向同理。\n\n![image-20210707225225357](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225225357.png)\n\n## 1.6 拥塞控制原理\n\n------\n\n### 前言\n\n在rdt可靠数据传输机制中，分组丢失是不可避免的，而**分组丢失的原因通常是由网络拥塞**，当路由器的缓存被占满后，后来者将会别抛弃，本质上说这种状况是因为网络是不可控的，很难从端系统获知网络的状况，但发送方又本着`多多益善`的方式在加剧网络的恶化。\n\n为了避免网络拥塞，TCP使用了怎样的机制，这种处理机制出发点是什么，它针对性地解决了哪些问题，如此种种。要解决这些问题，我们仍要铺好第一块砖石——\n\n`网络拥塞的定义`：太多的数据需要网络传输，超过了网络的处理能力。\n\n### 拥塞原因与表现\n\n这里我们仍使用渐进式分析问题的思想，一个不会发生分组丢失的网络是怎样的呢？\n\n- `路由器缓存无限大`\n- `端系统可以了解网络的状况并作出调整。`\n\n- `所有分组都可以不超时的到达，所以不需要重传`\n\n先来看路由器缓存，假设路由器缓存无限大，那分组就不会被丢弃。这时假设有两个发送端通过一条链路(带宽为R)发送数据，那么它的吞吐量和延时表现为这样——\n\n![image-20210707225238081](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225238081.png)\n\n可见，即便在理想状态下，当超出链路的承载能力后，`流量强度变大，排队延时激增`。硬件条件这是不可逾越的天花板。所以我们很难控制不发生拥塞，而要从拥塞发生后的处理技巧入手。\n\n接着，我们去掉缓存无限的假设，这时分组丢失就变得无可避免，分组丢失就意味着重传，而`重传导致链路中重复的分组`，也就是不必要的分组增多，直接使得`发送方比接收方更高的发送速率`，导致本就不宽裕的链路带宽更显的捉襟见肘。另外，超时重传作用的结果也是一样的。\n\n最后，我们设想在类似`进程发生死锁`的一种情景，每个发送方占用着别的发送方需要的链路带宽，而别的进程也占用着自己需要的链路带宽，如果人的欲望一般，我们知道这条路是错的，但贪念仍在驱使着躯干向前。\n\n### 拥塞控制的方式\n\n针对上面的状况，一般采用两种控制拥塞的方法——\n\n- `端对端的拥塞控制：`TCP就使用这种策略。端系统根据`延迟和丢失事件`推断是否有拥塞。\n- `网络辅助的拥塞控制：`路由器通过`置位`的方式显示的告诉发送端可以采用的速率。\n\n来通过实际的**ATM ABR场景**认识下这两种方式是怎样实际运转的：\n\n我们知道，在网络中传输的数据粒度是有区别的，专线更多使用线路交换的方式，而通用的则是分组交换的方式，这种在银行中大行其道的ATM ABR线路则使用数据粒度`介于线路交换和分组交换的粒度大小`，更具体地说，它传输的最小单元是`53个的比特`。\n\n**ABR(available bit rate)**提供的是弹性服务，它可以`根据网络的负载实时调整发送速率`。如果发送方路径轻载，则发送方就使用尽可能多地利用贷款。如果发送方路径阻塞，发送方限制速率至一个最小保障速率。\n\n那网络中的拥塞状况是如何被获知的呢？通过RM信元，即**资源管理信元**。\n\n它由发送端发送，在数据信元中间隔插入，通过该信元特定的比特位来作为网络辅助，这种行之有效的比特位分别是：\n\n- `NI bit:`即no increase in rate。\n- `CI bit:`即congestion indication拥塞指示。\n\n发送方发送的RM信元被接收方返回，`接收方仅用作中转`使用。另外，之前谈及信元可以返回给发送方最小发送速率，这是如何实现的呢？\n\n通过RM信元中的2个字节`ER(explicit rate)字段`.拥塞的交换机会降低ER的值，最终返回给发送方。\n\n------\n\n## 1.7 TCP拥塞\n\n在上一小节中，我们聊了通用的拥塞控制机制，也就是：**端系统处理**，**网络辅助的拥塞控制**。同时对网络辅助的案例做了简单描述，这一小节，我们将展开讲述在端系统如何处理拥塞。\n\n更具体地说，是**TCP的拥塞控制机制**。而在开始之前，我们先解决一个前置问题：TCP`为什么不在网络核心通过使用辅助信元的方式实现拥塞控制`。其实，纵观整个网络架构，复杂性都是在传输层及其以上提供的，也就是说，`网络层不会向上层应用提供显式的拥塞控制机制`。\n\n那TCP的拥塞控制机制是怎样实现的呢？不着急，本着先有问题，再有方案的思路，我们先来回答TCP拥塞机制面临的**三大问题**——\n\n- `如何感知到拥塞`\n\n  网络拥塞的最终结果是分组丢失，而导致分组丢失的原因却有一些区别——\n\n  1. 假如到达路由器的分组过多导致缓冲区已满，**分组就会被丢弃**。此外，有可能分组在传输时比特反转，接收方认不出来这是啥，那也会将其丢弃。这两种情况的直观表现都是超时，这种`拥塞情节严重`，发送方明显被动。\n  2. 当发送方连续收到4个ACK信号，也就是**3个冗余ACK**时，就会触发快速重传机制，这时还没有超时，发送方主动出手降低损失，姑且称其`轻微拥塞`。\n\n- `如何对速率做调整`\n\n  那明确了问题，如何针对两种拥塞做出发送速率的调整呢？在**RDT**中，我们引入`接收窗口rwnd`来限制接收分组，这里我们也采用类似的机制，引入`拥塞窗口cwnd`。类比接收窗口表示能够接收分组的上限，拥塞窗口表示的即是——\n\n  ![image-20210707225253295](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225253295.png)\n\n  是不是似曾相识，发送窗口表示的是**实际的**已发送未确认的分组数量。而拥塞窗口就如同在对发送窗口做**动态调整**，除此之外，别无二致。那确定了拥塞窗口的值，发送方的发送速率也可以得出来——\n\n  ![image-20210707225302111](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225302111.png)\n\n  \n\n- `通过怎样的算法对速率做调整：`\n\n有了衡量拥塞的标志，接下来就需要通过拥塞状况触发动态调整啦，这里的动态调整，就是广受赞誉的**TCP拥塞控制算法**。\n\n该算法分为三部分：慢启动，拥塞避免，快速恢复。我们详细来聊聊——\n\n- `慢启动：`\n\n  TCP会将cwnd的值`初始化为一个2/3/4MSS`(具体由MSS的大小决定)的值，但显然，这点速率是不够打的，所以当分组首次被确认后，会以`指数级的增长趋势`尽快加速，直至超时后打回原形，也就是1个MSS.这时，TCP还会维护一个**慢启动阈值**，也就是警戒值，它的值为**cwnd(max)/2**，接着，开始下一次拥塞控制，当cwnd的值指数增加至慢启动阈值后，不再鲁莽地指数级增长，而是维持`线性增长`。\n\n  ![image-20210707225311975](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225311975.png)\n\n  这种线性增长的机制就是拥塞避免——\n\n- `拥塞避免：`\n\n  那拥塞避免什么时候结束呢？和慢启动一样，拥塞避免阶段在触发超时后会重新开始SS慢启动阶段,这时，慢启动的阈值也势必会更新。\n\n  再来讨论下发送方收到**3个冗余ACK**的状况——\n\n  它的处理机制显然没必要像拥塞时那么剧烈，只需要在触发快速重传后，记录慢启动阈值，然后`直接从阈值开始线性增加`进入快速恢复阶段——\n\n- `快速恢复：`\n\n  所谓的快速恢复无非是针对两种拥塞状况的不同种处理，在上面已经提及，就不再赘述。\n\n  1. 超时重传：RFC建议将拥塞窗口降至1个MSS，而由慢启动过渡至拥塞窗口的值就有讲究了，应该调整至没别确认的数据量的1/2,但不能小于两个MSS\n  2. 快速恢复：不会处理拥塞窗口的值；\n\n接下来就是小总结环节——\n\n![image-20210707225324365](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225324365.png)\n\n再将两种情况汇总，就有了下图——\n\n![image-20210304182714108](C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210304182714108.png)\n\n\n\n### TCP吞吐量\n\n这里我们取快速恢复阶段的数据量均值作为参考(慢启动指数级的增加实则很快，也导致实际传输的流量不多)，即——\n$$\n一条连接的平均吞吐量=3/4*W/RTT\n$$\n另外也给出在`经过高带宽TCP，且丢包率为L的情况`下，吞吐量的描述——\n$$\n一条连接的平均吞吐量：1.22*MSS/RTT/根号下2\n$$\n\n### TCP公平性\n\n太饿了，去吃饭，偷懒一手——\n\n![image-20210707225338648](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225338648.png)\n\n也就是多个TCP连接时，网络状况会趋向于`带宽均分`。\n\n而如果一个链路中既有使用TCP的服务，也有使用UDP的服务，那对于TCP是不友好的，因为`UDP百无禁忌`，它没有拥塞控制机制，如果有可能，UDP会一点点的蚕食掉带宽，而最终导致更恶劣的后果，可见，**不限制贪欲最终会陷入恶性循环**。但这种机制也并非一无是处，流媒体就表示这是我的菜，因为`音视频应用起码泵出数据的速率是恒定`的，即便数据会丢失。\n\n------\n\n## 抓包番外\n\n### 简单的代价——UDP\n\n\n\n### DNS那些事\n\n![image-20210506232028231](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232028231.png)\n\nDNS常用的**应用场景**有两种：\n\n- `CNMAE:`即将一个域名映射到另一个域名，\n\n  ![image-20210506234636802](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234636802.png)\n\n- `A：`请求获取域名对应的IP地址\n\n  ![image-20210506234517700](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234517700.png)\n\n当DNS在缓存中没有找到要查询的记录后，就会发起**DNS查询**，查询有两种：递归查询，迭代查询。假如我们向一个`不权威的DNS服务器发起递归查询请求`，我们只会与这个不权威的DNS服务器交互，而`无从得知它的查询结果是否可靠`。迭代查询则会相对安全一些，因为客户端首先会查到根服务器的地址，再从根服务器查到权威服务器，然后从权威服务器查询。。。直到返回想要的结果。\n\n它的**响应**一般包含这些字段：\n\n![image-20210506235701873](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235701873.png)\n\n再来聊一些生僻的：**DNS循环工作模式**——\n\n假如某个网站有10台Web服务器，管理员可以在DNS创建10个同名记录指向这些服务器的IP，由于不同客户端查到的结果顺序不同，而且一般会选用结果中的第一个IP，所以大量客户端就会被均衡的分配到10台Web服务器上，也就是`负载均衡`咯。\n\n再来说说**DNS的缺点**，为人所知的`DNS放大攻击`就是缺陷之一，假如有这样的场景：我们由包发出去的请求只有少许字节，但收到的回复却高达几千字节，这种情况非常值得我们警惕。\n\n### 老生常谈的TCP\n\n![image-20210506235956824](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235956824.png)\n\n这个包抓的还是`恰如其分`的，它完美的涵盖了三次握手与四次挥手的7个包，同时出现的`乱序问题`也印证了TCP的强大之处。接下来我们分别从三次握手和四次挥手来分析它的细节——\n\n**三次握手**：\n\n- `SYN报文段`\n\n  在这个帧中，包含了Seq,Win，Len等字段，显然`Seq表示随机选择的报文段的初始字节偏移量`，而Win就比较有意思了，我们可能更熟悉它的另一个名称：rwnd，也就是说`Win就是接收窗口的大小`，只不过描述字段有区别，至于Len字段，见名知意，它描述了报文段的长度，但这并不包含报文头部的长度，所以`Len为0只能说明没有数据传输`。\n\n- `SYN/ACK报文段：`\n\n![image-20210507092224812](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507092224812.png)\n\n显然，TCP报文段（一个MSS长度）的`头部包含32个字节`，而我们常说的`XX报文段其实就是通过置位来标识`的。\n\n- `ACK报文段`\n\n  ![image-20210507093012217](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093012217.png)\n\n  我们试图再发现一些新颖的事物，在这个窗口我们看到`一个包被接口过滤器（网口）收到的完整过程`，它依次经历了物理层，数据链路层，网际层，传输层。\n\n**四次握手**\n\n- `SYN/ACK报文段：`\n\n  ![image-20210507093632419](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093632419.png)\n\n  显然，在发送该报文段后`不再发送数据，但仍然可以接收数据`。\n\n- `ACK报文段`\n\n  ![image-20210507093904412](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093904412.png)\n\n  显然，ACK包乱序了，但它仍可以被接收，这依赖于`TCP的累计确认`，也就是说TCP只关心发送的最古老的的那个包有没有被收到，如果`有乱序的包到达，它会将其放置在接收窗口而不给与确认`，在收到最古老的的那个包后，它会接收该包并累计确认，应用层再从接收窗口中读取这些包。\n\n最后再来看一个非常有用的命令：**netstat**\n\n![image-20210507095047707](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507095047707.png)\n\n这是我使用netstat命令陈列出来的TCP连接状态，我们发现有这样几种状态：\n\n1. TIME_WAIT:\n\n   TIME_WAIT又称`2MSL状态`(报文段最大存活时间)，被动关闭方在收到FIN并回复ACK后会进入该状态，它的作用主要有两个：\n\n   1. 允许老的重复报文分组在网络中消逝，`避免新连接接收老连接的数据`。\n\n   2. 保证TCP全双工连接的正确关闭，`避免RST拒绝服务`。\n\n2. ESTABLISHED:\n\n   表示`数据传输正在进行`\n\n3. CLOSE_WAIT\n\n   正常状态，会`很快转化为LAST_WAIT`,只出现在被动关闭方。\n\n### 历久弥新的HTTP\n\n![image-20210506232400891](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232400891.png)\n\n------\n\n> 山高路远，静水深流","slug":"计算机网络传输层","published":1,"updated":"2023-09-24T09:50:29.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7ms002kxjccgogm2avt","content":"<h2 id=\"1-1-概述和传输层服务\"><a href=\"#1-1-概述和传输层服务\" class=\"headerlink\" title=\"1.1 概述和传输层服务\"></a>1.1 概述和传输层服务</h2><p>传输层位于应用层与网络层之间，起着承上启下的重要作用。概括的说，<strong>传输层协议为运行在不同主机上的进程提供逻辑通信的功能</strong>。而从TCP/IP协议族的组成来看，它向上使<strong>进程间的通信成为可能</strong>，向下<strong>加强了网络层提供的尽力而为式</strong>的服务。那具体传输层如何使用服务，并在此基础上加强，最后提供服务的呢？我们还需要继续勾勒这个蓝图：</p>\n<p>在此之前，首先来看书中给出的例子——</p>\n<p>有两个关系不错的家庭A和B，家庭A的5位家庭成员都会向家庭B的5位家庭成员写信。写好信后交由邮递公司将其送到家庭B的信箱中，家庭B的长子再将信从信箱中取出交给弟弟妹妹们。我们来对这个例子做一个类比：</p>\n<p>两个家庭可以看做两个主机，弟弟妹妹们可以看做是应用进程，长子可以看做是传输层协议，邮递服务可以认为是网络层提供的服务，应用层的报文即是信的内容。</p>\n<p>从这个案例中，我们可以提取出一些<strong>有趣的信息</strong>——</p>\n<ul>\n<li>邮件服务有可能出现纰漏，比如会传错，丢失等，即<code>网络层传输的是不可靠的服务，它不对分组做有效力的保证</code>。</li>\n<li>邮箱里的信件是乱序的，但通过长子来传递到弟弟妹妹的信件却是有序的，即<code>传输层协议会对可靠性做保证，而其应用的机制则是RDT原理</code>。</li>\n<li>长子不需要跑去邮局取信件，而只需要定期检查邮箱就行啦。即传输层协议被定义在端系统，还是那句话，<code>网络核心的功能其实是在网络边沿实现的</code>。</li>\n<li>如果邮局没有在规定时间内传递邮件，那在此期间在家里就不可能取到信件。即<code>传输层的服务明显受限于网络层提供的服务</code>。</li>\n<li>如果邮箱中有很多信件，长子可以选择性的先取出一些邮件。即<code>传输层提供流量管理和拥塞控制的服务</code>。</li>\n<li>长子在取邮件时，首先需要需要拆开信封，再取出信件。即<code>目标端可以实现解复用</code>。</li>\n</ul>\n<p>除了上面将传输层当做<strong>整体</strong>看待来分析它的特点与实现以外，我们还需要将传输层拆解，广为人知的是，传输层提供TCP和UDP两个协议，</p>\n<p><code>TCP</code>：TCP提供的服务是可靠的，保序的，有拥塞控制，流量管理机制的，面向连接的，涉及复用与解复用，数据以<strong>字节流</strong>的形式传输。</p>\n<p><code>UDP</code>:   UDP提供的服务是不可靠的，不保序的，不面向连接的，数据以<strong>数据报</strong>的形式传输。</p>\n<p>蓝图已经画就，我们来用笔墨筑起传输层的万丈高楼——</p>\n<h2 id=\"1-2-多路复用与解复用\"><a href=\"#1-2-多路复用与解复用\" class=\"headerlink\" title=\"1.2 多路复用与解复用\"></a>1.2 多路复用与解复用</h2><p>我们在PC上可以同时运行QQ,网易云.它们是从属于不同的进程，所以当传输层向上层传输信息时，需要标识给哪一个进程，也就是需要使用<strong>Socket来标识一个进程</strong>，那向上传输的内容，除了Socket，显然还需要有报文。<strong>报文中包含传输层的首部字段和MSG</strong>。这里的描述其实就是解复用的过程，显然，我们在之前已经接触过。下面我们更具体地描述传输层的复用与解复用。</p>\n<ul>\n<li><code>复用：</code>在源主机从不同的套接字中收集数据块，并<strong>为每个数据块封装首部信息</strong>，生成报文段，最终将报文段交付于网络层。</li>\n<li><code>解复用：</code>将传输层报文段中的数据交付给应用进程的过程</li>\n</ul>\n<p>也就是说，传输层的多路复用与解复用实现的就是<code>将主机到主机的交付服务延伸到应用程序到应用程序之间</code>，它关注的问题无非是<strong>将报文传给谁，报文中都包括什么</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210324385.png\" alt=\"image-20210707210324385\"></p>\n<p>可以看出，复用与解复用的核心是通过套接字来完成的。而通过上一章节的知识，我们知道TCP和UDP的套接字所引用的信息是不一样的。我们分情况来看——</p>\n<h3 id=\"无连接的多路复用与解复用\"><a href=\"#无连接的多路复用与解复用\" class=\"headerlink\" title=\"无连接的多路复用与解复用\"></a>无连接的多路复用与解复用</h3><p>我们通过图解来解析UDP多路复用的过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210337051.png\" alt=\"image-20210707210337051\"></p>\n<p><code>饮</code>：主机A中的传输层创建一个传输层报文，<strong>报文包含应用程序数据，源端口号19157，目的端口号46428和其他两个值</strong>。接着，传输层将该报文段传输给<strong>网络层</strong>，网络层再将报文段封装到一个<strong>IP数据报</strong>中，并通过网络链路交付给接收主机。</p>\n<p><code>啄</code>：接收主机传输层检查该报文段中的<strong>目的端口号46428</strong>，并将该报文段交付给端口号46428所<strong>标识的套接字</strong>。</p>\n<p>这里有一点可能会引起<strong>困惑</strong>的地方：socket是如何参与这个过程的。首先明确的是，<strong>socket是不被包含在报文段中的</strong>。UDP的Socket包含目的IP，目的端口号，它仅用于处理源端口或者目标端口的<strong>识别</strong>，即<strong>层间接口</strong>。但报文是实际参与通信过程的。这里的socket就像是一个<strong>开门的钥匙</strong>。</p>\n<h3 id=\"面向连接的多路复用与解复用\"><a href=\"#面向连接的多路复用与解复用\" class=\"headerlink\" title=\"面向连接的多路复用与解复用\"></a>面向连接的多路复用与解复用</h3><p>同样的，开局一张图——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224235450.png\" alt=\"image-20210707224235450\"></p>\n<p>区别于UDP，TCP的socket所引用的信息是一个四元组，即——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224252958.png\" alt=\"image-20210707224252958\"></p>\n<p>额，PID就不用管了，当一个报文段被交付给应用进程时，它需要使用四元组的socket来判别报文段应该被交付给具体哪一个应用进程。</p>\n<p>如果我们要求在传输层上只实现<strong>必要的最简单协议</strong>，那UDP完成符合这样的要求。UDP的全称是<strong>用户数据报协议</strong>。它仅在网络层的基础上提供<strong>必要的复用，解复用，以及简单的校验和</strong>。这使得它的功能基本上和网络层一致。</p>\n<p>我们知道，网络层提供的服务是不可靠的，所以使用UDP的传输层提供的服务同样不可靠。这意味着它不需要握手，即不面向连接。数据有可能发生乱序，重复。而假设发生了这种错误，客户端如何处理呢？它会直接<strong>丢弃</strong>。</p>\n<p>这种简洁的设计会有它的用武之地吗？当然，<strong>简洁也是一种优雅</strong>，它简单所以头部信息少，传输快，它不需要建立连接，也自然没必要维护连接的状态。甚至一些应用是在UDP的协议上构建的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224304322.png\" alt=\"image-20210707224304322\"></p>\n<p>那这是否意味着基于UDP的应用是不可靠的呢？不完全是，<strong>在应用程序做可靠传输的处理</strong>是一种可选的方式。</p>\n<p>我们再来拨云见日地看看UDP的报文结构：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224316644.png\" alt=\"image-20210707224316644\"></p>\n<p>值得一提的是UDP仍然提供了必要的简单检错机制，即<strong>校验和</strong>，来看校验和的原理——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224330412.png\" alt=\"image-20210707224330412\"></p>\n<p>即我们在源端得到测试的和，如果有进位，则再回卷得到和。数据报传输到目标端以后，目标端将<strong>校验和的反码与源端得到的校验和相加</strong>，如果相加为全1，则校验通过，反之不通过。</p>\n<h2 id=\"1-4-重点：可靠数据传输原理\"><a href=\"#1-4-重点：可靠数据传输原理\" class=\"headerlink\" title=\"1.4 重点：可靠数据传输原理\"></a>1.4 重点：可靠数据传输原理</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>可靠数据传输是一个<strong>一般性的问题</strong>，它不仅在传输层使用这个机制，在网络层和应用层也可以实现。而下一个小节中我们将以最通用的传输层为例介绍可靠数据传输协议RDT。</p>\n<p>在编程时，我们通常使用这样的思维：即<code>首先将具体问题转化为抽象的数学问题，再使用编程语言将数学问题实现</code>，在学习rdt时，这种思路同样适用。</p>\n<p>首先来看可靠数据传输面临的场景：对于应用层来说，传输层通过可靠数据传输的机制，并使用<strong>可靠的信道</strong>来向应用层提供服务——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224342304.png\" alt=\"image-20210707224342304\"></p>\n<p><code>那这个可靠的服务是如何实现的呢</code>？显然是通过调用下层服务。从而对本层服务做加强来实现的，我们将这一过程<strong>抽象成原语实现</strong>，我们将这些原语具体描述，他们发挥着这样的功能——</p>\n<ul>\n<li><code>rdt_send:</code>被上层调用，将数据交付给下层的发送方实体。</li>\n<li><code>udt_send:</code>被rdt调用，将分组通过不可靠的信道发送给接收方。</li>\n<li><code>rdt_rcv:</code>分组到达接收方时被调用。</li>\n<li><code>deliver_data:</code>被rdt调用，将数据交付给上层。</li>\n</ul>\n<p>我们需要通过rdt来实现<strong>发送方和接收方动作的抽象</strong>，但这种抽象是基于不可靠的信道，它可能会发生<strong>乱序，重复，篡改</strong>等问题，直接给出解决方案着实有点难为人。所以这里引入了一种处理复杂问题的思路，即<strong>渐进式解决</strong>。</p>\n<p><code>具体的说，我们一层层地去掉那些美好的假设，然后在一个可行方案的基础上逐渐完善</code>。我们的任务仅仅是实现一个能够完成必要功能的rdt协议，所以双向传输可以简化为单向传输，此外，给出有助于解决问题的通用模型也势在必行。也就是有限状态机FSM，在学习数字系统设计时，接触过使用<strong>FSM描述的空调状态机</strong>。不想除了考试，居然还能有缘再见。在课堂终于学到有用的知识了。。。</p>\n<p>FSM是这样设计的：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224353943.png\" alt=\"image-20210707224353943\"></p>\n<p>至此，前置知识就完结了，故事的大幕就此拉开——</p>\n<h3 id=\"rdt1-0\"><a href=\"#rdt1-0\" class=\"headerlink\" title=\"rdt1.0\"></a>rdt1.0</h3><p>这里<code>假设信道完全可靠</code>，它没有比特出错，甚至不会分组丢失，此时的rdt协议,恕我说句：工具人~。</p>\n<p>用状态机来描述一下此时的发送方与接收方——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224406899.png\" alt=\"image-20210707224406899\"></p>\n<p>这个显然还没有复杂度需要详细描述的地步，next~</p>\n<h3 id=\"rdt2-0\"><a href=\"#rdt2-0\" class=\"headerlink\" title=\"rdt2.0\"></a>rdt2.0</h3><p>在2.0版本，我们就要抛弃掉一些幻想，这时候的信道不那么可靠，它可能会发生<code>比特的错误</code>。之前在聊UDP时谈及UDP报文结构中使用校验和来做差错检测，当然TCP也有这个机制。检测出来后，怎么更正呢？自然是重发，那<code>如何标识出错的状态</code>呢？</p>\n<p>这就需要引入<code>标记量</code>。假如接受方检测到比特出错，就发送显示的发送错误标志，也就是<code>NAK</code>，俗称：反向谢谢；而当检测后发送无误，就发送显示的发送正确标志，这回是正向的谢谢：<code>ACK</code>。</p>\n<p>同样的，向量机描述——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224420197.png\" alt=\"image-20210707224420197\"></p>\n<p>这时，状态机已经没那么友好了，我们简要描述一下——</p>\n<ul>\n<li><code>发送方：</code>当rdt接收到应用层的数据后，将<code>数据与校验和组成传输报文</code>通过不可靠的信道发送给接收方，然后发送方等待接收方的回应。当等待到的是ACK时，继续等待上层调用。</li>\n<li><code>接收方：</code>接收方接收来自不可靠信道的数据，然后<code>做校验</code>，当校验出错时发送NAK,校验正确时发送ACK。</li>\n</ul>\n<h3 id=\"rdt2-1\"><a href=\"#rdt2-1\" class=\"headerlink\" title=\"rdt2.1\"></a>rdt2.1</h3><p>咦，怎么又出现了2.1，自然是因为2.0实在不堪大用。2.0版本的确相比1.0版本迈出了一大步，但它本身存在致命的缺陷，也就是<strong>ACK,NAK本身也有可能发送错误</strong>。rdt的机制应该也必须是健壮的，所以当接收到不可识别的信息时<strong>有必要重发数据包</strong>。所以对数据包的标识就这么顺水推舟的发生了.即<strong>对分组加序号</strong>。但这里只使用1位，即2种可能结果标识正在处理的分组。这是因为目前仍处于<strong>STOP AND WAIT阶段</strong>，一次发送一个数据包，用0和1来标识要处理的数据包就行啦。但如何处理重复呢？<strong>丢弃</strong>发送时间较早那个的数据包。</p>\n<h4 id=\"接收方处理出错的ACK-NAK\"><a href=\"#接收方处理出错的ACK-NAK\" class=\"headerlink\" title=\"接收方处理出错的ACK/NAK\"></a>接收方处理出错的ACK/NAK</h4><p>老规矩——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224431777.png\" alt=\"image-20210707224431777\"></p>\n<p>这时接收方在2.0版本的基础上增加了对分组序号的识别，再来看发送方的处理——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224444037.png\" alt=\"image-20210707224444037\"></p>\n<p>看似很复杂，但实则只是穷举了对于不同分组的类似处理，毕竟只需要考虑两个分组，可以任性地穷举。来看下具体的场景——</p>\n<p><img src=\"http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210223150554157.png\" alt=\"image-20210223150554157\"></p>\n<h3 id=\"rdt2-2\"><a href=\"#rdt2-2\" class=\"headerlink\" title=\"rdt2.2\"></a>rdt2.2</h3><p>2.2版本本质上和2.1版本并无二致，但出于简洁的考虑，只使用ACK，而不用NAK。那具体怎么操作的呢？</p>\n<p>假设有这样一个场景——</p>\n<blockquote>\n<p>发送方发送<strong>数据包1</strong>，接收方检测出错了，所以发送<strong>ACK0</strong>给发送方。发送方默念一句你丫的，然后重新发送数据包1.双方继续和谐地传递着数据包。</p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224454789.png\" alt=\"image-20210707224454789\"></p>\n<p>一看就会的图解——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224504993.png\" alt=\"image-20210707224504993\"></p>\n<p>这里不再给出状态机描述，它的确适合转换为编程语言。但与人交互还是上图更友好些。</p>\n<h3 id=\"rdt3-0\"><a href=\"#rdt3-0\" class=\"headerlink\" title=\"rdt3.0\"></a>rdt3.0</h3><p>解决了乱序，比特出错。仍旧还有<strong>分组丢失</strong>的问题，如果按照rdt2.2机制，分组丢失后发送方接收方都鸦雀无声，陷入了<strong>死锁，浪费CPU资源</strong>。所以需要加入<strong>超时重传机制</strong>。</p>\n<p>即当分组发送出去后，计时器开始倒计时，如果计数到0还没有收到响应，那就重传。机制的核心在于<strong>计时的确定</strong>，<strong>网络状态是很难预测</strong>的，它的拥堵状况可以类似于高斯分布，我们需要使用数学中概率论的知识尽可能确定时间。当然，一个相对准确的计时器还需要<strong>相当长的路要走</strong>。</p>\n<p>诚然，凡事讲究善始如终，此处应有状态机——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224518042.png\" alt=\"image-20210707224518042\"></p>\n<ol>\n<li>首先发送方等待应用层调用，传输层组织好报文结构后，通过不可靠的信道将分组0传输给接收方，并启动超时定时器；</li>\n<li>状态切换到等待ACK0的响应，如果超时或出错(ACK1)，则重传，如果接收到ACK0，状态切换至等待应用层调用1；</li>\n<li>偷懒一手，同上。</li>\n</ol>\n<hr>\n<p>至此，rdt3.0已经是用于传输单个分组的无懈可击的协议，但在信道带宽大的情况下，rdt3.0的性能非常感人。这就好比八车道的高速公路全程只准跑一辆自行车。这显然很难以忍受，所以如何一次性发送多个分组而无须等待确认是必须要解决的问题。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224528848.png\" alt=\"image-20210707224528848\"></p>\n<p>我们将这种发送多个分组可以看做是填充到一条流水线中。因此解决这个问题的机制被称为<strong>流水线协议</strong>。流水线协议在rdt3.0基础上增加了<strong>传输分组的粒度</strong>。但它同时带来的问题可一点也不少——</p>\n<ul>\n<li>分组的序号显然只用0和1是不够的，必须<strong>扩大分组序号的范围</strong>，来唯一地标识一个分组；</li>\n<li>分组传输与接收的速率不一致，需要在接收方增加<strong>缓存机制</strong>，此外，发送方在发送分组以后可能处于两种状态：<code>等待确认,确认完成</code>。所以发送方的分组需要分区，即发送方也需要缓存机制；</li>\n<li>当分组出现损坏，丢失，延迟时如何处理呢？根据场景有两种可选的方式：<code>GBN(回退N步)和SR(选择重传)</code>.</li>\n</ul>\n<hr>\n<p>这两种处理差错的方式又都是基于<strong>通用的滑动窗口</strong>来实现的，滑动窗口是在<strong>缓冲区的基础上</strong>运作的，我们先来了解发送缓冲区及接收缓冲区——</p>\n<ul>\n<li><code>发送缓冲区：</code>缓冲区即是内存中的一块区域，它有大小属性，这里的发送缓冲区大小可以为1，即RDT3.0,当大小&gt;1时，即为流水线协议。这里的发送缓冲区用于<strong>存放已发送未确认的分组</strong>，以便用于检错重发或超时重传。</li>\n<li><code>接收缓冲区：</code>是为了解决分组在信道中传输的速率与接收方接收的<strong>速率不一致</strong>的问题所引入的。它的大小为1时即为RDT3.0,当发送缓冲区大小&gt;1时，接收缓冲区可以为1，此时为GBN协议，如果接收缓冲区&gt;1,则为SR协议。</li>\n</ul>\n<p>那如何表示缓冲区动态传输的过程呢？这就需要引入滑动窗口——</p>\n<h3 id=\"发送窗口\"><a href=\"#发送窗口\" class=\"headerlink\" title=\"发送窗口\"></a>发送窗口</h3><p>滑动窗口用来表示<code>发送缓冲区的范围</code>，即实际的<code>已发送未确认的分组个数</code>，我们通过图解来认识这个动态的过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224540604.png\" alt=\"image-20210707224540604\"></p>\n<p>此时，没有分组发送，缓冲区大小N=5，滑动窗口前沿=后沿，窗口大小=前沿-后沿=0。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224551296.png\" alt=\"image-20210707224551296\"></p>\n<p>接着，一个分组被发送，前沿移动一位，滑动窗口大小=前沿-后沿=1.此时分组0处于已发送未确认状态。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224601189.png\" alt=\"image-20210707224601189\"></p>\n<p>此时，5个分组都被发送，缓冲区已满，滑动窗口大小=前沿-后沿=5=缓冲区大小。</p>\n<hr>\n<p>这个过程我们是假设没有分组收到确认，现在我们打开潘多拉魔盒，认为已经有分组已经收到确认，情况就有所不同了——<br>!<img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224616355.png\" alt=\"image-20210707224616355\"></p>\n<p>这时，<code>分组0得到确认，窗口后沿移动</code>，此时前沿仍然指向最后一个进入缓冲区的已发送未确认分组。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224627690.png\" alt=\"image-20210707224627690\"></p>\n<p>然后，分组1也得到确认，窗口后沿移动。有两个分组5,6被发送，进入缓冲区等待确认。窗口前沿移动到6的位置。</p>\n<hr>\n<h3 id=\"接收窗口\"><a href=\"#接收窗口\" class=\"headerlink\" title=\"接收窗口\"></a>接收窗口</h3><p>发送窗口告一段落，来类比地看接收窗口，接收窗口可以控制哪些分组可以接收：</p>\n<ul>\n<li><code>收到的分组序号落在接收窗口内可以接受</code>；</li>\n<li>落在接收窗口外，则丢弃。</li>\n</ul>\n<p>此外，接收窗口根据出错的概率分为两种情况，对应两种协议——</p>\n<h4 id=\"GBN\"><a href=\"#GBN\" class=\"headerlink\" title=\"GBN\"></a>GBN</h4><p>接收窗口的尺寸等于1，即<code>只能顺序接收</code>：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224639851.png\" alt=\"image-20210707224639851\"></p>\n<p>接收窗口首先在分组0的位置，此时只有分组0的会被接收，如果接收到的是分组1，则丢弃。假设接收方接收到分组n,则表示小于等于分组n的所有分组都已经被接收，即<strong>累计式确认</strong>。</p>\n<h4 id=\"SR\"><a href=\"#SR\" class=\"headerlink\" title=\"SR\"></a>SR</h4><p>接收窗口的尺寸大于1，可以乱序接收：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224650324.png\" alt=\"image-20210707224650324\"></p>\n<p>起初，接收窗口中有分组0,1,2,3.收到分组0,1后，接收窗口向前滑动。但如果分组没有按序到来，会发生什么呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224701886.png\" alt=\"image-20210707224701886\"></p>\n<p>可以看到，当高序号的分组到来后<code>，仍旧将其缓存，但并不移动滑动窗口</code>，只有当低序号的分组到来后，窗口才会整体后移——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224711512.png\" alt=\"image-20210707224711512\"></p>\n<p>最后，可以总结出SR协议为非累积式接收。</p>\n<hr>\n<h4 id=\"正常情况下的窗口互动\"><a href=\"#正常情况下的窗口互动\" class=\"headerlink\" title=\"正常情况下的窗口互动\"></a>正常情况下的窗口互动</h4><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224721902.png\" alt=\"image-20210707224721902\"></p>\n<h4 id=\"异常情况下的窗口互动\"><a href=\"#异常情况下的窗口互动\" class=\"headerlink\" title=\"异常情况下的窗口互动\"></a>异常情况下的窗口互动</h4><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224736296.png\" alt=\"image-20210707224736296\"></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224827566.png\" alt=\"image-20210707224827566\"></p>\n<h4 id=\"用FSM描述的GBN\"><a href=\"#用FSM描述的GBN\" class=\"headerlink\" title=\"用FSM描述的GBN\"></a>用FSM描述的GBN</h4><ol>\n<li><p>发送方</p>\n<p>首先声明这些变量代表的含义：<code>N为窗口长度，base为窗口后沿，nextseqnum为满足发送条件但因缓冲区已满没有发送的分组序号</code>，</p>\n</li>\n</ol>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224840765.png\" alt=\"image-20210707224840765\"></p>\n<ol start=\"2\">\n<li><p>接收方</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224850680.png\" alt=\"image-20210707224850680\"></p>\n</li>\n</ol>\n<h4 id=\"运行中的SR\"><a href=\"#运行中的SR\" class=\"headerlink\" title=\"运行中的SR\"></a>运行中的SR</h4><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224903011.png\" alt=\"image-20210707224903011\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>GBN适用于<code>出错率低</code>的场景，<code>而链路容量大，回退代价高</code>的场景则是SR更优。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224915038.png\" alt=\"image-20210707224915038\"></p>\n<h2 id=\"1-5-面向连接的传输——TCP\"><a href=\"#1-5-面向连接的传输——TCP\" class=\"headerlink\" title=\"1.5 面向连接的传输——TCP\"></a>1.5 面向连接的传输——TCP</h2><p>在对TCP有大致的纹路了解后，我们进入TCP正式的探索。本着结构决定功能的特点，从TCP的段结构起笔，渲染TCP的可靠数据传输，进而浓墨于流量控制机制，最终落笔于连接管理。</p>\n<p><code>TCP提供的是点到点，可靠的，管道化的，按序的字节流，拥有流量控制机制，面向连接的服务。</code></p>\n<h3 id=\"段结构\"><a href=\"#段结构\" class=\"headerlink\" title=\"段结构\"></a>段结构</h3><p>TCP的报文段由一个<strong>首部字段和数据字段</strong>构成，数据字段即是应用层的数据，那这部分数据是源数据根据怎样的规则划分的呢？这里引入<strong>最大报文段长度MSS</strong>的概念。TCP会将要传输的文件分为若干个MSS。<strong>MSS的长度</strong>通常由<strong>本地发送主机发送的最大链路层帧长度</strong>来设置。在确定数据部分后，TCP为每个客户端数据配上一个<strong>TCP首部</strong>，从而形成多个TCP报文段。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224931500.png\" alt=\"image-20210707224931500\"></p>\n<p>具体来看每个字段：</p>\n<ul>\n<li><p><code>源端口号：</code>TCP提供的是进程之间的逻辑通信，而标识进程的即是端口号，标识源端口号就相当于给出了数据<strong>复用</strong>的路径。</p>\n</li>\n<li><p><code>目的端口号：</code>同样的，只有给出目的端口号，在接收方才能完成<strong>解复用</strong>的工作。</p>\n</li>\n<li><p><code>序号：</code>TCP把数据看做一个<strong>无结构，有序的字节流</strong>。而为了来标识每个报文段(<code>MSS</code>)的首字节在整个字节流中的位置，或者说偏移量，就引入了序号的概念。该序号的范围为<strong>2的32次方</strong>，可见冲突的几率比我中彩票还低~</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225012629.png\" alt=\"image-20210707225012629\"></p>\n</li>\n<li><p><code>确认号：</code>在可靠数据传输中，我们使用ACK来作为确认字段，但ACK只能表示接收方对接收到数据的回应，而实际的传输是全双工，且高并发的。所以接收方的确认号将<strong>确认与下一次传输的数据相结合</strong>作为确认号。也就是说，假设确认号为2000,即表示<strong>期望收到的下一个字节的序号</strong>，这里给出的序号同样也具有<strong>GBN累计确认</strong>的意义。</p>\n<p>我们试着使用序号与确认号来描述简化的传输过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225024780.png\" alt=\"image-20210707225024780\"></p>\n<p>即主机A发送序号42及对于序号79的确认，主机B收到后，发送对于序号42的确认，即ACK=43，且发送主机A期望的79，即seq=79.</p>\n</li>\n<li><p><code>接收窗口：</code>该字段用于<strong>流量控制</strong>，即指示接收方愿意接受的字节数量，在抓包的时候任一数据发送源都会使用<strong>Win字段</strong>来告诉另一方自己接收窗口的大小。</p>\n</li>\n<li><p><code>CRC校验和：</code>在UDP部分谈及过，用于<strong>检错</strong>。</p>\n</li>\n</ul>\n<p>而从进程通信的<code>流程框架</code>来看，TCP报文段又会经历怎样的<strong>复用与解复用</strong>呢——</p>\n<p>在形成报文段以后，这些报文段被下传给网络层，网络层将其分别封装在<strong>网络层IP数据报</strong>中，接着被发送到网络中，TCP在另一端接收报文段，该报文段被放在该<strong>TCP连接的接收缓存</strong>中，应用程序从缓存中读取数据流。</p>\n<h3 id=\"可靠数据传输\"><a href=\"#可靠数据传输\" class=\"headerlink\" title=\"可靠数据传输\"></a>可靠数据传输</h3><p>了解了确认号与序号，可靠数据传输的纹路已经逐渐明晰。在学习通用的rdt时，我们谈及当一个分组丢失时，超时重传机制是有必要的，这在TCP的机制中同样适用。但在TCP的机制中，我们需要将超时重传的机制具象化，即真正高效地使用。</p>\n<p>如何来估计超时重传的往返时间？<strong>定时器RTO</strong>应该设置多长时间？是否需要为每一个分组都设置一个定时器呢？我们来渐进式地解答——</p>\n<ol>\n<li><p>显然，定时器设置的时间应该是<strong>大于往返时间RTT</strong>的，所以我们可以随机地选取某一个RTT作为<strong>SampleRTT</strong>,但由于路由器的拥塞和网络负载均衡的特点，SampleRTT波动是很大的，所以为了更趋近于真实RTT，我们引入SampleRTT的均值EstimatedRTT。通过这两个标量，可以近似得到这样的公式：<br>$$<br>EstimatedRTT=（1-a）•EstimatedRTT+a•SampleRTT<br>$$<br>这里的a推荐值为<strong>0.125</strong>，将通过公式得到的均值称为之<strong>指数加权移动平均</strong>。</p>\n</li>\n<li><p>这里直接给出公式——<br>$$<br>Timeoutinterval=EstinMrtedRTT+4•DevRTT<br>$$<br>这里的DevRTT是为了解决波动问题，而引入的一个SampleRTT与EstimatedRTT之间差值。</p>\n</li>\n<li><p>TCP并不会为每个分组都维护一个定时器，因为高并发的发送维护定时器的代价是很大的，因此TCP使用了<strong>单一重传定时器机制</strong>。即只为<strong>发送缓冲区中最古老的已发送未确认分组</strong>维护定时器。</p>\n</li>\n</ol>\n<p>至此，TCP可靠数据传输的自肖像已经变得丰满起来。我们不妨在已经构建框架的前提下给出一个最简化的TCP发送方——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225039262.png\" alt=\"image-20210707225039262\">)</p>\n<p>即当超时定时器触发以后，发送方会传输<strong>至今没有得到确认的最小序号分组</strong>。即这里的机制又是类似于<strong>选择性重发SR</strong>。在重发后，超时定时器又会与当前没有得到确认的最小序号分组相关联。此外，还有一种情况，即缓冲区为空，即所有的分组都已得到确认，此时需要重启定时器。</p>\n<p>通过下图来看简要的交互：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225051029.png\" alt=\"image-20210707225051029\"></p>\n<p>另外，我们来穷举关于ACK的几种情况及相应的处理方式——</p>\n<table>\n<thead>\n<tr>\n<th><strong>接收方事件</strong></th>\n<th><strong>TCP接收方动作</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>所期望序号的报文段按序到达，期望序号之前的都已得到确认</td>\n<td>延迟的ACK，即对另一个按序报文段最多等待500ms</td>\n</tr>\n<tr>\n<td>有期望序号的报文段到达，另一个按需报文段等待发送ACK</td>\n<td>立即发送单个累积ACK，以确认两个按序报文段</td>\n</tr>\n<tr>\n<td>比期望序号大的报文段乱序到达，检测到数据流的间隔</td>\n<td>立即发送重复ACK，指明下一个期待字节的序号</td>\n</tr>\n<tr>\n<td>能部分或者完全填充接收数据间隔的报文段到达</td>\n<td>若该报文段起始于间隔的低端，则立即发送ACK</td>\n</tr>\n</tbody></table>\n<p>这个简化的TCP交互是默认不存在重复确认的，但实际上重复确认的情况是有可能出现的，TCP针对这种情况也给出了<strong>快速重传机制</strong>。</p>\n<p>收到<strong>重复确认</strong>往往是因为<strong>定时器设置的太大</strong>，接收方没有收到某个分组，但在定时器时间内仍会收到乱序到达的其他分组，这时接收方就会发送冗余分组，当发送方接收到<strong>三个冗余确认</strong>后，就会在定时期间<strong>重传最小序号的报文段</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225101991.png\" alt=\"image-20210707225101991\"></p>\n<p>再来看下快速重传的伪代码——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225112511.png\" alt=\"image-20210707225112511\"></p>\n<p>即接收方收到ACK，判断ACK与窗口后沿的关系，假如<strong>ACK大于窗口后沿，则将窗口后沿滑动</strong>，将<strong>定时器与新的报文段关联</strong>。否则，也就是ACK重复的情况，则记录ACK重复的个数，当其等于3时，触发快速重传机制。</p>\n<h3 id=\"流量管理\"><a href=\"#流量管理\" class=\"headerlink\" title=\"流量管理\"></a>流量管理</h3><p>传输层在将数据解复用以后，不是直接交付给应用程序使用，而是将其放置在<strong>接收缓冲区</strong>内，上层应用再<strong>从缓冲区中读取数据</strong>。但当从发送方发送来的数据太多就有可能<strong>淹没接收缓冲区</strong>，导致报文段丢失，因此，约定发送方的发送速率与接收方的接收速率是必须的，这种<strong>为了匹配速率的机制就称为流量控制</strong>。</p>\n<p>流量控制机制是通过互相告知缓冲区可用空间来实现的。那如何告知呢？即是通过接收方向发送方发送的报文段中的<strong>rwnd字段</strong>，它表示了<strong>接收缓冲区中可用的空间</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225128655.png\" alt=\"image-20210707225128655\"></p>\n<p>我们将rwnd再具象化，即它是通过什么来实现的呢？接收窗口！！！但这里的接收窗口和rdt中的接收窗口还是有所区别的。为了量化接收窗口的大小，我们还需要引入两个变量：</p>\n<ul>\n<li><code>LastByteRead</code>:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。</li>\n<li><code>LastByteRcvd</code>:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。</li>\n</ul>\n<p>那么接收窗口就可以表示为：<br>$$<br>rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]<br>$$</p>\n<h3 id=\"连接管理\"><a href=\"#连接管理\" class=\"headerlink\" title=\"连接管理\"></a>连接管理</h3><p>我们来深入了解如何建立和拆除一个TCP连接，首先，我们需要建立一些共识，也就是连接都需要做什么？</p>\n<p>在socketAPI的编程中，我们需要维护两个套接字，即连接是针对双方而言的，<strong>每一端可以看做维护一个半连接</strong>，所以在建立TCP连接时，两端都有<strong>告诉对方我要建立连接</strong>的诉求。除此之外，还需要<strong>为连接配置资源</strong>，因为连接就意味着马上会有数据传输，所以<strong>缓冲区自然是需要</strong>的，此外，<strong>序号和确认号也是必选项</strong>咯。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>好啦，实际地去建立连接时，首先先入为主的想法是两次握手——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225141658.png\" alt=\"image-20210707225141658\"></p>\n<p>但两次握手面临着很多问题：</p>\n<ul>\n<li>假如接收方的确认超时了，此时发送方会重发连接建立请求。但我们注意到<strong>接收方的机制简言之就是收到连接请求则同意建立</strong>。也就是说，虽然确认超时了，但接收方仍会维护一个<strong>半连接的状态</strong>及对应的资源。</li>\n<li>在上面状况的基础上，假如发送方接收到确认后，发送数据data，而接收data的接收方的状态为新的连接，那么此时<strong>新的连接接收的是老连接的数据</strong>。</li>\n</ul>\n<p>这些问题的症结本质上是<strong>半连接的孤立</strong>，那么如果<strong>在双方半连接的基础上增加两个半连接的交互</strong>，那问题就迎刃而解了。三次握手就是基于这样的思想实现的。我们来详细剖析三次握手的详细过程——</p>\n<ol>\n<li><p><code>第一次握手：</code>客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中<strong>不包含应用层数据</strong>。但是在报文段的首部中的一个标志位（即<strong>SYN</strong>比特）<strong>被置为1</strong>。因此，这个特殊报文段被称为<strong>SYN报文段</strong>。另外，客户会<strong>随机地选择一个初始序号</strong>（client_isn）,并将此编号放置于该起始的TCPSYN报文段的序号字段中。</p>\n</li>\n<li><p><code>第二次握手：</code>服务器会从该数据报中提取出SYN报文段，为该TCP连接<strong>分配TCP缓存和变量</strong>，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段<strong>也不包含应用层数据</strong>。但是，在报文段的首部却包含<strong>3个重要的信息</strong>。</p>\n<ol>\n<li>SYN比特被置为1。</li>\n<li>TCP报文段首部的确认号字段被置为<strong>client_isn+I</strong></li>\n<li>服务器选择自己的初始序号（<strong>serverjsn</strong>）,并将其放置到TCP报文段首部的序号字段中。这个允许连接的报文段实际上表明了：<strong>“我收到了你发起建立连接的SYN分组，该分组带有初始序号clientjsno我同意建立该连接。我自己的初始序号是serverjsnon</strong></li>\n</ol>\n<p>该允许连接的报文段被称为<strong>SYNACK报文段</strong>.</p>\n</li>\n<li><p><code>第三次握手:</code>在收到ACK报文段后，客户也要给该连接<strong>分配缓存和变</strong>量。客户主机则向服务器发送另外一个报文段；这最后一个报文段<strong>对服务器的允许连接的报文段进行了确认</strong>（该客户通过<strong>将值serverjsn+1放置到TCP报文段首部的确认字段</strong>中来完成此项工作）。因为连接已经建立了，所以该<strong>SYN比特被置为0</strong>。该三次握手的第三个阶段可以在报文段<strong>负载中携带客户到服务器的数据</strong>。</p>\n</li>\n</ol>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225201937.png\" alt=\"image-20210707225201937\"></p>\n<p>嗯，熟悉的FSM环节——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225214552.png\" alt=\"image-20210707225214552\"></p>\n<hr>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>天下没有不散的宴席。TCP连接也不能免俗。相比于三次握手，四次挥手还是水到渠成的，双端都可以主动发起断开连接的请求，然后<strong>双方断开自己维护的半连接</strong>即可，同样的，我们来复现这个过程——</p>\n<ol>\n<li>客户端进程向服务器进程发送一个特殊的报文段，该报文段中首部标志位<strong>FIN置1</strong>；</li>\n<li>服务器接收该报文段后，<strong>其ACK比特置1</strong>.</li>\n<li>反向同理。</li>\n</ol>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225225357.png\" alt=\"image-20210707225225357\"></p>\n<h2 id=\"1-6-拥塞控制原理\"><a href=\"#1-6-拥塞控制原理\" class=\"headerlink\" title=\"1.6 拥塞控制原理\"></a>1.6 拥塞控制原理</h2><hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在rdt可靠数据传输机制中，分组丢失是不可避免的，而<strong>分组丢失的原因通常是由网络拥塞</strong>，当路由器的缓存被占满后，后来者将会别抛弃，本质上说这种状况是因为网络是不可控的，很难从端系统获知网络的状况，但发送方又本着<code>多多益善</code>的方式在加剧网络的恶化。</p>\n<p>为了避免网络拥塞，TCP使用了怎样的机制，这种处理机制出发点是什么，它针对性地解决了哪些问题，如此种种。要解决这些问题，我们仍要铺好第一块砖石——</p>\n<p><code>网络拥塞的定义</code>：太多的数据需要网络传输，超过了网络的处理能力。</p>\n<h3 id=\"拥塞原因与表现\"><a href=\"#拥塞原因与表现\" class=\"headerlink\" title=\"拥塞原因与表现\"></a>拥塞原因与表现</h3><p>这里我们仍使用渐进式分析问题的思想，一个不会发生分组丢失的网络是怎样的呢？</p>\n<ul>\n<li><p><code>路由器缓存无限大</code></p>\n</li>\n<li><p><code>端系统可以了解网络的状况并作出调整。</code></p>\n</li>\n<li><p><code>所有分组都可以不超时的到达，所以不需要重传</code></p>\n</li>\n</ul>\n<p>先来看路由器缓存，假设路由器缓存无限大，那分组就不会被丢弃。这时假设有两个发送端通过一条链路(带宽为R)发送数据，那么它的吞吐量和延时表现为这样——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225238081.png\" alt=\"image-20210707225238081\"></p>\n<p>可见，即便在理想状态下，当超出链路的承载能力后，<code>流量强度变大，排队延时激增</code>。硬件条件这是不可逾越的天花板。所以我们很难控制不发生拥塞，而要从拥塞发生后的处理技巧入手。</p>\n<p>接着，我们去掉缓存无限的假设，这时分组丢失就变得无可避免，分组丢失就意味着重传，而<code>重传导致链路中重复的分组</code>，也就是不必要的分组增多，直接使得<code>发送方比接收方更高的发送速率</code>，导致本就不宽裕的链路带宽更显的捉襟见肘。另外，超时重传作用的结果也是一样的。</p>\n<p>最后，我们设想在类似<code>进程发生死锁</code>的一种情景，每个发送方占用着别的发送方需要的链路带宽，而别的进程也占用着自己需要的链路带宽，如果人的欲望一般，我们知道这条路是错的，但贪念仍在驱使着躯干向前。</p>\n<h3 id=\"拥塞控制的方式\"><a href=\"#拥塞控制的方式\" class=\"headerlink\" title=\"拥塞控制的方式\"></a>拥塞控制的方式</h3><p>针对上面的状况，一般采用两种控制拥塞的方法——</p>\n<ul>\n<li><code>端对端的拥塞控制：</code>TCP就使用这种策略。端系统根据<code>延迟和丢失事件</code>推断是否有拥塞。</li>\n<li><code>网络辅助的拥塞控制：</code>路由器通过<code>置位</code>的方式显示的告诉发送端可以采用的速率。</li>\n</ul>\n<p>来通过实际的<strong>ATM ABR场景</strong>认识下这两种方式是怎样实际运转的：</p>\n<p>我们知道，在网络中传输的数据粒度是有区别的，专线更多使用线路交换的方式，而通用的则是分组交换的方式，这种在银行中大行其道的ATM ABR线路则使用数据粒度<code>介于线路交换和分组交换的粒度大小</code>，更具体地说，它传输的最小单元是<code>53个的比特</code>。</p>\n<p>**ABR(available bit rate)**提供的是弹性服务，它可以<code>根据网络的负载实时调整发送速率</code>。如果发送方路径轻载，则发送方就使用尽可能多地利用贷款。如果发送方路径阻塞，发送方限制速率至一个最小保障速率。</p>\n<p>那网络中的拥塞状况是如何被获知的呢？通过RM信元，即<strong>资源管理信元</strong>。</p>\n<p>它由发送端发送，在数据信元中间隔插入，通过该信元特定的比特位来作为网络辅助，这种行之有效的比特位分别是：</p>\n<ul>\n<li><code>NI bit:</code>即no increase in rate。</li>\n<li><code>CI bit:</code>即congestion indication拥塞指示。</li>\n</ul>\n<p>发送方发送的RM信元被接收方返回，<code>接收方仅用作中转</code>使用。另外，之前谈及信元可以返回给发送方最小发送速率，这是如何实现的呢？</p>\n<p>通过RM信元中的2个字节<code>ER(explicit rate)字段</code>.拥塞的交换机会降低ER的值，最终返回给发送方。</p>\n<hr>\n<h2 id=\"1-7-TCP拥塞\"><a href=\"#1-7-TCP拥塞\" class=\"headerlink\" title=\"1.7 TCP拥塞\"></a>1.7 TCP拥塞</h2><p>在上一小节中，我们聊了通用的拥塞控制机制，也就是：<strong>端系统处理</strong>，<strong>网络辅助的拥塞控制</strong>。同时对网络辅助的案例做了简单描述，这一小节，我们将展开讲述在端系统如何处理拥塞。</p>\n<p>更具体地说，是<strong>TCP的拥塞控制机制</strong>。而在开始之前，我们先解决一个前置问题：TCP<code>为什么不在网络核心通过使用辅助信元的方式实现拥塞控制</code>。其实，纵观整个网络架构，复杂性都是在传输层及其以上提供的，也就是说，<code>网络层不会向上层应用提供显式的拥塞控制机制</code>。</p>\n<p>那TCP的拥塞控制机制是怎样实现的呢？不着急，本着先有问题，再有方案的思路，我们先来回答TCP拥塞机制面临的<strong>三大问题</strong>——</p>\n<ul>\n<li><p><code>如何感知到拥塞</code></p>\n<p>网络拥塞的最终结果是分组丢失，而导致分组丢失的原因却有一些区别——</p>\n<ol>\n<li>假如到达路由器的分组过多导致缓冲区已满，<strong>分组就会被丢弃</strong>。此外，有可能分组在传输时比特反转，接收方认不出来这是啥，那也会将其丢弃。这两种情况的直观表现都是超时，这种<code>拥塞情节严重</code>，发送方明显被动。</li>\n<li>当发送方连续收到4个ACK信号，也就是<strong>3个冗余ACK</strong>时，就会触发快速重传机制，这时还没有超时，发送方主动出手降低损失，姑且称其<code>轻微拥塞</code>。</li>\n</ol>\n</li>\n<li><p><code>如何对速率做调整</code></p>\n<p>那明确了问题，如何针对两种拥塞做出发送速率的调整呢？在<strong>RDT</strong>中，我们引入<code>接收窗口rwnd</code>来限制接收分组，这里我们也采用类似的机制，引入<code>拥塞窗口cwnd</code>。类比接收窗口表示能够接收分组的上限，拥塞窗口表示的即是——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225253295.png\" alt=\"image-20210707225253295\"></p>\n<p>是不是似曾相识，发送窗口表示的是<strong>实际的</strong>已发送未确认的分组数量。而拥塞窗口就如同在对发送窗口做<strong>动态调整</strong>，除此之外，别无二致。那确定了拥塞窗口的值，发送方的发送速率也可以得出来——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225302111.png\" alt=\"image-20210707225302111\"></p>\n</li>\n<li><p><code>通过怎样的算法对速率做调整：</code></p>\n</li>\n</ul>\n<p>有了衡量拥塞的标志，接下来就需要通过拥塞状况触发动态调整啦，这里的动态调整，就是广受赞誉的<strong>TCP拥塞控制算法</strong>。</p>\n<p>该算法分为三部分：慢启动，拥塞避免，快速恢复。我们详细来聊聊——</p>\n<ul>\n<li><p><code>慢启动：</code></p>\n<p>TCP会将cwnd的值<code>初始化为一个2/3/4MSS</code>(具体由MSS的大小决定)的值，但显然，这点速率是不够打的，所以当分组首次被确认后，会以<code>指数级的增长趋势</code>尽快加速，直至超时后打回原形，也就是1个MSS.这时，TCP还会维护一个<strong>慢启动阈值</strong>，也就是警戒值，它的值为<strong>cwnd(max)/2</strong>，接着，开始下一次拥塞控制，当cwnd的值指数增加至慢启动阈值后，不再鲁莽地指数级增长，而是维持<code>线性增长</code>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225311975.png\" alt=\"image-20210707225311975\"></p>\n<p>这种线性增长的机制就是拥塞避免——</p>\n</li>\n<li><p><code>拥塞避免：</code></p>\n<p>那拥塞避免什么时候结束呢？和慢启动一样，拥塞避免阶段在触发超时后会重新开始SS慢启动阶段,这时，慢启动的阈值也势必会更新。</p>\n<p>再来讨论下发送方收到<strong>3个冗余ACK</strong>的状况——</p>\n<p>它的处理机制显然没必要像拥塞时那么剧烈，只需要在触发快速重传后，记录慢启动阈值，然后<code>直接从阈值开始线性增加</code>进入快速恢复阶段——</p>\n</li>\n<li><p><code>快速恢复：</code></p>\n<p>所谓的快速恢复无非是针对两种拥塞状况的不同种处理，在上面已经提及，就不再赘述。</p>\n<ol>\n<li>超时重传：RFC建议将拥塞窗口降至1个MSS，而由慢启动过渡至拥塞窗口的值就有讲究了，应该调整至没别确认的数据量的1/2,但不能小于两个MSS</li>\n<li>快速恢复：不会处理拥塞窗口的值；</li>\n</ol>\n</li>\n</ul>\n<p>接下来就是小总结环节——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225324365.png\" alt=\"image-20210707225324365\"></p>\n<p>再将两种情况汇总，就有了下图——</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210304182714108.png\" alt=\"image-20210304182714108\"></p>\n<h3 id=\"TCP吞吐量\"><a href=\"#TCP吞吐量\" class=\"headerlink\" title=\"TCP吞吐量\"></a>TCP吞吐量</h3><p>这里我们取快速恢复阶段的数据量均值作为参考(慢启动指数级的增加实则很快，也导致实际传输的流量不多)，即——<br>$$<br>一条连接的平均吞吐量=3/4<em>W/RTT<br>$$<br>另外也给出在<code>经过高带宽TCP，且丢包率为L的情况</code>下，吞吐量的描述——<br>$$<br>一条连接的平均吞吐量：1.22</em>MSS/RTT/根号下2<br>$$</p>\n<h3 id=\"TCP公平性\"><a href=\"#TCP公平性\" class=\"headerlink\" title=\"TCP公平性\"></a>TCP公平性</h3><p>太饿了，去吃饭，偷懒一手——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225338648.png\" alt=\"image-20210707225338648\"></p>\n<p>也就是多个TCP连接时，网络状况会趋向于<code>带宽均分</code>。</p>\n<p>而如果一个链路中既有使用TCP的服务，也有使用UDP的服务，那对于TCP是不友好的，因为<code>UDP百无禁忌</code>，它没有拥塞控制机制，如果有可能，UDP会一点点的蚕食掉带宽，而最终导致更恶劣的后果，可见，<strong>不限制贪欲最终会陷入恶性循环</strong>。但这种机制也并非一无是处，流媒体就表示这是我的菜，因为<code>音视频应用起码泵出数据的速率是恒定</code>的，即便数据会丢失。</p>\n<hr>\n<h2 id=\"抓包番外\"><a href=\"#抓包番外\" class=\"headerlink\" title=\"抓包番外\"></a>抓包番外</h2><h3 id=\"简单的代价——UDP\"><a href=\"#简单的代价——UDP\" class=\"headerlink\" title=\"简单的代价——UDP\"></a>简单的代价——UDP</h3><h3 id=\"DNS那些事\"><a href=\"#DNS那些事\" class=\"headerlink\" title=\"DNS那些事\"></a>DNS那些事</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232028231.png\" alt=\"image-20210506232028231\"></p>\n<p>DNS常用的<strong>应用场景</strong>有两种：</p>\n<ul>\n<li><p><code>CNMAE:</code>即将一个域名映射到另一个域名，</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234636802.png\" alt=\"image-20210506234636802\"></p>\n</li>\n<li><p><code>A：</code>请求获取域名对应的IP地址</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234517700.png\" alt=\"image-20210506234517700\"></p>\n</li>\n</ul>\n<p>当DNS在缓存中没有找到要查询的记录后，就会发起<strong>DNS查询</strong>，查询有两种：递归查询，迭代查询。假如我们向一个<code>不权威的DNS服务器发起递归查询请求</code>，我们只会与这个不权威的DNS服务器交互，而<code>无从得知它的查询结果是否可靠</code>。迭代查询则会相对安全一些，因为客户端首先会查到根服务器的地址，再从根服务器查到权威服务器，然后从权威服务器查询。。。直到返回想要的结果。</p>\n<p>它的<strong>响应</strong>一般包含这些字段：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235701873.png\" alt=\"image-20210506235701873\"></p>\n<p>再来聊一些生僻的：<strong>DNS循环工作模式</strong>——</p>\n<p>假如某个网站有10台Web服务器，管理员可以在DNS创建10个同名记录指向这些服务器的IP，由于不同客户端查到的结果顺序不同，而且一般会选用结果中的第一个IP，所以大量客户端就会被均衡的分配到10台Web服务器上，也就是<code>负载均衡</code>咯。</p>\n<p>再来说说<strong>DNS的缺点</strong>，为人所知的<code>DNS放大攻击</code>就是缺陷之一，假如有这样的场景：我们由包发出去的请求只有少许字节，但收到的回复却高达几千字节，这种情况非常值得我们警惕。</p>\n<h3 id=\"老生常谈的TCP\"><a href=\"#老生常谈的TCP\" class=\"headerlink\" title=\"老生常谈的TCP\"></a>老生常谈的TCP</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235956824.png\" alt=\"image-20210506235956824\"></p>\n<p>这个包抓的还是<code>恰如其分</code>的，它完美的涵盖了三次握手与四次挥手的7个包，同时出现的<code>乱序问题</code>也印证了TCP的强大之处。接下来我们分别从三次握手和四次挥手来分析它的细节——</p>\n<p><strong>三次握手</strong>：</p>\n<ul>\n<li><p><code>SYN报文段</code></p>\n<p>在这个帧中，包含了Seq,Win，Len等字段，显然<code>Seq表示随机选择的报文段的初始字节偏移量</code>，而Win就比较有意思了，我们可能更熟悉它的另一个名称：rwnd，也就是说<code>Win就是接收窗口的大小</code>，只不过描述字段有区别，至于Len字段，见名知意，它描述了报文段的长度，但这并不包含报文头部的长度，所以<code>Len为0只能说明没有数据传输</code>。</p>\n</li>\n<li><p><code>SYN/ACK报文段：</code></p>\n</li>\n</ul>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507092224812.png\" alt=\"image-20210507092224812\"></p>\n<p>显然，TCP报文段（一个MSS长度）的<code>头部包含32个字节</code>，而我们常说的<code>XX报文段其实就是通过置位来标识</code>的。</p>\n<ul>\n<li><p><code>ACK报文段</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093012217.png\" alt=\"image-20210507093012217\"></p>\n<p>我们试图再发现一些新颖的事物，在这个窗口我们看到<code>一个包被接口过滤器（网口）收到的完整过程</code>，它依次经历了物理层，数据链路层，网际层，传输层。</p>\n</li>\n</ul>\n<p><strong>四次握手</strong></p>\n<ul>\n<li><p><code>SYN/ACK报文段：</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093632419.png\" alt=\"image-20210507093632419\"></p>\n<p>显然，在发送该报文段后<code>不再发送数据，但仍然可以接收数据</code>。</p>\n</li>\n<li><p><code>ACK报文段</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093904412.png\" alt=\"image-20210507093904412\"></p>\n<p>显然，ACK包乱序了，但它仍可以被接收，这依赖于<code>TCP的累计确认</code>，也就是说TCP只关心发送的最古老的的那个包有没有被收到，如果<code>有乱序的包到达，它会将其放置在接收窗口而不给与确认</code>，在收到最古老的的那个包后，它会接收该包并累计确认，应用层再从接收窗口中读取这些包。</p>\n</li>\n</ul>\n<p>最后再来看一个非常有用的命令：<strong>netstat</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507095047707.png\" alt=\"image-20210507095047707\"></p>\n<p>这是我使用netstat命令陈列出来的TCP连接状态，我们发现有这样几种状态：</p>\n<ol>\n<li><p>TIME_WAIT:</p>\n<p>TIME_WAIT又称<code>2MSL状态</code>(报文段最大存活时间)，被动关闭方在收到FIN并回复ACK后会进入该状态，它的作用主要有两个：</p>\n<ol>\n<li><p>允许老的重复报文分组在网络中消逝，<code>避免新连接接收老连接的数据</code>。</p>\n</li>\n<li><p>保证TCP全双工连接的正确关闭，<code>避免RST拒绝服务</code>。</p>\n</li>\n</ol>\n</li>\n<li><p>ESTABLISHED:</p>\n<p>表示<code>数据传输正在进行</code></p>\n</li>\n<li><p>CLOSE_WAIT</p>\n<p>正常状态，会<code>很快转化为LAST_WAIT</code>,只出现在被动关闭方。</p>\n</li>\n</ol>\n<h3 id=\"历久弥新的HTTP\"><a href=\"#历久弥新的HTTP\" class=\"headerlink\" title=\"历久弥新的HTTP\"></a>历久弥新的HTTP</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232400891.png\" alt=\"image-20210506232400891\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-1-概述和传输层服务\"><a href=\"#1-1-概述和传输层服务\" class=\"headerlink\" title=\"1.1 概述和传输层服务\"></a>1.1 概述和传输层服务</h2><p>传输层位于应用层与网络层之间，起着承上启下的重要作用。概括的说，<strong>传输层协议为运行在不同主机上的进程提供逻辑通信的功能</strong>。而从TCP/IP协议族的组成来看，它向上使<strong>进程间的通信成为可能</strong>，向下<strong>加强了网络层提供的尽力而为式</strong>的服务。那具体传输层如何使用服务，并在此基础上加强，最后提供服务的呢？我们还需要继续勾勒这个蓝图：</p>\n<p>在此之前，首先来看书中给出的例子——</p>\n<p>有两个关系不错的家庭A和B，家庭A的5位家庭成员都会向家庭B的5位家庭成员写信。写好信后交由邮递公司将其送到家庭B的信箱中，家庭B的长子再将信从信箱中取出交给弟弟妹妹们。我们来对这个例子做一个类比：</p>\n<p>两个家庭可以看做两个主机，弟弟妹妹们可以看做是应用进程，长子可以看做是传输层协议，邮递服务可以认为是网络层提供的服务，应用层的报文即是信的内容。</p>\n<p>从这个案例中，我们可以提取出一些<strong>有趣的信息</strong>——</p>\n<ul>\n<li>邮件服务有可能出现纰漏，比如会传错，丢失等，即<code>网络层传输的是不可靠的服务，它不对分组做有效力的保证</code>。</li>\n<li>邮箱里的信件是乱序的，但通过长子来传递到弟弟妹妹的信件却是有序的，即<code>传输层协议会对可靠性做保证，而其应用的机制则是RDT原理</code>。</li>\n<li>长子不需要跑去邮局取信件，而只需要定期检查邮箱就行啦。即传输层协议被定义在端系统，还是那句话，<code>网络核心的功能其实是在网络边沿实现的</code>。</li>\n<li>如果邮局没有在规定时间内传递邮件，那在此期间在家里就不可能取到信件。即<code>传输层的服务明显受限于网络层提供的服务</code>。</li>\n<li>如果邮箱中有很多信件，长子可以选择性的先取出一些邮件。即<code>传输层提供流量管理和拥塞控制的服务</code>。</li>\n<li>长子在取邮件时，首先需要需要拆开信封，再取出信件。即<code>目标端可以实现解复用</code>。</li>\n</ul>\n<p>除了上面将传输层当做<strong>整体</strong>看待来分析它的特点与实现以外，我们还需要将传输层拆解，广为人知的是，传输层提供TCP和UDP两个协议，</p>\n<p><code>TCP</code>：TCP提供的服务是可靠的，保序的，有拥塞控制，流量管理机制的，面向连接的，涉及复用与解复用，数据以<strong>字节流</strong>的形式传输。</p>\n<p><code>UDP</code>:   UDP提供的服务是不可靠的，不保序的，不面向连接的，数据以<strong>数据报</strong>的形式传输。</p>\n<p>蓝图已经画就，我们来用笔墨筑起传输层的万丈高楼——</p>\n<h2 id=\"1-2-多路复用与解复用\"><a href=\"#1-2-多路复用与解复用\" class=\"headerlink\" title=\"1.2 多路复用与解复用\"></a>1.2 多路复用与解复用</h2><p>我们在PC上可以同时运行QQ,网易云.它们是从属于不同的进程，所以当传输层向上层传输信息时，需要标识给哪一个进程，也就是需要使用<strong>Socket来标识一个进程</strong>，那向上传输的内容，除了Socket，显然还需要有报文。<strong>报文中包含传输层的首部字段和MSG</strong>。这里的描述其实就是解复用的过程，显然，我们在之前已经接触过。下面我们更具体地描述传输层的复用与解复用。</p>\n<ul>\n<li><code>复用：</code>在源主机从不同的套接字中收集数据块，并<strong>为每个数据块封装首部信息</strong>，生成报文段，最终将报文段交付于网络层。</li>\n<li><code>解复用：</code>将传输层报文段中的数据交付给应用进程的过程</li>\n</ul>\n<p>也就是说，传输层的多路复用与解复用实现的就是<code>将主机到主机的交付服务延伸到应用程序到应用程序之间</code>，它关注的问题无非是<strong>将报文传给谁，报文中都包括什么</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210324385.png\" alt=\"image-20210707210324385\"></p>\n<p>可以看出，复用与解复用的核心是通过套接字来完成的。而通过上一章节的知识，我们知道TCP和UDP的套接字所引用的信息是不一样的。我们分情况来看——</p>\n<h3 id=\"无连接的多路复用与解复用\"><a href=\"#无连接的多路复用与解复用\" class=\"headerlink\" title=\"无连接的多路复用与解复用\"></a>无连接的多路复用与解复用</h3><p>我们通过图解来解析UDP多路复用的过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210337051.png\" alt=\"image-20210707210337051\"></p>\n<p><code>饮</code>：主机A中的传输层创建一个传输层报文，<strong>报文包含应用程序数据，源端口号19157，目的端口号46428和其他两个值</strong>。接着，传输层将该报文段传输给<strong>网络层</strong>，网络层再将报文段封装到一个<strong>IP数据报</strong>中，并通过网络链路交付给接收主机。</p>\n<p><code>啄</code>：接收主机传输层检查该报文段中的<strong>目的端口号46428</strong>，并将该报文段交付给端口号46428所<strong>标识的套接字</strong>。</p>\n<p>这里有一点可能会引起<strong>困惑</strong>的地方：socket是如何参与这个过程的。首先明确的是，<strong>socket是不被包含在报文段中的</strong>。UDP的Socket包含目的IP，目的端口号，它仅用于处理源端口或者目标端口的<strong>识别</strong>，即<strong>层间接口</strong>。但报文是实际参与通信过程的。这里的socket就像是一个<strong>开门的钥匙</strong>。</p>\n<h3 id=\"面向连接的多路复用与解复用\"><a href=\"#面向连接的多路复用与解复用\" class=\"headerlink\" title=\"面向连接的多路复用与解复用\"></a>面向连接的多路复用与解复用</h3><p>同样的，开局一张图——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224235450.png\" alt=\"image-20210707224235450\"></p>\n<p>区别于UDP，TCP的socket所引用的信息是一个四元组，即——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224252958.png\" alt=\"image-20210707224252958\"></p>\n<p>额，PID就不用管了，当一个报文段被交付给应用进程时，它需要使用四元组的socket来判别报文段应该被交付给具体哪一个应用进程。</p>\n<p>如果我们要求在传输层上只实现<strong>必要的最简单协议</strong>，那UDP完成符合这样的要求。UDP的全称是<strong>用户数据报协议</strong>。它仅在网络层的基础上提供<strong>必要的复用，解复用，以及简单的校验和</strong>。这使得它的功能基本上和网络层一致。</p>\n<p>我们知道，网络层提供的服务是不可靠的，所以使用UDP的传输层提供的服务同样不可靠。这意味着它不需要握手，即不面向连接。数据有可能发生乱序，重复。而假设发生了这种错误，客户端如何处理呢？它会直接<strong>丢弃</strong>。</p>\n<p>这种简洁的设计会有它的用武之地吗？当然，<strong>简洁也是一种优雅</strong>，它简单所以头部信息少，传输快，它不需要建立连接，也自然没必要维护连接的状态。甚至一些应用是在UDP的协议上构建的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224304322.png\" alt=\"image-20210707224304322\"></p>\n<p>那这是否意味着基于UDP的应用是不可靠的呢？不完全是，<strong>在应用程序做可靠传输的处理</strong>是一种可选的方式。</p>\n<p>我们再来拨云见日地看看UDP的报文结构：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224316644.png\" alt=\"image-20210707224316644\"></p>\n<p>值得一提的是UDP仍然提供了必要的简单检错机制，即<strong>校验和</strong>，来看校验和的原理——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224330412.png\" alt=\"image-20210707224330412\"></p>\n<p>即我们在源端得到测试的和，如果有进位，则再回卷得到和。数据报传输到目标端以后，目标端将<strong>校验和的反码与源端得到的校验和相加</strong>，如果相加为全1，则校验通过，反之不通过。</p>\n<h2 id=\"1-4-重点：可靠数据传输原理\"><a href=\"#1-4-重点：可靠数据传输原理\" class=\"headerlink\" title=\"1.4 重点：可靠数据传输原理\"></a>1.4 重点：可靠数据传输原理</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>可靠数据传输是一个<strong>一般性的问题</strong>，它不仅在传输层使用这个机制，在网络层和应用层也可以实现。而下一个小节中我们将以最通用的传输层为例介绍可靠数据传输协议RDT。</p>\n<p>在编程时，我们通常使用这样的思维：即<code>首先将具体问题转化为抽象的数学问题，再使用编程语言将数学问题实现</code>，在学习rdt时，这种思路同样适用。</p>\n<p>首先来看可靠数据传输面临的场景：对于应用层来说，传输层通过可靠数据传输的机制，并使用<strong>可靠的信道</strong>来向应用层提供服务——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224342304.png\" alt=\"image-20210707224342304\"></p>\n<p><code>那这个可靠的服务是如何实现的呢</code>？显然是通过调用下层服务。从而对本层服务做加强来实现的，我们将这一过程<strong>抽象成原语实现</strong>，我们将这些原语具体描述，他们发挥着这样的功能——</p>\n<ul>\n<li><code>rdt_send:</code>被上层调用，将数据交付给下层的发送方实体。</li>\n<li><code>udt_send:</code>被rdt调用，将分组通过不可靠的信道发送给接收方。</li>\n<li><code>rdt_rcv:</code>分组到达接收方时被调用。</li>\n<li><code>deliver_data:</code>被rdt调用，将数据交付给上层。</li>\n</ul>\n<p>我们需要通过rdt来实现<strong>发送方和接收方动作的抽象</strong>，但这种抽象是基于不可靠的信道，它可能会发生<strong>乱序，重复，篡改</strong>等问题，直接给出解决方案着实有点难为人。所以这里引入了一种处理复杂问题的思路，即<strong>渐进式解决</strong>。</p>\n<p><code>具体的说，我们一层层地去掉那些美好的假设，然后在一个可行方案的基础上逐渐完善</code>。我们的任务仅仅是实现一个能够完成必要功能的rdt协议，所以双向传输可以简化为单向传输，此外，给出有助于解决问题的通用模型也势在必行。也就是有限状态机FSM，在学习数字系统设计时，接触过使用<strong>FSM描述的空调状态机</strong>。不想除了考试，居然还能有缘再见。在课堂终于学到有用的知识了。。。</p>\n<p>FSM是这样设计的：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224353943.png\" alt=\"image-20210707224353943\"></p>\n<p>至此，前置知识就完结了，故事的大幕就此拉开——</p>\n<h3 id=\"rdt1-0\"><a href=\"#rdt1-0\" class=\"headerlink\" title=\"rdt1.0\"></a>rdt1.0</h3><p>这里<code>假设信道完全可靠</code>，它没有比特出错，甚至不会分组丢失，此时的rdt协议,恕我说句：工具人~。</p>\n<p>用状态机来描述一下此时的发送方与接收方——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224406899.png\" alt=\"image-20210707224406899\"></p>\n<p>这个显然还没有复杂度需要详细描述的地步，next~</p>\n<h3 id=\"rdt2-0\"><a href=\"#rdt2-0\" class=\"headerlink\" title=\"rdt2.0\"></a>rdt2.0</h3><p>在2.0版本，我们就要抛弃掉一些幻想，这时候的信道不那么可靠，它可能会发生<code>比特的错误</code>。之前在聊UDP时谈及UDP报文结构中使用校验和来做差错检测，当然TCP也有这个机制。检测出来后，怎么更正呢？自然是重发，那<code>如何标识出错的状态</code>呢？</p>\n<p>这就需要引入<code>标记量</code>。假如接受方检测到比特出错，就发送显示的发送错误标志，也就是<code>NAK</code>，俗称：反向谢谢；而当检测后发送无误，就发送显示的发送正确标志，这回是正向的谢谢：<code>ACK</code>。</p>\n<p>同样的，向量机描述——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224420197.png\" alt=\"image-20210707224420197\"></p>\n<p>这时，状态机已经没那么友好了，我们简要描述一下——</p>\n<ul>\n<li><code>发送方：</code>当rdt接收到应用层的数据后，将<code>数据与校验和组成传输报文</code>通过不可靠的信道发送给接收方，然后发送方等待接收方的回应。当等待到的是ACK时，继续等待上层调用。</li>\n<li><code>接收方：</code>接收方接收来自不可靠信道的数据，然后<code>做校验</code>，当校验出错时发送NAK,校验正确时发送ACK。</li>\n</ul>\n<h3 id=\"rdt2-1\"><a href=\"#rdt2-1\" class=\"headerlink\" title=\"rdt2.1\"></a>rdt2.1</h3><p>咦，怎么又出现了2.1，自然是因为2.0实在不堪大用。2.0版本的确相比1.0版本迈出了一大步，但它本身存在致命的缺陷，也就是<strong>ACK,NAK本身也有可能发送错误</strong>。rdt的机制应该也必须是健壮的，所以当接收到不可识别的信息时<strong>有必要重发数据包</strong>。所以对数据包的标识就这么顺水推舟的发生了.即<strong>对分组加序号</strong>。但这里只使用1位，即2种可能结果标识正在处理的分组。这是因为目前仍处于<strong>STOP AND WAIT阶段</strong>，一次发送一个数据包，用0和1来标识要处理的数据包就行啦。但如何处理重复呢？<strong>丢弃</strong>发送时间较早那个的数据包。</p>\n<h4 id=\"接收方处理出错的ACK-NAK\"><a href=\"#接收方处理出错的ACK-NAK\" class=\"headerlink\" title=\"接收方处理出错的ACK/NAK\"></a>接收方处理出错的ACK/NAK</h4><p>老规矩——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224431777.png\" alt=\"image-20210707224431777\"></p>\n<p>这时接收方在2.0版本的基础上增加了对分组序号的识别，再来看发送方的处理——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224444037.png\" alt=\"image-20210707224444037\"></p>\n<p>看似很复杂，但实则只是穷举了对于不同分组的类似处理，毕竟只需要考虑两个分组，可以任性地穷举。来看下具体的场景——</p>\n<p><img src=\"http://qnuez6z2b.hn-bkt.clouddn.com/typora/image-20210223150554157.png\" alt=\"image-20210223150554157\"></p>\n<h3 id=\"rdt2-2\"><a href=\"#rdt2-2\" class=\"headerlink\" title=\"rdt2.2\"></a>rdt2.2</h3><p>2.2版本本质上和2.1版本并无二致，但出于简洁的考虑，只使用ACK，而不用NAK。那具体怎么操作的呢？</p>\n<p>假设有这样一个场景——</p>\n<blockquote>\n<p>发送方发送<strong>数据包1</strong>，接收方检测出错了，所以发送<strong>ACK0</strong>给发送方。发送方默念一句你丫的，然后重新发送数据包1.双方继续和谐地传递着数据包。</p>\n</blockquote>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224454789.png\" alt=\"image-20210707224454789\"></p>\n<p>一看就会的图解——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224504993.png\" alt=\"image-20210707224504993\"></p>\n<p>这里不再给出状态机描述，它的确适合转换为编程语言。但与人交互还是上图更友好些。</p>\n<h3 id=\"rdt3-0\"><a href=\"#rdt3-0\" class=\"headerlink\" title=\"rdt3.0\"></a>rdt3.0</h3><p>解决了乱序，比特出错。仍旧还有<strong>分组丢失</strong>的问题，如果按照rdt2.2机制，分组丢失后发送方接收方都鸦雀无声，陷入了<strong>死锁，浪费CPU资源</strong>。所以需要加入<strong>超时重传机制</strong>。</p>\n<p>即当分组发送出去后，计时器开始倒计时，如果计数到0还没有收到响应，那就重传。机制的核心在于<strong>计时的确定</strong>，<strong>网络状态是很难预测</strong>的，它的拥堵状况可以类似于高斯分布，我们需要使用数学中概率论的知识尽可能确定时间。当然，一个相对准确的计时器还需要<strong>相当长的路要走</strong>。</p>\n<p>诚然，凡事讲究善始如终，此处应有状态机——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224518042.png\" alt=\"image-20210707224518042\"></p>\n<ol>\n<li>首先发送方等待应用层调用，传输层组织好报文结构后，通过不可靠的信道将分组0传输给接收方，并启动超时定时器；</li>\n<li>状态切换到等待ACK0的响应，如果超时或出错(ACK1)，则重传，如果接收到ACK0，状态切换至等待应用层调用1；</li>\n<li>偷懒一手，同上。</li>\n</ol>\n<hr>\n<p>至此，rdt3.0已经是用于传输单个分组的无懈可击的协议，但在信道带宽大的情况下，rdt3.0的性能非常感人。这就好比八车道的高速公路全程只准跑一辆自行车。这显然很难以忍受，所以如何一次性发送多个分组而无须等待确认是必须要解决的问题。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224528848.png\" alt=\"image-20210707224528848\"></p>\n<p>我们将这种发送多个分组可以看做是填充到一条流水线中。因此解决这个问题的机制被称为<strong>流水线协议</strong>。流水线协议在rdt3.0基础上增加了<strong>传输分组的粒度</strong>。但它同时带来的问题可一点也不少——</p>\n<ul>\n<li>分组的序号显然只用0和1是不够的，必须<strong>扩大分组序号的范围</strong>，来唯一地标识一个分组；</li>\n<li>分组传输与接收的速率不一致，需要在接收方增加<strong>缓存机制</strong>，此外，发送方在发送分组以后可能处于两种状态：<code>等待确认,确认完成</code>。所以发送方的分组需要分区，即发送方也需要缓存机制；</li>\n<li>当分组出现损坏，丢失，延迟时如何处理呢？根据场景有两种可选的方式：<code>GBN(回退N步)和SR(选择重传)</code>.</li>\n</ul>\n<hr>\n<p>这两种处理差错的方式又都是基于<strong>通用的滑动窗口</strong>来实现的，滑动窗口是在<strong>缓冲区的基础上</strong>运作的，我们先来了解发送缓冲区及接收缓冲区——</p>\n<ul>\n<li><code>发送缓冲区：</code>缓冲区即是内存中的一块区域，它有大小属性，这里的发送缓冲区大小可以为1，即RDT3.0,当大小&gt;1时，即为流水线协议。这里的发送缓冲区用于<strong>存放已发送未确认的分组</strong>，以便用于检错重发或超时重传。</li>\n<li><code>接收缓冲区：</code>是为了解决分组在信道中传输的速率与接收方接收的<strong>速率不一致</strong>的问题所引入的。它的大小为1时即为RDT3.0,当发送缓冲区大小&gt;1时，接收缓冲区可以为1，此时为GBN协议，如果接收缓冲区&gt;1,则为SR协议。</li>\n</ul>\n<p>那如何表示缓冲区动态传输的过程呢？这就需要引入滑动窗口——</p>\n<h3 id=\"发送窗口\"><a href=\"#发送窗口\" class=\"headerlink\" title=\"发送窗口\"></a>发送窗口</h3><p>滑动窗口用来表示<code>发送缓冲区的范围</code>，即实际的<code>已发送未确认的分组个数</code>，我们通过图解来认识这个动态的过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224540604.png\" alt=\"image-20210707224540604\"></p>\n<p>此时，没有分组发送，缓冲区大小N=5，滑动窗口前沿=后沿，窗口大小=前沿-后沿=0。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224551296.png\" alt=\"image-20210707224551296\"></p>\n<p>接着，一个分组被发送，前沿移动一位，滑动窗口大小=前沿-后沿=1.此时分组0处于已发送未确认状态。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224601189.png\" alt=\"image-20210707224601189\"></p>\n<p>此时，5个分组都被发送，缓冲区已满，滑动窗口大小=前沿-后沿=5=缓冲区大小。</p>\n<hr>\n<p>这个过程我们是假设没有分组收到确认，现在我们打开潘多拉魔盒，认为已经有分组已经收到确认，情况就有所不同了——<br>!<img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224616355.png\" alt=\"image-20210707224616355\"></p>\n<p>这时，<code>分组0得到确认，窗口后沿移动</code>，此时前沿仍然指向最后一个进入缓冲区的已发送未确认分组。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224627690.png\" alt=\"image-20210707224627690\"></p>\n<p>然后，分组1也得到确认，窗口后沿移动。有两个分组5,6被发送，进入缓冲区等待确认。窗口前沿移动到6的位置。</p>\n<hr>\n<h3 id=\"接收窗口\"><a href=\"#接收窗口\" class=\"headerlink\" title=\"接收窗口\"></a>接收窗口</h3><p>发送窗口告一段落，来类比地看接收窗口，接收窗口可以控制哪些分组可以接收：</p>\n<ul>\n<li><code>收到的分组序号落在接收窗口内可以接受</code>；</li>\n<li>落在接收窗口外，则丢弃。</li>\n</ul>\n<p>此外，接收窗口根据出错的概率分为两种情况，对应两种协议——</p>\n<h4 id=\"GBN\"><a href=\"#GBN\" class=\"headerlink\" title=\"GBN\"></a>GBN</h4><p>接收窗口的尺寸等于1，即<code>只能顺序接收</code>：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224639851.png\" alt=\"image-20210707224639851\"></p>\n<p>接收窗口首先在分组0的位置，此时只有分组0的会被接收，如果接收到的是分组1，则丢弃。假设接收方接收到分组n,则表示小于等于分组n的所有分组都已经被接收，即<strong>累计式确认</strong>。</p>\n<h4 id=\"SR\"><a href=\"#SR\" class=\"headerlink\" title=\"SR\"></a>SR</h4><p>接收窗口的尺寸大于1，可以乱序接收：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224650324.png\" alt=\"image-20210707224650324\"></p>\n<p>起初，接收窗口中有分组0,1,2,3.收到分组0,1后，接收窗口向前滑动。但如果分组没有按序到来，会发生什么呢？</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224701886.png\" alt=\"image-20210707224701886\"></p>\n<p>可以看到，当高序号的分组到来后<code>，仍旧将其缓存，但并不移动滑动窗口</code>，只有当低序号的分组到来后，窗口才会整体后移——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224711512.png\" alt=\"image-20210707224711512\"></p>\n<p>最后，可以总结出SR协议为非累积式接收。</p>\n<hr>\n<h4 id=\"正常情况下的窗口互动\"><a href=\"#正常情况下的窗口互动\" class=\"headerlink\" title=\"正常情况下的窗口互动\"></a>正常情况下的窗口互动</h4><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224721902.png\" alt=\"image-20210707224721902\"></p>\n<h4 id=\"异常情况下的窗口互动\"><a href=\"#异常情况下的窗口互动\" class=\"headerlink\" title=\"异常情况下的窗口互动\"></a>异常情况下的窗口互动</h4><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224736296.png\" alt=\"image-20210707224736296\"></p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224827566.png\" alt=\"image-20210707224827566\"></p>\n<h4 id=\"用FSM描述的GBN\"><a href=\"#用FSM描述的GBN\" class=\"headerlink\" title=\"用FSM描述的GBN\"></a>用FSM描述的GBN</h4><ol>\n<li><p>发送方</p>\n<p>首先声明这些变量代表的含义：<code>N为窗口长度，base为窗口后沿，nextseqnum为满足发送条件但因缓冲区已满没有发送的分组序号</code>，</p>\n</li>\n</ol>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224840765.png\" alt=\"image-20210707224840765\"></p>\n<ol start=\"2\">\n<li><p>接收方</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224850680.png\" alt=\"image-20210707224850680\"></p>\n</li>\n</ol>\n<h4 id=\"运行中的SR\"><a href=\"#运行中的SR\" class=\"headerlink\" title=\"运行中的SR\"></a>运行中的SR</h4><p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224903011.png\" alt=\"image-20210707224903011\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>GBN适用于<code>出错率低</code>的场景，<code>而链路容量大，回退代价高</code>的场景则是SR更优。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224915038.png\" alt=\"image-20210707224915038\"></p>\n<h2 id=\"1-5-面向连接的传输——TCP\"><a href=\"#1-5-面向连接的传输——TCP\" class=\"headerlink\" title=\"1.5 面向连接的传输——TCP\"></a>1.5 面向连接的传输——TCP</h2><p>在对TCP有大致的纹路了解后，我们进入TCP正式的探索。本着结构决定功能的特点，从TCP的段结构起笔，渲染TCP的可靠数据传输，进而浓墨于流量控制机制，最终落笔于连接管理。</p>\n<p><code>TCP提供的是点到点，可靠的，管道化的，按序的字节流，拥有流量控制机制，面向连接的服务。</code></p>\n<h3 id=\"段结构\"><a href=\"#段结构\" class=\"headerlink\" title=\"段结构\"></a>段结构</h3><p>TCP的报文段由一个<strong>首部字段和数据字段</strong>构成，数据字段即是应用层的数据，那这部分数据是源数据根据怎样的规则划分的呢？这里引入<strong>最大报文段长度MSS</strong>的概念。TCP会将要传输的文件分为若干个MSS。<strong>MSS的长度</strong>通常由<strong>本地发送主机发送的最大链路层帧长度</strong>来设置。在确定数据部分后，TCP为每个客户端数据配上一个<strong>TCP首部</strong>，从而形成多个TCP报文段。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707224931500.png\" alt=\"image-20210707224931500\"></p>\n<p>具体来看每个字段：</p>\n<ul>\n<li><p><code>源端口号：</code>TCP提供的是进程之间的逻辑通信，而标识进程的即是端口号，标识源端口号就相当于给出了数据<strong>复用</strong>的路径。</p>\n</li>\n<li><p><code>目的端口号：</code>同样的，只有给出目的端口号，在接收方才能完成<strong>解复用</strong>的工作。</p>\n</li>\n<li><p><code>序号：</code>TCP把数据看做一个<strong>无结构，有序的字节流</strong>。而为了来标识每个报文段(<code>MSS</code>)的首字节在整个字节流中的位置，或者说偏移量，就引入了序号的概念。该序号的范围为<strong>2的32次方</strong>，可见冲突的几率比我中彩票还低~</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225012629.png\" alt=\"image-20210707225012629\"></p>\n</li>\n<li><p><code>确认号：</code>在可靠数据传输中，我们使用ACK来作为确认字段，但ACK只能表示接收方对接收到数据的回应，而实际的传输是全双工，且高并发的。所以接收方的确认号将<strong>确认与下一次传输的数据相结合</strong>作为确认号。也就是说，假设确认号为2000,即表示<strong>期望收到的下一个字节的序号</strong>，这里给出的序号同样也具有<strong>GBN累计确认</strong>的意义。</p>\n<p>我们试着使用序号与确认号来描述简化的传输过程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225024780.png\" alt=\"image-20210707225024780\"></p>\n<p>即主机A发送序号42及对于序号79的确认，主机B收到后，发送对于序号42的确认，即ACK=43，且发送主机A期望的79，即seq=79.</p>\n</li>\n<li><p><code>接收窗口：</code>该字段用于<strong>流量控制</strong>，即指示接收方愿意接受的字节数量，在抓包的时候任一数据发送源都会使用<strong>Win字段</strong>来告诉另一方自己接收窗口的大小。</p>\n</li>\n<li><p><code>CRC校验和：</code>在UDP部分谈及过，用于<strong>检错</strong>。</p>\n</li>\n</ul>\n<p>而从进程通信的<code>流程框架</code>来看，TCP报文段又会经历怎样的<strong>复用与解复用</strong>呢——</p>\n<p>在形成报文段以后，这些报文段被下传给网络层，网络层将其分别封装在<strong>网络层IP数据报</strong>中，接着被发送到网络中，TCP在另一端接收报文段，该报文段被放在该<strong>TCP连接的接收缓存</strong>中，应用程序从缓存中读取数据流。</p>\n<h3 id=\"可靠数据传输\"><a href=\"#可靠数据传输\" class=\"headerlink\" title=\"可靠数据传输\"></a>可靠数据传输</h3><p>了解了确认号与序号，可靠数据传输的纹路已经逐渐明晰。在学习通用的rdt时，我们谈及当一个分组丢失时，超时重传机制是有必要的，这在TCP的机制中同样适用。但在TCP的机制中，我们需要将超时重传的机制具象化，即真正高效地使用。</p>\n<p>如何来估计超时重传的往返时间？<strong>定时器RTO</strong>应该设置多长时间？是否需要为每一个分组都设置一个定时器呢？我们来渐进式地解答——</p>\n<ol>\n<li><p>显然，定时器设置的时间应该是<strong>大于往返时间RTT</strong>的，所以我们可以随机地选取某一个RTT作为<strong>SampleRTT</strong>,但由于路由器的拥塞和网络负载均衡的特点，SampleRTT波动是很大的，所以为了更趋近于真实RTT，我们引入SampleRTT的均值EstimatedRTT。通过这两个标量，可以近似得到这样的公式：<br>$$<br>EstimatedRTT=（1-a）•EstimatedRTT+a•SampleRTT<br>$$<br>这里的a推荐值为<strong>0.125</strong>，将通过公式得到的均值称为之<strong>指数加权移动平均</strong>。</p>\n</li>\n<li><p>这里直接给出公式——<br>$$<br>Timeoutinterval=EstinMrtedRTT+4•DevRTT<br>$$<br>这里的DevRTT是为了解决波动问题，而引入的一个SampleRTT与EstimatedRTT之间差值。</p>\n</li>\n<li><p>TCP并不会为每个分组都维护一个定时器，因为高并发的发送维护定时器的代价是很大的，因此TCP使用了<strong>单一重传定时器机制</strong>。即只为<strong>发送缓冲区中最古老的已发送未确认分组</strong>维护定时器。</p>\n</li>\n</ol>\n<p>至此，TCP可靠数据传输的自肖像已经变得丰满起来。我们不妨在已经构建框架的前提下给出一个最简化的TCP发送方——<br><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225039262.png\" alt=\"image-20210707225039262\">)</p>\n<p>即当超时定时器触发以后，发送方会传输<strong>至今没有得到确认的最小序号分组</strong>。即这里的机制又是类似于<strong>选择性重发SR</strong>。在重发后，超时定时器又会与当前没有得到确认的最小序号分组相关联。此外，还有一种情况，即缓冲区为空，即所有的分组都已得到确认，此时需要重启定时器。</p>\n<p>通过下图来看简要的交互：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225051029.png\" alt=\"image-20210707225051029\"></p>\n<p>另外，我们来穷举关于ACK的几种情况及相应的处理方式——</p>\n<table>\n<thead>\n<tr>\n<th><strong>接收方事件</strong></th>\n<th><strong>TCP接收方动作</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>所期望序号的报文段按序到达，期望序号之前的都已得到确认</td>\n<td>延迟的ACK，即对另一个按序报文段最多等待500ms</td>\n</tr>\n<tr>\n<td>有期望序号的报文段到达，另一个按需报文段等待发送ACK</td>\n<td>立即发送单个累积ACK，以确认两个按序报文段</td>\n</tr>\n<tr>\n<td>比期望序号大的报文段乱序到达，检测到数据流的间隔</td>\n<td>立即发送重复ACK，指明下一个期待字节的序号</td>\n</tr>\n<tr>\n<td>能部分或者完全填充接收数据间隔的报文段到达</td>\n<td>若该报文段起始于间隔的低端，则立即发送ACK</td>\n</tr>\n</tbody></table>\n<p>这个简化的TCP交互是默认不存在重复确认的，但实际上重复确认的情况是有可能出现的，TCP针对这种情况也给出了<strong>快速重传机制</strong>。</p>\n<p>收到<strong>重复确认</strong>往往是因为<strong>定时器设置的太大</strong>，接收方没有收到某个分组，但在定时器时间内仍会收到乱序到达的其他分组，这时接收方就会发送冗余分组，当发送方接收到<strong>三个冗余确认</strong>后，就会在定时期间<strong>重传最小序号的报文段</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225101991.png\" alt=\"image-20210707225101991\"></p>\n<p>再来看下快速重传的伪代码——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225112511.png\" alt=\"image-20210707225112511\"></p>\n<p>即接收方收到ACK，判断ACK与窗口后沿的关系，假如<strong>ACK大于窗口后沿，则将窗口后沿滑动</strong>，将<strong>定时器与新的报文段关联</strong>。否则，也就是ACK重复的情况，则记录ACK重复的个数，当其等于3时，触发快速重传机制。</p>\n<h3 id=\"流量管理\"><a href=\"#流量管理\" class=\"headerlink\" title=\"流量管理\"></a>流量管理</h3><p>传输层在将数据解复用以后，不是直接交付给应用程序使用，而是将其放置在<strong>接收缓冲区</strong>内，上层应用再<strong>从缓冲区中读取数据</strong>。但当从发送方发送来的数据太多就有可能<strong>淹没接收缓冲区</strong>，导致报文段丢失，因此，约定发送方的发送速率与接收方的接收速率是必须的，这种<strong>为了匹配速率的机制就称为流量控制</strong>。</p>\n<p>流量控制机制是通过互相告知缓冲区可用空间来实现的。那如何告知呢？即是通过接收方向发送方发送的报文段中的<strong>rwnd字段</strong>，它表示了<strong>接收缓冲区中可用的空间</strong>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225128655.png\" alt=\"image-20210707225128655\"></p>\n<p>我们将rwnd再具象化，即它是通过什么来实现的呢？接收窗口！！！但这里的接收窗口和rdt中的接收窗口还是有所区别的。为了量化接收窗口的大小，我们还需要引入两个变量：</p>\n<ul>\n<li><code>LastByteRead</code>:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。</li>\n<li><code>LastByteRcvd</code>:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。</li>\n</ul>\n<p>那么接收窗口就可以表示为：<br>$$<br>rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]<br>$$</p>\n<h3 id=\"连接管理\"><a href=\"#连接管理\" class=\"headerlink\" title=\"连接管理\"></a>连接管理</h3><p>我们来深入了解如何建立和拆除一个TCP连接，首先，我们需要建立一些共识，也就是连接都需要做什么？</p>\n<p>在socketAPI的编程中，我们需要维护两个套接字，即连接是针对双方而言的，<strong>每一端可以看做维护一个半连接</strong>，所以在建立TCP连接时，两端都有<strong>告诉对方我要建立连接</strong>的诉求。除此之外，还需要<strong>为连接配置资源</strong>，因为连接就意味着马上会有数据传输，所以<strong>缓冲区自然是需要</strong>的，此外，<strong>序号和确认号也是必选项</strong>咯。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>好啦，实际地去建立连接时，首先先入为主的想法是两次握手——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225141658.png\" alt=\"image-20210707225141658\"></p>\n<p>但两次握手面临着很多问题：</p>\n<ul>\n<li>假如接收方的确认超时了，此时发送方会重发连接建立请求。但我们注意到<strong>接收方的机制简言之就是收到连接请求则同意建立</strong>。也就是说，虽然确认超时了，但接收方仍会维护一个<strong>半连接的状态</strong>及对应的资源。</li>\n<li>在上面状况的基础上，假如发送方接收到确认后，发送数据data，而接收data的接收方的状态为新的连接，那么此时<strong>新的连接接收的是老连接的数据</strong>。</li>\n</ul>\n<p>这些问题的症结本质上是<strong>半连接的孤立</strong>，那么如果<strong>在双方半连接的基础上增加两个半连接的交互</strong>，那问题就迎刃而解了。三次握手就是基于这样的思想实现的。我们来详细剖析三次握手的详细过程——</p>\n<ol>\n<li><p><code>第一次握手：</code>客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中<strong>不包含应用层数据</strong>。但是在报文段的首部中的一个标志位（即<strong>SYN</strong>比特）<strong>被置为1</strong>。因此，这个特殊报文段被称为<strong>SYN报文段</strong>。另外，客户会<strong>随机地选择一个初始序号</strong>（client_isn）,并将此编号放置于该起始的TCPSYN报文段的序号字段中。</p>\n</li>\n<li><p><code>第二次握手：</code>服务器会从该数据报中提取出SYN报文段，为该TCP连接<strong>分配TCP缓存和变量</strong>，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段<strong>也不包含应用层数据</strong>。但是，在报文段的首部却包含<strong>3个重要的信息</strong>。</p>\n<ol>\n<li>SYN比特被置为1。</li>\n<li>TCP报文段首部的确认号字段被置为<strong>client_isn+I</strong></li>\n<li>服务器选择自己的初始序号（<strong>serverjsn</strong>）,并将其放置到TCP报文段首部的序号字段中。这个允许连接的报文段实际上表明了：<strong>“我收到了你发起建立连接的SYN分组，该分组带有初始序号clientjsno我同意建立该连接。我自己的初始序号是serverjsnon</strong></li>\n</ol>\n<p>该允许连接的报文段被称为<strong>SYNACK报文段</strong>.</p>\n</li>\n<li><p><code>第三次握手:</code>在收到ACK报文段后，客户也要给该连接<strong>分配缓存和变</strong>量。客户主机则向服务器发送另外一个报文段；这最后一个报文段<strong>对服务器的允许连接的报文段进行了确认</strong>（该客户通过<strong>将值serverjsn+1放置到TCP报文段首部的确认字段</strong>中来完成此项工作）。因为连接已经建立了，所以该<strong>SYN比特被置为0</strong>。该三次握手的第三个阶段可以在报文段<strong>负载中携带客户到服务器的数据</strong>。</p>\n</li>\n</ol>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225201937.png\" alt=\"image-20210707225201937\"></p>\n<p>嗯，熟悉的FSM环节——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225214552.png\" alt=\"image-20210707225214552\"></p>\n<hr>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>天下没有不散的宴席。TCP连接也不能免俗。相比于三次握手，四次挥手还是水到渠成的，双端都可以主动发起断开连接的请求，然后<strong>双方断开自己维护的半连接</strong>即可，同样的，我们来复现这个过程——</p>\n<ol>\n<li>客户端进程向服务器进程发送一个特殊的报文段，该报文段中首部标志位<strong>FIN置1</strong>；</li>\n<li>服务器接收该报文段后，<strong>其ACK比特置1</strong>.</li>\n<li>反向同理。</li>\n</ol>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225225357.png\" alt=\"image-20210707225225357\"></p>\n<h2 id=\"1-6-拥塞控制原理\"><a href=\"#1-6-拥塞控制原理\" class=\"headerlink\" title=\"1.6 拥塞控制原理\"></a>1.6 拥塞控制原理</h2><hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在rdt可靠数据传输机制中，分组丢失是不可避免的，而<strong>分组丢失的原因通常是由网络拥塞</strong>，当路由器的缓存被占满后，后来者将会别抛弃，本质上说这种状况是因为网络是不可控的，很难从端系统获知网络的状况，但发送方又本着<code>多多益善</code>的方式在加剧网络的恶化。</p>\n<p>为了避免网络拥塞，TCP使用了怎样的机制，这种处理机制出发点是什么，它针对性地解决了哪些问题，如此种种。要解决这些问题，我们仍要铺好第一块砖石——</p>\n<p><code>网络拥塞的定义</code>：太多的数据需要网络传输，超过了网络的处理能力。</p>\n<h3 id=\"拥塞原因与表现\"><a href=\"#拥塞原因与表现\" class=\"headerlink\" title=\"拥塞原因与表现\"></a>拥塞原因与表现</h3><p>这里我们仍使用渐进式分析问题的思想，一个不会发生分组丢失的网络是怎样的呢？</p>\n<ul>\n<li><p><code>路由器缓存无限大</code></p>\n</li>\n<li><p><code>端系统可以了解网络的状况并作出调整。</code></p>\n</li>\n<li><p><code>所有分组都可以不超时的到达，所以不需要重传</code></p>\n</li>\n</ul>\n<p>先来看路由器缓存，假设路由器缓存无限大，那分组就不会被丢弃。这时假设有两个发送端通过一条链路(带宽为R)发送数据，那么它的吞吐量和延时表现为这样——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225238081.png\" alt=\"image-20210707225238081\"></p>\n<p>可见，即便在理想状态下，当超出链路的承载能力后，<code>流量强度变大，排队延时激增</code>。硬件条件这是不可逾越的天花板。所以我们很难控制不发生拥塞，而要从拥塞发生后的处理技巧入手。</p>\n<p>接着，我们去掉缓存无限的假设，这时分组丢失就变得无可避免，分组丢失就意味着重传，而<code>重传导致链路中重复的分组</code>，也就是不必要的分组增多，直接使得<code>发送方比接收方更高的发送速率</code>，导致本就不宽裕的链路带宽更显的捉襟见肘。另外，超时重传作用的结果也是一样的。</p>\n<p>最后，我们设想在类似<code>进程发生死锁</code>的一种情景，每个发送方占用着别的发送方需要的链路带宽，而别的进程也占用着自己需要的链路带宽，如果人的欲望一般，我们知道这条路是错的，但贪念仍在驱使着躯干向前。</p>\n<h3 id=\"拥塞控制的方式\"><a href=\"#拥塞控制的方式\" class=\"headerlink\" title=\"拥塞控制的方式\"></a>拥塞控制的方式</h3><p>针对上面的状况，一般采用两种控制拥塞的方法——</p>\n<ul>\n<li><code>端对端的拥塞控制：</code>TCP就使用这种策略。端系统根据<code>延迟和丢失事件</code>推断是否有拥塞。</li>\n<li><code>网络辅助的拥塞控制：</code>路由器通过<code>置位</code>的方式显示的告诉发送端可以采用的速率。</li>\n</ul>\n<p>来通过实际的<strong>ATM ABR场景</strong>认识下这两种方式是怎样实际运转的：</p>\n<p>我们知道，在网络中传输的数据粒度是有区别的，专线更多使用线路交换的方式，而通用的则是分组交换的方式，这种在银行中大行其道的ATM ABR线路则使用数据粒度<code>介于线路交换和分组交换的粒度大小</code>，更具体地说，它传输的最小单元是<code>53个的比特</code>。</p>\n<p>**ABR(available bit rate)**提供的是弹性服务，它可以<code>根据网络的负载实时调整发送速率</code>。如果发送方路径轻载，则发送方就使用尽可能多地利用贷款。如果发送方路径阻塞，发送方限制速率至一个最小保障速率。</p>\n<p>那网络中的拥塞状况是如何被获知的呢？通过RM信元，即<strong>资源管理信元</strong>。</p>\n<p>它由发送端发送，在数据信元中间隔插入，通过该信元特定的比特位来作为网络辅助，这种行之有效的比特位分别是：</p>\n<ul>\n<li><code>NI bit:</code>即no increase in rate。</li>\n<li><code>CI bit:</code>即congestion indication拥塞指示。</li>\n</ul>\n<p>发送方发送的RM信元被接收方返回，<code>接收方仅用作中转</code>使用。另外，之前谈及信元可以返回给发送方最小发送速率，这是如何实现的呢？</p>\n<p>通过RM信元中的2个字节<code>ER(explicit rate)字段</code>.拥塞的交换机会降低ER的值，最终返回给发送方。</p>\n<hr>\n<h2 id=\"1-7-TCP拥塞\"><a href=\"#1-7-TCP拥塞\" class=\"headerlink\" title=\"1.7 TCP拥塞\"></a>1.7 TCP拥塞</h2><p>在上一小节中，我们聊了通用的拥塞控制机制，也就是：<strong>端系统处理</strong>，<strong>网络辅助的拥塞控制</strong>。同时对网络辅助的案例做了简单描述，这一小节，我们将展开讲述在端系统如何处理拥塞。</p>\n<p>更具体地说，是<strong>TCP的拥塞控制机制</strong>。而在开始之前，我们先解决一个前置问题：TCP<code>为什么不在网络核心通过使用辅助信元的方式实现拥塞控制</code>。其实，纵观整个网络架构，复杂性都是在传输层及其以上提供的，也就是说，<code>网络层不会向上层应用提供显式的拥塞控制机制</code>。</p>\n<p>那TCP的拥塞控制机制是怎样实现的呢？不着急，本着先有问题，再有方案的思路，我们先来回答TCP拥塞机制面临的<strong>三大问题</strong>——</p>\n<ul>\n<li><p><code>如何感知到拥塞</code></p>\n<p>网络拥塞的最终结果是分组丢失，而导致分组丢失的原因却有一些区别——</p>\n<ol>\n<li>假如到达路由器的分组过多导致缓冲区已满，<strong>分组就会被丢弃</strong>。此外，有可能分组在传输时比特反转，接收方认不出来这是啥，那也会将其丢弃。这两种情况的直观表现都是超时，这种<code>拥塞情节严重</code>，发送方明显被动。</li>\n<li>当发送方连续收到4个ACK信号，也就是<strong>3个冗余ACK</strong>时，就会触发快速重传机制，这时还没有超时，发送方主动出手降低损失，姑且称其<code>轻微拥塞</code>。</li>\n</ol>\n</li>\n<li><p><code>如何对速率做调整</code></p>\n<p>那明确了问题，如何针对两种拥塞做出发送速率的调整呢？在<strong>RDT</strong>中，我们引入<code>接收窗口rwnd</code>来限制接收分组，这里我们也采用类似的机制，引入<code>拥塞窗口cwnd</code>。类比接收窗口表示能够接收分组的上限，拥塞窗口表示的即是——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225253295.png\" alt=\"image-20210707225253295\"></p>\n<p>是不是似曾相识，发送窗口表示的是<strong>实际的</strong>已发送未确认的分组数量。而拥塞窗口就如同在对发送窗口做<strong>动态调整</strong>，除此之外，别无二致。那确定了拥塞窗口的值，发送方的发送速率也可以得出来——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225302111.png\" alt=\"image-20210707225302111\"></p>\n</li>\n<li><p><code>通过怎样的算法对速率做调整：</code></p>\n</li>\n</ul>\n<p>有了衡量拥塞的标志，接下来就需要通过拥塞状况触发动态调整啦，这里的动态调整，就是广受赞誉的<strong>TCP拥塞控制算法</strong>。</p>\n<p>该算法分为三部分：慢启动，拥塞避免，快速恢复。我们详细来聊聊——</p>\n<ul>\n<li><p><code>慢启动：</code></p>\n<p>TCP会将cwnd的值<code>初始化为一个2/3/4MSS</code>(具体由MSS的大小决定)的值，但显然，这点速率是不够打的，所以当分组首次被确认后，会以<code>指数级的增长趋势</code>尽快加速，直至超时后打回原形，也就是1个MSS.这时，TCP还会维护一个<strong>慢启动阈值</strong>，也就是警戒值，它的值为<strong>cwnd(max)/2</strong>，接着，开始下一次拥塞控制，当cwnd的值指数增加至慢启动阈值后，不再鲁莽地指数级增长，而是维持<code>线性增长</code>。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225311975.png\" alt=\"image-20210707225311975\"></p>\n<p>这种线性增长的机制就是拥塞避免——</p>\n</li>\n<li><p><code>拥塞避免：</code></p>\n<p>那拥塞避免什么时候结束呢？和慢启动一样，拥塞避免阶段在触发超时后会重新开始SS慢启动阶段,这时，慢启动的阈值也势必会更新。</p>\n<p>再来讨论下发送方收到<strong>3个冗余ACK</strong>的状况——</p>\n<p>它的处理机制显然没必要像拥塞时那么剧烈，只需要在触发快速重传后，记录慢启动阈值，然后<code>直接从阈值开始线性增加</code>进入快速恢复阶段——</p>\n</li>\n<li><p><code>快速恢复：</code></p>\n<p>所谓的快速恢复无非是针对两种拥塞状况的不同种处理，在上面已经提及，就不再赘述。</p>\n<ol>\n<li>超时重传：RFC建议将拥塞窗口降至1个MSS，而由慢启动过渡至拥塞窗口的值就有讲究了，应该调整至没别确认的数据量的1/2,但不能小于两个MSS</li>\n<li>快速恢复：不会处理拥塞窗口的值；</li>\n</ol>\n</li>\n</ul>\n<p>接下来就是小总结环节——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225324365.png\" alt=\"image-20210707225324365\"></p>\n<p>再将两种情况汇总，就有了下图——</p>\n<p><img src=\"C:\\Users\\zyz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210304182714108.png\" alt=\"image-20210304182714108\"></p>\n<h3 id=\"TCP吞吐量\"><a href=\"#TCP吞吐量\" class=\"headerlink\" title=\"TCP吞吐量\"></a>TCP吞吐量</h3><p>这里我们取快速恢复阶段的数据量均值作为参考(慢启动指数级的增加实则很快，也导致实际传输的流量不多)，即——<br>$$<br>一条连接的平均吞吐量=3/4<em>W/RTT<br>$$<br>另外也给出在<code>经过高带宽TCP，且丢包率为L的情况</code>下，吞吐量的描述——<br>$$<br>一条连接的平均吞吐量：1.22</em>MSS/RTT/根号下2<br>$$</p>\n<h3 id=\"TCP公平性\"><a href=\"#TCP公平性\" class=\"headerlink\" title=\"TCP公平性\"></a>TCP公平性</h3><p>太饿了，去吃饭，偷懒一手——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707225338648.png\" alt=\"image-20210707225338648\"></p>\n<p>也就是多个TCP连接时，网络状况会趋向于<code>带宽均分</code>。</p>\n<p>而如果一个链路中既有使用TCP的服务，也有使用UDP的服务，那对于TCP是不友好的，因为<code>UDP百无禁忌</code>，它没有拥塞控制机制，如果有可能，UDP会一点点的蚕食掉带宽，而最终导致更恶劣的后果，可见，<strong>不限制贪欲最终会陷入恶性循环</strong>。但这种机制也并非一无是处，流媒体就表示这是我的菜，因为<code>音视频应用起码泵出数据的速率是恒定</code>的，即便数据会丢失。</p>\n<hr>\n<h2 id=\"抓包番外\"><a href=\"#抓包番外\" class=\"headerlink\" title=\"抓包番外\"></a>抓包番外</h2><h3 id=\"简单的代价——UDP\"><a href=\"#简单的代价——UDP\" class=\"headerlink\" title=\"简单的代价——UDP\"></a>简单的代价——UDP</h3><h3 id=\"DNS那些事\"><a href=\"#DNS那些事\" class=\"headerlink\" title=\"DNS那些事\"></a>DNS那些事</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232028231.png\" alt=\"image-20210506232028231\"></p>\n<p>DNS常用的<strong>应用场景</strong>有两种：</p>\n<ul>\n<li><p><code>CNMAE:</code>即将一个域名映射到另一个域名，</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234636802.png\" alt=\"image-20210506234636802\"></p>\n</li>\n<li><p><code>A：</code>请求获取域名对应的IP地址</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506234517700.png\" alt=\"image-20210506234517700\"></p>\n</li>\n</ul>\n<p>当DNS在缓存中没有找到要查询的记录后，就会发起<strong>DNS查询</strong>，查询有两种：递归查询，迭代查询。假如我们向一个<code>不权威的DNS服务器发起递归查询请求</code>，我们只会与这个不权威的DNS服务器交互，而<code>无从得知它的查询结果是否可靠</code>。迭代查询则会相对安全一些，因为客户端首先会查到根服务器的地址，再从根服务器查到权威服务器，然后从权威服务器查询。。。直到返回想要的结果。</p>\n<p>它的<strong>响应</strong>一般包含这些字段：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235701873.png\" alt=\"image-20210506235701873\"></p>\n<p>再来聊一些生僻的：<strong>DNS循环工作模式</strong>——</p>\n<p>假如某个网站有10台Web服务器，管理员可以在DNS创建10个同名记录指向这些服务器的IP，由于不同客户端查到的结果顺序不同，而且一般会选用结果中的第一个IP，所以大量客户端就会被均衡的分配到10台Web服务器上，也就是<code>负载均衡</code>咯。</p>\n<p>再来说说<strong>DNS的缺点</strong>，为人所知的<code>DNS放大攻击</code>就是缺陷之一，假如有这样的场景：我们由包发出去的请求只有少许字节，但收到的回复却高达几千字节，这种情况非常值得我们警惕。</p>\n<h3 id=\"老生常谈的TCP\"><a href=\"#老生常谈的TCP\" class=\"headerlink\" title=\"老生常谈的TCP\"></a>老生常谈的TCP</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506235956824.png\" alt=\"image-20210506235956824\"></p>\n<p>这个包抓的还是<code>恰如其分</code>的，它完美的涵盖了三次握手与四次挥手的7个包，同时出现的<code>乱序问题</code>也印证了TCP的强大之处。接下来我们分别从三次握手和四次挥手来分析它的细节——</p>\n<p><strong>三次握手</strong>：</p>\n<ul>\n<li><p><code>SYN报文段</code></p>\n<p>在这个帧中，包含了Seq,Win，Len等字段，显然<code>Seq表示随机选择的报文段的初始字节偏移量</code>，而Win就比较有意思了，我们可能更熟悉它的另一个名称：rwnd，也就是说<code>Win就是接收窗口的大小</code>，只不过描述字段有区别，至于Len字段，见名知意，它描述了报文段的长度，但这并不包含报文头部的长度，所以<code>Len为0只能说明没有数据传输</code>。</p>\n</li>\n<li><p><code>SYN/ACK报文段：</code></p>\n</li>\n</ul>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507092224812.png\" alt=\"image-20210507092224812\"></p>\n<p>显然，TCP报文段（一个MSS长度）的<code>头部包含32个字节</code>，而我们常说的<code>XX报文段其实就是通过置位来标识</code>的。</p>\n<ul>\n<li><p><code>ACK报文段</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093012217.png\" alt=\"image-20210507093012217\"></p>\n<p>我们试图再发现一些新颖的事物，在这个窗口我们看到<code>一个包被接口过滤器（网口）收到的完整过程</code>，它依次经历了物理层，数据链路层，网际层，传输层。</p>\n</li>\n</ul>\n<p><strong>四次握手</strong></p>\n<ul>\n<li><p><code>SYN/ACK报文段：</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093632419.png\" alt=\"image-20210507093632419\"></p>\n<p>显然，在发送该报文段后<code>不再发送数据，但仍然可以接收数据</code>。</p>\n</li>\n<li><p><code>ACK报文段</code></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507093904412.png\" alt=\"image-20210507093904412\"></p>\n<p>显然，ACK包乱序了，但它仍可以被接收，这依赖于<code>TCP的累计确认</code>，也就是说TCP只关心发送的最古老的的那个包有没有被收到，如果<code>有乱序的包到达，它会将其放置在接收窗口而不给与确认</code>，在收到最古老的的那个包后，它会接收该包并累计确认，应用层再从接收窗口中读取这些包。</p>\n</li>\n</ul>\n<p>最后再来看一个非常有用的命令：<strong>netstat</strong></p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210507095047707.png\" alt=\"image-20210507095047707\"></p>\n<p>这是我使用netstat命令陈列出来的TCP连接状态，我们发现有这样几种状态：</p>\n<ol>\n<li><p>TIME_WAIT:</p>\n<p>TIME_WAIT又称<code>2MSL状态</code>(报文段最大存活时间)，被动关闭方在收到FIN并回复ACK后会进入该状态，它的作用主要有两个：</p>\n<ol>\n<li><p>允许老的重复报文分组在网络中消逝，<code>避免新连接接收老连接的数据</code>。</p>\n</li>\n<li><p>保证TCP全双工连接的正确关闭，<code>避免RST拒绝服务</code>。</p>\n</li>\n</ol>\n</li>\n<li><p>ESTABLISHED:</p>\n<p>表示<code>数据传输正在进行</code></p>\n</li>\n<li><p>CLOSE_WAIT</p>\n<p>正常状态，会<code>很快转化为LAST_WAIT</code>,只出现在被动关闭方。</p>\n</li>\n</ol>\n<h3 id=\"历久弥新的HTTP\"><a href=\"#历久弥新的HTTP\" class=\"headerlink\" title=\"历久弥新的HTTP\"></a>历久弥新的HTTP</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210506232400891.png\" alt=\"image-20210506232400891\"></p>\n<hr>\n<blockquote>\n<p>山高路远，静水深流</p>\n</blockquote>\n"},{"title":"进程与线程","top":true,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-11T12:32:04.000Z","password":null,"summary":"起笔自多进程图像，接着娓娓道出轻量级进程，即线程，然后着眼进程间如何切换，最后落笔于进程间的合作","_content":"\n# 一、多进程图像的引出\n\n## 1.多进程图像\n\n多个进程同时存在于内存，可能会出现前一个进程的地址中的内容被第二个进程更改。这样显然是不合理的。\n\n我们首先会想到，是否可以设置**DPL**的值，也就是将其设置为**特权级别**，这样进程之间就不能互相访问了，但这里忽略了一个问题，DPL的设置是针对**操作系统**而言的，进程的DPL都等于3，即**用户级权限**，依然可以互相访问，所以这种解决方式的思路是错误的。\n\n那如何保证进程间不冲突呢？直观的解决方式，就是给进程**上锁**，限制对**内存地址的读写**。\n\n**映射表**就是实现限制访问的那个利器。映射表的思路即是利用**虚拟内存**实现**地址分离**。\n\n说到这里，我们发现，所谓的多进程图像，不单单是进程的管理，还涉及到内存的管理。\n\n### 多进程如何合作\n\n先看下面的例子——\n\n假设有一段空闲的内存空间，两块进程都想利用这块内存空间，这样有可能会出现一块内存空间出现**两个不完整的进程片段**，也就是说，进程间是可以互相合作的，但合作的方式需要被协调。\n\n那怎样协调呢，纸上得来终觉浅，要想觉知此事，不妨理解**生产者-消费者实例**——\n\n> 生产者不断的产生数据放入缓冲区，而消费者从缓冲区中取出数据进行处理，当缓冲区已满的时候，生产者阻塞，当缓冲区为空的时候，消费者阻塞\n\n我们会使用三种方式来实现生产者-消费者问题——\n\n在下文的进程同步中会提及。。。\n\n# 二、线程的引出与实现\n\n从上一节我们知道多进程是操作系统的最基本，最核心的图像，多进程可以被组织，合作与切换。\n\n多进程的组织是通过**状态与队列**来实现的\n\n那么多进程是如何被**切换**的呢？且听我娓娓道来——\n\n------\n\n## 1.用户级线程\n\n### 线程的引出\n\n既然我们要了解的是进程间的切换，那为什么学习的却是线程呢？\n\n首先我们先来看宏观上的进程切换：一个**进程**，也就是**指令执行序列**+**资源**，在发生外中断后，切换到另一个进程。在这期间，指令访问的内存地址是通过**映射表**来获取的。这个切换是由中断引起的，因而会进入内核态，会涉及到**资源的分配**。而资源的分配是浪费时间的，那么为了提高进程执行的效率，能否将资源与指令的**执行分离**开，实现不动资源而只切换指令序列呢？——\n\n我们来看直观的表述——\n![image-20210619010326080](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010326080.png)\n\n\n\n这样就引出了轻巧级的进程——**线程**。\n\n### 线程的价值\n\n要回答**线程**是否实用，也就是要回答**多个执行序列+一个地址空间**的思想是否实用。\n\n我门来看下面的例子——\n\n![image-20210619010341740](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010341740.png)\n\n这个网页呈现出来的是，首先文字被加载出来，接着图片被加载，最后全部内容都展示了出来。\n\n实际上它的程序执行流程是多个线程从**浏览器的缓冲区**中读取**同一份资源**，程序执行展示文本的线程时，在此期间切换到展示图片的线程，过一段时间又切换回来，给用户更好的体验。\n\n这里我描述的比较**生涩**，其实多线程的执行，一言以蔽之，其实就是编程时**多条线路并发执行**：\n\n### 线程的切换\n\n开局一张图：\n\n![image-20210619010356747](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010356747.png)\n\n可以看出，这里线程间的切换是通过一个叫做**Yield**的函数来实现的，所以我们的**核心**就在于写出yeild函数的实现——\n\n要完成切换，就要保存上一个线程的状态，状态的保存是依赖栈来实现的，我们先从两个执行序列与一个栈讲起——\n\n#### 两个执行序列与一个栈\n\n![image-20210619010411788](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010411788.png)\n\n这张图到底表达了什么意思呢？\n\n在函数B中调用Yield函数，这时需要将程序B的下一条指令的地址压栈，跳转后，在C函数中调用了D函数并压栈，在D函数中调用Yield函数，此时我们需要跳转204的位置，跳转后，PC指针指向了地址204，接着往下执行，遇到**}**后，弹栈并跳转，然后程序指针跳到404处。\n\n嗯哼，是我剧本拿错了吗？的确，就是这么戏剧性，我要的是**弹栈104**并跳转，可没想调回**404**啊，死循环。。。\n\n那么这是为什么呢？因为我们**共用了一个栈**！！！\n\n所以我们很自然的需要从**一个栈**过渡到了**两个栈**。\n\n#### 两个执行序列与两个栈\n\n![image-20210619010426291](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010426291.png)\n\n现在线程切换的时候，首先yield函数需要切换栈，这里就需要一个能够保存当前线程栈状态的**容器**，也就是**TCB**。\n\n我们最后在执行yield函数时，首先切换TCB，然后Yiled函数结束，继续往下执行**}**,也就是执行**ret指令**\n\n弹栈执行104，一个线程切换就这样有惊无险的完成了。\n\n- [x] 这里不需要jmp 204,因为Yield函数执行完后，就会**默认往下顺序执行**。\n\n完成了两个栈，我们再将包含线程切换的**ThreadCreate**函数做初始化，并在其中关联**TCB与栈**。\n\n这样，一个完整的进程就有了——\n\n![image-20210619010441251](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010441251.png)\n\n------\n\n说到这里，我们就可以来回答这个小结为什么叫用户级线程，因为**field是用户级应用程序**。\n\n整个用户级线程可以实现有序的切换了，那么为什么还要内核级线程呢？当然是因为它有其天生的**限制**，而从另一个角度来说，核心级线程是用户级线程的**扩展**。\n\n### 用户级线程的缺点\n\n当用户级线程在执行指令过程中发生中断，系统会切换到内核态，然后执行中断程序，在执行完后，因为权限已经改变，**无法切换回用户级线程**，用户级线程不再执行。\n\n## 2.内核级线程\n\n我们首先来回顾一下**内核级线程的切换**——\n\n![image-20210619010458893](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010458893.png)\n\n宏观的看，内核级线程由用户级线程的两个栈演变成了两套栈，它的的实现机制大致分为五步——\n\n1. 用户栈通过**int中断指令**跳转到内核栈\n2. 在内核栈中存储当前内核线程的状态，而内核栈又由**线程控制块TCB1**维护\n3. 通过**Schedule函数**完成内核级线程跳转\n4. 在内核栈中存储当前内核线程的状态，而内核栈又由线程控制块TCB2维护\n5. 由内核栈跳转回用户栈\n\n下面我们将具体实现这个内核级线程：\n\n------\n\n这个故事首先从进入内核开始，也就是从某个**中断**开始，这里的系统调用案例我们选择**fork()**,fork()函数是用于创建进程的，而**进程**实质上是**资源+指令序列**，**指令序列**就是一系列的**线程**，所以我们使用fork函数，是可以完成内核级线程的切换的。\n\n我们来看下面的例子——\n\n### 中断入口\n\n![image-20210619010514141](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010514141.png)\n\n在main函数中调用了A函数，之后在A函数的执行中又调用了fork系统调用，fork系统调用会引起中断，在触发中断处理程序时，首先会将之前用户态的栈进行保存，也就是将SS,SP压栈，接着跳转fork的中断处理程序，也就是**system_call函数**——\n\n![image-20210619010528293](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010528293.png)\n\n在system_call中，首先会做寄存器的压栈，也就是**准备切换**，然后跳转sys_fork系统调用**开始切换**，在这个系统调用中，首先将当前线程的**TCB置给ex**，接着判断ex的状态，本质上是判断**TCB**的state**，如果**非0**的话，也就是处于**阻塞状态**。就需要执行schedule以完成**切换**，此外，当**时间片用完**以后，也需要进行切换。\n\n### 中断出口\n\n完成了切换，那怎样返回呢？通过**中断出口**，那中断出口做了什么呢？对应中断入口一系列的入栈，中断出口会做弹栈操作。\n\n![image-20210619010541971](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010541971.png)\n\n我们描述了中断入口和中断出口，那在中断的过程中做了什么事情呢？\n\n在中断中首先找到要切换的线程，再**切换**到该线程。这里面会涉及到线程的调度与切换，线程的调度我们后面会提及，这里我们只看线程的切换——\n\n### 中断过程——线程切换\n\n线程的切换是通过**switch_to**来完成的，在函数中主要通过**长跳转**来实现线程跳转——\n\n![image-20210619010558855](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010558855.png)\n\n首先使用**movw指令**将CPU中寄存器的内容都写入到到**TSS**中，**TSS**也就是**任务结构段**，它是**进程控制块PCB**的一部分。\n\n首先通过**TR寄存器**(**类CS寄存器**)找到位于**GDT表**中的**TSS描述符**，即指向TSS段的指针，最终通过TSS描述符定位到TSS段。\n\n而**长跳转**做的无非就是通过TR寄存器找到另一个线程的TSS描述符，通过TSS描述符找到TSS段，并将寄存器中的的内容也加载到TSS段中。\n\n但以TSS的方式实现跳转的效率是低下的，因为TSS中的**长跳转**需要对一系列**寄存器**操作。之后我们将采用**KIN stack**的方式完成切换。\n\n> 参考linux进程切换与TSS结构https://blog.51cto.com/stonehorse/1113115\n\n------\n\n在上一小节的学习中，我们了解了线程的切换，接着我们将范围放大，来一起学习线程创建，即**ThreaCreate函数**\n\n首先从**sys_fork函数**开始我们的求知之旅——\n\n![image-20210619010627862](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010627862.png)\n\n在**sys_fork函数**中，首先将**用户态状态入栈**，以便子进程调用，接着在sys_fork函数中调用**copy_process**，可以看到这个函数的参数有一长串，细心观察的话，会发现都是**父进程压入栈中的内容**，也就是子进程和父进程是**共用**一套用户栈的。\n\n那么子进程创建的细节是怎样的呢？\n\n![image-20210619010642915](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010642915.png)\n\n首先**申请了一页**的内存空间，我们再来回顾一下它的渊源：开机时**memmap**初始化，将内存分以**4k**为最小单元的页，需要申请**内核空间**时，则选取memmap**不等于0的**的一页内存空间即可。\n\n接着**创建TCB,**也就是从申请的内存起始开始往后一页的这段内存空间。\n\n然后创建内核栈和用户栈，最终将**TCB与栈相关联**。\n\n最后，我们只需要完成一系列的初始化即可，这里面值得关注的是ip的初始化，也就是从栈中取出中断后下一条指令的内存地址，另外还需要eax初始化为0，那么eax有什么用呢？\n\n我们经常看到的一个判断：**if(!fork()){子进程执行}**,这里判断的条件即是**eax的值**，如果eax等于**0**，**子进程执行**，反之，父进程执行。\n\n明确了子进程的执行条件，我们来看子进程的具体执行的代码，也就是**exec系统调用**——\n\n![image-20210619010701378](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010701378.png)\n\n我们从父进程的**shell**进入子进程的执行，当子进程执行完后，需要返回，那它会**返回到哪里**呢？我们知道在跳转执行的结束，会执行指令**iret**，所以返回的地址取决于iret中**ret**指令弹栈的**IP寄存器**内容。那IP指向哪里呢？\n\n![image-20210619010718802](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010718802.png)\n\nIP指向的位置，或者说IP寄存器中地址取决于**struct_exec系统调用**的参数。在它的执行中，将ex寄存器中的**a.entry**方法的地址加载到ret中作为**IP**的指向地址，a.entry是**可执行文件的入口地址**，当它连接产生可执行文件时，会将文件中的内容，即磁盘中的内容**写入到**内存执行，子进程执行完毕！\n\n## 3.操作系统的那棵树\n\n> 系统调用就是一种软中断处理程序\n\n在这一小节中，我们不看学习新的内容，因为旧的内容还一团乱麻。所以我们有必要将之前的知识点**连点成线**，让它从**萌芽**开始，随时光浸淫，最终长成**参天大树**。\n\n即便操作系统这颗很庞大的参天大树也是要从一个很小的火光发散的。就如同李志军老师告诫我们的一样——\n\n> The mind is not a vessel that needs filling,but wood that needs ignitng\n>\n> 我们的大脑不是装满水的容器，而应该是点燃的火光。\n\n所以我们接下来的内容我们将从一个很小，很具体，很有价值的IDEA开始——\n\n- [x] 我们要在屏幕上交错出现A和B\n\n首先回顾一下线程切换的思路——\n\n- [x] **运转CPU**-》**CPU没有好好运转**-》**要让CPU好好运转，首先从A函数跳到B函数**-》**跳转时使用1个栈和1个yeild发生混乱**-》**试着使用两个栈和两个TCB**-》**这样可以运转没错，但只能在用户态运转是不合适的**-》**引入两套栈，即内核栈的切换**\n\n首先从**用户代码**开始——\n\n```c\nmain(){\n    if(!fork()){while(1)printf(\"A\");}\n    if(!fork()){while(1)printf(\"B\");}\n    wait();\n}\n```\n\n我们再将其用**汇编**来表述——\n\n```asm\nmain(){\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax,res\n\tcmp1,res,0\n\tjne 208\n200: printf(\"A\")\n\tjmp 200\n208: ...\n304: wait()\n}\n```\n\n接着复现执行**int 0x80**后的代码——\n\n```ASM\nmain(){\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax , res\n\tcmp1 res,0\n}\n\nset_system_gate(0x80,&system_call);\nsystem_call:\n\tcall sys_call_table(,%eax,4)\n```\n\n首先将**系统调用号**赋给**_NR_fork**，触发中断**0x80**，进入**system_call**，在该系统调用中，跳转**system_call_table**,将1赋给eax,也就是当前内核进程为**父进程**，在其中调用**sys_fork**——\n\n```ASM\nsys_fork:\n\tpush1 ..\n\tcall copy_process\n\tret\n```\n\n开始**创建子进程**，子进程的创建也就是对父进程的复制，即**copy_process**_\n\n```C\ncopy_process(... ,long eip,..){\n\tp = (PCB *)get_free_page();\n        p->tss.esp0 = p+4k;\n        p->tss.esp = esp;\n        p->tss.eax = 0;\n        p->tss.eip = eip;\n}\n```\n\n完成了**PCB的创建与初始化**，也就是完成了子进程的创建，接着**ret**返回到父进程，**iret**返回用户态。\n\n然后接着调用main函数，不断的**创建线程**，接着执行main函数，就到了**wait()函数**，它的具体实现是——\n\n```C\nsys_waitpid(){\n\tcurrent -> state = TASK_INTERRUPTTIBLE;\n        schedule();\n}\n```\n\n将当前线程的状态置为**阻塞**，开始切换——\n\n```C\nshedule(){\n    if((*p)->state == TASK_RUNNING &&  (*p)->counter > c)\n        \tc = (*p) -> counter,next = i;\n    \t   ...\n               switch_to(next);\n}\n```\n\n如果当前状态为运行态，使用**调度算法**得到**要切换的线程**，进入切换——\n\n切换以后，就可以打出B了，但我们需要的是交替执行，所以要从B再进入A，也就是要完成切换，而切换是在内核态完成的，而用户态需要使用中断才能进入内核，那使用哪个中断呢？\n\n**时钟中断**！！！\n\n```c\nvoid sched_int(void){\n    set_intr_gate(0x20,&timer_interrupt)\n}\n\nvoid  _time_interrupt:\n\tcall do_time\n        \nvoid do_time(...){\n        if((--current -> counter >0)) \n            return ;\n        current -> counter = 0;\n        schedule();     \n }\n```\n\n将**中断类型码**赋给系统调用**time_interrupt**,在其中跳转**do_time**,在do_time中判断当前线程的数目，如果**大于0**，**不切换**，否则调用schedule切换线程。\n\n最终在**schdule**中调用**switch_to**。不断循环，完结~\n\n# 三、 CPU调度\n\n在上面的描述中，一个线程的切换就这样丝滑地完成了，但我们总将CPU调度刻意的当做一个黑盒子，这是因为CPU调度的确是一个很揪心的任务，但了解它又能加深我们对系统设计设计的理解，因此，这节内容，我们就明知山有虎，偏向虎山行了——\n\n------\n\n## 1.cpu调度策略\n\n当一个线程阻塞后，就要切换到另一个线程，那应该切换到哪一个线程呢？直观的说，我们需要**尽可能快**的完成任务。那如何衡量任务执行的效率呢？就连任务本身都有不同的类型，比如**I/O型**，**CPU型**，按照不同的分类角度，又有**前台型任务**和**后台型**任务。\n\n我们只捉住它**关键**的几个点来设计一个调度算法——\n\n1. **周转时间短**，从任务进入到任务结束，也就是尽可能快的完成任务。**周转时间=等待时间+运行时间**。\n2. **响应时间短**，即从操作到响应的时间短\n3. **系统内耗少**，即系统吞吐量大，执行任务多\n\n我们来看符合某些点的具体的算法思想，并用上面的**指标**来衡量它：\n\n### FCFS\n\n先来先服务是最直观的调度算法，但一个系统是复杂的，仅考虑到公平只会事倍功半。\n\n假设有n个任务，每个任务的周转时间分别为Ti，则它的**平均响应时间**为**：T1+T2+T3+Tn/n**,它的第**n个任务的响应周转**为**T1+T2+T3+...+Tn**，假如说T1的时间比其他时间的加和还要大，这样显然周转时间有可能很长，非常**不合理**。\n\n那能否在FCFC调度算法的前提下，根据任务的长短来决定执行的顺序呢？那我们来了解一下SJF——**短作业优先调度算法**\n\n### SJF\n\n假设有n个任务，按短作业优先的原则，调度的结果分别是：**P1,P2,P3...Pn**,则它总的周转时间为**n*P1+(n-1)*p2+....**，这样它的周转时间显然得到显著的降低。\n\n但假如我现在有一个很长的作业，但它又非常紧急，我是不是应该适当的根据优先级来调整执行的顺序呢？这就要谈及RR——**轮转时间片调度算法**。\n\n### RR\n\n时间片轮转的思想是将作业再**细分**，然后CPU为每个作业分配**时间片**，接着来**交错**地执行任务的最小单元。\n\n但这里同样面临问题，假如**时间片大**的话，**响应时间长**；**时间片小**的话，系统内耗大，**吞吐量小**\n\n我们先来微笑地说句fuck~\n\n那假如我们对周转时间和响应时间的需求同时存在，该怎么办呢？\n\n设置**优先级**！同时我们也需要首先遵守一个原则，人们更关心计算机与人的交互时间，也就是**前台任务执行快**，所以我们首先按**RR**的原则来安排**前台任务**，接着按照**SJF**的原则来安排**后台任务**，这两类任务之间通过**动态的优先级设置**进行互相切换。\n\n要满足上一小节的复杂指标，给我们的直观感受就是，这个实现的算法一定繁琐至极，但**linux0.11中的schdule函数**却很好地处理了这个问题——\n\n## 2.一个实际的schedule函数\n\n我们在开始之前，首先要明确时间片和优先级是有一定的关系的，时间片大的本身一定程度上优先级就高，能解决复杂问题的算法即便代码量少，但思想的深度却不会低。\n\n下面我们言归正传，来看chedule函数的实现——\n\n```C\nschele(void){\n    while(1){\n         int i = NR_TASKS;\n    \t  int c= -1;\n         int next = 0;\n   \t       p = &tasks[NR_TASKS];\n   \t       while(i--){\n    \t\tif(*p -> state == TASK_RUNNING &&  *p -> counter > c){//加入当前作业的状态为就绪态且优先级大\n            \t\tc = *p -> counter;\n                    \tnext = i;\t\n           }\n     \t}\n        if(c){\n            break;     //找到最大的counter\n        }\n        for(p = &LAST_TASK;p > &FIRST_TASK; p--){\t//重新设置优先级\n            (*p) -> counter = ((*p) -> counter >> 1) + *p ->priority;\n        }\n        switch_to(next);\n    }\n}\n```\n\n在这个程序中，counter是关键，它兼顾了优先级与时间片——\n\n```C\n//时间片\nvoid do_time(){\n    if(-- current -> counter >0)\n        \treturn;\n    current -> counter = 0;\n    schedule();\n}\n```\n\n即**时间片为0**时，则**切换时间片**。在这里**counter**满足**轮转调度**，保证了**响应**。\n\n而下面的程序中，counter又体现了优先级——\n\n```C\nif(*p -> state == TASK_RUNNING &&  *p -> counter > c){//加入当前作业的状态为就绪态且优先级大\n            c = *p -> counter;\n            next = i;\t\n }\n\nfor(p = &LAST_TASK;p > &FIRST_TASK; p--){\t//重新设置优先级\n            (*p) -> counter = ((*p) -> counter >> 1) + *p ->priority;\n }\n```\n\n这里counter体现的是动态的优先级，表现出来的是阻塞后进程的优先级会高于非阻塞进程的优先级，也就是优先前台进程。\n\n但值得注意的是，counter是否超出会响应时间的界，我们不妨来定量地看一下——\n\n假设进程n开始响应时的时间为p,而进程n的响应时间(**时间片**)是p+p/2,同样可以类比得到第**无穷个**进程的响应时间为**p+p/2+p/4+...+p/(2的无穷次方) < 2p**\n\n# 四.、进程同步和死锁\n\n我们在上一章中学习到了线程间的切换是如何完成的，而**进程**等于**资源**+**可执行的指令序列(线程),**那要完成进程的切换，也就是进程的**并发执行**，岂不是只需要知道**资源**是如何被**调度**的就可以了，那么资源如何表示，又如何量化呢，在调度资源的过程中，会出现怎样的问题，又应该怎样解决呢？这一系列的问题，我们都将在下面的内容中找到答案——\n\n------\n\n## 1.进程同步与信号量\n\n所谓进程的合作，就是多个进程来完成同一个任务，之前我们浅谈过**生产者与消费者**的实例，这里我们对它进行进一步的剖析——\n\n> 对于生产者而言，它生产了一个资源并放入缓冲区，当缓冲区满的时候，就不再生产。\n>\n> 同样的，对于消费者而言，它消费来自缓冲区的资源，当缓冲区空的时候，它就不再消费。\n\n从这种机制中，我们看出，首先需要一个放置资源的缓冲区——\n\n```c\n#define BUFFER_SIZE 10\n//声明资源的结构\ntypedef struct{} item;\n//声明缓冲区的大小\nitem buffer[BUFFER_SIZE];\nint in = out = counter = 0;\n\n```\n\n其次，我们来看最直观的生产者与消费者进程模型\n\n```c\n//生产者\nwhile(true){\n    while(counter == BUFFER_SIZE);\n    buffer[in] = item;\n    in =  (in + 1) % BUFFER_SIZE;\n    counter++;\n}\n\n//消费者\nwhile(true){\n    while(counter == 0);\n    item = buffer[out] ;\n    out=  (iout+ 1) % BUFFER_SIZE;\n    counter--;\n}\n```\n\n在这个最基础的模型中，我们的确**做到**了去控制生产者消费者运行的**时机**，但进程的调度是**不可预测**的，我们不妨再扩充一下如何使用**信号counter**控制进程的**休眠与唤醒**。\n\n```c\n//生产者\nwhile(true){\n    while(counter == BUFFER_SIZE){\n        sleep();//缓冲区已满以后，就让创建好的进程进入休眠队列\n    }\n    buffer[in] = item;\n    in =  (in + 1) % BUFFER_SIZE;\n    counter++;\n    if(counter  == 1){\n\twakeup();//唤醒消费者\t\n    } \n}\n\n//消费者\nwhile(true){\n    while(counter == 0){\n        sleep();//缓冲区为空的时候，就让消费者进程进出入休眠队列\n    }\n    item = buffer[out] ;\n    out=  (iout+ 1) % BUFFER_SIZE;\n    counter--;\n    if(counter  == BUFFER_SIZE-1){\n\twakeup();//唤醒生产者\n    } \n}\n```\n\n一个第二版的生产者消费者模型就这样形成的，它无疑更完善了一些，但因为**counter信号**终究表示的比较**宏观**，导致在细节上出错了——\n\n假设缓冲区**已满**，这时**生产者进程P1**运行，并进入**休眠队列**，紧接着**生产者进程P2**运行，也进入休眠队列，此时counter等于**BUFFER_SIZE**.然后消费者进程运行一次，**缓冲区内内容减1**，唤醒生产者，但在生产者执行之前，又有一个消费者进程运行，此时counter等于**BUFFER_SIZE-2**,则生产者进程**P2不会被唤醒**。\n\n出现这样的问题无疑是因为**信号counter**仅仅能表示**缓冲区中空闲的状态**，而无法判断**休眠队列**中有几个进程，换句话说，事情**不是非0即1**的，可能这个1表示的还有1.0和1.00的区分——\n\n因而我们要使这个信号可以表达休眠和唤醒两种状态，当然，这个时候已经不能称为信号了，不如就叫**信号量**？\n\n### 从信号到信号量\n\n通过信号量我们可以判断休眠或者唤醒的状态。\n\n姑且将信号量记为**sem**，当**sem=0**时，表示**无资源可用**，淡然，需要注意的是，对于进程而言，所谓的资源就是**空闲的空间**；当**sem<0**时，表示**有进程在等待资源**，假设sem=-2，表示有两个进程在等待资源；当**sem>0**时，表示有**多少个空闲资源**。\n\n接下来我们给出信号量的官方定义：\n\n> 1965年，由荷兰学者Dijkstra提出的信号量用于`记录`，信号用于sleep和wakeup.\n\n我们将信号量再去细化：\n\n```c\nstruct semphore{\n    int value; //记录资源个数\n    PCB * queue; //记录等待进程的队列\n}\n```\n\n此外，由信号量衍生出了P,V原语。**P**可以记做**test**，**V**则为**increament**\n\n下面给出P,V原语的实现——\n\n```c\n//p原语：没资源，队列休眠\nP(semaphore s){\n    s.value--;\n    if(s.value < 0){\n        sleep(s.queue);\n    }\n}\n\n//V原语：有资源，唤醒队列\nV(semaphore s){\n    s.value++;\n    if(s.value >= 0){\n        wakeup(s.queue);\n    }\n}\n```\n\n到这里，我们可以回过头来看生产者和消费者问题了，话不多说，上代码：\n\n```c\nint fd = open ('buffer.txt');\nwrite(fd,0,sizeof(int)); //写in\nwrite(fd,0,sizeof(int)); //写out\n\nsemaphore full = 0;\nsemaphore empty = BUFFER_SIZE;\n//声明互斥信号量为1,即并发修改数\nsemaphore mutex = 1;\n\nProducer(item){\n    //判断缓冲区是否已满\n    P(empty);\n    //判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量\n    P(mutex);//mutex--\n    //在这里写入in，即将item写到in的位置\n    V(mutex);//mutex++\n    V(full);//full++\n}\n\nConsumer(item){\n    P(full);//判断缓冲区为空\n    //判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量\n    P(mutex);//mutex--\n    //在这里写入iout，即从文件中的out位置读出到item中\n    V(mutex);//mutex++\n    V(empty);//empty++\n}\n```\n\n顺畅如斯，秒啊~\n\n到这里的确已经迈出了一大步，但仍有些小瑕疵，那就是由于**进程调度顺序**不确定，导致**两个进程同时访问一个信号量**的状况——\n\n## 2.对信号量的临界区\n\n为什么要保护临界区呢？什么是临界区，且听我娓娓道来——\n\n因为两个进程对同一份数据存在竞争关系，因而需要将这份资源作为**临界区**。而这里的**竞争条件**是**指和调度有关的共享语义错误**。\n\n- [x] 临界区： **一次只允许一个进程进入该进程的那一段代码，临界区的基本原则是互斥**，\n\n然而仅仅声明一段代码为临界区代码是不够的，一段好的临界区代码还应该是**有空让进**且**有限等待**。\n\n首先开始进入临界区的第一种尝试——轮换法。\n\n#### 1.轮换法\n\n![image-20210619010827920](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010827920.png)\n\n\n\n首先，这个临界区的设计是满足互斥的，但假如在调用进程P0以后，继续调用进程P0，这时就不再满足有空就进的原则了，所以下一位——\n\n#### 2.标记法\n\n![image-20210619010842398](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010842398.png)\n\nCPU大量时间闲置的问题的确得到了解决，且满足互斥，但假如有这么一种情景——\n\n两个标记都为true，那么两个进程都不再执行，我们可以类比生活中的例子：假设冰箱里没有牛奶，妻子看到丈夫大的标记后，认为丈夫会买，而丈夫看到妻子留下的标记后，认为妻子会买，这样没有真的去买了牛奶。\n\n这是一种对称法**，而在现实中，要打破这种没人买牛奶的窘况，就需要一个人**相对勤快一些。\n\n#### 3.peterson算法\n\n![image-20210619010856746](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010856746.png)\n\n而**映射到进程合作**，也应该如此，在两个标记都为true的情况下，需要有一个进程去执行，而另一个进程则什么都不做，我们来看具体的实现——\n![image-20210619010910974](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010910974.png)\n\n这是**peterson算法**的思想，它满足了一个好临界区的几个条件，是目前最好的临界区实现方式！！！\n\n两个进程竞争临界区的问题解决了，那一个多个进程呢，所谓**万法不离其宗**，我们来实际地体会一下\n\n------\n\n#### 面包店算法\n\n我们在开始的时候强调过，衡量临界区算法的标准是**互斥进入**，**有空让进**，**有限等待**。而正在之前的篇幅中，我们也验证了要同时满足这两个条件，需要结合**轮换**和**标记**的思想，那在多个进程中如何体现呢？\n\n- [x] 轮转：每个进程都有一个序号\n\n- [x] 标记 ：进程中序号最小的进入\n\n![image-20210619010925494](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010925494.png)\n\n首先**选中**第i个进程，即将它**标记**。并将**当前进程序号最小**的序号赋给数组**num的第i个元素**。\n\n接着再取消当前的标记，即做标记只是为了取出当前最小的序号。然后**遍历序号**，假如有被选中的其他进程，且该进程的序号比当前进程小，则等待它执行完，否则执行当前进程。进程结束后，将数组num的第i个元素置0.开始下一次循环。\n\n多个进程同步的问题的确可以通过面包店算法得到解决，但这么繁琐的算法看着就头疼，而且回顾为什么会产生临界区，本质上是因为**不可控的调度**导致的，而调度是要进入**内核**的，且进入内核的方式是**中断**，那我们只让一个进程触发中断不就可以保护临界区了吗？那么这样可行吗？\n\n这就要谈到软硬件协同开发中的**硬件**了——\n\n![image-20210619010938594](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010938594.png)\n\n这里使用**cli()**将**中断的寄存器INTR**置**1**，而在执行完临界区代码以后，再将其**置0**，就可以实现同一时刻只有一个进程访问临界区了。这种方法的核心在于中断寄存器，但假如是**多核CPU**，那每个CPU中都有这样一个寄存器，改变一个CPU的中断寄存器对别的CPU是没有影响的，可见这个方法是有**局限性**的。\n\n那要怎么办呢？显然我们需要一个全局的信号量来标记当前临界区的状态。这里我们尝试**硬件原子指令法**\n\n```c\nboolean \n    //这是一段原子代码，即一次执行完毕，不回切出\n    TestAndSet(boolean &x){//1.假如x为true，则执行完   2.假如为false,将x置为true并将false返回\n    \tbooean rv = x;\n    \tx = true ;\n    \treturn rv ;\n     }\n\n\nwhile(TestAndSet(&lock));\n//临界区\nlock = false;\n//剩余区\n```\n\n也就是说，假如**信号量是上锁**的的，则进入并执行完，**执行完后开锁**；而假如进去之后发现**锁是开着**的，则**马上上锁**，并返回等待下次执行。这种方式对于多CPU同样是可行的。\n\n## 3.临界区的代码实现\n\n在之前我们完成了信号量的引出，临界区的保护，接下来来看如何使用代码实现临界区。话不多说，我们直入主题——\n\n```c\nsem.c //进入内核\ntypedef struct{//声明信号量的结构体\n    char name[20];\n    int value;\n    task_struct * queue;\n}semable[20]\n    \n //用户态的程序\n producer.c\n main(){\n       //从信号量结构体中读取empty的下标\n \tsd = sem_open(\"empty\");\n       for（int i = 0; i<=5;i++）{\n           //设置阻塞状态，切换进程\n           sem_wait(sd);\n           //在文件fd中写入4个字节的数据\n           write(fd,&i,4);\n       }\n }\n\n//在semable中寻找name对应的，没找到则创建，找到则返回下标\nsys_sem_open(char *queue);\n\nsys_sem_wait(int sd){\n        //中断保护\n\tcli();\n        if(semtable[sd].value-- < 0){\n            //这里设置自己为阻塞，将自己加入到队列semtable.[sd].queue中去 \n            schedule();\n        }\n   \t   sti();\n}\n```\n\n复杂的思想最终也不过凝结为这几句宏观的代码，但即便如此，我们也要不忘初心，去探寻那**冰山下的百分之九十**。\n\n这样思想的应用在linux0.11中更是被广泛的应用，让我们来从那里学点思想吧——\n\n```c\n//读磁盘块\nbread(int dev,int block){\n    struct buffer_head *bh;\n    //开始磁盘读后睡眠，切换进程，再由磁盘中断将其唤醒，即同步\n    ll_rw_block(READ,bh);\n    wait_on_buffer(bh);\n}\n//锁住临界区\nlock_buffer (buffer_head *bh){\n    cli();\n    //while?为什么不用if\n    while(bh -> b_lock){//进入后，不管之前是否上锁，之后都要上锁\n        sleep_on(&bh_wait);\n        bh -> b_lock = 1;\n    }\n    sti();\n}\n\nvoid sleep_on(struct task_struct){\n       //加入队列，号称世界上最隐蔽的队列？\n\tstruct task_struct *tmp;\n        tmp = *p;\n        *p = current;\n        current -> state = TASK_UNINTERUPTIBLE;\n        schdule();\n        if(tmp){\n\t\ttmp -> state = 0;\n        }\n        \n}\n```\n\n我们来挑战一下世界上最**隐蔽的队列**——\n\n![image-20210619010955043](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010955043.png)\n\n将tmp指向task_struct,再将p指向当前的task_struct，**当前的即是队列的队首**，也就是说将tmp指向队首的下一个，p指向队首。又这两个指针都是存储在这个进程的内核栈中的，因此**下一次**可从**下一个进程**task_struct的内核栈中取出**tmp**指向**上一个进程**，再将**指针p**指向**当前进程**。\n\n这样就可以回答使用**while**，是将**所有的进程状态**都判断了一次，从而找出那个**优先级高的**，让他来执行。\n\n这里的p是指针的指针，我们可以理解为p指向的是一个**内存空间的起始地址**，则三级指针，n级指针同样——\n\n![image-20210619011007670](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011007670.png)\n\n上面的内容在切换进程时，会将当前进程加入阻塞队列，那如何唤醒呢？\n\n![image-20210619011019527](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011019527.png)\n\n通过**磁盘中断**调用**对临界区开锁的函数**，并在其中调用**wake_up函数**，在其中改变了**当前进程的状态**，然后使用**iret返回继续往下执行**。\n\n------\n\n## 4.死锁处理\n\n我们依然以生产者-消费者模型作为例子，我们知道不管在生产者抑或消费者函数，首先都是要判断缓冲区是否已满或者缓冲区为空，那假如将判断与之后的代码调换位置，会导致怎样的结果呢？\n\n这样的话会导致**死锁**，通俗的说，也就是**多个进程互相等待对方持有的资源，而造成谁也无法执行的现象**\n\n**本质上**说，死锁的成因是因为自己占有的资源和申请的资源造成**环路等待**。\n\n我们再来看死锁的必要条件——\n\n![image-20210619011032749](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011032749.png)\n\n那怎样处理死锁呢？\n\n![image-20210619011048485](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011048485.png)\n\n那针对每种方法，我们可以具体在进程同步中如何做呢？\n\n1. `死锁预防` ：**一次性申请所有需要资源**，这样就不需要因为资源冲突而造成环路等待，但效率太低，没有使用的价值；另外一种直观的想法就是**资源申请按需进行**，不会造成死锁没错，但资源浪费比较严重，果断弃坑。\n\n2. `死锁避免`： 死锁避免的思想被**银行家算法**“完美”地实现了——\n\n   假设系统中的所有进程存在一**个可以完成的执行序列**，则称系统处于**安全状态**，而银行家算法就是用来找出这个安全序列的。\n\n   对于一个进程来说，它与资源间的关系分为**目前占有的资源**，**还需要的资源**，**可供分配的资源**三种。\n\n   来看具体的实现——\n\n   ```c\n   int Available[1,...,n];//每种资源剩余的数量\n   int Allocation[1,....,m];//已分配的资源数量\n   int Need[1,..,m];//进程还需要的各种资源数量\n   int work[1,..,m];//工作向量\n   bool Finish [1,..,n];//进程是否结束\n   \n   work = Available;\n   Finish[1,..,n] = false;\n   while(true){\n       for(i=1; i<=n; i++){\n           if(Finish[i]==false&& Need[i]≤Work)\n           {\n               Work = Work + Allocation[i];\n               Finish[i] = true; \n               break;\n           }else \n           {\n               goto end;\n           }\n       }\n   }\n   End: \n   for(i=1;i<=n;i++) \n       if(Finish[i]==false) \n           return “deadlock”;\n   T(n)=O(mn2)\n   \n   ```\n\n   银行家算法的实现相对通俗易懂一些，但同时带来了**时间复杂度高**的问题，而时间复杂度高的原因在于它会事无巨细的判断每一个，但出现死锁的概率毕竟比较低，所以判断所有就显得浪费时间。\n\n   那我们是否可以**先假装分配**，然**后调用银行家算法**，再判断是否可行呢？这样我们就需要申请一个**死锁进程组**，判断每一个序列是否为安全序列。\n\n3. `死锁检测+恢复` ：核心思想在于先发现问题，然后再处理，当发生死锁的时候，就让**进程回滚**，但是实现机制比较复杂\n\n4. `死锁忽略` ：究极秘诀——**重启**；\n\n------\n\n> 山高路远，静水深流。","source":"_posts/进程与线程.md","raw":"---\ntitle: 进程与线程\ntop: true\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-11 20:32:04\npassword:\nsummary: 起笔自多进程图像，接着娓娓道出轻量级进程，即线程，然后着眼进程间如何切换，最后落笔于进程间的合作\ncategories: 计算机基础\ntags: \n\t- 操作系统\n\t- linux0.11\n---\n\n# 一、多进程图像的引出\n\n## 1.多进程图像\n\n多个进程同时存在于内存，可能会出现前一个进程的地址中的内容被第二个进程更改。这样显然是不合理的。\n\n我们首先会想到，是否可以设置**DPL**的值，也就是将其设置为**特权级别**，这样进程之间就不能互相访问了，但这里忽略了一个问题，DPL的设置是针对**操作系统**而言的，进程的DPL都等于3，即**用户级权限**，依然可以互相访问，所以这种解决方式的思路是错误的。\n\n那如何保证进程间不冲突呢？直观的解决方式，就是给进程**上锁**，限制对**内存地址的读写**。\n\n**映射表**就是实现限制访问的那个利器。映射表的思路即是利用**虚拟内存**实现**地址分离**。\n\n说到这里，我们发现，所谓的多进程图像，不单单是进程的管理，还涉及到内存的管理。\n\n### 多进程如何合作\n\n先看下面的例子——\n\n假设有一段空闲的内存空间，两块进程都想利用这块内存空间，这样有可能会出现一块内存空间出现**两个不完整的进程片段**，也就是说，进程间是可以互相合作的，但合作的方式需要被协调。\n\n那怎样协调呢，纸上得来终觉浅，要想觉知此事，不妨理解**生产者-消费者实例**——\n\n> 生产者不断的产生数据放入缓冲区，而消费者从缓冲区中取出数据进行处理，当缓冲区已满的时候，生产者阻塞，当缓冲区为空的时候，消费者阻塞\n\n我们会使用三种方式来实现生产者-消费者问题——\n\n在下文的进程同步中会提及。。。\n\n# 二、线程的引出与实现\n\n从上一节我们知道多进程是操作系统的最基本，最核心的图像，多进程可以被组织，合作与切换。\n\n多进程的组织是通过**状态与队列**来实现的\n\n那么多进程是如何被**切换**的呢？且听我娓娓道来——\n\n------\n\n## 1.用户级线程\n\n### 线程的引出\n\n既然我们要了解的是进程间的切换，那为什么学习的却是线程呢？\n\n首先我们先来看宏观上的进程切换：一个**进程**，也就是**指令执行序列**+**资源**，在发生外中断后，切换到另一个进程。在这期间，指令访问的内存地址是通过**映射表**来获取的。这个切换是由中断引起的，因而会进入内核态，会涉及到**资源的分配**。而资源的分配是浪费时间的，那么为了提高进程执行的效率，能否将资源与指令的**执行分离**开，实现不动资源而只切换指令序列呢？——\n\n我们来看直观的表述——\n![image-20210619010326080](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010326080.png)\n\n\n\n这样就引出了轻巧级的进程——**线程**。\n\n### 线程的价值\n\n要回答**线程**是否实用，也就是要回答**多个执行序列+一个地址空间**的思想是否实用。\n\n我门来看下面的例子——\n\n![image-20210619010341740](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010341740.png)\n\n这个网页呈现出来的是，首先文字被加载出来，接着图片被加载，最后全部内容都展示了出来。\n\n实际上它的程序执行流程是多个线程从**浏览器的缓冲区**中读取**同一份资源**，程序执行展示文本的线程时，在此期间切换到展示图片的线程，过一段时间又切换回来，给用户更好的体验。\n\n这里我描述的比较**生涩**，其实多线程的执行，一言以蔽之，其实就是编程时**多条线路并发执行**：\n\n### 线程的切换\n\n开局一张图：\n\n![image-20210619010356747](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010356747.png)\n\n可以看出，这里线程间的切换是通过一个叫做**Yield**的函数来实现的，所以我们的**核心**就在于写出yeild函数的实现——\n\n要完成切换，就要保存上一个线程的状态，状态的保存是依赖栈来实现的，我们先从两个执行序列与一个栈讲起——\n\n#### 两个执行序列与一个栈\n\n![image-20210619010411788](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010411788.png)\n\n这张图到底表达了什么意思呢？\n\n在函数B中调用Yield函数，这时需要将程序B的下一条指令的地址压栈，跳转后，在C函数中调用了D函数并压栈，在D函数中调用Yield函数，此时我们需要跳转204的位置，跳转后，PC指针指向了地址204，接着往下执行，遇到**}**后，弹栈并跳转，然后程序指针跳到404处。\n\n嗯哼，是我剧本拿错了吗？的确，就是这么戏剧性，我要的是**弹栈104**并跳转，可没想调回**404**啊，死循环。。。\n\n那么这是为什么呢？因为我们**共用了一个栈**！！！\n\n所以我们很自然的需要从**一个栈**过渡到了**两个栈**。\n\n#### 两个执行序列与两个栈\n\n![image-20210619010426291](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010426291.png)\n\n现在线程切换的时候，首先yield函数需要切换栈，这里就需要一个能够保存当前线程栈状态的**容器**，也就是**TCB**。\n\n我们最后在执行yield函数时，首先切换TCB，然后Yiled函数结束，继续往下执行**}**,也就是执行**ret指令**\n\n弹栈执行104，一个线程切换就这样有惊无险的完成了。\n\n- [x] 这里不需要jmp 204,因为Yield函数执行完后，就会**默认往下顺序执行**。\n\n完成了两个栈，我们再将包含线程切换的**ThreadCreate**函数做初始化，并在其中关联**TCB与栈**。\n\n这样，一个完整的进程就有了——\n\n![image-20210619010441251](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010441251.png)\n\n------\n\n说到这里，我们就可以来回答这个小结为什么叫用户级线程，因为**field是用户级应用程序**。\n\n整个用户级线程可以实现有序的切换了，那么为什么还要内核级线程呢？当然是因为它有其天生的**限制**，而从另一个角度来说，核心级线程是用户级线程的**扩展**。\n\n### 用户级线程的缺点\n\n当用户级线程在执行指令过程中发生中断，系统会切换到内核态，然后执行中断程序，在执行完后，因为权限已经改变，**无法切换回用户级线程**，用户级线程不再执行。\n\n## 2.内核级线程\n\n我们首先来回顾一下**内核级线程的切换**——\n\n![image-20210619010458893](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010458893.png)\n\n宏观的看，内核级线程由用户级线程的两个栈演变成了两套栈，它的的实现机制大致分为五步——\n\n1. 用户栈通过**int中断指令**跳转到内核栈\n2. 在内核栈中存储当前内核线程的状态，而内核栈又由**线程控制块TCB1**维护\n3. 通过**Schedule函数**完成内核级线程跳转\n4. 在内核栈中存储当前内核线程的状态，而内核栈又由线程控制块TCB2维护\n5. 由内核栈跳转回用户栈\n\n下面我们将具体实现这个内核级线程：\n\n------\n\n这个故事首先从进入内核开始，也就是从某个**中断**开始，这里的系统调用案例我们选择**fork()**,fork()函数是用于创建进程的，而**进程**实质上是**资源+指令序列**，**指令序列**就是一系列的**线程**，所以我们使用fork函数，是可以完成内核级线程的切换的。\n\n我们来看下面的例子——\n\n### 中断入口\n\n![image-20210619010514141](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010514141.png)\n\n在main函数中调用了A函数，之后在A函数的执行中又调用了fork系统调用，fork系统调用会引起中断，在触发中断处理程序时，首先会将之前用户态的栈进行保存，也就是将SS,SP压栈，接着跳转fork的中断处理程序，也就是**system_call函数**——\n\n![image-20210619010528293](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010528293.png)\n\n在system_call中，首先会做寄存器的压栈，也就是**准备切换**，然后跳转sys_fork系统调用**开始切换**，在这个系统调用中，首先将当前线程的**TCB置给ex**，接着判断ex的状态，本质上是判断**TCB**的state**，如果**非0**的话，也就是处于**阻塞状态**。就需要执行schedule以完成**切换**，此外，当**时间片用完**以后，也需要进行切换。\n\n### 中断出口\n\n完成了切换，那怎样返回呢？通过**中断出口**，那中断出口做了什么呢？对应中断入口一系列的入栈，中断出口会做弹栈操作。\n\n![image-20210619010541971](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010541971.png)\n\n我们描述了中断入口和中断出口，那在中断的过程中做了什么事情呢？\n\n在中断中首先找到要切换的线程，再**切换**到该线程。这里面会涉及到线程的调度与切换，线程的调度我们后面会提及，这里我们只看线程的切换——\n\n### 中断过程——线程切换\n\n线程的切换是通过**switch_to**来完成的，在函数中主要通过**长跳转**来实现线程跳转——\n\n![image-20210619010558855](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010558855.png)\n\n首先使用**movw指令**将CPU中寄存器的内容都写入到到**TSS**中，**TSS**也就是**任务结构段**，它是**进程控制块PCB**的一部分。\n\n首先通过**TR寄存器**(**类CS寄存器**)找到位于**GDT表**中的**TSS描述符**，即指向TSS段的指针，最终通过TSS描述符定位到TSS段。\n\n而**长跳转**做的无非就是通过TR寄存器找到另一个线程的TSS描述符，通过TSS描述符找到TSS段，并将寄存器中的的内容也加载到TSS段中。\n\n但以TSS的方式实现跳转的效率是低下的，因为TSS中的**长跳转**需要对一系列**寄存器**操作。之后我们将采用**KIN stack**的方式完成切换。\n\n> 参考linux进程切换与TSS结构https://blog.51cto.com/stonehorse/1113115\n\n------\n\n在上一小节的学习中，我们了解了线程的切换，接着我们将范围放大，来一起学习线程创建，即**ThreaCreate函数**\n\n首先从**sys_fork函数**开始我们的求知之旅——\n\n![image-20210619010627862](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010627862.png)\n\n在**sys_fork函数**中，首先将**用户态状态入栈**，以便子进程调用，接着在sys_fork函数中调用**copy_process**，可以看到这个函数的参数有一长串，细心观察的话，会发现都是**父进程压入栈中的内容**，也就是子进程和父进程是**共用**一套用户栈的。\n\n那么子进程创建的细节是怎样的呢？\n\n![image-20210619010642915](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010642915.png)\n\n首先**申请了一页**的内存空间，我们再来回顾一下它的渊源：开机时**memmap**初始化，将内存分以**4k**为最小单元的页，需要申请**内核空间**时，则选取memmap**不等于0的**的一页内存空间即可。\n\n接着**创建TCB,**也就是从申请的内存起始开始往后一页的这段内存空间。\n\n然后创建内核栈和用户栈，最终将**TCB与栈相关联**。\n\n最后，我们只需要完成一系列的初始化即可，这里面值得关注的是ip的初始化，也就是从栈中取出中断后下一条指令的内存地址，另外还需要eax初始化为0，那么eax有什么用呢？\n\n我们经常看到的一个判断：**if(!fork()){子进程执行}**,这里判断的条件即是**eax的值**，如果eax等于**0**，**子进程执行**，反之，父进程执行。\n\n明确了子进程的执行条件，我们来看子进程的具体执行的代码，也就是**exec系统调用**——\n\n![image-20210619010701378](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010701378.png)\n\n我们从父进程的**shell**进入子进程的执行，当子进程执行完后，需要返回，那它会**返回到哪里**呢？我们知道在跳转执行的结束，会执行指令**iret**，所以返回的地址取决于iret中**ret**指令弹栈的**IP寄存器**内容。那IP指向哪里呢？\n\n![image-20210619010718802](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010718802.png)\n\nIP指向的位置，或者说IP寄存器中地址取决于**struct_exec系统调用**的参数。在它的执行中，将ex寄存器中的**a.entry**方法的地址加载到ret中作为**IP**的指向地址，a.entry是**可执行文件的入口地址**，当它连接产生可执行文件时，会将文件中的内容，即磁盘中的内容**写入到**内存执行，子进程执行完毕！\n\n## 3.操作系统的那棵树\n\n> 系统调用就是一种软中断处理程序\n\n在这一小节中，我们不看学习新的内容，因为旧的内容还一团乱麻。所以我们有必要将之前的知识点**连点成线**，让它从**萌芽**开始，随时光浸淫，最终长成**参天大树**。\n\n即便操作系统这颗很庞大的参天大树也是要从一个很小的火光发散的。就如同李志军老师告诫我们的一样——\n\n> The mind is not a vessel that needs filling,but wood that needs ignitng\n>\n> 我们的大脑不是装满水的容器，而应该是点燃的火光。\n\n所以我们接下来的内容我们将从一个很小，很具体，很有价值的IDEA开始——\n\n- [x] 我们要在屏幕上交错出现A和B\n\n首先回顾一下线程切换的思路——\n\n- [x] **运转CPU**-》**CPU没有好好运转**-》**要让CPU好好运转，首先从A函数跳到B函数**-》**跳转时使用1个栈和1个yeild发生混乱**-》**试着使用两个栈和两个TCB**-》**这样可以运转没错，但只能在用户态运转是不合适的**-》**引入两套栈，即内核栈的切换**\n\n首先从**用户代码**开始——\n\n```c\nmain(){\n    if(!fork()){while(1)printf(\"A\");}\n    if(!fork()){while(1)printf(\"B\");}\n    wait();\n}\n```\n\n我们再将其用**汇编**来表述——\n\n```asm\nmain(){\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax,res\n\tcmp1,res,0\n\tjne 208\n200: printf(\"A\")\n\tjmp 200\n208: ...\n304: wait()\n}\n```\n\n接着复现执行**int 0x80**后的代码——\n\n```ASM\nmain(){\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax , res\n\tcmp1 res,0\n}\n\nset_system_gate(0x80,&system_call);\nsystem_call:\n\tcall sys_call_table(,%eax,4)\n```\n\n首先将**系统调用号**赋给**_NR_fork**，触发中断**0x80**，进入**system_call**，在该系统调用中，跳转**system_call_table**,将1赋给eax,也就是当前内核进程为**父进程**，在其中调用**sys_fork**——\n\n```ASM\nsys_fork:\n\tpush1 ..\n\tcall copy_process\n\tret\n```\n\n开始**创建子进程**，子进程的创建也就是对父进程的复制，即**copy_process**_\n\n```C\ncopy_process(... ,long eip,..){\n\tp = (PCB *)get_free_page();\n        p->tss.esp0 = p+4k;\n        p->tss.esp = esp;\n        p->tss.eax = 0;\n        p->tss.eip = eip;\n}\n```\n\n完成了**PCB的创建与初始化**，也就是完成了子进程的创建，接着**ret**返回到父进程，**iret**返回用户态。\n\n然后接着调用main函数，不断的**创建线程**，接着执行main函数，就到了**wait()函数**，它的具体实现是——\n\n```C\nsys_waitpid(){\n\tcurrent -> state = TASK_INTERRUPTTIBLE;\n        schedule();\n}\n```\n\n将当前线程的状态置为**阻塞**，开始切换——\n\n```C\nshedule(){\n    if((*p)->state == TASK_RUNNING &&  (*p)->counter > c)\n        \tc = (*p) -> counter,next = i;\n    \t   ...\n               switch_to(next);\n}\n```\n\n如果当前状态为运行态，使用**调度算法**得到**要切换的线程**，进入切换——\n\n切换以后，就可以打出B了，但我们需要的是交替执行，所以要从B再进入A，也就是要完成切换，而切换是在内核态完成的，而用户态需要使用中断才能进入内核，那使用哪个中断呢？\n\n**时钟中断**！！！\n\n```c\nvoid sched_int(void){\n    set_intr_gate(0x20,&timer_interrupt)\n}\n\nvoid  _time_interrupt:\n\tcall do_time\n        \nvoid do_time(...){\n        if((--current -> counter >0)) \n            return ;\n        current -> counter = 0;\n        schedule();     \n }\n```\n\n将**中断类型码**赋给系统调用**time_interrupt**,在其中跳转**do_time**,在do_time中判断当前线程的数目，如果**大于0**，**不切换**，否则调用schedule切换线程。\n\n最终在**schdule**中调用**switch_to**。不断循环，完结~\n\n# 三、 CPU调度\n\n在上面的描述中，一个线程的切换就这样丝滑地完成了，但我们总将CPU调度刻意的当做一个黑盒子，这是因为CPU调度的确是一个很揪心的任务，但了解它又能加深我们对系统设计设计的理解，因此，这节内容，我们就明知山有虎，偏向虎山行了——\n\n------\n\n## 1.cpu调度策略\n\n当一个线程阻塞后，就要切换到另一个线程，那应该切换到哪一个线程呢？直观的说，我们需要**尽可能快**的完成任务。那如何衡量任务执行的效率呢？就连任务本身都有不同的类型，比如**I/O型**，**CPU型**，按照不同的分类角度，又有**前台型任务**和**后台型**任务。\n\n我们只捉住它**关键**的几个点来设计一个调度算法——\n\n1. **周转时间短**，从任务进入到任务结束，也就是尽可能快的完成任务。**周转时间=等待时间+运行时间**。\n2. **响应时间短**，即从操作到响应的时间短\n3. **系统内耗少**，即系统吞吐量大，执行任务多\n\n我们来看符合某些点的具体的算法思想，并用上面的**指标**来衡量它：\n\n### FCFS\n\n先来先服务是最直观的调度算法，但一个系统是复杂的，仅考虑到公平只会事倍功半。\n\n假设有n个任务，每个任务的周转时间分别为Ti，则它的**平均响应时间**为**：T1+T2+T3+Tn/n**,它的第**n个任务的响应周转**为**T1+T2+T3+...+Tn**，假如说T1的时间比其他时间的加和还要大，这样显然周转时间有可能很长，非常**不合理**。\n\n那能否在FCFC调度算法的前提下，根据任务的长短来决定执行的顺序呢？那我们来了解一下SJF——**短作业优先调度算法**\n\n### SJF\n\n假设有n个任务，按短作业优先的原则，调度的结果分别是：**P1,P2,P3...Pn**,则它总的周转时间为**n*P1+(n-1)*p2+....**，这样它的周转时间显然得到显著的降低。\n\n但假如我现在有一个很长的作业，但它又非常紧急，我是不是应该适当的根据优先级来调整执行的顺序呢？这就要谈及RR——**轮转时间片调度算法**。\n\n### RR\n\n时间片轮转的思想是将作业再**细分**，然后CPU为每个作业分配**时间片**，接着来**交错**地执行任务的最小单元。\n\n但这里同样面临问题，假如**时间片大**的话，**响应时间长**；**时间片小**的话，系统内耗大，**吞吐量小**\n\n我们先来微笑地说句fuck~\n\n那假如我们对周转时间和响应时间的需求同时存在，该怎么办呢？\n\n设置**优先级**！同时我们也需要首先遵守一个原则，人们更关心计算机与人的交互时间，也就是**前台任务执行快**，所以我们首先按**RR**的原则来安排**前台任务**，接着按照**SJF**的原则来安排**后台任务**，这两类任务之间通过**动态的优先级设置**进行互相切换。\n\n要满足上一小节的复杂指标，给我们的直观感受就是，这个实现的算法一定繁琐至极，但**linux0.11中的schdule函数**却很好地处理了这个问题——\n\n## 2.一个实际的schedule函数\n\n我们在开始之前，首先要明确时间片和优先级是有一定的关系的，时间片大的本身一定程度上优先级就高，能解决复杂问题的算法即便代码量少，但思想的深度却不会低。\n\n下面我们言归正传，来看chedule函数的实现——\n\n```C\nschele(void){\n    while(1){\n         int i = NR_TASKS;\n    \t  int c= -1;\n         int next = 0;\n   \t       p = &tasks[NR_TASKS];\n   \t       while(i--){\n    \t\tif(*p -> state == TASK_RUNNING &&  *p -> counter > c){//加入当前作业的状态为就绪态且优先级大\n            \t\tc = *p -> counter;\n                    \tnext = i;\t\n           }\n     \t}\n        if(c){\n            break;     //找到最大的counter\n        }\n        for(p = &LAST_TASK;p > &FIRST_TASK; p--){\t//重新设置优先级\n            (*p) -> counter = ((*p) -> counter >> 1) + *p ->priority;\n        }\n        switch_to(next);\n    }\n}\n```\n\n在这个程序中，counter是关键，它兼顾了优先级与时间片——\n\n```C\n//时间片\nvoid do_time(){\n    if(-- current -> counter >0)\n        \treturn;\n    current -> counter = 0;\n    schedule();\n}\n```\n\n即**时间片为0**时，则**切换时间片**。在这里**counter**满足**轮转调度**，保证了**响应**。\n\n而下面的程序中，counter又体现了优先级——\n\n```C\nif(*p -> state == TASK_RUNNING &&  *p -> counter > c){//加入当前作业的状态为就绪态且优先级大\n            c = *p -> counter;\n            next = i;\t\n }\n\nfor(p = &LAST_TASK;p > &FIRST_TASK; p--){\t//重新设置优先级\n            (*p) -> counter = ((*p) -> counter >> 1) + *p ->priority;\n }\n```\n\n这里counter体现的是动态的优先级，表现出来的是阻塞后进程的优先级会高于非阻塞进程的优先级，也就是优先前台进程。\n\n但值得注意的是，counter是否超出会响应时间的界，我们不妨来定量地看一下——\n\n假设进程n开始响应时的时间为p,而进程n的响应时间(**时间片**)是p+p/2,同样可以类比得到第**无穷个**进程的响应时间为**p+p/2+p/4+...+p/(2的无穷次方) < 2p**\n\n# 四.、进程同步和死锁\n\n我们在上一章中学习到了线程间的切换是如何完成的，而**进程**等于**资源**+**可执行的指令序列(线程),**那要完成进程的切换，也就是进程的**并发执行**，岂不是只需要知道**资源**是如何被**调度**的就可以了，那么资源如何表示，又如何量化呢，在调度资源的过程中，会出现怎样的问题，又应该怎样解决呢？这一系列的问题，我们都将在下面的内容中找到答案——\n\n------\n\n## 1.进程同步与信号量\n\n所谓进程的合作，就是多个进程来完成同一个任务，之前我们浅谈过**生产者与消费者**的实例，这里我们对它进行进一步的剖析——\n\n> 对于生产者而言，它生产了一个资源并放入缓冲区，当缓冲区满的时候，就不再生产。\n>\n> 同样的，对于消费者而言，它消费来自缓冲区的资源，当缓冲区空的时候，它就不再消费。\n\n从这种机制中，我们看出，首先需要一个放置资源的缓冲区——\n\n```c\n#define BUFFER_SIZE 10\n//声明资源的结构\ntypedef struct{} item;\n//声明缓冲区的大小\nitem buffer[BUFFER_SIZE];\nint in = out = counter = 0;\n\n```\n\n其次，我们来看最直观的生产者与消费者进程模型\n\n```c\n//生产者\nwhile(true){\n    while(counter == BUFFER_SIZE);\n    buffer[in] = item;\n    in =  (in + 1) % BUFFER_SIZE;\n    counter++;\n}\n\n//消费者\nwhile(true){\n    while(counter == 0);\n    item = buffer[out] ;\n    out=  (iout+ 1) % BUFFER_SIZE;\n    counter--;\n}\n```\n\n在这个最基础的模型中，我们的确**做到**了去控制生产者消费者运行的**时机**，但进程的调度是**不可预测**的，我们不妨再扩充一下如何使用**信号counter**控制进程的**休眠与唤醒**。\n\n```c\n//生产者\nwhile(true){\n    while(counter == BUFFER_SIZE){\n        sleep();//缓冲区已满以后，就让创建好的进程进入休眠队列\n    }\n    buffer[in] = item;\n    in =  (in + 1) % BUFFER_SIZE;\n    counter++;\n    if(counter  == 1){\n\twakeup();//唤醒消费者\t\n    } \n}\n\n//消费者\nwhile(true){\n    while(counter == 0){\n        sleep();//缓冲区为空的时候，就让消费者进程进出入休眠队列\n    }\n    item = buffer[out] ;\n    out=  (iout+ 1) % BUFFER_SIZE;\n    counter--;\n    if(counter  == BUFFER_SIZE-1){\n\twakeup();//唤醒生产者\n    } \n}\n```\n\n一个第二版的生产者消费者模型就这样形成的，它无疑更完善了一些，但因为**counter信号**终究表示的比较**宏观**，导致在细节上出错了——\n\n假设缓冲区**已满**，这时**生产者进程P1**运行，并进入**休眠队列**，紧接着**生产者进程P2**运行，也进入休眠队列，此时counter等于**BUFFER_SIZE**.然后消费者进程运行一次，**缓冲区内内容减1**，唤醒生产者，但在生产者执行之前，又有一个消费者进程运行，此时counter等于**BUFFER_SIZE-2**,则生产者进程**P2不会被唤醒**。\n\n出现这样的问题无疑是因为**信号counter**仅仅能表示**缓冲区中空闲的状态**，而无法判断**休眠队列**中有几个进程，换句话说，事情**不是非0即1**的，可能这个1表示的还有1.0和1.00的区分——\n\n因而我们要使这个信号可以表达休眠和唤醒两种状态，当然，这个时候已经不能称为信号了，不如就叫**信号量**？\n\n### 从信号到信号量\n\n通过信号量我们可以判断休眠或者唤醒的状态。\n\n姑且将信号量记为**sem**，当**sem=0**时，表示**无资源可用**，淡然，需要注意的是，对于进程而言，所谓的资源就是**空闲的空间**；当**sem<0**时，表示**有进程在等待资源**，假设sem=-2，表示有两个进程在等待资源；当**sem>0**时，表示有**多少个空闲资源**。\n\n接下来我们给出信号量的官方定义：\n\n> 1965年，由荷兰学者Dijkstra提出的信号量用于`记录`，信号用于sleep和wakeup.\n\n我们将信号量再去细化：\n\n```c\nstruct semphore{\n    int value; //记录资源个数\n    PCB * queue; //记录等待进程的队列\n}\n```\n\n此外，由信号量衍生出了P,V原语。**P**可以记做**test**，**V**则为**increament**\n\n下面给出P,V原语的实现——\n\n```c\n//p原语：没资源，队列休眠\nP(semaphore s){\n    s.value--;\n    if(s.value < 0){\n        sleep(s.queue);\n    }\n}\n\n//V原语：有资源，唤醒队列\nV(semaphore s){\n    s.value++;\n    if(s.value >= 0){\n        wakeup(s.queue);\n    }\n}\n```\n\n到这里，我们可以回过头来看生产者和消费者问题了，话不多说，上代码：\n\n```c\nint fd = open ('buffer.txt');\nwrite(fd,0,sizeof(int)); //写in\nwrite(fd,0,sizeof(int)); //写out\n\nsemaphore full = 0;\nsemaphore empty = BUFFER_SIZE;\n//声明互斥信号量为1,即并发修改数\nsemaphore mutex = 1;\n\nProducer(item){\n    //判断缓冲区是否已满\n    P(empty);\n    //判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量\n    P(mutex);//mutex--\n    //在这里写入in，即将item写到in的位置\n    V(mutex);//mutex++\n    V(full);//full++\n}\n\nConsumer(item){\n    P(full);//判断缓冲区为空\n    //判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量\n    P(mutex);//mutex--\n    //在这里写入iout，即从文件中的out位置读出到item中\n    V(mutex);//mutex++\n    V(empty);//empty++\n}\n```\n\n顺畅如斯，秒啊~\n\n到这里的确已经迈出了一大步，但仍有些小瑕疵，那就是由于**进程调度顺序**不确定，导致**两个进程同时访问一个信号量**的状况——\n\n## 2.对信号量的临界区\n\n为什么要保护临界区呢？什么是临界区，且听我娓娓道来——\n\n因为两个进程对同一份数据存在竞争关系，因而需要将这份资源作为**临界区**。而这里的**竞争条件**是**指和调度有关的共享语义错误**。\n\n- [x] 临界区： **一次只允许一个进程进入该进程的那一段代码，临界区的基本原则是互斥**，\n\n然而仅仅声明一段代码为临界区代码是不够的，一段好的临界区代码还应该是**有空让进**且**有限等待**。\n\n首先开始进入临界区的第一种尝试——轮换法。\n\n#### 1.轮换法\n\n![image-20210619010827920](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010827920.png)\n\n\n\n首先，这个临界区的设计是满足互斥的，但假如在调用进程P0以后，继续调用进程P0，这时就不再满足有空就进的原则了，所以下一位——\n\n#### 2.标记法\n\n![image-20210619010842398](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010842398.png)\n\nCPU大量时间闲置的问题的确得到了解决，且满足互斥，但假如有这么一种情景——\n\n两个标记都为true，那么两个进程都不再执行，我们可以类比生活中的例子：假设冰箱里没有牛奶，妻子看到丈夫大的标记后，认为丈夫会买，而丈夫看到妻子留下的标记后，认为妻子会买，这样没有真的去买了牛奶。\n\n这是一种对称法**，而在现实中，要打破这种没人买牛奶的窘况，就需要一个人**相对勤快一些。\n\n#### 3.peterson算法\n\n![image-20210619010856746](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010856746.png)\n\n而**映射到进程合作**，也应该如此，在两个标记都为true的情况下，需要有一个进程去执行，而另一个进程则什么都不做，我们来看具体的实现——\n![image-20210619010910974](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010910974.png)\n\n这是**peterson算法**的思想，它满足了一个好临界区的几个条件，是目前最好的临界区实现方式！！！\n\n两个进程竞争临界区的问题解决了，那一个多个进程呢，所谓**万法不离其宗**，我们来实际地体会一下\n\n------\n\n#### 面包店算法\n\n我们在开始的时候强调过，衡量临界区算法的标准是**互斥进入**，**有空让进**，**有限等待**。而正在之前的篇幅中，我们也验证了要同时满足这两个条件，需要结合**轮换**和**标记**的思想，那在多个进程中如何体现呢？\n\n- [x] 轮转：每个进程都有一个序号\n\n- [x] 标记 ：进程中序号最小的进入\n\n![image-20210619010925494](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010925494.png)\n\n首先**选中**第i个进程，即将它**标记**。并将**当前进程序号最小**的序号赋给数组**num的第i个元素**。\n\n接着再取消当前的标记，即做标记只是为了取出当前最小的序号。然后**遍历序号**，假如有被选中的其他进程，且该进程的序号比当前进程小，则等待它执行完，否则执行当前进程。进程结束后，将数组num的第i个元素置0.开始下一次循环。\n\n多个进程同步的问题的确可以通过面包店算法得到解决，但这么繁琐的算法看着就头疼，而且回顾为什么会产生临界区，本质上是因为**不可控的调度**导致的，而调度是要进入**内核**的，且进入内核的方式是**中断**，那我们只让一个进程触发中断不就可以保护临界区了吗？那么这样可行吗？\n\n这就要谈到软硬件协同开发中的**硬件**了——\n\n![image-20210619010938594](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010938594.png)\n\n这里使用**cli()**将**中断的寄存器INTR**置**1**，而在执行完临界区代码以后，再将其**置0**，就可以实现同一时刻只有一个进程访问临界区了。这种方法的核心在于中断寄存器，但假如是**多核CPU**，那每个CPU中都有这样一个寄存器，改变一个CPU的中断寄存器对别的CPU是没有影响的，可见这个方法是有**局限性**的。\n\n那要怎么办呢？显然我们需要一个全局的信号量来标记当前临界区的状态。这里我们尝试**硬件原子指令法**\n\n```c\nboolean \n    //这是一段原子代码，即一次执行完毕，不回切出\n    TestAndSet(boolean &x){//1.假如x为true，则执行完   2.假如为false,将x置为true并将false返回\n    \tbooean rv = x;\n    \tx = true ;\n    \treturn rv ;\n     }\n\n\nwhile(TestAndSet(&lock));\n//临界区\nlock = false;\n//剩余区\n```\n\n也就是说，假如**信号量是上锁**的的，则进入并执行完，**执行完后开锁**；而假如进去之后发现**锁是开着**的，则**马上上锁**，并返回等待下次执行。这种方式对于多CPU同样是可行的。\n\n## 3.临界区的代码实现\n\n在之前我们完成了信号量的引出，临界区的保护，接下来来看如何使用代码实现临界区。话不多说，我们直入主题——\n\n```c\nsem.c //进入内核\ntypedef struct{//声明信号量的结构体\n    char name[20];\n    int value;\n    task_struct * queue;\n}semable[20]\n    \n //用户态的程序\n producer.c\n main(){\n       //从信号量结构体中读取empty的下标\n \tsd = sem_open(\"empty\");\n       for（int i = 0; i<=5;i++）{\n           //设置阻塞状态，切换进程\n           sem_wait(sd);\n           //在文件fd中写入4个字节的数据\n           write(fd,&i,4);\n       }\n }\n\n//在semable中寻找name对应的，没找到则创建，找到则返回下标\nsys_sem_open(char *queue);\n\nsys_sem_wait(int sd){\n        //中断保护\n\tcli();\n        if(semtable[sd].value-- < 0){\n            //这里设置自己为阻塞，将自己加入到队列semtable.[sd].queue中去 \n            schedule();\n        }\n   \t   sti();\n}\n```\n\n复杂的思想最终也不过凝结为这几句宏观的代码，但即便如此，我们也要不忘初心，去探寻那**冰山下的百分之九十**。\n\n这样思想的应用在linux0.11中更是被广泛的应用，让我们来从那里学点思想吧——\n\n```c\n//读磁盘块\nbread(int dev,int block){\n    struct buffer_head *bh;\n    //开始磁盘读后睡眠，切换进程，再由磁盘中断将其唤醒，即同步\n    ll_rw_block(READ,bh);\n    wait_on_buffer(bh);\n}\n//锁住临界区\nlock_buffer (buffer_head *bh){\n    cli();\n    //while?为什么不用if\n    while(bh -> b_lock){//进入后，不管之前是否上锁，之后都要上锁\n        sleep_on(&bh_wait);\n        bh -> b_lock = 1;\n    }\n    sti();\n}\n\nvoid sleep_on(struct task_struct){\n       //加入队列，号称世界上最隐蔽的队列？\n\tstruct task_struct *tmp;\n        tmp = *p;\n        *p = current;\n        current -> state = TASK_UNINTERUPTIBLE;\n        schdule();\n        if(tmp){\n\t\ttmp -> state = 0;\n        }\n        \n}\n```\n\n我们来挑战一下世界上最**隐蔽的队列**——\n\n![image-20210619010955043](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010955043.png)\n\n将tmp指向task_struct,再将p指向当前的task_struct，**当前的即是队列的队首**，也就是说将tmp指向队首的下一个，p指向队首。又这两个指针都是存储在这个进程的内核栈中的，因此**下一次**可从**下一个进程**task_struct的内核栈中取出**tmp**指向**上一个进程**，再将**指针p**指向**当前进程**。\n\n这样就可以回答使用**while**，是将**所有的进程状态**都判断了一次，从而找出那个**优先级高的**，让他来执行。\n\n这里的p是指针的指针，我们可以理解为p指向的是一个**内存空间的起始地址**，则三级指针，n级指针同样——\n\n![image-20210619011007670](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011007670.png)\n\n上面的内容在切换进程时，会将当前进程加入阻塞队列，那如何唤醒呢？\n\n![image-20210619011019527](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011019527.png)\n\n通过**磁盘中断**调用**对临界区开锁的函数**，并在其中调用**wake_up函数**，在其中改变了**当前进程的状态**，然后使用**iret返回继续往下执行**。\n\n------\n\n## 4.死锁处理\n\n我们依然以生产者-消费者模型作为例子，我们知道不管在生产者抑或消费者函数，首先都是要判断缓冲区是否已满或者缓冲区为空，那假如将判断与之后的代码调换位置，会导致怎样的结果呢？\n\n这样的话会导致**死锁**，通俗的说，也就是**多个进程互相等待对方持有的资源，而造成谁也无法执行的现象**\n\n**本质上**说，死锁的成因是因为自己占有的资源和申请的资源造成**环路等待**。\n\n我们再来看死锁的必要条件——\n\n![image-20210619011032749](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011032749.png)\n\n那怎样处理死锁呢？\n\n![image-20210619011048485](https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011048485.png)\n\n那针对每种方法，我们可以具体在进程同步中如何做呢？\n\n1. `死锁预防` ：**一次性申请所有需要资源**，这样就不需要因为资源冲突而造成环路等待，但效率太低，没有使用的价值；另外一种直观的想法就是**资源申请按需进行**，不会造成死锁没错，但资源浪费比较严重，果断弃坑。\n\n2. `死锁避免`： 死锁避免的思想被**银行家算法**“完美”地实现了——\n\n   假设系统中的所有进程存在一**个可以完成的执行序列**，则称系统处于**安全状态**，而银行家算法就是用来找出这个安全序列的。\n\n   对于一个进程来说，它与资源间的关系分为**目前占有的资源**，**还需要的资源**，**可供分配的资源**三种。\n\n   来看具体的实现——\n\n   ```c\n   int Available[1,...,n];//每种资源剩余的数量\n   int Allocation[1,....,m];//已分配的资源数量\n   int Need[1,..,m];//进程还需要的各种资源数量\n   int work[1,..,m];//工作向量\n   bool Finish [1,..,n];//进程是否结束\n   \n   work = Available;\n   Finish[1,..,n] = false;\n   while(true){\n       for(i=1; i<=n; i++){\n           if(Finish[i]==false&& Need[i]≤Work)\n           {\n               Work = Work + Allocation[i];\n               Finish[i] = true; \n               break;\n           }else \n           {\n               goto end;\n           }\n       }\n   }\n   End: \n   for(i=1;i<=n;i++) \n       if(Finish[i]==false) \n           return “deadlock”;\n   T(n)=O(mn2)\n   \n   ```\n\n   银行家算法的实现相对通俗易懂一些，但同时带来了**时间复杂度高**的问题，而时间复杂度高的原因在于它会事无巨细的判断每一个，但出现死锁的概率毕竟比较低，所以判断所有就显得浪费时间。\n\n   那我们是否可以**先假装分配**，然**后调用银行家算法**，再判断是否可行呢？这样我们就需要申请一个**死锁进程组**，判断每一个序列是否为安全序列。\n\n3. `死锁检测+恢复` ：核心思想在于先发现问题，然后再处理，当发生死锁的时候，就让**进程回滚**，但是实现机制比较复杂\n\n4. `死锁忽略` ：究极秘诀——**重启**；\n\n------\n\n> 山高路远，静水深流。","slug":"进程与线程","published":1,"updated":"2023-09-24T09:50:29.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7mt002nxjcccwm9gzpw","content":"<h1 id=\"一、多进程图像的引出\"><a href=\"#一、多进程图像的引出\" class=\"headerlink\" title=\"一、多进程图像的引出\"></a>一、多进程图像的引出</h1><h2 id=\"1-多进程图像\"><a href=\"#1-多进程图像\" class=\"headerlink\" title=\"1.多进程图像\"></a>1.多进程图像</h2><p>多个进程同时存在于内存，可能会出现前一个进程的地址中的内容被第二个进程更改。这样显然是不合理的。</p>\n<p>我们首先会想到，是否可以设置<strong>DPL</strong>的值，也就是将其设置为<strong>特权级别</strong>，这样进程之间就不能互相访问了，但这里忽略了一个问题，DPL的设置是针对<strong>操作系统</strong>而言的，进程的DPL都等于3，即<strong>用户级权限</strong>，依然可以互相访问，所以这种解决方式的思路是错误的。</p>\n<p>那如何保证进程间不冲突呢？直观的解决方式，就是给进程<strong>上锁</strong>，限制对<strong>内存地址的读写</strong>。</p>\n<p><strong>映射表</strong>就是实现限制访问的那个利器。映射表的思路即是利用<strong>虚拟内存</strong>实现<strong>地址分离</strong>。</p>\n<p>说到这里，我们发现，所谓的多进程图像，不单单是进程的管理，还涉及到内存的管理。</p>\n<h3 id=\"多进程如何合作\"><a href=\"#多进程如何合作\" class=\"headerlink\" title=\"多进程如何合作\"></a>多进程如何合作</h3><p>先看下面的例子——</p>\n<p>假设有一段空闲的内存空间，两块进程都想利用这块内存空间，这样有可能会出现一块内存空间出现<strong>两个不完整的进程片段</strong>，也就是说，进程间是可以互相合作的，但合作的方式需要被协调。</p>\n<p>那怎样协调呢，纸上得来终觉浅，要想觉知此事，不妨理解<strong>生产者-消费者实例</strong>——</p>\n<blockquote>\n<p>生产者不断的产生数据放入缓冲区，而消费者从缓冲区中取出数据进行处理，当缓冲区已满的时候，生产者阻塞，当缓冲区为空的时候，消费者阻塞</p>\n</blockquote>\n<p>我们会使用三种方式来实现生产者-消费者问题——</p>\n<p>在下文的进程同步中会提及。。。</p>\n<h1 id=\"二、线程的引出与实现\"><a href=\"#二、线程的引出与实现\" class=\"headerlink\" title=\"二、线程的引出与实现\"></a>二、线程的引出与实现</h1><p>从上一节我们知道多进程是操作系统的最基本，最核心的图像，多进程可以被组织，合作与切换。</p>\n<p>多进程的组织是通过<strong>状态与队列</strong>来实现的</p>\n<p>那么多进程是如何被<strong>切换</strong>的呢？且听我娓娓道来——</p>\n<hr>\n<h2 id=\"1-用户级线程\"><a href=\"#1-用户级线程\" class=\"headerlink\" title=\"1.用户级线程\"></a>1.用户级线程</h2><h3 id=\"线程的引出\"><a href=\"#线程的引出\" class=\"headerlink\" title=\"线程的引出\"></a>线程的引出</h3><p>既然我们要了解的是进程间的切换，那为什么学习的却是线程呢？</p>\n<p>首先我们先来看宏观上的进程切换：一个<strong>进程</strong>，也就是<strong>指令执行序列</strong>+<strong>资源</strong>，在发生外中断后，切换到另一个进程。在这期间，指令访问的内存地址是通过<strong>映射表</strong>来获取的。这个切换是由中断引起的，因而会进入内核态，会涉及到<strong>资源的分配</strong>。而资源的分配是浪费时间的，那么为了提高进程执行的效率，能否将资源与指令的<strong>执行分离</strong>开，实现不动资源而只切换指令序列呢？——</p>\n<p>我们来看直观的表述——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010326080.png\" alt=\"image-20210619010326080\"></p>\n<p>这样就引出了轻巧级的进程——<strong>线程</strong>。</p>\n<h3 id=\"线程的价值\"><a href=\"#线程的价值\" class=\"headerlink\" title=\"线程的价值\"></a>线程的价值</h3><p>要回答<strong>线程</strong>是否实用，也就是要回答<strong>多个执行序列+一个地址空间</strong>的思想是否实用。</p>\n<p>我门来看下面的例子——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010341740.png\" alt=\"image-20210619010341740\"></p>\n<p>这个网页呈现出来的是，首先文字被加载出来，接着图片被加载，最后全部内容都展示了出来。</p>\n<p>实际上它的程序执行流程是多个线程从<strong>浏览器的缓冲区</strong>中读取<strong>同一份资源</strong>，程序执行展示文本的线程时，在此期间切换到展示图片的线程，过一段时间又切换回来，给用户更好的体验。</p>\n<p>这里我描述的比较<strong>生涩</strong>，其实多线程的执行，一言以蔽之，其实就是编程时<strong>多条线路并发执行</strong>：</p>\n<h3 id=\"线程的切换\"><a href=\"#线程的切换\" class=\"headerlink\" title=\"线程的切换\"></a>线程的切换</h3><p>开局一张图：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010356747.png\" alt=\"image-20210619010356747\"></p>\n<p>可以看出，这里线程间的切换是通过一个叫做<strong>Yield</strong>的函数来实现的，所以我们的<strong>核心</strong>就在于写出yeild函数的实现——</p>\n<p>要完成切换，就要保存上一个线程的状态，状态的保存是依赖栈来实现的，我们先从两个执行序列与一个栈讲起——</p>\n<h4 id=\"两个执行序列与一个栈\"><a href=\"#两个执行序列与一个栈\" class=\"headerlink\" title=\"两个执行序列与一个栈\"></a>两个执行序列与一个栈</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010411788.png\" alt=\"image-20210619010411788\"></p>\n<p>这张图到底表达了什么意思呢？</p>\n<p>在函数B中调用Yield函数，这时需要将程序B的下一条指令的地址压栈，跳转后，在C函数中调用了D函数并压栈，在D函数中调用Yield函数，此时我们需要跳转204的位置，跳转后，PC指针指向了地址204，接着往下执行，遇到**}**后，弹栈并跳转，然后程序指针跳到404处。</p>\n<p>嗯哼，是我剧本拿错了吗？的确，就是这么戏剧性，我要的是<strong>弹栈104</strong>并跳转，可没想调回<strong>404</strong>啊，死循环。。。</p>\n<p>那么这是为什么呢？因为我们<strong>共用了一个栈</strong>！！！</p>\n<p>所以我们很自然的需要从<strong>一个栈</strong>过渡到了<strong>两个栈</strong>。</p>\n<h4 id=\"两个执行序列与两个栈\"><a href=\"#两个执行序列与两个栈\" class=\"headerlink\" title=\"两个执行序列与两个栈\"></a>两个执行序列与两个栈</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010426291.png\" alt=\"image-20210619010426291\"></p>\n<p>现在线程切换的时候，首先yield函数需要切换栈，这里就需要一个能够保存当前线程栈状态的<strong>容器</strong>，也就是<strong>TCB</strong>。</p>\n<p>我们最后在执行yield函数时，首先切换TCB，然后Yiled函数结束，继续往下执行**}<strong>,也就是执行</strong>ret指令**</p>\n<p>弹栈执行104，一个线程切换就这样有惊无险的完成了。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 这里不需要jmp 204,因为Yield函数执行完后，就会<strong>默认往下顺序执行</strong>。</li>\n</ul>\n<p>完成了两个栈，我们再将包含线程切换的<strong>ThreadCreate</strong>函数做初始化，并在其中关联<strong>TCB与栈</strong>。</p>\n<p>这样，一个完整的进程就有了——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010441251.png\" alt=\"image-20210619010441251\"></p>\n<hr>\n<p>说到这里，我们就可以来回答这个小结为什么叫用户级线程，因为<strong>field是用户级应用程序</strong>。</p>\n<p>整个用户级线程可以实现有序的切换了，那么为什么还要内核级线程呢？当然是因为它有其天生的<strong>限制</strong>，而从另一个角度来说，核心级线程是用户级线程的<strong>扩展</strong>。</p>\n<h3 id=\"用户级线程的缺点\"><a href=\"#用户级线程的缺点\" class=\"headerlink\" title=\"用户级线程的缺点\"></a>用户级线程的缺点</h3><p>当用户级线程在执行指令过程中发生中断，系统会切换到内核态，然后执行中断程序，在执行完后，因为权限已经改变，<strong>无法切换回用户级线程</strong>，用户级线程不再执行。</p>\n<h2 id=\"2-内核级线程\"><a href=\"#2-内核级线程\" class=\"headerlink\" title=\"2.内核级线程\"></a>2.内核级线程</h2><p>我们首先来回顾一下<strong>内核级线程的切换</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010458893.png\" alt=\"image-20210619010458893\"></p>\n<p>宏观的看，内核级线程由用户级线程的两个栈演变成了两套栈，它的的实现机制大致分为五步——</p>\n<ol>\n<li>用户栈通过<strong>int中断指令</strong>跳转到内核栈</li>\n<li>在内核栈中存储当前内核线程的状态，而内核栈又由<strong>线程控制块TCB1</strong>维护</li>\n<li>通过<strong>Schedule函数</strong>完成内核级线程跳转</li>\n<li>在内核栈中存储当前内核线程的状态，而内核栈又由线程控制块TCB2维护</li>\n<li>由内核栈跳转回用户栈</li>\n</ol>\n<p>下面我们将具体实现这个内核级线程：</p>\n<hr>\n<p>这个故事首先从进入内核开始，也就是从某个<strong>中断</strong>开始，这里的系统调用案例我们选择<strong>fork()</strong>,fork()函数是用于创建进程的，而<strong>进程</strong>实质上是<strong>资源+指令序列</strong>，<strong>指令序列</strong>就是一系列的<strong>线程</strong>，所以我们使用fork函数，是可以完成内核级线程的切换的。</p>\n<p>我们来看下面的例子——</p>\n<h3 id=\"中断入口\"><a href=\"#中断入口\" class=\"headerlink\" title=\"中断入口\"></a>中断入口</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010514141.png\" alt=\"image-20210619010514141\"></p>\n<p>在main函数中调用了A函数，之后在A函数的执行中又调用了fork系统调用，fork系统调用会引起中断，在触发中断处理程序时，首先会将之前用户态的栈进行保存，也就是将SS,SP压栈，接着跳转fork的中断处理程序，也就是<strong>system_call函数</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010528293.png\" alt=\"image-20210619010528293\"></p>\n<p>在system_call中，首先会做寄存器的压栈，也就是<strong>准备切换</strong>，然后跳转sys_fork系统调用<strong>开始切换</strong>，在这个系统调用中，首先将当前线程的<strong>TCB置给ex</strong>，接着判断ex的状态，本质上是判断<strong>TCB</strong>的state<strong>，如果</strong>非0<strong>的话，也就是处于</strong>阻塞状态<strong>。就需要执行schedule以完成</strong>切换<strong>，此外，当</strong>时间片用完**以后，也需要进行切换。</p>\n<h3 id=\"中断出口\"><a href=\"#中断出口\" class=\"headerlink\" title=\"中断出口\"></a>中断出口</h3><p>完成了切换，那怎样返回呢？通过<strong>中断出口</strong>，那中断出口做了什么呢？对应中断入口一系列的入栈，中断出口会做弹栈操作。</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010541971.png\" alt=\"image-20210619010541971\"></p>\n<p>我们描述了中断入口和中断出口，那在中断的过程中做了什么事情呢？</p>\n<p>在中断中首先找到要切换的线程，再<strong>切换</strong>到该线程。这里面会涉及到线程的调度与切换，线程的调度我们后面会提及，这里我们只看线程的切换——</p>\n<h3 id=\"中断过程——线程切换\"><a href=\"#中断过程——线程切换\" class=\"headerlink\" title=\"中断过程——线程切换\"></a>中断过程——线程切换</h3><p>线程的切换是通过<strong>switch_to</strong>来完成的，在函数中主要通过<strong>长跳转</strong>来实现线程跳转——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010558855.png\" alt=\"image-20210619010558855\"></p>\n<p>首先使用<strong>movw指令</strong>将CPU中寄存器的内容都写入到到<strong>TSS</strong>中，<strong>TSS</strong>也就是<strong>任务结构段</strong>，它是<strong>进程控制块PCB</strong>的一部分。</p>\n<p>首先通过<strong>TR寄存器</strong>(<strong>类CS寄存器</strong>)找到位于<strong>GDT表</strong>中的<strong>TSS描述符</strong>，即指向TSS段的指针，最终通过TSS描述符定位到TSS段。</p>\n<p>而<strong>长跳转</strong>做的无非就是通过TR寄存器找到另一个线程的TSS描述符，通过TSS描述符找到TSS段，并将寄存器中的的内容也加载到TSS段中。</p>\n<p>但以TSS的方式实现跳转的效率是低下的，因为TSS中的<strong>长跳转</strong>需要对一系列<strong>寄存器</strong>操作。之后我们将采用<strong>KIN stack</strong>的方式完成切换。</p>\n<blockquote>\n<p>参考linux进程切换与TSS结构<a href=\"https://blog.51cto.com/stonehorse/1113115\">https://blog.51cto.com/stonehorse/1113115</a></p>\n</blockquote>\n<hr>\n<p>在上一小节的学习中，我们了解了线程的切换，接着我们将范围放大，来一起学习线程创建，即<strong>ThreaCreate函数</strong></p>\n<p>首先从<strong>sys_fork函数</strong>开始我们的求知之旅——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010627862.png\" alt=\"image-20210619010627862\"></p>\n<p>在<strong>sys_fork函数</strong>中，首先将<strong>用户态状态入栈</strong>，以便子进程调用，接着在sys_fork函数中调用<strong>copy_process</strong>，可以看到这个函数的参数有一长串，细心观察的话，会发现都是<strong>父进程压入栈中的内容</strong>，也就是子进程和父进程是<strong>共用</strong>一套用户栈的。</p>\n<p>那么子进程创建的细节是怎样的呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010642915.png\" alt=\"image-20210619010642915\"></p>\n<p>首先<strong>申请了一页</strong>的内存空间，我们再来回顾一下它的渊源：开机时<strong>memmap</strong>初始化，将内存分以<strong>4k</strong>为最小单元的页，需要申请<strong>内核空间</strong>时，则选取memmap<strong>不等于0的</strong>的一页内存空间即可。</p>\n<p>接着**创建TCB,**也就是从申请的内存起始开始往后一页的这段内存空间。</p>\n<p>然后创建内核栈和用户栈，最终将<strong>TCB与栈相关联</strong>。</p>\n<p>最后，我们只需要完成一系列的初始化即可，这里面值得关注的是ip的初始化，也就是从栈中取出中断后下一条指令的内存地址，另外还需要eax初始化为0，那么eax有什么用呢？</p>\n<p>我们经常看到的一个判断：<strong>if(!fork()){子进程执行}</strong>,这里判断的条件即是<strong>eax的值</strong>，如果eax等于<strong>0</strong>，<strong>子进程执行</strong>，反之，父进程执行。</p>\n<p>明确了子进程的执行条件，我们来看子进程的具体执行的代码，也就是<strong>exec系统调用</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010701378.png\" alt=\"image-20210619010701378\"></p>\n<p>我们从父进程的<strong>shell</strong>进入子进程的执行，当子进程执行完后，需要返回，那它会<strong>返回到哪里</strong>呢？我们知道在跳转执行的结束，会执行指令<strong>iret</strong>，所以返回的地址取决于iret中<strong>ret</strong>指令弹栈的<strong>IP寄存器</strong>内容。那IP指向哪里呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010718802.png\" alt=\"image-20210619010718802\"></p>\n<p>IP指向的位置，或者说IP寄存器中地址取决于<strong>struct_exec系统调用</strong>的参数。在它的执行中，将ex寄存器中的<strong>a.entry</strong>方法的地址加载到ret中作为<strong>IP</strong>的指向地址，a.entry是<strong>可执行文件的入口地址</strong>，当它连接产生可执行文件时，会将文件中的内容，即磁盘中的内容<strong>写入到</strong>内存执行，子进程执行完毕！</p>\n<h2 id=\"3-操作系统的那棵树\"><a href=\"#3-操作系统的那棵树\" class=\"headerlink\" title=\"3.操作系统的那棵树\"></a>3.操作系统的那棵树</h2><blockquote>\n<p>系统调用就是一种软中断处理程序</p>\n</blockquote>\n<p>在这一小节中，我们不看学习新的内容，因为旧的内容还一团乱麻。所以我们有必要将之前的知识点<strong>连点成线</strong>，让它从<strong>萌芽</strong>开始，随时光浸淫，最终长成<strong>参天大树</strong>。</p>\n<p>即便操作系统这颗很庞大的参天大树也是要从一个很小的火光发散的。就如同李志军老师告诫我们的一样——</p>\n<blockquote>\n<p>The mind is not a vessel that needs filling,but wood that needs ignitng</p>\n<p>我们的大脑不是装满水的容器，而应该是点燃的火光。</p>\n</blockquote>\n<p>所以我们接下来的内容我们将从一个很小，很具体，很有价值的IDEA开始——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 我们要在屏幕上交错出现A和B</li>\n</ul>\n<p>首先回顾一下线程切换的思路——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <strong>运转CPU</strong>-》<strong>CPU没有好好运转</strong>-》<strong>要让CPU好好运转，首先从A函数跳到B函数</strong>-》<strong>跳转时使用1个栈和1个yeild发生混乱</strong>-》<strong>试着使用两个栈和两个TCB</strong>-》<strong>这样可以运转没错，但只能在用户态运转是不合适的</strong>-》<strong>引入两套栈，即内核栈的切换</strong></li>\n</ul>\n<p>首先从<strong>用户代码</strong>开始——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们再将其用<strong>汇编</strong>来表述——</p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">main()&#123;\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax,res\n\tcmp1,res,0\n\tjne 208\n200: printf(&quot;A&quot;)\n\tjmp 200\n208: ...\n304: wait()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>接着复现执行<strong>int 0x80</strong>后的代码——</p>\n<pre class=\"line-numbers language-ASM\" data-language=\"ASM\"><code class=\"language-ASM\">main()&#123;\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax , res\n\tcmp1 res,0\n&#125;\n\nset_system_gate(0x80,&amp;system_call);\nsystem_call:\n\tcall sys_call_table(,%eax,4)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>首先将<strong>系统调用号</strong>赋给**_NR_fork<strong>，触发中断</strong>0x80<strong>，进入</strong>system_call<strong>，在该系统调用中，跳转</strong>system_call_table**,将1赋给eax,也就是当前内核进程为<strong>父进程</strong>，在其中调用<strong>sys_fork</strong>——</p>\n<pre class=\"line-numbers language-ASM\" data-language=\"ASM\"><code class=\"language-ASM\">sys_fork:\n\tpush1 ..\n\tcall copy_process\n\tret<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>开始<strong>创建子进程</strong>，子进程的创建也就是对父进程的复制，即<strong>copy_process</strong>_</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">copy_process(... ,long eip,..)&#123;\n\tp &#x3D; (PCB *)get_free_page();\n        p-&gt;tss.esp0 &#x3D; p+4k;\n        p-&gt;tss.esp &#x3D; esp;\n        p-&gt;tss.eax &#x3D; 0;\n        p-&gt;tss.eip &#x3D; eip;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完成了<strong>PCB的创建与初始化</strong>，也就是完成了子进程的创建，接着<strong>ret</strong>返回到父进程，<strong>iret</strong>返回用户态。</p>\n<p>然后接着调用main函数，不断的<strong>创建线程</strong>，接着执行main函数，就到了<strong>wait()函数</strong>，它的具体实现是——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">sys_waitpid()&#123;\n\tcurrent -&gt; state &#x3D; TASK_INTERRUPTTIBLE;\n        schedule();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将当前线程的状态置为<strong>阻塞</strong>，开始切换——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">shedule()&#123;\n    if((*p)-&gt;state &#x3D;&#x3D; TASK_RUNNING &amp;&amp;  (*p)-&gt;counter &gt; c)\n        \tc &#x3D; (*p) -&gt; counter,next &#x3D; i;\n    \t   ...\n               switch_to(next);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果当前状态为运行态，使用<strong>调度算法</strong>得到<strong>要切换的线程</strong>，进入切换——</p>\n<p>切换以后，就可以打出B了，但我们需要的是交替执行，所以要从B再进入A，也就是要完成切换，而切换是在内核态完成的，而用户态需要使用中断才能进入内核，那使用哪个中断呢？</p>\n<p><strong>时钟中断</strong>！！！</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">sched_int</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">set_intr_gate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x20</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>timer_interrupt<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span>  _time_interrupt<span class=\"token operator\">:</span>\n\tcall do_time\n        \n<span class=\"token keyword\">void</span> <span class=\"token function\">do_time</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">--</span>current <span class=\"token operator\">-></span> counter <span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">-></span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     \n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将<strong>中断类型码</strong>赋给系统调用<strong>time_interrupt</strong>,在其中跳转<strong>do_time</strong>,在do_time中判断当前线程的数目，如果<strong>大于0</strong>，<strong>不切换</strong>，否则调用schedule切换线程。</p>\n<p>最终在<strong>schdule</strong>中调用<strong>switch_to</strong>。不断循环，完结~</p>\n<h1 id=\"三、-CPU调度\"><a href=\"#三、-CPU调度\" class=\"headerlink\" title=\"三、 CPU调度\"></a>三、 CPU调度</h1><p>在上面的描述中，一个线程的切换就这样丝滑地完成了，但我们总将CPU调度刻意的当做一个黑盒子，这是因为CPU调度的确是一个很揪心的任务，但了解它又能加深我们对系统设计设计的理解，因此，这节内容，我们就明知山有虎，偏向虎山行了——</p>\n<hr>\n<h2 id=\"1-cpu调度策略\"><a href=\"#1-cpu调度策略\" class=\"headerlink\" title=\"1.cpu调度策略\"></a>1.cpu调度策略</h2><p>当一个线程阻塞后，就要切换到另一个线程，那应该切换到哪一个线程呢？直观的说，我们需要<strong>尽可能快</strong>的完成任务。那如何衡量任务执行的效率呢？就连任务本身都有不同的类型，比如<strong>I/O型</strong>，<strong>CPU型</strong>，按照不同的分类角度，又有<strong>前台型任务</strong>和<strong>后台型</strong>任务。</p>\n<p>我们只捉住它<strong>关键</strong>的几个点来设计一个调度算法——</p>\n<ol>\n<li><strong>周转时间短</strong>，从任务进入到任务结束，也就是尽可能快的完成任务。<strong>周转时间=等待时间+运行时间</strong>。</li>\n<li><strong>响应时间短</strong>，即从操作到响应的时间短</li>\n<li><strong>系统内耗少</strong>，即系统吞吐量大，执行任务多</li>\n</ol>\n<p>我们来看符合某些点的具体的算法思想，并用上面的<strong>指标</strong>来衡量它：</p>\n<h3 id=\"FCFS\"><a href=\"#FCFS\" class=\"headerlink\" title=\"FCFS\"></a>FCFS</h3><p>先来先服务是最直观的调度算法，但一个系统是复杂的，仅考虑到公平只会事倍功半。</p>\n<p>假设有n个任务，每个任务的周转时间分别为Ti，则它的<strong>平均响应时间</strong>为<strong>：T1+T2+T3+Tn/n</strong>,它的第<strong>n个任务的响应周转</strong>为<strong>T1+T2+T3+…+Tn</strong>，假如说T1的时间比其他时间的加和还要大，这样显然周转时间有可能很长，非常<strong>不合理</strong>。</p>\n<p>那能否在FCFC调度算法的前提下，根据任务的长短来决定执行的顺序呢？那我们来了解一下SJF——<strong>短作业优先调度算法</strong></p>\n<h3 id=\"SJF\"><a href=\"#SJF\" class=\"headerlink\" title=\"SJF\"></a>SJF</h3><p>假设有n个任务，按短作业优先的原则，调度的结果分别是：<strong>P1,P2,P3…Pn</strong>,则它总的周转时间为*<em>n</em>P1+(n-1)*p2+….**，这样它的周转时间显然得到显著的降低。</p>\n<p>但假如我现在有一个很长的作业，但它又非常紧急，我是不是应该适当的根据优先级来调整执行的顺序呢？这就要谈及RR——<strong>轮转时间片调度算法</strong>。</p>\n<h3 id=\"RR\"><a href=\"#RR\" class=\"headerlink\" title=\"RR\"></a>RR</h3><p>时间片轮转的思想是将作业再<strong>细分</strong>，然后CPU为每个作业分配<strong>时间片</strong>，接着来<strong>交错</strong>地执行任务的最小单元。</p>\n<p>但这里同样面临问题，假如<strong>时间片大</strong>的话，<strong>响应时间长</strong>；<strong>时间片小</strong>的话，系统内耗大，<strong>吞吐量小</strong></p>\n<p>我们先来微笑地说句fuck~</p>\n<p>那假如我们对周转时间和响应时间的需求同时存在，该怎么办呢？</p>\n<p>设置<strong>优先级</strong>！同时我们也需要首先遵守一个原则，人们更关心计算机与人的交互时间，也就是<strong>前台任务执行快</strong>，所以我们首先按<strong>RR</strong>的原则来安排<strong>前台任务</strong>，接着按照<strong>SJF</strong>的原则来安排<strong>后台任务</strong>，这两类任务之间通过<strong>动态的优先级设置</strong>进行互相切换。</p>\n<p>要满足上一小节的复杂指标，给我们的直观感受就是，这个实现的算法一定繁琐至极，但<strong>linux0.11中的schdule函数</strong>却很好地处理了这个问题——</p>\n<h2 id=\"2-一个实际的schedule函数\"><a href=\"#2-一个实际的schedule函数\" class=\"headerlink\" title=\"2.一个实际的schedule函数\"></a>2.一个实际的schedule函数</h2><p>我们在开始之前，首先要明确时间片和优先级是有一定的关系的，时间片大的本身一定程度上优先级就高，能解决复杂问题的算法即便代码量少，但思想的深度却不会低。</p>\n<p>下面我们言归正传，来看chedule函数的实现——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">schele(void)&#123;\n    while(1)&#123;\n         int i &#x3D; NR_TASKS;\n    \t  int c&#x3D; -1;\n         int next &#x3D; 0;\n   \t       p &#x3D; &amp;tasks[NR_TASKS];\n   \t       while(i--)&#123;\n    \t\tif(*p -&gt; state &#x3D;&#x3D; TASK_RUNNING &amp;&amp;  *p -&gt; counter &gt; c)&#123;&#x2F;&#x2F;加入当前作业的状态为就绪态且优先级大\n            \t\tc &#x3D; *p -&gt; counter;\n                    \tnext &#x3D; i;\t\n           &#125;\n     \t&#125;\n        if(c)&#123;\n            break;     &#x2F;&#x2F;找到最大的counter\n        &#125;\n        for(p &#x3D; &amp;LAST_TASK;p &gt; &amp;FIRST_TASK; p--)&#123;\t&#x2F;&#x2F;重新设置优先级\n            (*p) -&gt; counter &#x3D; ((*p) -&gt; counter &gt;&gt; 1) + *p -&gt;priority;\n        &#125;\n        switch_to(next);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这个程序中，counter是关键，它兼顾了优先级与时间片——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">&#x2F;&#x2F;时间片\nvoid do_time()&#123;\n    if(-- current -&gt; counter &gt;0)\n        \treturn;\n    current -&gt; counter &#x3D; 0;\n    schedule();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>即<strong>时间片为0</strong>时，则<strong>切换时间片</strong>。在这里<strong>counter</strong>满足<strong>轮转调度</strong>，保证了<strong>响应</strong>。</p>\n<p>而下面的程序中，counter又体现了优先级——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">if(*p -&gt; state &#x3D;&#x3D; TASK_RUNNING &amp;&amp;  *p -&gt; counter &gt; c)&#123;&#x2F;&#x2F;加入当前作业的状态为就绪态且优先级大\n            c &#x3D; *p -&gt; counter;\n            next &#x3D; i;\t\n &#125;\n\nfor(p &#x3D; &amp;LAST_TASK;p &gt; &amp;FIRST_TASK; p--)&#123;\t&#x2F;&#x2F;重新设置优先级\n            (*p) -&gt; counter &#x3D; ((*p) -&gt; counter &gt;&gt; 1) + *p -&gt;priority;\n &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里counter体现的是动态的优先级，表现出来的是阻塞后进程的优先级会高于非阻塞进程的优先级，也就是优先前台进程。</p>\n<p>但值得注意的是，counter是否超出会响应时间的界，我们不妨来定量地看一下——</p>\n<p>假设进程n开始响应时的时间为p,而进程n的响应时间(<strong>时间片</strong>)是p+p/2,同样可以类比得到第<strong>无穷个</strong>进程的响应时间为<strong>p+p/2+p/4+…+p/(2的无穷次方) &lt; 2p</strong></p>\n<h1 id=\"四-、进程同步和死锁\"><a href=\"#四-、进程同步和死锁\" class=\"headerlink\" title=\"四.、进程同步和死锁\"></a>四.、进程同步和死锁</h1><p>我们在上一章中学习到了线程间的切换是如何完成的，而<strong>进程</strong>等于<strong>资源</strong>+<strong>可执行的指令序列(线程),<strong>那要完成进程的切换，也就是进程的</strong>并发执行</strong>，岂不是只需要知道<strong>资源</strong>是如何被<strong>调度</strong>的就可以了，那么资源如何表示，又如何量化呢，在调度资源的过程中，会出现怎样的问题，又应该怎样解决呢？这一系列的问题，我们都将在下面的内容中找到答案——</p>\n<hr>\n<h2 id=\"1-进程同步与信号量\"><a href=\"#1-进程同步与信号量\" class=\"headerlink\" title=\"1.进程同步与信号量\"></a>1.进程同步与信号量</h2><p>所谓进程的合作，就是多个进程来完成同一个任务，之前我们浅谈过<strong>生产者与消费者</strong>的实例，这里我们对它进行进一步的剖析——</p>\n<blockquote>\n<p>对于生产者而言，它生产了一个资源并放入缓冲区，当缓冲区满的时候，就不再生产。</p>\n<p>同样的，对于消费者而言，它消费来自缓冲区的资源，当缓冲区空的时候，它就不再消费。</p>\n</blockquote>\n<p>从这种机制中，我们看出，首先需要一个放置资源的缓冲区——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">BUFFER_SIZE</span> <span class=\"token expression\"><span class=\"token number\">10</span></span></span>\n<span class=\"token comment\">//声明资源的结构</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> item<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//声明缓冲区的大小</span>\nitem buffer<span class=\"token punctuation\">[</span>BUFFER_SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> in <span class=\"token operator\">=</span> out <span class=\"token operator\">=</span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其次，我们来看最直观的生产者与消费者进程模型</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//生产者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> BUFFER_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    buffer<span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> item<span class=\"token punctuation\">;</span>\n    in <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>in <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//消费者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    item <span class=\"token operator\">=</span> buffer<span class=\"token punctuation\">[</span>out<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span>\n    out<span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>iout<span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这个最基础的模型中，我们的确<strong>做到</strong>了去控制生产者消费者运行的<strong>时机</strong>，但进程的调度是<strong>不可预测</strong>的，我们不妨再扩充一下如何使用<strong>信号counter</strong>控制进程的<strong>休眠与唤醒</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//生产者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> BUFFER_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//缓冲区已满以后，就让创建好的进程进入休眠队列</span>\n    <span class=\"token punctuation\">&#125;</span>\n    buffer<span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> item<span class=\"token punctuation\">;</span>\n    in <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>in <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>counter  <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//唤醒消费者\t</span>\n    <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//消费者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//缓冲区为空的时候，就让消费者进程进出入休眠队列</span>\n    <span class=\"token punctuation\">&#125;</span>\n    item <span class=\"token operator\">=</span> buffer<span class=\"token punctuation\">[</span>out<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span>\n    out<span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>iout<span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>counter  <span class=\"token operator\">==</span> BUFFER_SIZE<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//唤醒生产者</span>\n    <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>一个第二版的生产者消费者模型就这样形成的，它无疑更完善了一些，但因为<strong>counter信号</strong>终究表示的比较<strong>宏观</strong>，导致在细节上出错了——</p>\n<p>假设缓冲区<strong>已满</strong>，这时<strong>生产者进程P1</strong>运行，并进入<strong>休眠队列</strong>，紧接着<strong>生产者进程P2</strong>运行，也进入休眠队列，此时counter等于<strong>BUFFER_SIZE</strong>.然后消费者进程运行一次，<strong>缓冲区内内容减1</strong>，唤醒生产者，但在生产者执行之前，又有一个消费者进程运行，此时counter等于<strong>BUFFER_SIZE-2</strong>,则生产者进程<strong>P2不会被唤醒</strong>。</p>\n<p>出现这样的问题无疑是因为<strong>信号counter</strong>仅仅能表示<strong>缓冲区中空闲的状态</strong>，而无法判断<strong>休眠队列</strong>中有几个进程，换句话说，事情<strong>不是非0即1</strong>的，可能这个1表示的还有1.0和1.00的区分——</p>\n<p>因而我们要使这个信号可以表达休眠和唤醒两种状态，当然，这个时候已经不能称为信号了，不如就叫<strong>信号量</strong>？</p>\n<h3 id=\"从信号到信号量\"><a href=\"#从信号到信号量\" class=\"headerlink\" title=\"从信号到信号量\"></a>从信号到信号量</h3><p>通过信号量我们可以判断休眠或者唤醒的状态。</p>\n<p>姑且将信号量记为<strong>sem</strong>，当<strong>sem=0</strong>时，表示<strong>无资源可用</strong>，淡然，需要注意的是，对于进程而言，所谓的资源就是<strong>空闲的空间</strong>；当<strong>sem&lt;0**时，表示**有进程在等待资源**，假设sem=-2，表示有两个进程在等待资源；当**sem&gt;0</strong>时，表示有<strong>多少个空闲资源</strong>。</p>\n<p>接下来我们给出信号量的官方定义：</p>\n<blockquote>\n<p>1965年，由荷兰学者Dijkstra提出的信号量用于<code>记录</code>，信号用于sleep和wakeup.</p>\n</blockquote>\n<p>我们将信号量再去细化：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">semphore</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span> <span class=\"token comment\">//记录资源个数</span>\n    PCB <span class=\"token operator\">*</span> queue<span class=\"token punctuation\">;</span> <span class=\"token comment\">//记录等待进程的队列</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此外，由信号量衍生出了P,V原语。<strong>P</strong>可以记做<strong>test</strong>，<strong>V</strong>则为<strong>increament</strong></p>\n<p>下面给出P,V原语的实现——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//p原语：没资源，队列休眠</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>semaphore s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    s<span class=\"token punctuation\">.</span>value<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>value <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//V原语：有资源，唤醒队列</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>semaphore s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    s<span class=\"token punctuation\">.</span>value<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>value <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>到这里，我们可以回过头来看生产者和消费者问题了，话不多说，上代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">open</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'buffer.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//写in</span>\n<span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//写out</span>\n\nsemaphore full <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\nsemaphore empty <span class=\"token operator\">=</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//声明互斥信号量为1,即并发修改数</span>\nsemaphore mutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">Producer</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//判断缓冲区是否已满</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex--</span>\n    <span class=\"token comment\">//在这里写入in，即将item写到in的位置</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex++</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//full++</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token function\">Consumer</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//判断缓冲区为空</span>\n    <span class=\"token comment\">//判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex--</span>\n    <span class=\"token comment\">//在这里写入iout，即从文件中的out位置读出到item中</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex++</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//empty++</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>顺畅如斯，秒啊~</p>\n<p>到这里的确已经迈出了一大步，但仍有些小瑕疵，那就是由于<strong>进程调度顺序</strong>不确定，导致<strong>两个进程同时访问一个信号量</strong>的状况——</p>\n<h2 id=\"2-对信号量的临界区\"><a href=\"#2-对信号量的临界区\" class=\"headerlink\" title=\"2.对信号量的临界区\"></a>2.对信号量的临界区</h2><p>为什么要保护临界区呢？什么是临界区，且听我娓娓道来——</p>\n<p>因为两个进程对同一份数据存在竞争关系，因而需要将这份资源作为<strong>临界区</strong>。而这里的<strong>竞争条件</strong>是<strong>指和调度有关的共享语义错误</strong>。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 临界区： <strong>一次只允许一个进程进入该进程的那一段代码，临界区的基本原则是互斥</strong>，</li>\n</ul>\n<p>然而仅仅声明一段代码为临界区代码是不够的，一段好的临界区代码还应该是<strong>有空让进</strong>且<strong>有限等待</strong>。</p>\n<p>首先开始进入临界区的第一种尝试——轮换法。</p>\n<h4 id=\"1-轮换法\"><a href=\"#1-轮换法\" class=\"headerlink\" title=\"1.轮换法\"></a>1.轮换法</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010827920.png\" alt=\"image-20210619010827920\"></p>\n<p>首先，这个临界区的设计是满足互斥的，但假如在调用进程P0以后，继续调用进程P0，这时就不再满足有空就进的原则了，所以下一位——</p>\n<h4 id=\"2-标记法\"><a href=\"#2-标记法\" class=\"headerlink\" title=\"2.标记法\"></a>2.标记法</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010842398.png\" alt=\"image-20210619010842398\"></p>\n<p>CPU大量时间闲置的问题的确得到了解决，且满足互斥，但假如有这么一种情景——</p>\n<p>两个标记都为true，那么两个进程都不再执行，我们可以类比生活中的例子：假设冰箱里没有牛奶，妻子看到丈夫大的标记后，认为丈夫会买，而丈夫看到妻子留下的标记后，认为妻子会买，这样没有真的去买了牛奶。</p>\n<p>这是一种对称法<strong>，而在现实中，要打破这种没人买牛奶的窘况，就需要一个人</strong>相对勤快一些。</p>\n<h4 id=\"3-peterson算法\"><a href=\"#3-peterson算法\" class=\"headerlink\" title=\"3.peterson算法\"></a>3.peterson算法</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010856746.png\" alt=\"image-20210619010856746\"></p>\n<p>而<strong>映射到进程合作</strong>，也应该如此，在两个标记都为true的情况下，需要有一个进程去执行，而另一个进程则什么都不做，我们来看具体的实现——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010910974.png\" alt=\"image-20210619010910974\"></p>\n<p>这是<strong>peterson算法</strong>的思想，它满足了一个好临界区的几个条件，是目前最好的临界区实现方式！！！</p>\n<p>两个进程竞争临界区的问题解决了，那一个多个进程呢，所谓<strong>万法不离其宗</strong>，我们来实际地体会一下</p>\n<hr>\n<h4 id=\"面包店算法\"><a href=\"#面包店算法\" class=\"headerlink\" title=\"面包店算法\"></a>面包店算法</h4><p>我们在开始的时候强调过，衡量临界区算法的标准是<strong>互斥进入</strong>，<strong>有空让进</strong>，<strong>有限等待</strong>。而正在之前的篇幅中，我们也验证了要同时满足这两个条件，需要结合<strong>轮换</strong>和<strong>标记</strong>的思想，那在多个进程中如何体现呢？</p>\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\">  轮转：每个进程都有一个序号</p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\">  标记 ：进程中序号最小的进入</p>\n</li>\n</ul>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010925494.png\" alt=\"image-20210619010925494\"></p>\n<p>首先<strong>选中</strong>第i个进程，即将它<strong>标记</strong>。并将<strong>当前进程序号最小</strong>的序号赋给数组<strong>num的第i个元素</strong>。</p>\n<p>接着再取消当前的标记，即做标记只是为了取出当前最小的序号。然后<strong>遍历序号</strong>，假如有被选中的其他进程，且该进程的序号比当前进程小，则等待它执行完，否则执行当前进程。进程结束后，将数组num的第i个元素置0.开始下一次循环。</p>\n<p>多个进程同步的问题的确可以通过面包店算法得到解决，但这么繁琐的算法看着就头疼，而且回顾为什么会产生临界区，本质上是因为<strong>不可控的调度</strong>导致的，而调度是要进入<strong>内核</strong>的，且进入内核的方式是<strong>中断</strong>，那我们只让一个进程触发中断不就可以保护临界区了吗？那么这样可行吗？</p>\n<p>这就要谈到软硬件协同开发中的<strong>硬件</strong>了——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010938594.png\" alt=\"image-20210619010938594\"></p>\n<p>这里使用<strong>cli()<strong>将</strong>中断的寄存器INTR</strong>置<strong>1</strong>，而在执行完临界区代码以后，再将其<strong>置0</strong>，就可以实现同一时刻只有一个进程访问临界区了。这种方法的核心在于中断寄存器，但假如是<strong>多核CPU</strong>，那每个CPU中都有这样一个寄存器，改变一个CPU的中断寄存器对别的CPU是没有影响的，可见这个方法是有<strong>局限性</strong>的。</p>\n<p>那要怎么办呢？显然我们需要一个全局的信号量来标记当前临界区的状态。这里我们尝试<strong>硬件原子指令法</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">boolean \n    <span class=\"token comment\">//这是一段原子代码，即一次执行完毕，不回切出</span>\n    <span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span>boolean <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//1.假如x为true，则执行完   2.假如为false,将x置为true并将false返回</span>\n    \tbooean rv <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    \tx <span class=\"token operator\">=</span> true <span class=\"token punctuation\">;</span>\n    \t<span class=\"token keyword\">return</span> rv <span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//临界区</span>\nlock <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//剩余区</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>也就是说，假如<strong>信号量是上锁</strong>的的，则进入并执行完，<strong>执行完后开锁</strong>；而假如进去之后发现<strong>锁是开着</strong>的，则<strong>马上上锁</strong>，并返回等待下次执行。这种方式对于多CPU同样是可行的。</p>\n<h2 id=\"3-临界区的代码实现\"><a href=\"#3-临界区的代码实现\" class=\"headerlink\" title=\"3.临界区的代码实现\"></a>3.临界区的代码实现</h2><p>在之前我们完成了信号量的引出，临界区的保护，接下来来看如何使用代码实现临界区。话不多说，我们直入主题——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">sem<span class=\"token punctuation\">.</span>c <span class=\"token comment\">//进入内核</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//声明信号量的结构体</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n    task_struct <span class=\"token operator\">*</span> queue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>semable<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span>\n    \n <span class=\"token comment\">//用户态的程序</span>\n producer<span class=\"token punctuation\">.</span>c\n <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//从信号量结构体中读取empty的下标</span>\n \tsd <span class=\"token operator\">=</span> <span class=\"token function\">sem_open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"empty\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">for</span>（<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span>）<span class=\"token punctuation\">&#123;</span>\n           <span class=\"token comment\">//设置阻塞状态，切换进程</span>\n           <span class=\"token function\">sem_wait</span><span class=\"token punctuation\">(</span>sd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token comment\">//在文件fd中写入4个字节的数据</span>\n           <span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//在semable中寻找name对应的，没找到则创建，找到则返回下标</span>\n<span class=\"token function\">sys_sem_open</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">sys_sem_wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//中断保护</span>\n\t<span class=\"token function\">cli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>semtable<span class=\"token punctuation\">[</span>sd<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>value<span class=\"token operator\">--</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//这里设置自己为阻塞，将自己加入到队列semtable.[sd].queue中去 </span>\n            <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n   \t   <span class=\"token function\">sti</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>复杂的思想最终也不过凝结为这几句宏观的代码，但即便如此，我们也要不忘初心，去探寻那<strong>冰山下的百分之九十</strong>。</p>\n<p>这样思想的应用在linux0.11中更是被广泛的应用，让我们来从那里学点思想吧——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//读磁盘块</span>\n<span class=\"token function\">bread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> dev<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> block<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">buffer_head</span> <span class=\"token operator\">*</span>bh<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//开始磁盘读后睡眠，切换进程，再由磁盘中断将其唤醒，即同步</span>\n    <span class=\"token function\">ll_rw_block</span><span class=\"token punctuation\">(</span>READ<span class=\"token punctuation\">,</span>bh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">wait_on_buffer</span><span class=\"token punctuation\">(</span>bh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//锁住临界区</span>\n<span class=\"token function\">lock_buffer</span> <span class=\"token punctuation\">(</span>buffer_head <span class=\"token operator\">*</span>bh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">cli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//while?为什么不用if</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>bh <span class=\"token operator\">-></span> b_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//进入后，不管之前是否上锁，之后都要上锁</span>\n        <span class=\"token function\">sleep_on</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>bh_wait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        bh <span class=\"token operator\">-></span> b_lock <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">sti</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">sleep_on</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//加入队列，号称世界上最隐蔽的队列？</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>tmp<span class=\"token punctuation\">;</span>\n        tmp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">-></span> state <span class=\"token operator\">=</span> TASK_UNINTERUPTIBLE<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">schdule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\ttmp <span class=\"token operator\">-></span> state <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们来挑战一下世界上最<strong>隐蔽的队列</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010955043.png\" alt=\"image-20210619010955043\"></p>\n<p>将tmp指向task_struct,再将p指向当前的task_struct，<strong>当前的即是队列的队首</strong>，也就是说将tmp指向队首的下一个，p指向队首。又这两个指针都是存储在这个进程的内核栈中的，因此<strong>下一次</strong>可从<strong>下一个进程</strong>task_struct的内核栈中取出<strong>tmp</strong>指向<strong>上一个进程</strong>，再将<strong>指针p</strong>指向<strong>当前进程</strong>。</p>\n<p>这样就可以回答使用<strong>while</strong>，是将<strong>所有的进程状态</strong>都判断了一次，从而找出那个<strong>优先级高的</strong>，让他来执行。</p>\n<p>这里的p是指针的指针，我们可以理解为p指向的是一个<strong>内存空间的起始地址</strong>，则三级指针，n级指针同样——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011007670.png\" alt=\"image-20210619011007670\"></p>\n<p>上面的内容在切换进程时，会将当前进程加入阻塞队列，那如何唤醒呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011019527.png\" alt=\"image-20210619011019527\"></p>\n<p>通过<strong>磁盘中断</strong>调用<strong>对临界区开锁的函数</strong>，并在其中调用<strong>wake_up函数</strong>，在其中改变了<strong>当前进程的状态</strong>，然后使用<strong>iret返回继续往下执行</strong>。</p>\n<hr>\n<h2 id=\"4-死锁处理\"><a href=\"#4-死锁处理\" class=\"headerlink\" title=\"4.死锁处理\"></a>4.死锁处理</h2><p>我们依然以生产者-消费者模型作为例子，我们知道不管在生产者抑或消费者函数，首先都是要判断缓冲区是否已满或者缓冲区为空，那假如将判断与之后的代码调换位置，会导致怎样的结果呢？</p>\n<p>这样的话会导致<strong>死锁</strong>，通俗的说，也就是<strong>多个进程互相等待对方持有的资源，而造成谁也无法执行的现象</strong></p>\n<p><strong>本质上</strong>说，死锁的成因是因为自己占有的资源和申请的资源造成<strong>环路等待</strong>。</p>\n<p>我们再来看死锁的必要条件——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011032749.png\" alt=\"image-20210619011032749\"></p>\n<p>那怎样处理死锁呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011048485.png\" alt=\"image-20210619011048485\"></p>\n<p>那针对每种方法，我们可以具体在进程同步中如何做呢？</p>\n<ol>\n<li><p><code>死锁预防</code> ：<strong>一次性申请所有需要资源</strong>，这样就不需要因为资源冲突而造成环路等待，但效率太低，没有使用的价值；另外一种直观的想法就是<strong>资源申请按需进行</strong>，不会造成死锁没错，但资源浪费比较严重，果断弃坑。</p>\n</li>\n<li><p><code>死锁避免</code>： 死锁避免的思想被<strong>银行家算法</strong>“完美”地实现了——</p>\n<p>假设系统中的所有进程存在一<strong>个可以完成的执行序列</strong>，则称系统处于<strong>安全状态</strong>，而银行家算法就是用来找出这个安全序列的。</p>\n<p>对于一个进程来说，它与资源间的关系分为<strong>目前占有的资源</strong>，<strong>还需要的资源</strong>，<strong>可供分配的资源</strong>三种。</p>\n<p>来看具体的实现——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> Available<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//每种资源剩余的数量</span>\n<span class=\"token keyword\">int</span> Allocation<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//已分配的资源数量</span>\n<span class=\"token keyword\">int</span> Need<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//进程还需要的各种资源数量</span>\n<span class=\"token keyword\">int</span> work<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//工作向量</span>\nbool Finish <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//进程是否结束</span>\n\nwork <span class=\"token operator\">=</span> Available<span class=\"token punctuation\">;</span>\nFinish<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Finish<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>false<span class=\"token operator\">&amp;&amp;</span> Need<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>≤Work<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            Work <span class=\"token operator\">=</span> Work <span class=\"token operator\">+</span> Allocation<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            Finish<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span> \n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> \n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">goto</span> end<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\nEnd<span class=\"token operator\">:</span> \n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Finish<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>false<span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">return</span> “deadlock”<span class=\"token punctuation\">;</span>\n<span class=\"token function\">T</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token function\">O</span><span class=\"token punctuation\">(</span>mn2<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>银行家算法的实现相对通俗易懂一些，但同时带来了<strong>时间复杂度高</strong>的问题，而时间复杂度高的原因在于它会事无巨细的判断每一个，但出现死锁的概率毕竟比较低，所以判断所有就显得浪费时间。</p>\n<p>那我们是否可以<strong>先假装分配</strong>，然<strong>后调用银行家算法</strong>，再判断是否可行呢？这样我们就需要申请一个<strong>死锁进程组</strong>，判断每一个序列是否为安全序列。</p>\n</li>\n<li><p><code>死锁检测+恢复</code> ：核心思想在于先发现问题，然后再处理，当发生死锁的时候，就让<strong>进程回滚</strong>，但是实现机制比较复杂</p>\n</li>\n<li><p><code>死锁忽略</code> ：究极秘诀——<strong>重启</strong>；</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、多进程图像的引出\"><a href=\"#一、多进程图像的引出\" class=\"headerlink\" title=\"一、多进程图像的引出\"></a>一、多进程图像的引出</h1><h2 id=\"1-多进程图像\"><a href=\"#1-多进程图像\" class=\"headerlink\" title=\"1.多进程图像\"></a>1.多进程图像</h2><p>多个进程同时存在于内存，可能会出现前一个进程的地址中的内容被第二个进程更改。这样显然是不合理的。</p>\n<p>我们首先会想到，是否可以设置<strong>DPL</strong>的值，也就是将其设置为<strong>特权级别</strong>，这样进程之间就不能互相访问了，但这里忽略了一个问题，DPL的设置是针对<strong>操作系统</strong>而言的，进程的DPL都等于3，即<strong>用户级权限</strong>，依然可以互相访问，所以这种解决方式的思路是错误的。</p>\n<p>那如何保证进程间不冲突呢？直观的解决方式，就是给进程<strong>上锁</strong>，限制对<strong>内存地址的读写</strong>。</p>\n<p><strong>映射表</strong>就是实现限制访问的那个利器。映射表的思路即是利用<strong>虚拟内存</strong>实现<strong>地址分离</strong>。</p>\n<p>说到这里，我们发现，所谓的多进程图像，不单单是进程的管理，还涉及到内存的管理。</p>\n<h3 id=\"多进程如何合作\"><a href=\"#多进程如何合作\" class=\"headerlink\" title=\"多进程如何合作\"></a>多进程如何合作</h3><p>先看下面的例子——</p>\n<p>假设有一段空闲的内存空间，两块进程都想利用这块内存空间，这样有可能会出现一块内存空间出现<strong>两个不完整的进程片段</strong>，也就是说，进程间是可以互相合作的，但合作的方式需要被协调。</p>\n<p>那怎样协调呢，纸上得来终觉浅，要想觉知此事，不妨理解<strong>生产者-消费者实例</strong>——</p>\n<blockquote>\n<p>生产者不断的产生数据放入缓冲区，而消费者从缓冲区中取出数据进行处理，当缓冲区已满的时候，生产者阻塞，当缓冲区为空的时候，消费者阻塞</p>\n</blockquote>\n<p>我们会使用三种方式来实现生产者-消费者问题——</p>\n<p>在下文的进程同步中会提及。。。</p>\n<h1 id=\"二、线程的引出与实现\"><a href=\"#二、线程的引出与实现\" class=\"headerlink\" title=\"二、线程的引出与实现\"></a>二、线程的引出与实现</h1><p>从上一节我们知道多进程是操作系统的最基本，最核心的图像，多进程可以被组织，合作与切换。</p>\n<p>多进程的组织是通过<strong>状态与队列</strong>来实现的</p>\n<p>那么多进程是如何被<strong>切换</strong>的呢？且听我娓娓道来——</p>\n<hr>\n<h2 id=\"1-用户级线程\"><a href=\"#1-用户级线程\" class=\"headerlink\" title=\"1.用户级线程\"></a>1.用户级线程</h2><h3 id=\"线程的引出\"><a href=\"#线程的引出\" class=\"headerlink\" title=\"线程的引出\"></a>线程的引出</h3><p>既然我们要了解的是进程间的切换，那为什么学习的却是线程呢？</p>\n<p>首先我们先来看宏观上的进程切换：一个<strong>进程</strong>，也就是<strong>指令执行序列</strong>+<strong>资源</strong>，在发生外中断后，切换到另一个进程。在这期间，指令访问的内存地址是通过<strong>映射表</strong>来获取的。这个切换是由中断引起的，因而会进入内核态，会涉及到<strong>资源的分配</strong>。而资源的分配是浪费时间的，那么为了提高进程执行的效率，能否将资源与指令的<strong>执行分离</strong>开，实现不动资源而只切换指令序列呢？——</p>\n<p>我们来看直观的表述——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010326080.png\" alt=\"image-20210619010326080\"></p>\n<p>这样就引出了轻巧级的进程——<strong>线程</strong>。</p>\n<h3 id=\"线程的价值\"><a href=\"#线程的价值\" class=\"headerlink\" title=\"线程的价值\"></a>线程的价值</h3><p>要回答<strong>线程</strong>是否实用，也就是要回答<strong>多个执行序列+一个地址空间</strong>的思想是否实用。</p>\n<p>我门来看下面的例子——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010341740.png\" alt=\"image-20210619010341740\"></p>\n<p>这个网页呈现出来的是，首先文字被加载出来，接着图片被加载，最后全部内容都展示了出来。</p>\n<p>实际上它的程序执行流程是多个线程从<strong>浏览器的缓冲区</strong>中读取<strong>同一份资源</strong>，程序执行展示文本的线程时，在此期间切换到展示图片的线程，过一段时间又切换回来，给用户更好的体验。</p>\n<p>这里我描述的比较<strong>生涩</strong>，其实多线程的执行，一言以蔽之，其实就是编程时<strong>多条线路并发执行</strong>：</p>\n<h3 id=\"线程的切换\"><a href=\"#线程的切换\" class=\"headerlink\" title=\"线程的切换\"></a>线程的切换</h3><p>开局一张图：</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010356747.png\" alt=\"image-20210619010356747\"></p>\n<p>可以看出，这里线程间的切换是通过一个叫做<strong>Yield</strong>的函数来实现的，所以我们的<strong>核心</strong>就在于写出yeild函数的实现——</p>\n<p>要完成切换，就要保存上一个线程的状态，状态的保存是依赖栈来实现的，我们先从两个执行序列与一个栈讲起——</p>\n<h4 id=\"两个执行序列与一个栈\"><a href=\"#两个执行序列与一个栈\" class=\"headerlink\" title=\"两个执行序列与一个栈\"></a>两个执行序列与一个栈</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010411788.png\" alt=\"image-20210619010411788\"></p>\n<p>这张图到底表达了什么意思呢？</p>\n<p>在函数B中调用Yield函数，这时需要将程序B的下一条指令的地址压栈，跳转后，在C函数中调用了D函数并压栈，在D函数中调用Yield函数，此时我们需要跳转204的位置，跳转后，PC指针指向了地址204，接着往下执行，遇到**}**后，弹栈并跳转，然后程序指针跳到404处。</p>\n<p>嗯哼，是我剧本拿错了吗？的确，就是这么戏剧性，我要的是<strong>弹栈104</strong>并跳转，可没想调回<strong>404</strong>啊，死循环。。。</p>\n<p>那么这是为什么呢？因为我们<strong>共用了一个栈</strong>！！！</p>\n<p>所以我们很自然的需要从<strong>一个栈</strong>过渡到了<strong>两个栈</strong>。</p>\n<h4 id=\"两个执行序列与两个栈\"><a href=\"#两个执行序列与两个栈\" class=\"headerlink\" title=\"两个执行序列与两个栈\"></a>两个执行序列与两个栈</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010426291.png\" alt=\"image-20210619010426291\"></p>\n<p>现在线程切换的时候，首先yield函数需要切换栈，这里就需要一个能够保存当前线程栈状态的<strong>容器</strong>，也就是<strong>TCB</strong>。</p>\n<p>我们最后在执行yield函数时，首先切换TCB，然后Yiled函数结束，继续往下执行**}<strong>,也就是执行</strong>ret指令**</p>\n<p>弹栈执行104，一个线程切换就这样有惊无险的完成了。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 这里不需要jmp 204,因为Yield函数执行完后，就会<strong>默认往下顺序执行</strong>。</li>\n</ul>\n<p>完成了两个栈，我们再将包含线程切换的<strong>ThreadCreate</strong>函数做初始化，并在其中关联<strong>TCB与栈</strong>。</p>\n<p>这样，一个完整的进程就有了——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010441251.png\" alt=\"image-20210619010441251\"></p>\n<hr>\n<p>说到这里，我们就可以来回答这个小结为什么叫用户级线程，因为<strong>field是用户级应用程序</strong>。</p>\n<p>整个用户级线程可以实现有序的切换了，那么为什么还要内核级线程呢？当然是因为它有其天生的<strong>限制</strong>，而从另一个角度来说，核心级线程是用户级线程的<strong>扩展</strong>。</p>\n<h3 id=\"用户级线程的缺点\"><a href=\"#用户级线程的缺点\" class=\"headerlink\" title=\"用户级线程的缺点\"></a>用户级线程的缺点</h3><p>当用户级线程在执行指令过程中发生中断，系统会切换到内核态，然后执行中断程序，在执行完后，因为权限已经改变，<strong>无法切换回用户级线程</strong>，用户级线程不再执行。</p>\n<h2 id=\"2-内核级线程\"><a href=\"#2-内核级线程\" class=\"headerlink\" title=\"2.内核级线程\"></a>2.内核级线程</h2><p>我们首先来回顾一下<strong>内核级线程的切换</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010458893.png\" alt=\"image-20210619010458893\"></p>\n<p>宏观的看，内核级线程由用户级线程的两个栈演变成了两套栈，它的的实现机制大致分为五步——</p>\n<ol>\n<li>用户栈通过<strong>int中断指令</strong>跳转到内核栈</li>\n<li>在内核栈中存储当前内核线程的状态，而内核栈又由<strong>线程控制块TCB1</strong>维护</li>\n<li>通过<strong>Schedule函数</strong>完成内核级线程跳转</li>\n<li>在内核栈中存储当前内核线程的状态，而内核栈又由线程控制块TCB2维护</li>\n<li>由内核栈跳转回用户栈</li>\n</ol>\n<p>下面我们将具体实现这个内核级线程：</p>\n<hr>\n<p>这个故事首先从进入内核开始，也就是从某个<strong>中断</strong>开始，这里的系统调用案例我们选择<strong>fork()</strong>,fork()函数是用于创建进程的，而<strong>进程</strong>实质上是<strong>资源+指令序列</strong>，<strong>指令序列</strong>就是一系列的<strong>线程</strong>，所以我们使用fork函数，是可以完成内核级线程的切换的。</p>\n<p>我们来看下面的例子——</p>\n<h3 id=\"中断入口\"><a href=\"#中断入口\" class=\"headerlink\" title=\"中断入口\"></a>中断入口</h3><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010514141.png\" alt=\"image-20210619010514141\"></p>\n<p>在main函数中调用了A函数，之后在A函数的执行中又调用了fork系统调用，fork系统调用会引起中断，在触发中断处理程序时，首先会将之前用户态的栈进行保存，也就是将SS,SP压栈，接着跳转fork的中断处理程序，也就是<strong>system_call函数</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010528293.png\" alt=\"image-20210619010528293\"></p>\n<p>在system_call中，首先会做寄存器的压栈，也就是<strong>准备切换</strong>，然后跳转sys_fork系统调用<strong>开始切换</strong>，在这个系统调用中，首先将当前线程的<strong>TCB置给ex</strong>，接着判断ex的状态，本质上是判断<strong>TCB</strong>的state<strong>，如果</strong>非0<strong>的话，也就是处于</strong>阻塞状态<strong>。就需要执行schedule以完成</strong>切换<strong>，此外，当</strong>时间片用完**以后，也需要进行切换。</p>\n<h3 id=\"中断出口\"><a href=\"#中断出口\" class=\"headerlink\" title=\"中断出口\"></a>中断出口</h3><p>完成了切换，那怎样返回呢？通过<strong>中断出口</strong>，那中断出口做了什么呢？对应中断入口一系列的入栈，中断出口会做弹栈操作。</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010541971.png\" alt=\"image-20210619010541971\"></p>\n<p>我们描述了中断入口和中断出口，那在中断的过程中做了什么事情呢？</p>\n<p>在中断中首先找到要切换的线程，再<strong>切换</strong>到该线程。这里面会涉及到线程的调度与切换，线程的调度我们后面会提及，这里我们只看线程的切换——</p>\n<h3 id=\"中断过程——线程切换\"><a href=\"#中断过程——线程切换\" class=\"headerlink\" title=\"中断过程——线程切换\"></a>中断过程——线程切换</h3><p>线程的切换是通过<strong>switch_to</strong>来完成的，在函数中主要通过<strong>长跳转</strong>来实现线程跳转——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010558855.png\" alt=\"image-20210619010558855\"></p>\n<p>首先使用<strong>movw指令</strong>将CPU中寄存器的内容都写入到到<strong>TSS</strong>中，<strong>TSS</strong>也就是<strong>任务结构段</strong>，它是<strong>进程控制块PCB</strong>的一部分。</p>\n<p>首先通过<strong>TR寄存器</strong>(<strong>类CS寄存器</strong>)找到位于<strong>GDT表</strong>中的<strong>TSS描述符</strong>，即指向TSS段的指针，最终通过TSS描述符定位到TSS段。</p>\n<p>而<strong>长跳转</strong>做的无非就是通过TR寄存器找到另一个线程的TSS描述符，通过TSS描述符找到TSS段，并将寄存器中的的内容也加载到TSS段中。</p>\n<p>但以TSS的方式实现跳转的效率是低下的，因为TSS中的<strong>长跳转</strong>需要对一系列<strong>寄存器</strong>操作。之后我们将采用<strong>KIN stack</strong>的方式完成切换。</p>\n<blockquote>\n<p>参考linux进程切换与TSS结构<a href=\"https://blog.51cto.com/stonehorse/1113115\">https://blog.51cto.com/stonehorse/1113115</a></p>\n</blockquote>\n<hr>\n<p>在上一小节的学习中，我们了解了线程的切换，接着我们将范围放大，来一起学习线程创建，即<strong>ThreaCreate函数</strong></p>\n<p>首先从<strong>sys_fork函数</strong>开始我们的求知之旅——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010627862.png\" alt=\"image-20210619010627862\"></p>\n<p>在<strong>sys_fork函数</strong>中，首先将<strong>用户态状态入栈</strong>，以便子进程调用，接着在sys_fork函数中调用<strong>copy_process</strong>，可以看到这个函数的参数有一长串，细心观察的话，会发现都是<strong>父进程压入栈中的内容</strong>，也就是子进程和父进程是<strong>共用</strong>一套用户栈的。</p>\n<p>那么子进程创建的细节是怎样的呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010642915.png\" alt=\"image-20210619010642915\"></p>\n<p>首先<strong>申请了一页</strong>的内存空间，我们再来回顾一下它的渊源：开机时<strong>memmap</strong>初始化，将内存分以<strong>4k</strong>为最小单元的页，需要申请<strong>内核空间</strong>时，则选取memmap<strong>不等于0的</strong>的一页内存空间即可。</p>\n<p>接着**创建TCB,**也就是从申请的内存起始开始往后一页的这段内存空间。</p>\n<p>然后创建内核栈和用户栈，最终将<strong>TCB与栈相关联</strong>。</p>\n<p>最后，我们只需要完成一系列的初始化即可，这里面值得关注的是ip的初始化，也就是从栈中取出中断后下一条指令的内存地址，另外还需要eax初始化为0，那么eax有什么用呢？</p>\n<p>我们经常看到的一个判断：<strong>if(!fork()){子进程执行}</strong>,这里判断的条件即是<strong>eax的值</strong>，如果eax等于<strong>0</strong>，<strong>子进程执行</strong>，反之，父进程执行。</p>\n<p>明确了子进程的执行条件，我们来看子进程的具体执行的代码，也就是<strong>exec系统调用</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010701378.png\" alt=\"image-20210619010701378\"></p>\n<p>我们从父进程的<strong>shell</strong>进入子进程的执行，当子进程执行完后，需要返回，那它会<strong>返回到哪里</strong>呢？我们知道在跳转执行的结束，会执行指令<strong>iret</strong>，所以返回的地址取决于iret中<strong>ret</strong>指令弹栈的<strong>IP寄存器</strong>内容。那IP指向哪里呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010718802.png\" alt=\"image-20210619010718802\"></p>\n<p>IP指向的位置，或者说IP寄存器中地址取决于<strong>struct_exec系统调用</strong>的参数。在它的执行中，将ex寄存器中的<strong>a.entry</strong>方法的地址加载到ret中作为<strong>IP</strong>的指向地址，a.entry是<strong>可执行文件的入口地址</strong>，当它连接产生可执行文件时，会将文件中的内容，即磁盘中的内容<strong>写入到</strong>内存执行，子进程执行完毕！</p>\n<h2 id=\"3-操作系统的那棵树\"><a href=\"#3-操作系统的那棵树\" class=\"headerlink\" title=\"3.操作系统的那棵树\"></a>3.操作系统的那棵树</h2><blockquote>\n<p>系统调用就是一种软中断处理程序</p>\n</blockquote>\n<p>在这一小节中，我们不看学习新的内容，因为旧的内容还一团乱麻。所以我们有必要将之前的知识点<strong>连点成线</strong>，让它从<strong>萌芽</strong>开始，随时光浸淫，最终长成<strong>参天大树</strong>。</p>\n<p>即便操作系统这颗很庞大的参天大树也是要从一个很小的火光发散的。就如同李志军老师告诫我们的一样——</p>\n<blockquote>\n<p>The mind is not a vessel that needs filling,but wood that needs ignitng</p>\n<p>我们的大脑不是装满水的容器，而应该是点燃的火光。</p>\n</blockquote>\n<p>所以我们接下来的内容我们将从一个很小，很具体，很有价值的IDEA开始——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 我们要在屏幕上交错出现A和B</li>\n</ul>\n<p>首先回顾一下线程切换的思路——</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <strong>运转CPU</strong>-》<strong>CPU没有好好运转</strong>-》<strong>要让CPU好好运转，首先从A函数跳到B函数</strong>-》<strong>跳转时使用1个栈和1个yeild发生混乱</strong>-》<strong>试着使用两个栈和两个TCB</strong>-》<strong>这样可以运转没错，但只能在用户态运转是不合适的</strong>-》<strong>引入两套栈，即内核栈的切换</strong></li>\n</ul>\n<p>首先从<strong>用户代码</strong>开始——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们再将其用<strong>汇编</strong>来表述——</p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">main()&#123;\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax,res\n\tcmp1,res,0\n\tjne 208\n200: printf(&quot;A&quot;)\n\tjmp 200\n208: ...\n304: wait()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>接着复现执行<strong>int 0x80</strong>后的代码——</p>\n<pre class=\"line-numbers language-ASM\" data-language=\"ASM\"><code class=\"language-ASM\">main()&#123;\n\tmov _NR_fork,%eax\n\tint 0x80\n100: mov %eax , res\n\tcmp1 res,0\n&#125;\n\nset_system_gate(0x80,&amp;system_call);\nsystem_call:\n\tcall sys_call_table(,%eax,4)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>首先将<strong>系统调用号</strong>赋给**_NR_fork<strong>，触发中断</strong>0x80<strong>，进入</strong>system_call<strong>，在该系统调用中，跳转</strong>system_call_table**,将1赋给eax,也就是当前内核进程为<strong>父进程</strong>，在其中调用<strong>sys_fork</strong>——</p>\n<pre class=\"line-numbers language-ASM\" data-language=\"ASM\"><code class=\"language-ASM\">sys_fork:\n\tpush1 ..\n\tcall copy_process\n\tret<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>开始<strong>创建子进程</strong>，子进程的创建也就是对父进程的复制，即<strong>copy_process</strong>_</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">copy_process(... ,long eip,..)&#123;\n\tp &#x3D; (PCB *)get_free_page();\n        p-&gt;tss.esp0 &#x3D; p+4k;\n        p-&gt;tss.esp &#x3D; esp;\n        p-&gt;tss.eax &#x3D; 0;\n        p-&gt;tss.eip &#x3D; eip;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完成了<strong>PCB的创建与初始化</strong>，也就是完成了子进程的创建，接着<strong>ret</strong>返回到父进程，<strong>iret</strong>返回用户态。</p>\n<p>然后接着调用main函数，不断的<strong>创建线程</strong>，接着执行main函数，就到了<strong>wait()函数</strong>，它的具体实现是——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">sys_waitpid()&#123;\n\tcurrent -&gt; state &#x3D; TASK_INTERRUPTTIBLE;\n        schedule();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将当前线程的状态置为<strong>阻塞</strong>，开始切换——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">shedule()&#123;\n    if((*p)-&gt;state &#x3D;&#x3D; TASK_RUNNING &amp;&amp;  (*p)-&gt;counter &gt; c)\n        \tc &#x3D; (*p) -&gt; counter,next &#x3D; i;\n    \t   ...\n               switch_to(next);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果当前状态为运行态，使用<strong>调度算法</strong>得到<strong>要切换的线程</strong>，进入切换——</p>\n<p>切换以后，就可以打出B了，但我们需要的是交替执行，所以要从B再进入A，也就是要完成切换，而切换是在内核态完成的，而用户态需要使用中断才能进入内核，那使用哪个中断呢？</p>\n<p><strong>时钟中断</strong>！！！</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">sched_int</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">set_intr_gate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x20</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>timer_interrupt<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span>  _time_interrupt<span class=\"token operator\">:</span>\n\tcall do_time\n        \n<span class=\"token keyword\">void</span> <span class=\"token function\">do_time</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">--</span>current <span class=\"token operator\">-></span> counter <span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">-></span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     \n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将<strong>中断类型码</strong>赋给系统调用<strong>time_interrupt</strong>,在其中跳转<strong>do_time</strong>,在do_time中判断当前线程的数目，如果<strong>大于0</strong>，<strong>不切换</strong>，否则调用schedule切换线程。</p>\n<p>最终在<strong>schdule</strong>中调用<strong>switch_to</strong>。不断循环，完结~</p>\n<h1 id=\"三、-CPU调度\"><a href=\"#三、-CPU调度\" class=\"headerlink\" title=\"三、 CPU调度\"></a>三、 CPU调度</h1><p>在上面的描述中，一个线程的切换就这样丝滑地完成了，但我们总将CPU调度刻意的当做一个黑盒子，这是因为CPU调度的确是一个很揪心的任务，但了解它又能加深我们对系统设计设计的理解，因此，这节内容，我们就明知山有虎，偏向虎山行了——</p>\n<hr>\n<h2 id=\"1-cpu调度策略\"><a href=\"#1-cpu调度策略\" class=\"headerlink\" title=\"1.cpu调度策略\"></a>1.cpu调度策略</h2><p>当一个线程阻塞后，就要切换到另一个线程，那应该切换到哪一个线程呢？直观的说，我们需要<strong>尽可能快</strong>的完成任务。那如何衡量任务执行的效率呢？就连任务本身都有不同的类型，比如<strong>I/O型</strong>，<strong>CPU型</strong>，按照不同的分类角度，又有<strong>前台型任务</strong>和<strong>后台型</strong>任务。</p>\n<p>我们只捉住它<strong>关键</strong>的几个点来设计一个调度算法——</p>\n<ol>\n<li><strong>周转时间短</strong>，从任务进入到任务结束，也就是尽可能快的完成任务。<strong>周转时间=等待时间+运行时间</strong>。</li>\n<li><strong>响应时间短</strong>，即从操作到响应的时间短</li>\n<li><strong>系统内耗少</strong>，即系统吞吐量大，执行任务多</li>\n</ol>\n<p>我们来看符合某些点的具体的算法思想，并用上面的<strong>指标</strong>来衡量它：</p>\n<h3 id=\"FCFS\"><a href=\"#FCFS\" class=\"headerlink\" title=\"FCFS\"></a>FCFS</h3><p>先来先服务是最直观的调度算法，但一个系统是复杂的，仅考虑到公平只会事倍功半。</p>\n<p>假设有n个任务，每个任务的周转时间分别为Ti，则它的<strong>平均响应时间</strong>为<strong>：T1+T2+T3+Tn/n</strong>,它的第<strong>n个任务的响应周转</strong>为<strong>T1+T2+T3+…+Tn</strong>，假如说T1的时间比其他时间的加和还要大，这样显然周转时间有可能很长，非常<strong>不合理</strong>。</p>\n<p>那能否在FCFC调度算法的前提下，根据任务的长短来决定执行的顺序呢？那我们来了解一下SJF——<strong>短作业优先调度算法</strong></p>\n<h3 id=\"SJF\"><a href=\"#SJF\" class=\"headerlink\" title=\"SJF\"></a>SJF</h3><p>假设有n个任务，按短作业优先的原则，调度的结果分别是：<strong>P1,P2,P3…Pn</strong>,则它总的周转时间为*<em>n</em>P1+(n-1)*p2+….**，这样它的周转时间显然得到显著的降低。</p>\n<p>但假如我现在有一个很长的作业，但它又非常紧急，我是不是应该适当的根据优先级来调整执行的顺序呢？这就要谈及RR——<strong>轮转时间片调度算法</strong>。</p>\n<h3 id=\"RR\"><a href=\"#RR\" class=\"headerlink\" title=\"RR\"></a>RR</h3><p>时间片轮转的思想是将作业再<strong>细分</strong>，然后CPU为每个作业分配<strong>时间片</strong>，接着来<strong>交错</strong>地执行任务的最小单元。</p>\n<p>但这里同样面临问题，假如<strong>时间片大</strong>的话，<strong>响应时间长</strong>；<strong>时间片小</strong>的话，系统内耗大，<strong>吞吐量小</strong></p>\n<p>我们先来微笑地说句fuck~</p>\n<p>那假如我们对周转时间和响应时间的需求同时存在，该怎么办呢？</p>\n<p>设置<strong>优先级</strong>！同时我们也需要首先遵守一个原则，人们更关心计算机与人的交互时间，也就是<strong>前台任务执行快</strong>，所以我们首先按<strong>RR</strong>的原则来安排<strong>前台任务</strong>，接着按照<strong>SJF</strong>的原则来安排<strong>后台任务</strong>，这两类任务之间通过<strong>动态的优先级设置</strong>进行互相切换。</p>\n<p>要满足上一小节的复杂指标，给我们的直观感受就是，这个实现的算法一定繁琐至极，但<strong>linux0.11中的schdule函数</strong>却很好地处理了这个问题——</p>\n<h2 id=\"2-一个实际的schedule函数\"><a href=\"#2-一个实际的schedule函数\" class=\"headerlink\" title=\"2.一个实际的schedule函数\"></a>2.一个实际的schedule函数</h2><p>我们在开始之前，首先要明确时间片和优先级是有一定的关系的，时间片大的本身一定程度上优先级就高，能解决复杂问题的算法即便代码量少，但思想的深度却不会低。</p>\n<p>下面我们言归正传，来看chedule函数的实现——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">schele(void)&#123;\n    while(1)&#123;\n         int i &#x3D; NR_TASKS;\n    \t  int c&#x3D; -1;\n         int next &#x3D; 0;\n   \t       p &#x3D; &amp;tasks[NR_TASKS];\n   \t       while(i--)&#123;\n    \t\tif(*p -&gt; state &#x3D;&#x3D; TASK_RUNNING &amp;&amp;  *p -&gt; counter &gt; c)&#123;&#x2F;&#x2F;加入当前作业的状态为就绪态且优先级大\n            \t\tc &#x3D; *p -&gt; counter;\n                    \tnext &#x3D; i;\t\n           &#125;\n     \t&#125;\n        if(c)&#123;\n            break;     &#x2F;&#x2F;找到最大的counter\n        &#125;\n        for(p &#x3D; &amp;LAST_TASK;p &gt; &amp;FIRST_TASK; p--)&#123;\t&#x2F;&#x2F;重新设置优先级\n            (*p) -&gt; counter &#x3D; ((*p) -&gt; counter &gt;&gt; 1) + *p -&gt;priority;\n        &#125;\n        switch_to(next);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这个程序中，counter是关键，它兼顾了优先级与时间片——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">&#x2F;&#x2F;时间片\nvoid do_time()&#123;\n    if(-- current -&gt; counter &gt;0)\n        \treturn;\n    current -&gt; counter &#x3D; 0;\n    schedule();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>即<strong>时间片为0</strong>时，则<strong>切换时间片</strong>。在这里<strong>counter</strong>满足<strong>轮转调度</strong>，保证了<strong>响应</strong>。</p>\n<p>而下面的程序中，counter又体现了优先级——</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">if(*p -&gt; state &#x3D;&#x3D; TASK_RUNNING &amp;&amp;  *p -&gt; counter &gt; c)&#123;&#x2F;&#x2F;加入当前作业的状态为就绪态且优先级大\n            c &#x3D; *p -&gt; counter;\n            next &#x3D; i;\t\n &#125;\n\nfor(p &#x3D; &amp;LAST_TASK;p &gt; &amp;FIRST_TASK; p--)&#123;\t&#x2F;&#x2F;重新设置优先级\n            (*p) -&gt; counter &#x3D; ((*p) -&gt; counter &gt;&gt; 1) + *p -&gt;priority;\n &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里counter体现的是动态的优先级，表现出来的是阻塞后进程的优先级会高于非阻塞进程的优先级，也就是优先前台进程。</p>\n<p>但值得注意的是，counter是否超出会响应时间的界，我们不妨来定量地看一下——</p>\n<p>假设进程n开始响应时的时间为p,而进程n的响应时间(<strong>时间片</strong>)是p+p/2,同样可以类比得到第<strong>无穷个</strong>进程的响应时间为<strong>p+p/2+p/4+…+p/(2的无穷次方) &lt; 2p</strong></p>\n<h1 id=\"四-、进程同步和死锁\"><a href=\"#四-、进程同步和死锁\" class=\"headerlink\" title=\"四.、进程同步和死锁\"></a>四.、进程同步和死锁</h1><p>我们在上一章中学习到了线程间的切换是如何完成的，而<strong>进程</strong>等于<strong>资源</strong>+<strong>可执行的指令序列(线程),<strong>那要完成进程的切换，也就是进程的</strong>并发执行</strong>，岂不是只需要知道<strong>资源</strong>是如何被<strong>调度</strong>的就可以了，那么资源如何表示，又如何量化呢，在调度资源的过程中，会出现怎样的问题，又应该怎样解决呢？这一系列的问题，我们都将在下面的内容中找到答案——</p>\n<hr>\n<h2 id=\"1-进程同步与信号量\"><a href=\"#1-进程同步与信号量\" class=\"headerlink\" title=\"1.进程同步与信号量\"></a>1.进程同步与信号量</h2><p>所谓进程的合作，就是多个进程来完成同一个任务，之前我们浅谈过<strong>生产者与消费者</strong>的实例，这里我们对它进行进一步的剖析——</p>\n<blockquote>\n<p>对于生产者而言，它生产了一个资源并放入缓冲区，当缓冲区满的时候，就不再生产。</p>\n<p>同样的，对于消费者而言，它消费来自缓冲区的资源，当缓冲区空的时候，它就不再消费。</p>\n</blockquote>\n<p>从这种机制中，我们看出，首先需要一个放置资源的缓冲区——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">BUFFER_SIZE</span> <span class=\"token expression\"><span class=\"token number\">10</span></span></span>\n<span class=\"token comment\">//声明资源的结构</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> item<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//声明缓冲区的大小</span>\nitem buffer<span class=\"token punctuation\">[</span>BUFFER_SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> in <span class=\"token operator\">=</span> out <span class=\"token operator\">=</span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其次，我们来看最直观的生产者与消费者进程模型</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//生产者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> BUFFER_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    buffer<span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> item<span class=\"token punctuation\">;</span>\n    in <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>in <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//消费者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    item <span class=\"token operator\">=</span> buffer<span class=\"token punctuation\">[</span>out<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span>\n    out<span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>iout<span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这个最基础的模型中，我们的确<strong>做到</strong>了去控制生产者消费者运行的<strong>时机</strong>，但进程的调度是<strong>不可预测</strong>的，我们不妨再扩充一下如何使用<strong>信号counter</strong>控制进程的<strong>休眠与唤醒</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//生产者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> BUFFER_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//缓冲区已满以后，就让创建好的进程进入休眠队列</span>\n    <span class=\"token punctuation\">&#125;</span>\n    buffer<span class=\"token punctuation\">[</span>in<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> item<span class=\"token punctuation\">;</span>\n    in <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>in <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>counter  <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//唤醒消费者\t</span>\n    <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//消费者</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>counter <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//缓冲区为空的时候，就让消费者进程进出入休眠队列</span>\n    <span class=\"token punctuation\">&#125;</span>\n    item <span class=\"token operator\">=</span> buffer<span class=\"token punctuation\">[</span>out<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span>\n    out<span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span>iout<span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n    counter<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>counter  <span class=\"token operator\">==</span> BUFFER_SIZE<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//唤醒生产者</span>\n    <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>一个第二版的生产者消费者模型就这样形成的，它无疑更完善了一些，但因为<strong>counter信号</strong>终究表示的比较<strong>宏观</strong>，导致在细节上出错了——</p>\n<p>假设缓冲区<strong>已满</strong>，这时<strong>生产者进程P1</strong>运行，并进入<strong>休眠队列</strong>，紧接着<strong>生产者进程P2</strong>运行，也进入休眠队列，此时counter等于<strong>BUFFER_SIZE</strong>.然后消费者进程运行一次，<strong>缓冲区内内容减1</strong>，唤醒生产者，但在生产者执行之前，又有一个消费者进程运行，此时counter等于<strong>BUFFER_SIZE-2</strong>,则生产者进程<strong>P2不会被唤醒</strong>。</p>\n<p>出现这样的问题无疑是因为<strong>信号counter</strong>仅仅能表示<strong>缓冲区中空闲的状态</strong>，而无法判断<strong>休眠队列</strong>中有几个进程，换句话说，事情<strong>不是非0即1</strong>的，可能这个1表示的还有1.0和1.00的区分——</p>\n<p>因而我们要使这个信号可以表达休眠和唤醒两种状态，当然，这个时候已经不能称为信号了，不如就叫<strong>信号量</strong>？</p>\n<h3 id=\"从信号到信号量\"><a href=\"#从信号到信号量\" class=\"headerlink\" title=\"从信号到信号量\"></a>从信号到信号量</h3><p>通过信号量我们可以判断休眠或者唤醒的状态。</p>\n<p>姑且将信号量记为<strong>sem</strong>，当<strong>sem=0</strong>时，表示<strong>无资源可用</strong>，淡然，需要注意的是，对于进程而言，所谓的资源就是<strong>空闲的空间</strong>；当<strong>sem&lt;0**时，表示**有进程在等待资源**，假设sem=-2，表示有两个进程在等待资源；当**sem&gt;0</strong>时，表示有<strong>多少个空闲资源</strong>。</p>\n<p>接下来我们给出信号量的官方定义：</p>\n<blockquote>\n<p>1965年，由荷兰学者Dijkstra提出的信号量用于<code>记录</code>，信号用于sleep和wakeup.</p>\n</blockquote>\n<p>我们将信号量再去细化：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">semphore</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span> <span class=\"token comment\">//记录资源个数</span>\n    PCB <span class=\"token operator\">*</span> queue<span class=\"token punctuation\">;</span> <span class=\"token comment\">//记录等待进程的队列</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此外，由信号量衍生出了P,V原语。<strong>P</strong>可以记做<strong>test</strong>，<strong>V</strong>则为<strong>increament</strong></p>\n<p>下面给出P,V原语的实现——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//p原语：没资源，队列休眠</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>semaphore s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    s<span class=\"token punctuation\">.</span>value<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>value <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//V原语：有资源，唤醒队列</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>semaphore s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    s<span class=\"token punctuation\">.</span>value<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>value <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>到这里，我们可以回过头来看生产者和消费者问题了，话不多说，上代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">open</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'buffer.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//写in</span>\n<span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//写out</span>\n\nsemaphore full <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\nsemaphore empty <span class=\"token operator\">=</span> BUFFER_SIZE<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//声明互斥信号量为1,即并发修改数</span>\nsemaphore mutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">Producer</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//判断缓冲区是否已满</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex--</span>\n    <span class=\"token comment\">//在这里写入in，即将item写到in的位置</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex++</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//full++</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token function\">Consumer</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//判断缓冲区为空</span>\n    <span class=\"token comment\">//判断mutex是否小于0,也就是判断访问的当前资源是否为互斥信号量</span>\n    <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex--</span>\n    <span class=\"token comment\">//在这里写入iout，即从文件中的out位置读出到item中</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//mutex++</span>\n    <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//empty++</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>顺畅如斯，秒啊~</p>\n<p>到这里的确已经迈出了一大步，但仍有些小瑕疵，那就是由于<strong>进程调度顺序</strong>不确定，导致<strong>两个进程同时访问一个信号量</strong>的状况——</p>\n<h2 id=\"2-对信号量的临界区\"><a href=\"#2-对信号量的临界区\" class=\"headerlink\" title=\"2.对信号量的临界区\"></a>2.对信号量的临界区</h2><p>为什么要保护临界区呢？什么是临界区，且听我娓娓道来——</p>\n<p>因为两个进程对同一份数据存在竞争关系，因而需要将这份资源作为<strong>临界区</strong>。而这里的<strong>竞争条件</strong>是<strong>指和调度有关的共享语义错误</strong>。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 临界区： <strong>一次只允许一个进程进入该进程的那一段代码，临界区的基本原则是互斥</strong>，</li>\n</ul>\n<p>然而仅仅声明一段代码为临界区代码是不够的，一段好的临界区代码还应该是<strong>有空让进</strong>且<strong>有限等待</strong>。</p>\n<p>首先开始进入临界区的第一种尝试——轮换法。</p>\n<h4 id=\"1-轮换法\"><a href=\"#1-轮换法\" class=\"headerlink\" title=\"1.轮换法\"></a>1.轮换法</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010827920.png\" alt=\"image-20210619010827920\"></p>\n<p>首先，这个临界区的设计是满足互斥的，但假如在调用进程P0以后，继续调用进程P0，这时就不再满足有空就进的原则了，所以下一位——</p>\n<h4 id=\"2-标记法\"><a href=\"#2-标记法\" class=\"headerlink\" title=\"2.标记法\"></a>2.标记法</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010842398.png\" alt=\"image-20210619010842398\"></p>\n<p>CPU大量时间闲置的问题的确得到了解决，且满足互斥，但假如有这么一种情景——</p>\n<p>两个标记都为true，那么两个进程都不再执行，我们可以类比生活中的例子：假设冰箱里没有牛奶，妻子看到丈夫大的标记后，认为丈夫会买，而丈夫看到妻子留下的标记后，认为妻子会买，这样没有真的去买了牛奶。</p>\n<p>这是一种对称法<strong>，而在现实中，要打破这种没人买牛奶的窘况，就需要一个人</strong>相对勤快一些。</p>\n<h4 id=\"3-peterson算法\"><a href=\"#3-peterson算法\" class=\"headerlink\" title=\"3.peterson算法\"></a>3.peterson算法</h4><p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010856746.png\" alt=\"image-20210619010856746\"></p>\n<p>而<strong>映射到进程合作</strong>，也应该如此，在两个标记都为true的情况下，需要有一个进程去执行，而另一个进程则什么都不做，我们来看具体的实现——<br><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010910974.png\" alt=\"image-20210619010910974\"></p>\n<p>这是<strong>peterson算法</strong>的思想，它满足了一个好临界区的几个条件，是目前最好的临界区实现方式！！！</p>\n<p>两个进程竞争临界区的问题解决了，那一个多个进程呢，所谓<strong>万法不离其宗</strong>，我们来实际地体会一下</p>\n<hr>\n<h4 id=\"面包店算法\"><a href=\"#面包店算法\" class=\"headerlink\" title=\"面包店算法\"></a>面包店算法</h4><p>我们在开始的时候强调过，衡量临界区算法的标准是<strong>互斥进入</strong>，<strong>有空让进</strong>，<strong>有限等待</strong>。而正在之前的篇幅中，我们也验证了要同时满足这两个条件，需要结合<strong>轮换</strong>和<strong>标记</strong>的思想，那在多个进程中如何体现呢？</p>\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\">  轮转：每个进程都有一个序号</p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\">  标记 ：进程中序号最小的进入</p>\n</li>\n</ul>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010925494.png\" alt=\"image-20210619010925494\"></p>\n<p>首先<strong>选中</strong>第i个进程，即将它<strong>标记</strong>。并将<strong>当前进程序号最小</strong>的序号赋给数组<strong>num的第i个元素</strong>。</p>\n<p>接着再取消当前的标记，即做标记只是为了取出当前最小的序号。然后<strong>遍历序号</strong>，假如有被选中的其他进程，且该进程的序号比当前进程小，则等待它执行完，否则执行当前进程。进程结束后，将数组num的第i个元素置0.开始下一次循环。</p>\n<p>多个进程同步的问题的确可以通过面包店算法得到解决，但这么繁琐的算法看着就头疼，而且回顾为什么会产生临界区，本质上是因为<strong>不可控的调度</strong>导致的，而调度是要进入<strong>内核</strong>的，且进入内核的方式是<strong>中断</strong>，那我们只让一个进程触发中断不就可以保护临界区了吗？那么这样可行吗？</p>\n<p>这就要谈到软硬件协同开发中的<strong>硬件</strong>了——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010938594.png\" alt=\"image-20210619010938594\"></p>\n<p>这里使用<strong>cli()<strong>将</strong>中断的寄存器INTR</strong>置<strong>1</strong>，而在执行完临界区代码以后，再将其<strong>置0</strong>，就可以实现同一时刻只有一个进程访问临界区了。这种方法的核心在于中断寄存器，但假如是<strong>多核CPU</strong>，那每个CPU中都有这样一个寄存器，改变一个CPU的中断寄存器对别的CPU是没有影响的，可见这个方法是有<strong>局限性</strong>的。</p>\n<p>那要怎么办呢？显然我们需要一个全局的信号量来标记当前临界区的状态。这里我们尝试<strong>硬件原子指令法</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">boolean \n    <span class=\"token comment\">//这是一段原子代码，即一次执行完毕，不回切出</span>\n    <span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span>boolean <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//1.假如x为true，则执行完   2.假如为false,将x置为true并将false返回</span>\n    \tbooean rv <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    \tx <span class=\"token operator\">=</span> true <span class=\"token punctuation\">;</span>\n    \t<span class=\"token keyword\">return</span> rv <span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//临界区</span>\nlock <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//剩余区</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>也就是说，假如<strong>信号量是上锁</strong>的的，则进入并执行完，<strong>执行完后开锁</strong>；而假如进去之后发现<strong>锁是开着</strong>的，则<strong>马上上锁</strong>，并返回等待下次执行。这种方式对于多CPU同样是可行的。</p>\n<h2 id=\"3-临界区的代码实现\"><a href=\"#3-临界区的代码实现\" class=\"headerlink\" title=\"3.临界区的代码实现\"></a>3.临界区的代码实现</h2><p>在之前我们完成了信号量的引出，临界区的保护，接下来来看如何使用代码实现临界区。话不多说，我们直入主题——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">sem<span class=\"token punctuation\">.</span>c <span class=\"token comment\">//进入内核</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//声明信号量的结构体</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n    task_struct <span class=\"token operator\">*</span> queue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>semable<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span>\n    \n <span class=\"token comment\">//用户态的程序</span>\n producer<span class=\"token punctuation\">.</span>c\n <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//从信号量结构体中读取empty的下标</span>\n \tsd <span class=\"token operator\">=</span> <span class=\"token function\">sem_open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"empty\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">for</span>（<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span>）<span class=\"token punctuation\">&#123;</span>\n           <span class=\"token comment\">//设置阻塞状态，切换进程</span>\n           <span class=\"token function\">sem_wait</span><span class=\"token punctuation\">(</span>sd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token comment\">//在文件fd中写入4个字节的数据</span>\n           <span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//在semable中寻找name对应的，没找到则创建，找到则返回下标</span>\n<span class=\"token function\">sys_sem_open</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">sys_sem_wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//中断保护</span>\n\t<span class=\"token function\">cli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>semtable<span class=\"token punctuation\">[</span>sd<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>value<span class=\"token operator\">--</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//这里设置自己为阻塞，将自己加入到队列semtable.[sd].queue中去 </span>\n            <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n   \t   <span class=\"token function\">sti</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>复杂的思想最终也不过凝结为这几句宏观的代码，但即便如此，我们也要不忘初心，去探寻那<strong>冰山下的百分之九十</strong>。</p>\n<p>这样思想的应用在linux0.11中更是被广泛的应用，让我们来从那里学点思想吧——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//读磁盘块</span>\n<span class=\"token function\">bread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> dev<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> block<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">buffer_head</span> <span class=\"token operator\">*</span>bh<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//开始磁盘读后睡眠，切换进程，再由磁盘中断将其唤醒，即同步</span>\n    <span class=\"token function\">ll_rw_block</span><span class=\"token punctuation\">(</span>READ<span class=\"token punctuation\">,</span>bh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">wait_on_buffer</span><span class=\"token punctuation\">(</span>bh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//锁住临界区</span>\n<span class=\"token function\">lock_buffer</span> <span class=\"token punctuation\">(</span>buffer_head <span class=\"token operator\">*</span>bh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">cli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//while?为什么不用if</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>bh <span class=\"token operator\">-></span> b_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//进入后，不管之前是否上锁，之后都要上锁</span>\n        <span class=\"token function\">sleep_on</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>bh_wait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        bh <span class=\"token operator\">-></span> b_lock <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">sti</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">sleep_on</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//加入队列，号称世界上最隐蔽的队列？</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>tmp<span class=\"token punctuation\">;</span>\n        tmp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">-></span> state <span class=\"token operator\">=</span> TASK_UNINTERUPTIBLE<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">schdule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\ttmp <span class=\"token operator\">-></span> state <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们来挑战一下世界上最<strong>隐蔽的队列</strong>——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619010955043.png\" alt=\"image-20210619010955043\"></p>\n<p>将tmp指向task_struct,再将p指向当前的task_struct，<strong>当前的即是队列的队首</strong>，也就是说将tmp指向队首的下一个，p指向队首。又这两个指针都是存储在这个进程的内核栈中的，因此<strong>下一次</strong>可从<strong>下一个进程</strong>task_struct的内核栈中取出<strong>tmp</strong>指向<strong>上一个进程</strong>，再将<strong>指针p</strong>指向<strong>当前进程</strong>。</p>\n<p>这样就可以回答使用<strong>while</strong>，是将<strong>所有的进程状态</strong>都判断了一次，从而找出那个<strong>优先级高的</strong>，让他来执行。</p>\n<p>这里的p是指针的指针，我们可以理解为p指向的是一个<strong>内存空间的起始地址</strong>，则三级指针，n级指针同样——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011007670.png\" alt=\"image-20210619011007670\"></p>\n<p>上面的内容在切换进程时，会将当前进程加入阻塞队列，那如何唤醒呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011019527.png\" alt=\"image-20210619011019527\"></p>\n<p>通过<strong>磁盘中断</strong>调用<strong>对临界区开锁的函数</strong>，并在其中调用<strong>wake_up函数</strong>，在其中改变了<strong>当前进程的状态</strong>，然后使用<strong>iret返回继续往下执行</strong>。</p>\n<hr>\n<h2 id=\"4-死锁处理\"><a href=\"#4-死锁处理\" class=\"headerlink\" title=\"4.死锁处理\"></a>4.死锁处理</h2><p>我们依然以生产者-消费者模型作为例子，我们知道不管在生产者抑或消费者函数，首先都是要判断缓冲区是否已满或者缓冲区为空，那假如将判断与之后的代码调换位置，会导致怎样的结果呢？</p>\n<p>这样的话会导致<strong>死锁</strong>，通俗的说，也就是<strong>多个进程互相等待对方持有的资源，而造成谁也无法执行的现象</strong></p>\n<p><strong>本质上</strong>说，死锁的成因是因为自己占有的资源和申请的资源造成<strong>环路等待</strong>。</p>\n<p>我们再来看死锁的必要条件——</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011032749.png\" alt=\"image-20210619011032749\"></p>\n<p>那怎样处理死锁呢？</p>\n<p><img src=\"https://zyz-img.oss-cn-chengdu.aliyuncs.com/img/image-20210619011048485.png\" alt=\"image-20210619011048485\"></p>\n<p>那针对每种方法，我们可以具体在进程同步中如何做呢？</p>\n<ol>\n<li><p><code>死锁预防</code> ：<strong>一次性申请所有需要资源</strong>，这样就不需要因为资源冲突而造成环路等待，但效率太低，没有使用的价值；另外一种直观的想法就是<strong>资源申请按需进行</strong>，不会造成死锁没错，但资源浪费比较严重，果断弃坑。</p>\n</li>\n<li><p><code>死锁避免</code>： 死锁避免的思想被<strong>银行家算法</strong>“完美”地实现了——</p>\n<p>假设系统中的所有进程存在一<strong>个可以完成的执行序列</strong>，则称系统处于<strong>安全状态</strong>，而银行家算法就是用来找出这个安全序列的。</p>\n<p>对于一个进程来说，它与资源间的关系分为<strong>目前占有的资源</strong>，<strong>还需要的资源</strong>，<strong>可供分配的资源</strong>三种。</p>\n<p>来看具体的实现——</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> Available<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//每种资源剩余的数量</span>\n<span class=\"token keyword\">int</span> Allocation<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//已分配的资源数量</span>\n<span class=\"token keyword\">int</span> Need<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//进程还需要的各种资源数量</span>\n<span class=\"token keyword\">int</span> work<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//工作向量</span>\nbool Finish <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//进程是否结束</span>\n\nwork <span class=\"token operator\">=</span> Available<span class=\"token punctuation\">;</span>\nFinish<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Finish<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>false<span class=\"token operator\">&amp;&amp;</span> Need<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>≤Work<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            Work <span class=\"token operator\">=</span> Work <span class=\"token operator\">+</span> Allocation<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            Finish<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span> \n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> \n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">goto</span> end<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\nEnd<span class=\"token operator\">:</span> \n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Finish<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>false<span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">return</span> “deadlock”<span class=\"token punctuation\">;</span>\n<span class=\"token function\">T</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token function\">O</span><span class=\"token punctuation\">(</span>mn2<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>银行家算法的实现相对通俗易懂一些，但同时带来了<strong>时间复杂度高</strong>的问题，而时间复杂度高的原因在于它会事无巨细的判断每一个，但出现死锁的概率毕竟比较低，所以判断所有就显得浪费时间。</p>\n<p>那我们是否可以<strong>先假装分配</strong>，然<strong>后调用银行家算法</strong>，再判断是否可行呢？这样我们就需要申请一个<strong>死锁进程组</strong>，判断每一个序列是否为安全序列。</p>\n</li>\n<li><p><code>死锁检测+恢复</code> ：核心思想在于先发现问题，然后再处理，当发生死锁的时候，就让<strong>进程回滚</strong>，但是实现机制比较复杂</p>\n</li>\n<li><p><code>死锁忽略</code> ：究极秘诀——<strong>重启</strong>；</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n"},{"title":"计算机网络应用层","top":true,"cover":false,"toc":true,"mathjax":true,"date":"2021-07-12T03:51:04.000Z","password":null,"summary":null,"_content":"\n## 摘要\n\n到第二章我们就将进入具体5层协议栈的描述，更具体地说，是从顶层**应用层**开始，渐进地学习计算机网络。我们知道，应用层是在传输层提供的服务上实现应用进程通信的，也就是**借助操作系统使用Socket API的方式**实现的。那基于Socket API应用层都实现了服务呢？常用的有**Web,Http，FTP,Email，DNS，CDN**。在讲述这些具体应用之前，我们会先对**通用的原理**作以介绍。然后展开描述这些应用层的服务。\n\n好啦，了解了概况，就让我们出发吧。。。\n\n![image-20210707205341750](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205341750.png)\n\n## 前言\n\n在开始正式的内容之前，我们有必要先建立有意识的学习习惯。\n\n为什么要学习应用层呢？应用层或者更具体的说是应用程序，**应用程序是互联网存在的理由**，在其以下的四层，它们的确实现了很多功能，但这些功能如果不能被集成应用到一个应用程序上，那分层的结构就只是纸上谈兵罢了。\n\n应用层也是与我们**日常生活最贴近**的一层，我们与电脑上可以实现**人机交互**的绝大部分应用都是应用层的应用。\n\n好啦，说了这么多，无非想表达一个观点，应用层很重要。\n\n- [x] `我们将从应用层协议原理起笔，浓墨重彩的描述Web,Http,Ftp,Email,DNS,这几个应用层协议，落笔于P2P应用与CDN。`\n\n## 1.1 应用层协议原理\n\n任何复杂的系统实现都是从一个小的灵感异或想法开始的。\n\n假如我们想做一个交易旧书的网站，并且让它实际的运营，那我们应该从哪里点亮这个火光呢？\n\n> 研发网络应用程序的**核心是写出能够运行在不同的端系统和通过网络彼此通信的程序**。\n\n也就是说我们重点关注如何用程序实现端系统间通信，而程序的书写首先必须是基于框架的，互联网应用的体系结构分为两种：CS架构和P2P架构。\n\n### CS服务体系\n\nCS服务体系指的是服务器和客户端组成的架构。\n\n`服务器` ：服务器是**一直运行着**的，通过**固定IP与端口号**来访问的，**可扩展性较差**的终端设备；\n\n`客户端`：客户端在网络中以**动态IP**的方式标识，并**主动与服务器建立通信**。\n\n### P2P服务体系\n\n在P2P体系结构中，任何端系统既可以是客户端，也可以是服务器，这也使得它们的**可扩展性强**，又因为没有限制，所以**任意两台端设备之间可以进行通信**。但这也导致**难以有效的管理**体系中的端系统，在现实中的应用场景包括**迅雷，Gnutella**。\n\n------\n\n我们发现，P2P的负载均衡能力强，而CS架构更容易维护，那可不可以取其所长，来做一种CS与P2P体系结构的混合体呢？\n\n别说，还真有人实现了。一个大学生做了一个名为**Napster**的应用。这个应用是用来提供**文件传输**的。一个用户想查询该系统中是否存在某个文件，首先她的主机向**中心服务器**查询资源的位置，要实现这个功能就需要使用**CS体系**，即每台主机上线以后，会**在中心服务器上注册它所拥有的的资源**。查询到存在这个资源后，中心服务器会返回给主机**这个资源所在的主机位置**，最后使用**P2P体系**完成**两个节点间的文件传输**即可。\n\n------\n\n### 分布式进程通信\n\n再回到核心问题，在确定使用哪种体系的前提下，我们还需要解决通信的问题。而**通信的实体是进程**，也就是要解决**分布式进程间通信**的问题。但这个问题是宽泛的，我们不妨分而治之——\n\n1. **如何标识一个进程，怎样来寻址一个进程。**\n2. **传输层是如何为应用层提供服务的？**\n3. **如何使用传输层提供的服务来实现进程之间的报文交换。**\n\n换个角度来思考这三个问题，就是怎样找到要服务的用户，这个服务怎样提供给用户，用户怎样使用这个服务。带着这三个问题，我们出发吧——\n\n#### 问题一\n\n我们通常使用**32位的IP地址来唯一的标识一台主机**，在主机之上，用**端口号来标识特定的进程**。比如HTTP,**TCP的默认端口号就为80**.进程可以使用TCP或者UDP的传输层协议进行通信。\n\n#### 问题二\n\n前面提到，传输层通过接口向应用层提供服务。这个接口需要携带一些通信必须的信息，这种信息至少应该包含：要传输的报文，这个报文要传给谁，这个报文是从哪里传输来的。\n\n官方地说，我们需要知道`SDU,IP+TCP(UDP)端口，对方的IP+TCP(UDP)端口。`\n\n但每次通过接口通信使单独传输这些信息实在有点繁琐。所以，将这些信息封装变得很有必要。\n\n`应用进程通过一个称为套接字的软件接口向网络中发送报文和接收报文。`所谓套接字，也就是Socket .那如何来理解这个socket呢？\n\n我们先从它的作用入手**，socket是用于指明应用进程会话的本地标识**，我们可以打个比方来形象地理解——\n\n> 进程可类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接收进程对该报文进行处理。\n\n再从它的含义来看，socket是操作系统生成的一个整数，这个整数可以理解为**传输信息的引用**。这些信息具体的说，即是包含源IP，源port，目标IP，目标port的四元组。\n\n![image-20210707205357679](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205357679.png)\n\n我们不必关注四元组的信息，而只需要关注**socket的状态**即可。操作系统的文件系统同样应用了这样的思想，在打开一个文件时，**OS返回一个文件句柄**，而不是使用这个文件的目录名，文件名，这样使用简单且易管理。\n\n值得一提的是，四元组是针对TCP的socket信息，但对于使用UDP的服务来说，情况又有所不同。\n\n使用UDP提供的服务时，两个进程之间的通信不需要建立连接，即**不面向连接**，每个报文都是独立传输的，它的前后报文也可能被送到**不同的分布式进程**，也就是说，对于UDP的socket，即只需指明报文将发往何处，而不必关心报文来自哪里。所以**Socket中封装对方的IP及端口**即可，\n\n### 问题三\n\n问题三需要回答的是怎样约定传输的格式，动作。这就需要定义**应用层的协议**，那这个协议的遵守是如何体现的呢？通过**编制程序**，使用**API**来调用网络基础设施来提供通信服务传报文，解析报文，实现应用时序等。\n\n应用层的协议是如何定义的呢？它需要解决的具体包含哪些问题？\n\n- [x] `应用层的协议定义了运行在不同端系统上的应用进程如何相互交换报文`。\n\n- [x] `它需要包含报文的类型，报文类型对应的语法，报文中字段的语义，报文所导致的动作。`\n\n## 1.2 Web与http\n\n我们在学习工作时总会无可避免地访问web页面了，一个键盘，一声敲击，一个奇迹。这奇迹的背后似乎`有迹可循`——\n\n在我们浏览的网页中，包含图文，动画，视频等，为了更好地描述这些事物，它们有了通用的名字：**对象**。对象可以认为是**HTML页面的最小组成单元**。直观地看，在我们浏览一个页面时，不同的对象并非同时出现，显然它们有可能来自不同的目的地，那如何来**标识由对象组成的HTML页面**呢？\n\n这就需要**URL**(统一资源定位符)，URL表示资源的**地点**，即资源来自于互联网中哪个IP。如果只使用URL标识资源位置，未免有点宽泛。所以引入**URI**(统一资源标识符)就势在必行了。\n\nURI用字符串标识资源的**位置**。则URL是URI的子集，具体看下符合**RFC标准**的URI格式——\n\n![image-20210707205411737](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205411737.png)\n\n\n\n- `协议方案名：`更多被使用的是http，但使用**SSL安全传输层**服务的**https**必然将取代http.\n- `登录信息：`即用户认证，默认是匿名访问。\n- `服务器地址：`即服务器的域名。\n- `服务器端口号：` 这里的80端口指的就是TCP服务。\n- `文件路径：` 不能再具体的描述了。\n- `查询字符串：` 即参数，比如点开某件商品的详情页时需要附带该商品的ID与该客户的ID。\n- `片段标识符：` 无题。\n\n了解了页面的组成，以及资源如何标识，我们再来看下页面是如何展示给用户的——\n\n1. 浏览器通过HTML表单或超链接请求指向一个`应用程序的URL`。\n2. 服务器收发到用户的请求。\n3. 服务器执行已接受创建的指定应用程序。\n4. 应用程序通常是基于用户输入的内容，执行所需要的操作。\n5. 应用程序把结果格式化为网络服务器和浏览器能够理解的文档，即我们所说的`HTML网页`。\n6. 网络服务器最后将结果返回到浏览器中。\n7. 浏览器使用解释器解析页面。\n\n这么多的步骤，想来应该会比较耗时，这也是起初web被戏称**World wide wait**的原因，如今网络节点的增加与带宽的提高让网页的传输有了一丝飞一般的感觉~\n\n### HTTP协议的引入\n\n我们知道应用层的应用程序都需要遵循规范，那web应用程序需要遵循什么规范呢？\n\n自然是HTTP协议咯，HTTP协议全称是**超文本传输协议**。它的出现主要是为了解决**文本传输**的问题。一路走来经历了**HTTP1.0,HTTP1.1,HTTP2.0**.可见版本更迭异常缓慢。但这并不意味着HTTP不受人青睐。相反，由于它本身非常简单。开发者在它的基础上开发出了很多应用方法并投入使用，现在**HTTP协议已经超出Web框架的局限**，被用于各种各样的场景中。可见，简单也意味着丰富的可扩展性。\n\n### 网络基础TCP/IP\n\n为了更好地理解HTTP，我们有必要先了解一下TCP/IP。\n\n我们所用的网络都是在TCP/IP协议族的基础上运行的，它约定了**端系统间相互通信的规则**。因为后面的小结会涉及到具体的TCP/IP协议族，这里我们只给出一个框架——\n\n![image-20210707205429415](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205429415.png)\n\n\n\n在TCP/IP协议族提供的网络基础上，HTTP按部就班地传输着报文。接下来我们将剥茧抽丝地**解析报文传输**的过程：\n\n![image-20210707205540218](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205540218.png)\n\n在这张图中，可以看到HTTP协议的职责在于**生成目标Web服务器的请求报文，及对Web服务器请求内容的处理**。\n\n### HTTP报文\n\nHTTP报文都是以**ASCII码**的形式与人交互，请求报文和响应报文的格式是这样的——\n\n![image-20210707205553641](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205553641.png)\n\n### HTTP请求报文\n\n这里给出一个请求报文的例子，我们来剖析它的每一个字段——\n\n![image-20210707205631561](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205631561.png)\n\n请求行中包括请求的方法，使用的协议及版本。\n\n- `Host:`请求资源所在的服务器，比如WWW.Baidu.com\n- `User-Agent:`HTTP客户端程序的信息\n- `Accept:`用户代理可以处理的**媒体类型**。\n- `Accept-Language:`优先的语言。\n- `Accept-Encoding:`优先的内容编码。\n- `DNT:`请求追踪字段，即**用户不希望被追踪**。\n- `Connection:`主要有两个用途：**控制不再转发给代理的首部字段**和**持久连接**的状态管理\n- `Pragma:`报文的**指令**。\n- `Cache-Control:`控制**浏览器端缓存**的行为\n\n其他的首部还有很多，我们就不一一列举了。\n\n### HTTP响应报文\n\n同样的，通过一个小例子我们简要认识一下HTTP响应报文——\n\n![image-20210707205648733](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205648733.png)\n\n首先是状态行，它的信息包括协议类型，版本，状态码，状态码对应的解释。\n\n再来看字段的解析：\n\n- `Date:`服务器端**创建报文的日期时间**，必选项。\n- `Server:`用于告知客户端当前**服务器上安装的HTTP服务器应用程序**的信息。\n- `Last-Modified:`资源**最终修改的时间**。\n- `ETag:`资源的匹配信息，只有当If-Match的字段值与ETag值**匹配时，服务器才会接收请求**。\n- `Accept-Ranges:`是否接收**字节范围请求**，当我们只需要一部分数据时，可以加这个参数来减少网络链路的带宽压力。\n- `Content-Length:`实体主体的长度，它的**单位是字节**，TCP提供的是字节流的服务，他不会维护信息的边界，所以需要一些辅助信息。\n- `Connection:`连接的状态，可选Keep-alive和Close\n- `Connect-Type:` 实体类型\n\n我们再从层间接口的角度来看Web是如何工作的。。。\n\n### Web的层间接口Socket\n\nHTTP协议使用是**基于TCP的传输层服务**，则服务器的**80号端口**会始终处于等待状态，客户端发起请求后，服务器端的**守护socket**在接收到请求以后，会生成一个该请求**独有的socket**，这个socket表示服务器端与特定客户端的**会话关系**。\n\n### 无状态协议\n\nHTTP协议是一个**无状态**的协议，它不会维护历史信息，这使得它能够**支持的用户数量多**，但比如说在登录网页以后，维护登录状态又是必不可少的。\n\n那如何使它可以记录状态呢？对HTTP协议本身做文章未免**不是开发者的初衷**，所以由**客户端**来维护历史信息，由于要维护的历史信息比较多，这里与用户交互的不是信息本身，而是指向这些信息的引用，小甜饼**Cookie**就这样应运而生了。\n\n我们通过下图来认识一下Cookie机制——\n\n![image-20210707205705315](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205705315.png)\n\n### 持久连接\n\nHTTP1.0协议是不支持持久连接的，也就是每次发送报文时，都需要建立TCP连接——\n\n![image-20210707205856780](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205856780.png)\n\n\n\n这样每次请求时都会造成**无谓的TCP连接和断开**，增加通信量的消耗。\n\n因此在HTTP1.1中引入了持久连接，持久连接是指如果**没有一方明确要求断开连接时，这个连接会一直保存**。也就是说，持久连接是`双方端系统需要设置的`，而不是在通信过程中设定。\n\n持久连接使多数请求以**管线化方式**发送称为可能。这就可以实现**高并发发送**。类似于**流水线**。\n\n### HTTP首部字段的应用\n\n我们通过**搜索引擎**来获取想要的web页面，那搜索引擎是如何找到web页面的呢？它会通过网络**爬虫**爬取到HTTP的**首部字段**，使用首部字段中的关键信息来建立**索引**，实现高效查找。\n\n### HTTP请求行与状态行浅析\n\n- `请求行：`这里我们主要描述用于告知服务器意图的方法：\n  - 如get用于请求访问已被URI识别的资源；\n  - POST方法用来传输实体的主体；\n  - PUT用于传输文件;\n  - HEAD用于请求报文首部\n- `状态行：`![image-20210707205842449](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205842449.png)\n- \n\n### Web缓存\n\n假设有这样一种需求，客户请求服务器资源时因为链路太长导致响应时间慢，老板要求你解决这个问题，这时根据你的经验有两种处理方式——\n\n1. **增加链路带宽**，可行，但你被辞退了，因为解决方式太土豪；\n2. **在局域网内部增加缓存节点**。也就是Web代理，购置一台服务器就好了，还可以通过增加缓存的命中率来**减轻服务器的负载，降低网络的通信量**，爽歪歪。老板直呼内行。\n\n缓存应该是学习的一大热点了，但凡缓存，就需要注意缓存一致性问题。首先我们要能发现缓存是否一致，也就是**通过加时间字段**。如果字段值超时了，Web代理就丢弃缓存内容。\n\n------\n\n### 加餐——HTTPS\n\n先来看张图，可以看到在URL的前面有一个**锁的标识**，而我们所熟识的HTTP是不加密的，所以呢，这里的锁实际上标识使用的协议是HTTPS，我们的故事也将从这张图开始啦。。。\n\n![image-20210408101342730](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408101342730.png)\n\n我们知道，HTTP最大的特点与优点就是**简单易用**，但简单也必然带来一些问题：\n\n- `明文传输`：由于HTTP本身不具备加密的功能，自然就不可能对通信整体(即通信请求与通信内容)进行加密，而不加密的HTTP有被窃听的风险，如果我们使用**wireShark抓包工具**，就会收获满满——\n\n  ![image-20210408102109238](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408102109238.png)\n\n  这可不怎么靠谱，那怎样实现加密呢？考虑到发生数据泄露的位置可能是**通信源或者通信链路**，我们可以对症下药，对**通信链路**进行加密，这就引出了**SSL安全套接字层/TLS安全层传输协议**。当然对通信内容本身加密也是一种可行的idea,这里我们先着重介绍SSL。\n\n  SSL采用一种叫做公开密钥加密的加密处理方式，我们常说的使用密钥加密，指的是客户端使用密钥加密，服务器端使用同一密钥解密，但这样显然面临一种困境：如果有第三方得到密钥，那就可以为所欲为。这里可以尝试客户端使用公开密钥加密，而服务器端使用私有秘钥解密的策略。\n\n  两种策略各有千秋，那到底使用哪一种呢？\n\n  HTTPS表示我全都要，HTTPS使用混合加密机制，在**交换密钥环节使用公开密钥加密方式**，之后的**建立通信交换报文使用共享密钥加密方式**。\n\n- `身份验证`：HTTP协议中的请求与响应不会对同新方进行确认，也就是说任何人都可以发起请求，如果发起多次**恶意请求，网站负载就会增大**，显然需要机制来确认通信方的身份。\n\n  SSL不仅提供加密处理，还使用了称之为**证书**的手段来身份认证，证书由靠谱的第三方机构颁发。\n\n- `报文完整性`：在通信过程中，如果请求或者响应的内容遭到中间人的篡改，就会事与愿违，那如何来防止篡改呢？显然需要一种指代内容的唯一标识，**MD5和SHA**就是常用的方法，\n\n现在，我们可以给出HTTPS的明确定义了：\n\n> HTTPS = HTTP + 加密 + 认证 +完整性保护\n\n## 1.3 FTP&Email\n\n在开发应用时，FTP的身影并不多，唯一一次见证它的背影是在使用**Maven找包**的时候，给我的直观感觉就是，这不就是**文件系统**嘛~\n\n鉴于它太古老了，我们只是简要描述一下它工作的流程——\n\n![image-20210707205929522](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205929522.png)\n\n1. FTP的服务器始终守护在21号端口处等待连接，FTP的客户端发起连接请求，**基于TCP的控制连接**建立。\n2. **用户身份认证**，认证后访问文件目录，也因此需要维护历史信息，即**FTP是有状态的协议**，值得一提的是，身份认证是使用**明文传输**，着实不可靠。\n3. 服务器**主动**与客户端的20号端口建立**数据连接**，客户端下载数据，完结。\n\n------\n\n这是一个么得感情的分割线~\n\nEmail不同于FTP，它在工作交流，面试简历提交等方面**应用非常广泛**。Email由三部分构成：**用户代理**，也就是客户端软件，**邮件服务器**，**协议**。\n\n我们同样复现EMail的工作流程——\n\n![image-20210707205938954](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205938954.png)\n\n1. 首先用户在用户代理中写好邮件，用户代理通过**STMP协议**将邮件传输到**用户邮箱服务器的队列**中。\n2. 邮箱服务器再将邮件从队列中提取出来，使用SMTP协议将邮件发送到目标服务器。\n3. 目标服务器将邮件存储在**目标用户的邮箱目录**中。\n4. 目标用户通过**POP3协议**从邮箱中拉取邮件阅读。\n\nEmail使用**7位的ASCII码**编码，而中文需要两个字节描述，如果使用7位ASCII码传输时就会乱码。为了防止乱码，使用**MIME多媒体扩展协议**，这是基于**Base64**的编码，即**将ASCII码序列化**再传输。\n\n而使用POP3的拉取协议，显然不应该记录邮件都经由谁手，在什么时间写好这种敏感信息，所以它被设计为**无状态协议**。\n\n## 1.5 DNS\n\n### 概述\n\nDNS不同于其他应用层协议，它是用来**为其他应用协议提供服务**的协议，DNS为人所知的功能是**完成域名到IP地址的转换**，且非常**健壮**。而这个转化实质上是由**DNS系统**来完成的。\n\n系统的设计是为了解决复杂问题，而DNS系统解决的核心问题就是如何完成域名到IP地址的转换，我们再将这个问题拆解为三个小问题——\n\n### 1.如何命名一台设备？\n\n如果我们想访问一个网站，那就需要在地址输入栏中输入网站的URI，而URI中显然需要**包含易记的用来标识端系统位置**的东西，这就是**域名**，域名是一个端系统的**别名**，易于记忆，显然www.baidu.com比起纯数字的方式交互起来友好地多。\n\n既然有别名，那就一定有正规名称，也就是IP地址.IP地址被用来表示一台主机，同时也用于寻址。IP地址分为IPV4和IPV6两种。IPV4使用点分十进制的书写习惯，共有32位，IPV6则有128位，可标识的主机数量非常多。\n\n显然，日常使用时域名显然是更好的选择，域名在初期使用没有分层的结构，因为主机数量少，不会出现重名，只需要维护一张映射表就行了，维护起来游刃有余。\n\n但当主机数指数级增多以后，重名变得不可避免，**分层式的命名**开始大势所趋。这时只维护一张表也显然不够了，**分布式数据库**被引入。而既然是应用层协议，自然会使用到传输层的服务，DNS使用的就是相对简单的**UDP协议**，可见网络核心的功能其实是在网络边沿实现的，网络核心只要保证传输就ok了。\n\n再说回**层次树状化**的命名，首先从根开始，也就是顶级域名，顶级域名对应的是顶级服务器，全世界只有13台顶级，即**根服务器**。而且**中国并没有**，有人担忧万一根服务器被黑了，网络安全是否变的不可靠了。但实际上这对网络安全并没有什么大的影响。分布式足以解决这一看起来很棘手的问题。在这些顶级域下，又有很多**子域**，子域的类型分为两种，即**通用的**和**国家的**。最终演化到树叶，就是**主机**啦。\n\n![image-20210707210048205](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210048205.png)\n\n如果将DNS的命名规则平面化的话，它可以这样表示：\n\n![image-20210707210104057](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210104057.png)\n\n假如我们要访问耶鲁大学AI学院的网站。通俗的方式是首先找到顶级域名，再找到通用域名edu，然后找到edu下的yale,接着发现cs，最后定位到AI。从它宽泛的命名框架来看，域名适用于任何主机，这就意味着**域名不代表地域，它只是一个逻辑的概念**，而非物理上的。\n\n### 2.如何解析转换关系？\n\n解析关系直观地看，可以维护一张映射表，但考虑到性能，我们使用专门的名字服务器来存储这样的一张表，但当主机变多时，**一个服务器容易宕机，且不好维护**。\n\n这时需要演化为分布式的名字服务器，而完成其功能的实际上是**分布式的数据库**。\n\n在**每一个区域Zone**内需要维护一个名字服务器，它存储有这个区域内所有主机Ip与域名的**映射关系**，同时它也应该满足**寻址**的要求，这就需要维护指向路径的指针。因其完备的功能，因此也称其为权威服务器。\n\n那权威服务器是如何维护转换关系的呢？通过数据库中的**资源记录**。\n\n资源记录使用**RR格式**来维护**域名到IP**(或者其他标识)的映射关系。它包含如下字段——\n\n- `Domain_name:`域名，没什么可说的~\n- `Ttl:`生存时间，假如我现在要访问中国以外的一个域名，我所在区域的权威服务器会沿路径获取到这个域名与IP的映射关系，并将其是作为缓存记录下来，但它显然不常用，所以存活时间仅有**两天**。而对于区域内的域名，考虑到作为老大的职责，会**长期缓存**区域内小弟的映射关系。\n- `Class:`只要是因特网范围内的，值都为IN,在物联网时代，NOT IN将成为一种可能。\n- `Value:`可以是数字，域名或者ASCII码。\n- `Type:`资源记录的类型，它包括：\n  - `A`：name为主机，Value为IP地址\n  - `CNMAE`:name为规范名字的别名，value是规范名字。\n  - `NS`:name为域名，value为该域名权威服务器的名字\n  - `MX`:value为name对应的邮件服务器的名字。\n\n#### DNS系统的工作原理\n\n- 应用首先调用解析器，解析器作为客户向名字服务器发出查询报文，该查询报文被封装在UDP段中。\n- 名字服务器返回响应报文。\n\n![image-20210707210144625](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210144625.png)\n\n那名字服务器是如何获取到远端的IP映射关系呢？\n\n这里要分有缓存和没缓存两种情况讨论——\n\n1. `存在缓存`：直接返回\n2. `没有缓存`：\n   1. `递归查询`，即从根服务器开始递，再从目标服务器的权威服务器开始归\n   2. `迭代查询`，即依次遍历每种可能。\n\n### 3.如何维护映射关系？\n\n关系的维护无非增删改查，假如要在上级域的名字服务器中增加一个映射关系，那就往数据库中**添加两条记录**，分别指向**新增的子域的域名**和**域名服务器的地址**。这样在下次访问时会方便很多。但缓存有可能出现**不一致**的问题，因而在某些时候删除也是必要的。\n\n### 报文结构\n\n最后，简单看下DNS协议的报文——\n\n![image-20210707210157098](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210157098.png)\n\n## 1.6 P2P应用\n\n因为我在毕业后所将从事的工作和P2P的体系架构**大抵是没有太多交集**的，所以这一小节的知识点我只**简要描述原理**。\n\n先入为主地说，P2P的产生是为了解决CS体系的缺陷，即**服务器压力大，负载均衡能力弱，可靠性不好**。而相应的，P2P体系在这些方面是要略胜一筹的。\n\nP2P体系常常被应用在**文件分发，流媒体**，在这些应用场景中，peer节点的压力比较轻。\n\n为了形象描述P2P体系，我们来看下面这张图——\n\n![image-20210707210209024](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210209024.png)\n\n这张图描述了两种体系结构随着客户端数量的增加，下载文件所消耗的时间，可以看到，CS体系呈现出线性的关系，而P2P则是类似于对数关系。\n\n如果单纯从下载性能方面来看的话，P2P早就风靡一时了。但因为它难以管理的缺陷，导致了它应用的并不多。\n\n我们来了解通用的P2P的管理模式——\n\n- `非结构化的P2P：`邻居节点间存在互通有无的关系，形成**覆盖网**。典型的应用是**文件共享**，即通过**集中目录**的方式，用户首先键入**关键字**，然后**目录服务器**告诉用户有哪些节点拥有该资源，用户建立**TCP连接**，再去请求某节点的资源。拥有该资源后，将自己拥有该资源的信息**上报目录服务器**，流程结束。\n\n  但集中式的目录，存在**单点故障，性能瓶颈，侵犯版权**的问题。此外，查询时采用**洪泛**的方式有可能导致**请求无限放大**，所以有必要设置**TTL或由节点维护历史信息**避免成环。因此除了集中式的目录以外，还存在**完全分布式**和**混合体**的机制。混合体机制利用节点的**不均匀性**，某个对等点要么是属于一个组或者组长，查询时，上报组长，如果组内有，直接去请求，组内没有的话，则交由组长传递给其他组长。\n\n  那如何找到唯一地那个文件呢，首先通过输入框的**描述信息**找到该文件的**哈希值**，然后将哈希值作为**唯一Id**查询返回结果\n\n  这里还有一个有意思的模式，**BitTorrow**。在这种模式下，文件被分为很多块，每个节点各持一块，且每个节点维护一个位图，即**BitMap**，0标识不拥有此资源，1表示拥有此资源。为了使所有节点都拥有相同的资源，需要**定期洪泛**。\n\n- `结构化的P2P：`节点与节点之间的关系是往往成**网状或者环状**的。在更新节点时始终维护节点间的关系，即根据哈希值更新环。\n\n## 1.7 CDN\n\n在互联网中，视频类的流量占据所有流量的大部分，这也使得**带宽的增加有用武之地**。那视频的流量为什么这么大呢？\n\n视频是**固定速度显示的图片序列**，而图片是由许多**像素点集成**得到的。所以视频就会比较大，编码也会相应复杂一些。\n\n那针对太大的视频，应该做如何的处理呢？这就首先要看网络视频的特点——\n\n- 高码率\n- 可压缩\n\n所以降低视频流量的方式就是**降低码率并做时空上的压缩**，比如我国的AVS编码方式。\n\n我们再从整体的框架看，显然只用一台超级服务器来提供流式服务是不可能的，因为**规模太大**，并且**存在异构性**。因此提供流式服务的**分布式服务器**被广泛应用。\n\n我们在平时观看视频时，有时会发生卡顿，并且提示我们缓存一会再看，如何解释它的原理呢？\n\n`互联网提供给我们的是存储视频的流化服务，它可以实现辺下载辺看，就像河流一般，我们在从缓冲区中取视频内容，实现了高并发的视频传输。`\n\n但不同的用户对于视频的要求不同，这可能受限于带宽，或者是设备。那如何解决这个问题呢？\n\n采用**动态自适应的流化技术DASH**，服务器端并不会有选择性的发送内容，但它会将视频分块，每块有不同的解析度，不同的编码标准，为了为客户端标识不同块的URL，服务器还维护一个**告示文件**用以提供不同块的URL。\n\n客户端首先获取到告示文件，然后**周期性的测试**服务器到客户端的**带宽**，根据带宽来**实时**地请求某一块，最后**解析**观看视频。\n\n假如视频流量出现超高并发，比如春晚直播，如果仅从央视的服务器去请求资源的话，那你将体会到什么叫做超高频延迟。但我们实际观看时，貌似很流畅，这是为什么呢?\n\n因为使用了CDN服务商的加速服务，加速的原理也很简洁，无非部署缓存节点。但如何部署呢？CDN服务商使用的部署策略通常有两种——\n\n- `策略1`：在本地ISP的区域内部署缓存节点，这样离用户最近，但未免投入太高。\n- `策略2`：靠近ISP的数据中心部署，效果也很不错，而且部署的节点相对较少，减少了成本。\n\n我们来看一个小例子来体会下CDN服务是如何被使用的——\n\n![image-20210707210224483](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210224483.png)\n\n步骤：\n\n1. ICP预先部署资源到CDN节点\n\n2. 用户访问Netflix的注册网站；\n\n3. 重定向到部署在亚马逊云端的网站；\n\n4. 使用域名解析重定向的机制从最近的CDN节点中获取资源；\n\n5. 将动态自适应的资源返回给用户，\n\n------\n\n> 山高路远，静水深流。\n\n\n\n\n\n\n\n","source":"_posts/计算机网络应用层.md","raw":"---\ntitle: 计算机网络应用层\ntop: true\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-07-12 11:51:04\npassword:\nsummary:\ntags: \n\t- 计算机网络\n\t- 抓包\ncategories: 计算机基础\n---\n\n## 摘要\n\n到第二章我们就将进入具体5层协议栈的描述，更具体地说，是从顶层**应用层**开始，渐进地学习计算机网络。我们知道，应用层是在传输层提供的服务上实现应用进程通信的，也就是**借助操作系统使用Socket API的方式**实现的。那基于Socket API应用层都实现了服务呢？常用的有**Web,Http，FTP,Email，DNS，CDN**。在讲述这些具体应用之前，我们会先对**通用的原理**作以介绍。然后展开描述这些应用层的服务。\n\n好啦，了解了概况，就让我们出发吧。。。\n\n![image-20210707205341750](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205341750.png)\n\n## 前言\n\n在开始正式的内容之前，我们有必要先建立有意识的学习习惯。\n\n为什么要学习应用层呢？应用层或者更具体的说是应用程序，**应用程序是互联网存在的理由**，在其以下的四层，它们的确实现了很多功能，但这些功能如果不能被集成应用到一个应用程序上，那分层的结构就只是纸上谈兵罢了。\n\n应用层也是与我们**日常生活最贴近**的一层，我们与电脑上可以实现**人机交互**的绝大部分应用都是应用层的应用。\n\n好啦，说了这么多，无非想表达一个观点，应用层很重要。\n\n- [x] `我们将从应用层协议原理起笔，浓墨重彩的描述Web,Http,Ftp,Email,DNS,这几个应用层协议，落笔于P2P应用与CDN。`\n\n## 1.1 应用层协议原理\n\n任何复杂的系统实现都是从一个小的灵感异或想法开始的。\n\n假如我们想做一个交易旧书的网站，并且让它实际的运营，那我们应该从哪里点亮这个火光呢？\n\n> 研发网络应用程序的**核心是写出能够运行在不同的端系统和通过网络彼此通信的程序**。\n\n也就是说我们重点关注如何用程序实现端系统间通信，而程序的书写首先必须是基于框架的，互联网应用的体系结构分为两种：CS架构和P2P架构。\n\n### CS服务体系\n\nCS服务体系指的是服务器和客户端组成的架构。\n\n`服务器` ：服务器是**一直运行着**的，通过**固定IP与端口号**来访问的，**可扩展性较差**的终端设备；\n\n`客户端`：客户端在网络中以**动态IP**的方式标识，并**主动与服务器建立通信**。\n\n### P2P服务体系\n\n在P2P体系结构中，任何端系统既可以是客户端，也可以是服务器，这也使得它们的**可扩展性强**，又因为没有限制，所以**任意两台端设备之间可以进行通信**。但这也导致**难以有效的管理**体系中的端系统，在现实中的应用场景包括**迅雷，Gnutella**。\n\n------\n\n我们发现，P2P的负载均衡能力强，而CS架构更容易维护，那可不可以取其所长，来做一种CS与P2P体系结构的混合体呢？\n\n别说，还真有人实现了。一个大学生做了一个名为**Napster**的应用。这个应用是用来提供**文件传输**的。一个用户想查询该系统中是否存在某个文件，首先她的主机向**中心服务器**查询资源的位置，要实现这个功能就需要使用**CS体系**，即每台主机上线以后，会**在中心服务器上注册它所拥有的的资源**。查询到存在这个资源后，中心服务器会返回给主机**这个资源所在的主机位置**，最后使用**P2P体系**完成**两个节点间的文件传输**即可。\n\n------\n\n### 分布式进程通信\n\n再回到核心问题，在确定使用哪种体系的前提下，我们还需要解决通信的问题。而**通信的实体是进程**，也就是要解决**分布式进程间通信**的问题。但这个问题是宽泛的，我们不妨分而治之——\n\n1. **如何标识一个进程，怎样来寻址一个进程。**\n2. **传输层是如何为应用层提供服务的？**\n3. **如何使用传输层提供的服务来实现进程之间的报文交换。**\n\n换个角度来思考这三个问题，就是怎样找到要服务的用户，这个服务怎样提供给用户，用户怎样使用这个服务。带着这三个问题，我们出发吧——\n\n#### 问题一\n\n我们通常使用**32位的IP地址来唯一的标识一台主机**，在主机之上，用**端口号来标识特定的进程**。比如HTTP,**TCP的默认端口号就为80**.进程可以使用TCP或者UDP的传输层协议进行通信。\n\n#### 问题二\n\n前面提到，传输层通过接口向应用层提供服务。这个接口需要携带一些通信必须的信息，这种信息至少应该包含：要传输的报文，这个报文要传给谁，这个报文是从哪里传输来的。\n\n官方地说，我们需要知道`SDU,IP+TCP(UDP)端口，对方的IP+TCP(UDP)端口。`\n\n但每次通过接口通信使单独传输这些信息实在有点繁琐。所以，将这些信息封装变得很有必要。\n\n`应用进程通过一个称为套接字的软件接口向网络中发送报文和接收报文。`所谓套接字，也就是Socket .那如何来理解这个socket呢？\n\n我们先从它的作用入手**，socket是用于指明应用进程会话的本地标识**，我们可以打个比方来形象地理解——\n\n> 进程可类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接收进程对该报文进行处理。\n\n再从它的含义来看，socket是操作系统生成的一个整数，这个整数可以理解为**传输信息的引用**。这些信息具体的说，即是包含源IP，源port，目标IP，目标port的四元组。\n\n![image-20210707205357679](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205357679.png)\n\n我们不必关注四元组的信息，而只需要关注**socket的状态**即可。操作系统的文件系统同样应用了这样的思想，在打开一个文件时，**OS返回一个文件句柄**，而不是使用这个文件的目录名，文件名，这样使用简单且易管理。\n\n值得一提的是，四元组是针对TCP的socket信息，但对于使用UDP的服务来说，情况又有所不同。\n\n使用UDP提供的服务时，两个进程之间的通信不需要建立连接，即**不面向连接**，每个报文都是独立传输的，它的前后报文也可能被送到**不同的分布式进程**，也就是说，对于UDP的socket，即只需指明报文将发往何处，而不必关心报文来自哪里。所以**Socket中封装对方的IP及端口**即可，\n\n### 问题三\n\n问题三需要回答的是怎样约定传输的格式，动作。这就需要定义**应用层的协议**，那这个协议的遵守是如何体现的呢？通过**编制程序**，使用**API**来调用网络基础设施来提供通信服务传报文，解析报文，实现应用时序等。\n\n应用层的协议是如何定义的呢？它需要解决的具体包含哪些问题？\n\n- [x] `应用层的协议定义了运行在不同端系统上的应用进程如何相互交换报文`。\n\n- [x] `它需要包含报文的类型，报文类型对应的语法，报文中字段的语义，报文所导致的动作。`\n\n## 1.2 Web与http\n\n我们在学习工作时总会无可避免地访问web页面了，一个键盘，一声敲击，一个奇迹。这奇迹的背后似乎`有迹可循`——\n\n在我们浏览的网页中，包含图文，动画，视频等，为了更好地描述这些事物，它们有了通用的名字：**对象**。对象可以认为是**HTML页面的最小组成单元**。直观地看，在我们浏览一个页面时，不同的对象并非同时出现，显然它们有可能来自不同的目的地，那如何来**标识由对象组成的HTML页面**呢？\n\n这就需要**URL**(统一资源定位符)，URL表示资源的**地点**，即资源来自于互联网中哪个IP。如果只使用URL标识资源位置，未免有点宽泛。所以引入**URI**(统一资源标识符)就势在必行了。\n\nURI用字符串标识资源的**位置**。则URL是URI的子集，具体看下符合**RFC标准**的URI格式——\n\n![image-20210707205411737](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205411737.png)\n\n\n\n- `协议方案名：`更多被使用的是http，但使用**SSL安全传输层**服务的**https**必然将取代http.\n- `登录信息：`即用户认证，默认是匿名访问。\n- `服务器地址：`即服务器的域名。\n- `服务器端口号：` 这里的80端口指的就是TCP服务。\n- `文件路径：` 不能再具体的描述了。\n- `查询字符串：` 即参数，比如点开某件商品的详情页时需要附带该商品的ID与该客户的ID。\n- `片段标识符：` 无题。\n\n了解了页面的组成，以及资源如何标识，我们再来看下页面是如何展示给用户的——\n\n1. 浏览器通过HTML表单或超链接请求指向一个`应用程序的URL`。\n2. 服务器收发到用户的请求。\n3. 服务器执行已接受创建的指定应用程序。\n4. 应用程序通常是基于用户输入的内容，执行所需要的操作。\n5. 应用程序把结果格式化为网络服务器和浏览器能够理解的文档，即我们所说的`HTML网页`。\n6. 网络服务器最后将结果返回到浏览器中。\n7. 浏览器使用解释器解析页面。\n\n这么多的步骤，想来应该会比较耗时，这也是起初web被戏称**World wide wait**的原因，如今网络节点的增加与带宽的提高让网页的传输有了一丝飞一般的感觉~\n\n### HTTP协议的引入\n\n我们知道应用层的应用程序都需要遵循规范，那web应用程序需要遵循什么规范呢？\n\n自然是HTTP协议咯，HTTP协议全称是**超文本传输协议**。它的出现主要是为了解决**文本传输**的问题。一路走来经历了**HTTP1.0,HTTP1.1,HTTP2.0**.可见版本更迭异常缓慢。但这并不意味着HTTP不受人青睐。相反，由于它本身非常简单。开发者在它的基础上开发出了很多应用方法并投入使用，现在**HTTP协议已经超出Web框架的局限**，被用于各种各样的场景中。可见，简单也意味着丰富的可扩展性。\n\n### 网络基础TCP/IP\n\n为了更好地理解HTTP，我们有必要先了解一下TCP/IP。\n\n我们所用的网络都是在TCP/IP协议族的基础上运行的，它约定了**端系统间相互通信的规则**。因为后面的小结会涉及到具体的TCP/IP协议族，这里我们只给出一个框架——\n\n![image-20210707205429415](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205429415.png)\n\n\n\n在TCP/IP协议族提供的网络基础上，HTTP按部就班地传输着报文。接下来我们将剥茧抽丝地**解析报文传输**的过程：\n\n![image-20210707205540218](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205540218.png)\n\n在这张图中，可以看到HTTP协议的职责在于**生成目标Web服务器的请求报文，及对Web服务器请求内容的处理**。\n\n### HTTP报文\n\nHTTP报文都是以**ASCII码**的形式与人交互，请求报文和响应报文的格式是这样的——\n\n![image-20210707205553641](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205553641.png)\n\n### HTTP请求报文\n\n这里给出一个请求报文的例子，我们来剖析它的每一个字段——\n\n![image-20210707205631561](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205631561.png)\n\n请求行中包括请求的方法，使用的协议及版本。\n\n- `Host:`请求资源所在的服务器，比如WWW.Baidu.com\n- `User-Agent:`HTTP客户端程序的信息\n- `Accept:`用户代理可以处理的**媒体类型**。\n- `Accept-Language:`优先的语言。\n- `Accept-Encoding:`优先的内容编码。\n- `DNT:`请求追踪字段，即**用户不希望被追踪**。\n- `Connection:`主要有两个用途：**控制不再转发给代理的首部字段**和**持久连接**的状态管理\n- `Pragma:`报文的**指令**。\n- `Cache-Control:`控制**浏览器端缓存**的行为\n\n其他的首部还有很多，我们就不一一列举了。\n\n### HTTP响应报文\n\n同样的，通过一个小例子我们简要认识一下HTTP响应报文——\n\n![image-20210707205648733](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205648733.png)\n\n首先是状态行，它的信息包括协议类型，版本，状态码，状态码对应的解释。\n\n再来看字段的解析：\n\n- `Date:`服务器端**创建报文的日期时间**，必选项。\n- `Server:`用于告知客户端当前**服务器上安装的HTTP服务器应用程序**的信息。\n- `Last-Modified:`资源**最终修改的时间**。\n- `ETag:`资源的匹配信息，只有当If-Match的字段值与ETag值**匹配时，服务器才会接收请求**。\n- `Accept-Ranges:`是否接收**字节范围请求**，当我们只需要一部分数据时，可以加这个参数来减少网络链路的带宽压力。\n- `Content-Length:`实体主体的长度，它的**单位是字节**，TCP提供的是字节流的服务，他不会维护信息的边界，所以需要一些辅助信息。\n- `Connection:`连接的状态，可选Keep-alive和Close\n- `Connect-Type:` 实体类型\n\n我们再从层间接口的角度来看Web是如何工作的。。。\n\n### Web的层间接口Socket\n\nHTTP协议使用是**基于TCP的传输层服务**，则服务器的**80号端口**会始终处于等待状态，客户端发起请求后，服务器端的**守护socket**在接收到请求以后，会生成一个该请求**独有的socket**，这个socket表示服务器端与特定客户端的**会话关系**。\n\n### 无状态协议\n\nHTTP协议是一个**无状态**的协议，它不会维护历史信息，这使得它能够**支持的用户数量多**，但比如说在登录网页以后，维护登录状态又是必不可少的。\n\n那如何使它可以记录状态呢？对HTTP协议本身做文章未免**不是开发者的初衷**，所以由**客户端**来维护历史信息，由于要维护的历史信息比较多，这里与用户交互的不是信息本身，而是指向这些信息的引用，小甜饼**Cookie**就这样应运而生了。\n\n我们通过下图来认识一下Cookie机制——\n\n![image-20210707205705315](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205705315.png)\n\n### 持久连接\n\nHTTP1.0协议是不支持持久连接的，也就是每次发送报文时，都需要建立TCP连接——\n\n![image-20210707205856780](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205856780.png)\n\n\n\n这样每次请求时都会造成**无谓的TCP连接和断开**，增加通信量的消耗。\n\n因此在HTTP1.1中引入了持久连接，持久连接是指如果**没有一方明确要求断开连接时，这个连接会一直保存**。也就是说，持久连接是`双方端系统需要设置的`，而不是在通信过程中设定。\n\n持久连接使多数请求以**管线化方式**发送称为可能。这就可以实现**高并发发送**。类似于**流水线**。\n\n### HTTP首部字段的应用\n\n我们通过**搜索引擎**来获取想要的web页面，那搜索引擎是如何找到web页面的呢？它会通过网络**爬虫**爬取到HTTP的**首部字段**，使用首部字段中的关键信息来建立**索引**，实现高效查找。\n\n### HTTP请求行与状态行浅析\n\n- `请求行：`这里我们主要描述用于告知服务器意图的方法：\n  - 如get用于请求访问已被URI识别的资源；\n  - POST方法用来传输实体的主体；\n  - PUT用于传输文件;\n  - HEAD用于请求报文首部\n- `状态行：`![image-20210707205842449](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205842449.png)\n- \n\n### Web缓存\n\n假设有这样一种需求，客户请求服务器资源时因为链路太长导致响应时间慢，老板要求你解决这个问题，这时根据你的经验有两种处理方式——\n\n1. **增加链路带宽**，可行，但你被辞退了，因为解决方式太土豪；\n2. **在局域网内部增加缓存节点**。也就是Web代理，购置一台服务器就好了，还可以通过增加缓存的命中率来**减轻服务器的负载，降低网络的通信量**，爽歪歪。老板直呼内行。\n\n缓存应该是学习的一大热点了，但凡缓存，就需要注意缓存一致性问题。首先我们要能发现缓存是否一致，也就是**通过加时间字段**。如果字段值超时了，Web代理就丢弃缓存内容。\n\n------\n\n### 加餐——HTTPS\n\n先来看张图，可以看到在URL的前面有一个**锁的标识**，而我们所熟识的HTTP是不加密的，所以呢，这里的锁实际上标识使用的协议是HTTPS，我们的故事也将从这张图开始啦。。。\n\n![image-20210408101342730](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408101342730.png)\n\n我们知道，HTTP最大的特点与优点就是**简单易用**，但简单也必然带来一些问题：\n\n- `明文传输`：由于HTTP本身不具备加密的功能，自然就不可能对通信整体(即通信请求与通信内容)进行加密，而不加密的HTTP有被窃听的风险，如果我们使用**wireShark抓包工具**，就会收获满满——\n\n  ![image-20210408102109238](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408102109238.png)\n\n  这可不怎么靠谱，那怎样实现加密呢？考虑到发生数据泄露的位置可能是**通信源或者通信链路**，我们可以对症下药，对**通信链路**进行加密，这就引出了**SSL安全套接字层/TLS安全层传输协议**。当然对通信内容本身加密也是一种可行的idea,这里我们先着重介绍SSL。\n\n  SSL采用一种叫做公开密钥加密的加密处理方式，我们常说的使用密钥加密，指的是客户端使用密钥加密，服务器端使用同一密钥解密，但这样显然面临一种困境：如果有第三方得到密钥，那就可以为所欲为。这里可以尝试客户端使用公开密钥加密，而服务器端使用私有秘钥解密的策略。\n\n  两种策略各有千秋，那到底使用哪一种呢？\n\n  HTTPS表示我全都要，HTTPS使用混合加密机制，在**交换密钥环节使用公开密钥加密方式**，之后的**建立通信交换报文使用共享密钥加密方式**。\n\n- `身份验证`：HTTP协议中的请求与响应不会对同新方进行确认，也就是说任何人都可以发起请求，如果发起多次**恶意请求，网站负载就会增大**，显然需要机制来确认通信方的身份。\n\n  SSL不仅提供加密处理，还使用了称之为**证书**的手段来身份认证，证书由靠谱的第三方机构颁发。\n\n- `报文完整性`：在通信过程中，如果请求或者响应的内容遭到中间人的篡改，就会事与愿违，那如何来防止篡改呢？显然需要一种指代内容的唯一标识，**MD5和SHA**就是常用的方法，\n\n现在，我们可以给出HTTPS的明确定义了：\n\n> HTTPS = HTTP + 加密 + 认证 +完整性保护\n\n## 1.3 FTP&Email\n\n在开发应用时，FTP的身影并不多，唯一一次见证它的背影是在使用**Maven找包**的时候，给我的直观感觉就是，这不就是**文件系统**嘛~\n\n鉴于它太古老了，我们只是简要描述一下它工作的流程——\n\n![image-20210707205929522](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205929522.png)\n\n1. FTP的服务器始终守护在21号端口处等待连接，FTP的客户端发起连接请求，**基于TCP的控制连接**建立。\n2. **用户身份认证**，认证后访问文件目录，也因此需要维护历史信息，即**FTP是有状态的协议**，值得一提的是，身份认证是使用**明文传输**，着实不可靠。\n3. 服务器**主动**与客户端的20号端口建立**数据连接**，客户端下载数据，完结。\n\n------\n\n这是一个么得感情的分割线~\n\nEmail不同于FTP，它在工作交流，面试简历提交等方面**应用非常广泛**。Email由三部分构成：**用户代理**，也就是客户端软件，**邮件服务器**，**协议**。\n\n我们同样复现EMail的工作流程——\n\n![image-20210707205938954](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205938954.png)\n\n1. 首先用户在用户代理中写好邮件，用户代理通过**STMP协议**将邮件传输到**用户邮箱服务器的队列**中。\n2. 邮箱服务器再将邮件从队列中提取出来，使用SMTP协议将邮件发送到目标服务器。\n3. 目标服务器将邮件存储在**目标用户的邮箱目录**中。\n4. 目标用户通过**POP3协议**从邮箱中拉取邮件阅读。\n\nEmail使用**7位的ASCII码**编码，而中文需要两个字节描述，如果使用7位ASCII码传输时就会乱码。为了防止乱码，使用**MIME多媒体扩展协议**，这是基于**Base64**的编码，即**将ASCII码序列化**再传输。\n\n而使用POP3的拉取协议，显然不应该记录邮件都经由谁手，在什么时间写好这种敏感信息，所以它被设计为**无状态协议**。\n\n## 1.5 DNS\n\n### 概述\n\nDNS不同于其他应用层协议，它是用来**为其他应用协议提供服务**的协议，DNS为人所知的功能是**完成域名到IP地址的转换**，且非常**健壮**。而这个转化实质上是由**DNS系统**来完成的。\n\n系统的设计是为了解决复杂问题，而DNS系统解决的核心问题就是如何完成域名到IP地址的转换，我们再将这个问题拆解为三个小问题——\n\n### 1.如何命名一台设备？\n\n如果我们想访问一个网站，那就需要在地址输入栏中输入网站的URI，而URI中显然需要**包含易记的用来标识端系统位置**的东西，这就是**域名**，域名是一个端系统的**别名**，易于记忆，显然www.baidu.com比起纯数字的方式交互起来友好地多。\n\n既然有别名，那就一定有正规名称，也就是IP地址.IP地址被用来表示一台主机，同时也用于寻址。IP地址分为IPV4和IPV6两种。IPV4使用点分十进制的书写习惯，共有32位，IPV6则有128位，可标识的主机数量非常多。\n\n显然，日常使用时域名显然是更好的选择，域名在初期使用没有分层的结构，因为主机数量少，不会出现重名，只需要维护一张映射表就行了，维护起来游刃有余。\n\n但当主机数指数级增多以后，重名变得不可避免，**分层式的命名**开始大势所趋。这时只维护一张表也显然不够了，**分布式数据库**被引入。而既然是应用层协议，自然会使用到传输层的服务，DNS使用的就是相对简单的**UDP协议**，可见网络核心的功能其实是在网络边沿实现的，网络核心只要保证传输就ok了。\n\n再说回**层次树状化**的命名，首先从根开始，也就是顶级域名，顶级域名对应的是顶级服务器，全世界只有13台顶级，即**根服务器**。而且**中国并没有**，有人担忧万一根服务器被黑了，网络安全是否变的不可靠了。但实际上这对网络安全并没有什么大的影响。分布式足以解决这一看起来很棘手的问题。在这些顶级域下，又有很多**子域**，子域的类型分为两种，即**通用的**和**国家的**。最终演化到树叶，就是**主机**啦。\n\n![image-20210707210048205](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210048205.png)\n\n如果将DNS的命名规则平面化的话，它可以这样表示：\n\n![image-20210707210104057](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210104057.png)\n\n假如我们要访问耶鲁大学AI学院的网站。通俗的方式是首先找到顶级域名，再找到通用域名edu，然后找到edu下的yale,接着发现cs，最后定位到AI。从它宽泛的命名框架来看，域名适用于任何主机，这就意味着**域名不代表地域，它只是一个逻辑的概念**，而非物理上的。\n\n### 2.如何解析转换关系？\n\n解析关系直观地看，可以维护一张映射表，但考虑到性能，我们使用专门的名字服务器来存储这样的一张表，但当主机变多时，**一个服务器容易宕机，且不好维护**。\n\n这时需要演化为分布式的名字服务器，而完成其功能的实际上是**分布式的数据库**。\n\n在**每一个区域Zone**内需要维护一个名字服务器，它存储有这个区域内所有主机Ip与域名的**映射关系**，同时它也应该满足**寻址**的要求，这就需要维护指向路径的指针。因其完备的功能，因此也称其为权威服务器。\n\n那权威服务器是如何维护转换关系的呢？通过数据库中的**资源记录**。\n\n资源记录使用**RR格式**来维护**域名到IP**(或者其他标识)的映射关系。它包含如下字段——\n\n- `Domain_name:`域名，没什么可说的~\n- `Ttl:`生存时间，假如我现在要访问中国以外的一个域名，我所在区域的权威服务器会沿路径获取到这个域名与IP的映射关系，并将其是作为缓存记录下来，但它显然不常用，所以存活时间仅有**两天**。而对于区域内的域名，考虑到作为老大的职责，会**长期缓存**区域内小弟的映射关系。\n- `Class:`只要是因特网范围内的，值都为IN,在物联网时代，NOT IN将成为一种可能。\n- `Value:`可以是数字，域名或者ASCII码。\n- `Type:`资源记录的类型，它包括：\n  - `A`：name为主机，Value为IP地址\n  - `CNMAE`:name为规范名字的别名，value是规范名字。\n  - `NS`:name为域名，value为该域名权威服务器的名字\n  - `MX`:value为name对应的邮件服务器的名字。\n\n#### DNS系统的工作原理\n\n- 应用首先调用解析器，解析器作为客户向名字服务器发出查询报文，该查询报文被封装在UDP段中。\n- 名字服务器返回响应报文。\n\n![image-20210707210144625](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210144625.png)\n\n那名字服务器是如何获取到远端的IP映射关系呢？\n\n这里要分有缓存和没缓存两种情况讨论——\n\n1. `存在缓存`：直接返回\n2. `没有缓存`：\n   1. `递归查询`，即从根服务器开始递，再从目标服务器的权威服务器开始归\n   2. `迭代查询`，即依次遍历每种可能。\n\n### 3.如何维护映射关系？\n\n关系的维护无非增删改查，假如要在上级域的名字服务器中增加一个映射关系，那就往数据库中**添加两条记录**，分别指向**新增的子域的域名**和**域名服务器的地址**。这样在下次访问时会方便很多。但缓存有可能出现**不一致**的问题，因而在某些时候删除也是必要的。\n\n### 报文结构\n\n最后，简单看下DNS协议的报文——\n\n![image-20210707210157098](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210157098.png)\n\n## 1.6 P2P应用\n\n因为我在毕业后所将从事的工作和P2P的体系架构**大抵是没有太多交集**的，所以这一小节的知识点我只**简要描述原理**。\n\n先入为主地说，P2P的产生是为了解决CS体系的缺陷，即**服务器压力大，负载均衡能力弱，可靠性不好**。而相应的，P2P体系在这些方面是要略胜一筹的。\n\nP2P体系常常被应用在**文件分发，流媒体**，在这些应用场景中，peer节点的压力比较轻。\n\n为了形象描述P2P体系，我们来看下面这张图——\n\n![image-20210707210209024](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210209024.png)\n\n这张图描述了两种体系结构随着客户端数量的增加，下载文件所消耗的时间，可以看到，CS体系呈现出线性的关系，而P2P则是类似于对数关系。\n\n如果单纯从下载性能方面来看的话，P2P早就风靡一时了。但因为它难以管理的缺陷，导致了它应用的并不多。\n\n我们来了解通用的P2P的管理模式——\n\n- `非结构化的P2P：`邻居节点间存在互通有无的关系，形成**覆盖网**。典型的应用是**文件共享**，即通过**集中目录**的方式，用户首先键入**关键字**，然后**目录服务器**告诉用户有哪些节点拥有该资源，用户建立**TCP连接**，再去请求某节点的资源。拥有该资源后，将自己拥有该资源的信息**上报目录服务器**，流程结束。\n\n  但集中式的目录，存在**单点故障，性能瓶颈，侵犯版权**的问题。此外，查询时采用**洪泛**的方式有可能导致**请求无限放大**，所以有必要设置**TTL或由节点维护历史信息**避免成环。因此除了集中式的目录以外，还存在**完全分布式**和**混合体**的机制。混合体机制利用节点的**不均匀性**，某个对等点要么是属于一个组或者组长，查询时，上报组长，如果组内有，直接去请求，组内没有的话，则交由组长传递给其他组长。\n\n  那如何找到唯一地那个文件呢，首先通过输入框的**描述信息**找到该文件的**哈希值**，然后将哈希值作为**唯一Id**查询返回结果\n\n  这里还有一个有意思的模式，**BitTorrow**。在这种模式下，文件被分为很多块，每个节点各持一块，且每个节点维护一个位图，即**BitMap**，0标识不拥有此资源，1表示拥有此资源。为了使所有节点都拥有相同的资源，需要**定期洪泛**。\n\n- `结构化的P2P：`节点与节点之间的关系是往往成**网状或者环状**的。在更新节点时始终维护节点间的关系，即根据哈希值更新环。\n\n## 1.7 CDN\n\n在互联网中，视频类的流量占据所有流量的大部分，这也使得**带宽的增加有用武之地**。那视频的流量为什么这么大呢？\n\n视频是**固定速度显示的图片序列**，而图片是由许多**像素点集成**得到的。所以视频就会比较大，编码也会相应复杂一些。\n\n那针对太大的视频，应该做如何的处理呢？这就首先要看网络视频的特点——\n\n- 高码率\n- 可压缩\n\n所以降低视频流量的方式就是**降低码率并做时空上的压缩**，比如我国的AVS编码方式。\n\n我们再从整体的框架看，显然只用一台超级服务器来提供流式服务是不可能的，因为**规模太大**，并且**存在异构性**。因此提供流式服务的**分布式服务器**被广泛应用。\n\n我们在平时观看视频时，有时会发生卡顿，并且提示我们缓存一会再看，如何解释它的原理呢？\n\n`互联网提供给我们的是存储视频的流化服务，它可以实现辺下载辺看，就像河流一般，我们在从缓冲区中取视频内容，实现了高并发的视频传输。`\n\n但不同的用户对于视频的要求不同，这可能受限于带宽，或者是设备。那如何解决这个问题呢？\n\n采用**动态自适应的流化技术DASH**，服务器端并不会有选择性的发送内容，但它会将视频分块，每块有不同的解析度，不同的编码标准，为了为客户端标识不同块的URL，服务器还维护一个**告示文件**用以提供不同块的URL。\n\n客户端首先获取到告示文件，然后**周期性的测试**服务器到客户端的**带宽**，根据带宽来**实时**地请求某一块，最后**解析**观看视频。\n\n假如视频流量出现超高并发，比如春晚直播，如果仅从央视的服务器去请求资源的话，那你将体会到什么叫做超高频延迟。但我们实际观看时，貌似很流畅，这是为什么呢?\n\n因为使用了CDN服务商的加速服务，加速的原理也很简洁，无非部署缓存节点。但如何部署呢？CDN服务商使用的部署策略通常有两种——\n\n- `策略1`：在本地ISP的区域内部署缓存节点，这样离用户最近，但未免投入太高。\n- `策略2`：靠近ISP的数据中心部署，效果也很不错，而且部署的节点相对较少，减少了成本。\n\n我们来看一个小例子来体会下CDN服务是如何被使用的——\n\n![image-20210707210224483](https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210224483.png)\n\n步骤：\n\n1. ICP预先部署资源到CDN节点\n\n2. 用户访问Netflix的注册网站；\n\n3. 重定向到部署在亚马逊云端的网站；\n\n4. 使用域名解析重定向的机制从最近的CDN节点中获取资源；\n\n5. 将动态自适应的资源返回给用户，\n\n------\n\n> 山高路远，静水深流。\n\n\n\n\n\n\n\n","slug":"计算机网络应用层","published":1,"updated":"2023-09-24T09:50:29.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln02j7n7002zxjcc74ic4m06","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>到第二章我们就将进入具体5层协议栈的描述，更具体地说，是从顶层<strong>应用层</strong>开始，渐进地学习计算机网络。我们知道，应用层是在传输层提供的服务上实现应用进程通信的，也就是<strong>借助操作系统使用Socket API的方式</strong>实现的。那基于Socket API应用层都实现了服务呢？常用的有<strong>Web,Http，FTP,Email，DNS，CDN</strong>。在讲述这些具体应用之前，我们会先对<strong>通用的原理</strong>作以介绍。然后展开描述这些应用层的服务。</p>\n<p>好啦，了解了概况，就让我们出发吧。。。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205341750.png\" alt=\"image-20210707205341750\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在开始正式的内容之前，我们有必要先建立有意识的学习习惯。</p>\n<p>为什么要学习应用层呢？应用层或者更具体的说是应用程序，<strong>应用程序是互联网存在的理由</strong>，在其以下的四层，它们的确实现了很多功能，但这些功能如果不能被集成应用到一个应用程序上，那分层的结构就只是纸上谈兵罢了。</p>\n<p>应用层也是与我们<strong>日常生活最贴近</strong>的一层，我们与电脑上可以实现<strong>人机交互</strong>的绝大部分应用都是应用层的应用。</p>\n<p>好啦，说了这么多，无非想表达一个观点，应用层很重要。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <code>我们将从应用层协议原理起笔，浓墨重彩的描述Web,Http,Ftp,Email,DNS,这几个应用层协议，落笔于P2P应用与CDN。</code></li>\n</ul>\n<h2 id=\"1-1-应用层协议原理\"><a href=\"#1-1-应用层协议原理\" class=\"headerlink\" title=\"1.1 应用层协议原理\"></a>1.1 应用层协议原理</h2><p>任何复杂的系统实现都是从一个小的灵感异或想法开始的。</p>\n<p>假如我们想做一个交易旧书的网站，并且让它实际的运营，那我们应该从哪里点亮这个火光呢？</p>\n<blockquote>\n<p>研发网络应用程序的<strong>核心是写出能够运行在不同的端系统和通过网络彼此通信的程序</strong>。</p>\n</blockquote>\n<p>也就是说我们重点关注如何用程序实现端系统间通信，而程序的书写首先必须是基于框架的，互联网应用的体系结构分为两种：CS架构和P2P架构。</p>\n<h3 id=\"CS服务体系\"><a href=\"#CS服务体系\" class=\"headerlink\" title=\"CS服务体系\"></a>CS服务体系</h3><p>CS服务体系指的是服务器和客户端组成的架构。</p>\n<p><code>服务器</code> ：服务器是<strong>一直运行着</strong>的，通过<strong>固定IP与端口号</strong>来访问的，<strong>可扩展性较差</strong>的终端设备；</p>\n<p><code>客户端</code>：客户端在网络中以<strong>动态IP</strong>的方式标识，并<strong>主动与服务器建立通信</strong>。</p>\n<h3 id=\"P2P服务体系\"><a href=\"#P2P服务体系\" class=\"headerlink\" title=\"P2P服务体系\"></a>P2P服务体系</h3><p>在P2P体系结构中，任何端系统既可以是客户端，也可以是服务器，这也使得它们的<strong>可扩展性强</strong>，又因为没有限制，所以<strong>任意两台端设备之间可以进行通信</strong>。但这也导致<strong>难以有效的管理</strong>体系中的端系统，在现实中的应用场景包括<strong>迅雷，Gnutella</strong>。</p>\n<hr>\n<p>我们发现，P2P的负载均衡能力强，而CS架构更容易维护，那可不可以取其所长，来做一种CS与P2P体系结构的混合体呢？</p>\n<p>别说，还真有人实现了。一个大学生做了一个名为<strong>Napster</strong>的应用。这个应用是用来提供<strong>文件传输</strong>的。一个用户想查询该系统中是否存在某个文件，首先她的主机向<strong>中心服务器</strong>查询资源的位置，要实现这个功能就需要使用<strong>CS体系</strong>，即每台主机上线以后，会<strong>在中心服务器上注册它所拥有的的资源</strong>。查询到存在这个资源后，中心服务器会返回给主机<strong>这个资源所在的主机位置</strong>，最后使用<strong>P2P体系</strong>完成<strong>两个节点间的文件传输</strong>即可。</p>\n<hr>\n<h3 id=\"分布式进程通信\"><a href=\"#分布式进程通信\" class=\"headerlink\" title=\"分布式进程通信\"></a>分布式进程通信</h3><p>再回到核心问题，在确定使用哪种体系的前提下，我们还需要解决通信的问题。而<strong>通信的实体是进程</strong>，也就是要解决<strong>分布式进程间通信</strong>的问题。但这个问题是宽泛的，我们不妨分而治之——</p>\n<ol>\n<li><strong>如何标识一个进程，怎样来寻址一个进程。</strong></li>\n<li><strong>传输层是如何为应用层提供服务的？</strong></li>\n<li><strong>如何使用传输层提供的服务来实现进程之间的报文交换。</strong></li>\n</ol>\n<p>换个角度来思考这三个问题，就是怎样找到要服务的用户，这个服务怎样提供给用户，用户怎样使用这个服务。带着这三个问题，我们出发吧——</p>\n<h4 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h4><p>我们通常使用<strong>32位的IP地址来唯一的标识一台主机</strong>，在主机之上，用<strong>端口号来标识特定的进程</strong>。比如HTTP,<strong>TCP的默认端口号就为80</strong>.进程可以使用TCP或者UDP的传输层协议进行通信。</p>\n<h4 id=\"问题二\"><a href=\"#问题二\" class=\"headerlink\" title=\"问题二\"></a>问题二</h4><p>前面提到，传输层通过接口向应用层提供服务。这个接口需要携带一些通信必须的信息，这种信息至少应该包含：要传输的报文，这个报文要传给谁，这个报文是从哪里传输来的。</p>\n<p>官方地说，我们需要知道<code>SDU,IP+TCP(UDP)端口，对方的IP+TCP(UDP)端口。</code></p>\n<p>但每次通过接口通信使单独传输这些信息实在有点繁琐。所以，将这些信息封装变得很有必要。</p>\n<p><code>应用进程通过一个称为套接字的软件接口向网络中发送报文和接收报文。</code>所谓套接字，也就是Socket .那如何来理解这个socket呢？</p>\n<p>我们先从它的作用入手<strong>，socket是用于指明应用进程会话的本地标识</strong>，我们可以打个比方来形象地理解——</p>\n<blockquote>\n<p>进程可类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接收进程对该报文进行处理。</p>\n</blockquote>\n<p>再从它的含义来看，socket是操作系统生成的一个整数，这个整数可以理解为<strong>传输信息的引用</strong>。这些信息具体的说，即是包含源IP，源port，目标IP，目标port的四元组。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205357679.png\" alt=\"image-20210707205357679\"></p>\n<p>我们不必关注四元组的信息，而只需要关注<strong>socket的状态</strong>即可。操作系统的文件系统同样应用了这样的思想，在打开一个文件时，<strong>OS返回一个文件句柄</strong>，而不是使用这个文件的目录名，文件名，这样使用简单且易管理。</p>\n<p>值得一提的是，四元组是针对TCP的socket信息，但对于使用UDP的服务来说，情况又有所不同。</p>\n<p>使用UDP提供的服务时，两个进程之间的通信不需要建立连接，即<strong>不面向连接</strong>，每个报文都是独立传输的，它的前后报文也可能被送到<strong>不同的分布式进程</strong>，也就是说，对于UDP的socket，即只需指明报文将发往何处，而不必关心报文来自哪里。所以<strong>Socket中封装对方的IP及端口</strong>即可，</p>\n<h3 id=\"问题三\"><a href=\"#问题三\" class=\"headerlink\" title=\"问题三\"></a>问题三</h3><p>问题三需要回答的是怎样约定传输的格式，动作。这就需要定义<strong>应用层的协议</strong>，那这个协议的遵守是如何体现的呢？通过<strong>编制程序</strong>，使用<strong>API</strong>来调用网络基础设施来提供通信服务传报文，解析报文，实现应用时序等。</p>\n<p>应用层的协议是如何定义的呢？它需要解决的具体包含哪些问题？</p>\n<ul>\n<li><p><code>应用层的协议定义了运行在不同端系统上的应用进程如何相互交换报文</code>。</p>\n</li>\n<li><p><code>它需要包含报文的类型，报文类型对应的语法，报文中字段的语义，报文所导致的动作。</code></p>\n</li>\n</ul>\n<h2 id=\"1-2-Web与http\"><a href=\"#1-2-Web与http\" class=\"headerlink\" title=\"1.2 Web与http\"></a>1.2 Web与http</h2><p>我们在学习工作时总会无可避免地访问web页面了，一个键盘，一声敲击，一个奇迹。这奇迹的背后似乎<code>有迹可循</code>——</p>\n<p>在我们浏览的网页中，包含图文，动画，视频等，为了更好地描述这些事物，它们有了通用的名字：<strong>对象</strong>。对象可以认为是<strong>HTML页面的最小组成单元</strong>。直观地看，在我们浏览一个页面时，不同的对象并非同时出现，显然它们有可能来自不同的目的地，那如何来<strong>标识由对象组成的HTML页面</strong>呢？</p>\n<p>这就需要<strong>URL</strong>(统一资源定位符)，URL表示资源的<strong>地点</strong>，即资源来自于互联网中哪个IP。如果只使用URL标识资源位置，未免有点宽泛。所以引入<strong>URI</strong>(统一资源标识符)就势在必行了。</p>\n<p>URI用字符串标识资源的<strong>位置</strong>。则URL是URI的子集，具体看下符合<strong>RFC标准</strong>的URI格式——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205411737.png\" alt=\"image-20210707205411737\"></p>\n<ul>\n<li><code>协议方案名：</code>更多被使用的是http，但使用<strong>SSL安全传输层</strong>服务的<strong>https</strong>必然将取代http.</li>\n<li><code>登录信息：</code>即用户认证，默认是匿名访问。</li>\n<li><code>服务器地址：</code>即服务器的域名。</li>\n<li><code>服务器端口号：</code> 这里的80端口指的就是TCP服务。</li>\n<li><code>文件路径：</code> 不能再具体的描述了。</li>\n<li><code>查询字符串：</code> 即参数，比如点开某件商品的详情页时需要附带该商品的ID与该客户的ID。</li>\n<li><code>片段标识符：</code> 无题。</li>\n</ul>\n<p>了解了页面的组成，以及资源如何标识，我们再来看下页面是如何展示给用户的——</p>\n<ol>\n<li>浏览器通过HTML表单或超链接请求指向一个<code>应用程序的URL</code>。</li>\n<li>服务器收发到用户的请求。</li>\n<li>服务器执行已接受创建的指定应用程序。</li>\n<li>应用程序通常是基于用户输入的内容，执行所需要的操作。</li>\n<li>应用程序把结果格式化为网络服务器和浏览器能够理解的文档，即我们所说的<code>HTML网页</code>。</li>\n<li>网络服务器最后将结果返回到浏览器中。</li>\n<li>浏览器使用解释器解析页面。</li>\n</ol>\n<p>这么多的步骤，想来应该会比较耗时，这也是起初web被戏称<strong>World wide wait</strong>的原因，如今网络节点的增加与带宽的提高让网页的传输有了一丝飞一般的感觉~</p>\n<h3 id=\"HTTP协议的引入\"><a href=\"#HTTP协议的引入\" class=\"headerlink\" title=\"HTTP协议的引入\"></a>HTTP协议的引入</h3><p>我们知道应用层的应用程序都需要遵循规范，那web应用程序需要遵循什么规范呢？</p>\n<p>自然是HTTP协议咯，HTTP协议全称是<strong>超文本传输协议</strong>。它的出现主要是为了解决<strong>文本传输</strong>的问题。一路走来经历了<strong>HTTP1.0,HTTP1.1,HTTP2.0</strong>.可见版本更迭异常缓慢。但这并不意味着HTTP不受人青睐。相反，由于它本身非常简单。开发者在它的基础上开发出了很多应用方法并投入使用，现在<strong>HTTP协议已经超出Web框架的局限</strong>，被用于各种各样的场景中。可见，简单也意味着丰富的可扩展性。</p>\n<h3 id=\"网络基础TCP-IP\"><a href=\"#网络基础TCP-IP\" class=\"headerlink\" title=\"网络基础TCP/IP\"></a>网络基础TCP/IP</h3><p>为了更好地理解HTTP，我们有必要先了解一下TCP/IP。</p>\n<p>我们所用的网络都是在TCP/IP协议族的基础上运行的，它约定了<strong>端系统间相互通信的规则</strong>。因为后面的小结会涉及到具体的TCP/IP协议族，这里我们只给出一个框架——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205429415.png\" alt=\"image-20210707205429415\"></p>\n<p>在TCP/IP协议族提供的网络基础上，HTTP按部就班地传输着报文。接下来我们将剥茧抽丝地<strong>解析报文传输</strong>的过程：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205540218.png\" alt=\"image-20210707205540218\"></p>\n<p>在这张图中，可以看到HTTP协议的职责在于<strong>生成目标Web服务器的请求报文，及对Web服务器请求内容的处理</strong>。</p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>HTTP报文都是以<strong>ASCII码</strong>的形式与人交互，请求报文和响应报文的格式是这样的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205553641.png\" alt=\"image-20210707205553641\"></p>\n<h3 id=\"HTTP请求报文\"><a href=\"#HTTP请求报文\" class=\"headerlink\" title=\"HTTP请求报文\"></a>HTTP请求报文</h3><p>这里给出一个请求报文的例子，我们来剖析它的每一个字段——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205631561.png\" alt=\"image-20210707205631561\"></p>\n<p>请求行中包括请求的方法，使用的协议及版本。</p>\n<ul>\n<li><code>Host:</code>请求资源所在的服务器，比如WWW.Baidu.com</li>\n<li><code>User-Agent:</code>HTTP客户端程序的信息</li>\n<li><code>Accept:</code>用户代理可以处理的<strong>媒体类型</strong>。</li>\n<li><code>Accept-Language:</code>优先的语言。</li>\n<li><code>Accept-Encoding:</code>优先的内容编码。</li>\n<li><code>DNT:</code>请求追踪字段，即<strong>用户不希望被追踪</strong>。</li>\n<li><code>Connection:</code>主要有两个用途：<strong>控制不再转发给代理的首部字段</strong>和<strong>持久连接</strong>的状态管理</li>\n<li><code>Pragma:</code>报文的<strong>指令</strong>。</li>\n<li><code>Cache-Control:</code>控制<strong>浏览器端缓存</strong>的行为</li>\n</ul>\n<p>其他的首部还有很多，我们就不一一列举了。</p>\n<h3 id=\"HTTP响应报文\"><a href=\"#HTTP响应报文\" class=\"headerlink\" title=\"HTTP响应报文\"></a>HTTP响应报文</h3><p>同样的，通过一个小例子我们简要认识一下HTTP响应报文——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205648733.png\" alt=\"image-20210707205648733\"></p>\n<p>首先是状态行，它的信息包括协议类型，版本，状态码，状态码对应的解释。</p>\n<p>再来看字段的解析：</p>\n<ul>\n<li><code>Date:</code>服务器端<strong>创建报文的日期时间</strong>，必选项。</li>\n<li><code>Server:</code>用于告知客户端当前<strong>服务器上安装的HTTP服务器应用程序</strong>的信息。</li>\n<li><code>Last-Modified:</code>资源<strong>最终修改的时间</strong>。</li>\n<li><code>ETag:</code>资源的匹配信息，只有当If-Match的字段值与ETag值<strong>匹配时，服务器才会接收请求</strong>。</li>\n<li><code>Accept-Ranges:</code>是否接收<strong>字节范围请求</strong>，当我们只需要一部分数据时，可以加这个参数来减少网络链路的带宽压力。</li>\n<li><code>Content-Length:</code>实体主体的长度，它的<strong>单位是字节</strong>，TCP提供的是字节流的服务，他不会维护信息的边界，所以需要一些辅助信息。</li>\n<li><code>Connection:</code>连接的状态，可选Keep-alive和Close</li>\n<li><code>Connect-Type:</code> 实体类型</li>\n</ul>\n<p>我们再从层间接口的角度来看Web是如何工作的。。。</p>\n<h3 id=\"Web的层间接口Socket\"><a href=\"#Web的层间接口Socket\" class=\"headerlink\" title=\"Web的层间接口Socket\"></a>Web的层间接口Socket</h3><p>HTTP协议使用是<strong>基于TCP的传输层服务</strong>，则服务器的<strong>80号端口</strong>会始终处于等待状态，客户端发起请求后，服务器端的<strong>守护socket</strong>在接收到请求以后，会生成一个该请求<strong>独有的socket</strong>，这个socket表示服务器端与特定客户端的<strong>会话关系</strong>。</p>\n<h3 id=\"无状态协议\"><a href=\"#无状态协议\" class=\"headerlink\" title=\"无状态协议\"></a>无状态协议</h3><p>HTTP协议是一个<strong>无状态</strong>的协议，它不会维护历史信息，这使得它能够<strong>支持的用户数量多</strong>，但比如说在登录网页以后，维护登录状态又是必不可少的。</p>\n<p>那如何使它可以记录状态呢？对HTTP协议本身做文章未免<strong>不是开发者的初衷</strong>，所以由<strong>客户端</strong>来维护历史信息，由于要维护的历史信息比较多，这里与用户交互的不是信息本身，而是指向这些信息的引用，小甜饼<strong>Cookie</strong>就这样应运而生了。</p>\n<p>我们通过下图来认识一下Cookie机制——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205705315.png\" alt=\"image-20210707205705315\"></p>\n<h3 id=\"持久连接\"><a href=\"#持久连接\" class=\"headerlink\" title=\"持久连接\"></a>持久连接</h3><p>HTTP1.0协议是不支持持久连接的，也就是每次发送报文时，都需要建立TCP连接——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205856780.png\" alt=\"image-20210707205856780\"></p>\n<p>这样每次请求时都会造成<strong>无谓的TCP连接和断开</strong>，增加通信量的消耗。</p>\n<p>因此在HTTP1.1中引入了持久连接，持久连接是指如果<strong>没有一方明确要求断开连接时，这个连接会一直保存</strong>。也就是说，持久连接是<code>双方端系统需要设置的</code>，而不是在通信过程中设定。</p>\n<p>持久连接使多数请求以<strong>管线化方式</strong>发送称为可能。这就可以实现<strong>高并发发送</strong>。类似于<strong>流水线</strong>。</p>\n<h3 id=\"HTTP首部字段的应用\"><a href=\"#HTTP首部字段的应用\" class=\"headerlink\" title=\"HTTP首部字段的应用\"></a>HTTP首部字段的应用</h3><p>我们通过<strong>搜索引擎</strong>来获取想要的web页面，那搜索引擎是如何找到web页面的呢？它会通过网络<strong>爬虫</strong>爬取到HTTP的<strong>首部字段</strong>，使用首部字段中的关键信息来建立<strong>索引</strong>，实现高效查找。</p>\n<h3 id=\"HTTP请求行与状态行浅析\"><a href=\"#HTTP请求行与状态行浅析\" class=\"headerlink\" title=\"HTTP请求行与状态行浅析\"></a>HTTP请求行与状态行浅析</h3><ul>\n<li><code>请求行：</code>这里我们主要描述用于告知服务器意图的方法：<ul>\n<li>如get用于请求访问已被URI识别的资源；</li>\n<li>POST方法用来传输实体的主体；</li>\n<li>PUT用于传输文件;</li>\n<li>HEAD用于请求报文首部</li>\n</ul>\n</li>\n<li><code>状态行：</code><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205842449.png\" alt=\"image-20210707205842449\"></li>\n<li></li>\n</ul>\n<h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><p>假设有这样一种需求，客户请求服务器资源时因为链路太长导致响应时间慢，老板要求你解决这个问题，这时根据你的经验有两种处理方式——</p>\n<ol>\n<li><strong>增加链路带宽</strong>，可行，但你被辞退了，因为解决方式太土豪；</li>\n<li><strong>在局域网内部增加缓存节点</strong>。也就是Web代理，购置一台服务器就好了，还可以通过增加缓存的命中率来<strong>减轻服务器的负载，降低网络的通信量</strong>，爽歪歪。老板直呼内行。</li>\n</ol>\n<p>缓存应该是学习的一大热点了，但凡缓存，就需要注意缓存一致性问题。首先我们要能发现缓存是否一致，也就是<strong>通过加时间字段</strong>。如果字段值超时了，Web代理就丢弃缓存内容。</p>\n<hr>\n<h3 id=\"加餐——HTTPS\"><a href=\"#加餐——HTTPS\" class=\"headerlink\" title=\"加餐——HTTPS\"></a>加餐——HTTPS</h3><p>先来看张图，可以看到在URL的前面有一个<strong>锁的标识</strong>，而我们所熟识的HTTP是不加密的，所以呢，这里的锁实际上标识使用的协议是HTTPS，我们的故事也将从这张图开始啦。。。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408101342730.png\" alt=\"image-20210408101342730\"></p>\n<p>我们知道，HTTP最大的特点与优点就是<strong>简单易用</strong>，但简单也必然带来一些问题：</p>\n<ul>\n<li><p><code>明文传输</code>：由于HTTP本身不具备加密的功能，自然就不可能对通信整体(即通信请求与通信内容)进行加密，而不加密的HTTP有被窃听的风险，如果我们使用<strong>wireShark抓包工具</strong>，就会收获满满——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408102109238.png\" alt=\"image-20210408102109238\"></p>\n<p>这可不怎么靠谱，那怎样实现加密呢？考虑到发生数据泄露的位置可能是<strong>通信源或者通信链路</strong>，我们可以对症下药，对<strong>通信链路</strong>进行加密，这就引出了<strong>SSL安全套接字层/TLS安全层传输协议</strong>。当然对通信内容本身加密也是一种可行的idea,这里我们先着重介绍SSL。</p>\n<p>SSL采用一种叫做公开密钥加密的加密处理方式，我们常说的使用密钥加密，指的是客户端使用密钥加密，服务器端使用同一密钥解密，但这样显然面临一种困境：如果有第三方得到密钥，那就可以为所欲为。这里可以尝试客户端使用公开密钥加密，而服务器端使用私有秘钥解密的策略。</p>\n<p>两种策略各有千秋，那到底使用哪一种呢？</p>\n<p>HTTPS表示我全都要，HTTPS使用混合加密机制，在<strong>交换密钥环节使用公开密钥加密方式</strong>，之后的<strong>建立通信交换报文使用共享密钥加密方式</strong>。</p>\n</li>\n<li><p><code>身份验证</code>：HTTP协议中的请求与响应不会对同新方进行确认，也就是说任何人都可以发起请求，如果发起多次<strong>恶意请求，网站负载就会增大</strong>，显然需要机制来确认通信方的身份。</p>\n<p>SSL不仅提供加密处理，还使用了称之为<strong>证书</strong>的手段来身份认证，证书由靠谱的第三方机构颁发。</p>\n</li>\n<li><p><code>报文完整性</code>：在通信过程中，如果请求或者响应的内容遭到中间人的篡改，就会事与愿违，那如何来防止篡改呢？显然需要一种指代内容的唯一标识，<strong>MD5和SHA</strong>就是常用的方法，</p>\n</li>\n</ul>\n<p>现在，我们可以给出HTTPS的明确定义了：</p>\n<blockquote>\n<p>HTTPS = HTTP + 加密 + 认证 +完整性保护</p>\n</blockquote>\n<h2 id=\"1-3-FTP-amp-Email\"><a href=\"#1-3-FTP-amp-Email\" class=\"headerlink\" title=\"1.3 FTP&amp;Email\"></a>1.3 FTP&amp;Email</h2><p>在开发应用时，FTP的身影并不多，唯一一次见证它的背影是在使用<strong>Maven找包</strong>的时候，给我的直观感觉就是，这不就是<strong>文件系统</strong>嘛~</p>\n<p>鉴于它太古老了，我们只是简要描述一下它工作的流程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205929522.png\" alt=\"image-20210707205929522\"></p>\n<ol>\n<li>FTP的服务器始终守护在21号端口处等待连接，FTP的客户端发起连接请求，<strong>基于TCP的控制连接</strong>建立。</li>\n<li><strong>用户身份认证</strong>，认证后访问文件目录，也因此需要维护历史信息，即<strong>FTP是有状态的协议</strong>，值得一提的是，身份认证是使用<strong>明文传输</strong>，着实不可靠。</li>\n<li>服务器<strong>主动</strong>与客户端的20号端口建立<strong>数据连接</strong>，客户端下载数据，完结。</li>\n</ol>\n<hr>\n<p>这是一个么得感情的分割线~</p>\n<p>Email不同于FTP，它在工作交流，面试简历提交等方面<strong>应用非常广泛</strong>。Email由三部分构成：<strong>用户代理</strong>，也就是客户端软件，<strong>邮件服务器</strong>，<strong>协议</strong>。</p>\n<p>我们同样复现EMail的工作流程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205938954.png\" alt=\"image-20210707205938954\"></p>\n<ol>\n<li>首先用户在用户代理中写好邮件，用户代理通过<strong>STMP协议</strong>将邮件传输到<strong>用户邮箱服务器的队列</strong>中。</li>\n<li>邮箱服务器再将邮件从队列中提取出来，使用SMTP协议将邮件发送到目标服务器。</li>\n<li>目标服务器将邮件存储在<strong>目标用户的邮箱目录</strong>中。</li>\n<li>目标用户通过<strong>POP3协议</strong>从邮箱中拉取邮件阅读。</li>\n</ol>\n<p>Email使用<strong>7位的ASCII码</strong>编码，而中文需要两个字节描述，如果使用7位ASCII码传输时就会乱码。为了防止乱码，使用<strong>MIME多媒体扩展协议</strong>，这是基于<strong>Base64</strong>的编码，即<strong>将ASCII码序列化</strong>再传输。</p>\n<p>而使用POP3的拉取协议，显然不应该记录邮件都经由谁手，在什么时间写好这种敏感信息，所以它被设计为<strong>无状态协议</strong>。</p>\n<h2 id=\"1-5-DNS\"><a href=\"#1-5-DNS\" class=\"headerlink\" title=\"1.5 DNS\"></a>1.5 DNS</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>DNS不同于其他应用层协议，它是用来<strong>为其他应用协议提供服务</strong>的协议，DNS为人所知的功能是<strong>完成域名到IP地址的转换</strong>，且非常<strong>健壮</strong>。而这个转化实质上是由<strong>DNS系统</strong>来完成的。</p>\n<p>系统的设计是为了解决复杂问题，而DNS系统解决的核心问题就是如何完成域名到IP地址的转换，我们再将这个问题拆解为三个小问题——</p>\n<h3 id=\"1-如何命名一台设备？\"><a href=\"#1-如何命名一台设备？\" class=\"headerlink\" title=\"1.如何命名一台设备？\"></a>1.如何命名一台设备？</h3><p>如果我们想访问一个网站，那就需要在地址输入栏中输入网站的URI，而URI中显然需要<strong>包含易记的用来标识端系统位置</strong>的东西，这就是<strong>域名</strong>，域名是一个端系统的<strong>别名</strong>，易于记忆，显然<a href=\"http://www.baidu.com比起纯数字的方式交互起来友好地多./\">www.baidu.com比起纯数字的方式交互起来友好地多。</a></p>\n<p>既然有别名，那就一定有正规名称，也就是IP地址.IP地址被用来表示一台主机，同时也用于寻址。IP地址分为IPV4和IPV6两种。IPV4使用点分十进制的书写习惯，共有32位，IPV6则有128位，可标识的主机数量非常多。</p>\n<p>显然，日常使用时域名显然是更好的选择，域名在初期使用没有分层的结构，因为主机数量少，不会出现重名，只需要维护一张映射表就行了，维护起来游刃有余。</p>\n<p>但当主机数指数级增多以后，重名变得不可避免，<strong>分层式的命名</strong>开始大势所趋。这时只维护一张表也显然不够了，<strong>分布式数据库</strong>被引入。而既然是应用层协议，自然会使用到传输层的服务，DNS使用的就是相对简单的<strong>UDP协议</strong>，可见网络核心的功能其实是在网络边沿实现的，网络核心只要保证传输就ok了。</p>\n<p>再说回<strong>层次树状化</strong>的命名，首先从根开始，也就是顶级域名，顶级域名对应的是顶级服务器，全世界只有13台顶级，即<strong>根服务器</strong>。而且<strong>中国并没有</strong>，有人担忧万一根服务器被黑了，网络安全是否变的不可靠了。但实际上这对网络安全并没有什么大的影响。分布式足以解决这一看起来很棘手的问题。在这些顶级域下，又有很多<strong>子域</strong>，子域的类型分为两种，即<strong>通用的</strong>和<strong>国家的</strong>。最终演化到树叶，就是<strong>主机</strong>啦。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210048205.png\" alt=\"image-20210707210048205\"></p>\n<p>如果将DNS的命名规则平面化的话，它可以这样表示：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210104057.png\" alt=\"image-20210707210104057\"></p>\n<p>假如我们要访问耶鲁大学AI学院的网站。通俗的方式是首先找到顶级域名，再找到通用域名edu，然后找到edu下的yale,接着发现cs，最后定位到AI。从它宽泛的命名框架来看，域名适用于任何主机，这就意味着<strong>域名不代表地域，它只是一个逻辑的概念</strong>，而非物理上的。</p>\n<h3 id=\"2-如何解析转换关系？\"><a href=\"#2-如何解析转换关系？\" class=\"headerlink\" title=\"2.如何解析转换关系？\"></a>2.如何解析转换关系？</h3><p>解析关系直观地看，可以维护一张映射表，但考虑到性能，我们使用专门的名字服务器来存储这样的一张表，但当主机变多时，<strong>一个服务器容易宕机，且不好维护</strong>。</p>\n<p>这时需要演化为分布式的名字服务器，而完成其功能的实际上是<strong>分布式的数据库</strong>。</p>\n<p>在<strong>每一个区域Zone</strong>内需要维护一个名字服务器，它存储有这个区域内所有主机Ip与域名的<strong>映射关系</strong>，同时它也应该满足<strong>寻址</strong>的要求，这就需要维护指向路径的指针。因其完备的功能，因此也称其为权威服务器。</p>\n<p>那权威服务器是如何维护转换关系的呢？通过数据库中的<strong>资源记录</strong>。</p>\n<p>资源记录使用<strong>RR格式</strong>来维护<strong>域名到IP</strong>(或者其他标识)的映射关系。它包含如下字段——</p>\n<ul>\n<li><code>Domain_name:</code>域名，没什么可说的~</li>\n<li><code>Ttl:</code>生存时间，假如我现在要访问中国以外的一个域名，我所在区域的权威服务器会沿路径获取到这个域名与IP的映射关系，并将其是作为缓存记录下来，但它显然不常用，所以存活时间仅有<strong>两天</strong>。而对于区域内的域名，考虑到作为老大的职责，会<strong>长期缓存</strong>区域内小弟的映射关系。</li>\n<li><code>Class:</code>只要是因特网范围内的，值都为IN,在物联网时代，NOT IN将成为一种可能。</li>\n<li><code>Value:</code>可以是数字，域名或者ASCII码。</li>\n<li><code>Type:</code>资源记录的类型，它包括：<ul>\n<li><code>A</code>：name为主机，Value为IP地址</li>\n<li><code>CNMAE</code>:name为规范名字的别名，value是规范名字。</li>\n<li><code>NS</code>:name为域名，value为该域名权威服务器的名字</li>\n<li><code>MX</code>:value为name对应的邮件服务器的名字。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"DNS系统的工作原理\"><a href=\"#DNS系统的工作原理\" class=\"headerlink\" title=\"DNS系统的工作原理\"></a>DNS系统的工作原理</h4><ul>\n<li>应用首先调用解析器，解析器作为客户向名字服务器发出查询报文，该查询报文被封装在UDP段中。</li>\n<li>名字服务器返回响应报文。</li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210144625.png\" alt=\"image-20210707210144625\"></p>\n<p>那名字服务器是如何获取到远端的IP映射关系呢？</p>\n<p>这里要分有缓存和没缓存两种情况讨论——</p>\n<ol>\n<li><code>存在缓存</code>：直接返回</li>\n<li><code>没有缓存</code>：<ol>\n<li><code>递归查询</code>，即从根服务器开始递，再从目标服务器的权威服务器开始归</li>\n<li><code>迭代查询</code>，即依次遍历每种可能。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-如何维护映射关系？\"><a href=\"#3-如何维护映射关系？\" class=\"headerlink\" title=\"3.如何维护映射关系？\"></a>3.如何维护映射关系？</h3><p>关系的维护无非增删改查，假如要在上级域的名字服务器中增加一个映射关系，那就往数据库中<strong>添加两条记录</strong>，分别指向<strong>新增的子域的域名</strong>和<strong>域名服务器的地址</strong>。这样在下次访问时会方便很多。但缓存有可能出现<strong>不一致</strong>的问题，因而在某些时候删除也是必要的。</p>\n<h3 id=\"报文结构\"><a href=\"#报文结构\" class=\"headerlink\" title=\"报文结构\"></a>报文结构</h3><p>最后，简单看下DNS协议的报文——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210157098.png\" alt=\"image-20210707210157098\"></p>\n<h2 id=\"1-6-P2P应用\"><a href=\"#1-6-P2P应用\" class=\"headerlink\" title=\"1.6 P2P应用\"></a>1.6 P2P应用</h2><p>因为我在毕业后所将从事的工作和P2P的体系架构<strong>大抵是没有太多交集</strong>的，所以这一小节的知识点我只<strong>简要描述原理</strong>。</p>\n<p>先入为主地说，P2P的产生是为了解决CS体系的缺陷，即<strong>服务器压力大，负载均衡能力弱，可靠性不好</strong>。而相应的，P2P体系在这些方面是要略胜一筹的。</p>\n<p>P2P体系常常被应用在<strong>文件分发，流媒体</strong>，在这些应用场景中，peer节点的压力比较轻。</p>\n<p>为了形象描述P2P体系，我们来看下面这张图——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210209024.png\" alt=\"image-20210707210209024\"></p>\n<p>这张图描述了两种体系结构随着客户端数量的增加，下载文件所消耗的时间，可以看到，CS体系呈现出线性的关系，而P2P则是类似于对数关系。</p>\n<p>如果单纯从下载性能方面来看的话，P2P早就风靡一时了。但因为它难以管理的缺陷，导致了它应用的并不多。</p>\n<p>我们来了解通用的P2P的管理模式——</p>\n<ul>\n<li><p><code>非结构化的P2P：</code>邻居节点间存在互通有无的关系，形成<strong>覆盖网</strong>。典型的应用是<strong>文件共享</strong>，即通过<strong>集中目录</strong>的方式，用户首先键入<strong>关键字</strong>，然后<strong>目录服务器</strong>告诉用户有哪些节点拥有该资源，用户建立<strong>TCP连接</strong>，再去请求某节点的资源。拥有该资源后，将自己拥有该资源的信息<strong>上报目录服务器</strong>，流程结束。</p>\n<p>但集中式的目录，存在<strong>单点故障，性能瓶颈，侵犯版权</strong>的问题。此外，查询时采用<strong>洪泛</strong>的方式有可能导致<strong>请求无限放大</strong>，所以有必要设置<strong>TTL或由节点维护历史信息</strong>避免成环。因此除了集中式的目录以外，还存在<strong>完全分布式</strong>和<strong>混合体</strong>的机制。混合体机制利用节点的<strong>不均匀性</strong>，某个对等点要么是属于一个组或者组长，查询时，上报组长，如果组内有，直接去请求，组内没有的话，则交由组长传递给其他组长。</p>\n<p>那如何找到唯一地那个文件呢，首先通过输入框的<strong>描述信息</strong>找到该文件的<strong>哈希值</strong>，然后将哈希值作为<strong>唯一Id</strong>查询返回结果</p>\n<p>这里还有一个有意思的模式，<strong>BitTorrow</strong>。在这种模式下，文件被分为很多块，每个节点各持一块，且每个节点维护一个位图，即<strong>BitMap</strong>，0标识不拥有此资源，1表示拥有此资源。为了使所有节点都拥有相同的资源，需要<strong>定期洪泛</strong>。</p>\n</li>\n<li><p><code>结构化的P2P：</code>节点与节点之间的关系是往往成<strong>网状或者环状</strong>的。在更新节点时始终维护节点间的关系，即根据哈希值更新环。</p>\n</li>\n</ul>\n<h2 id=\"1-7-CDN\"><a href=\"#1-7-CDN\" class=\"headerlink\" title=\"1.7 CDN\"></a>1.7 CDN</h2><p>在互联网中，视频类的流量占据所有流量的大部分，这也使得<strong>带宽的增加有用武之地</strong>。那视频的流量为什么这么大呢？</p>\n<p>视频是<strong>固定速度显示的图片序列</strong>，而图片是由许多<strong>像素点集成</strong>得到的。所以视频就会比较大，编码也会相应复杂一些。</p>\n<p>那针对太大的视频，应该做如何的处理呢？这就首先要看网络视频的特点——</p>\n<ul>\n<li>高码率</li>\n<li>可压缩</li>\n</ul>\n<p>所以降低视频流量的方式就是<strong>降低码率并做时空上的压缩</strong>，比如我国的AVS编码方式。</p>\n<p>我们再从整体的框架看，显然只用一台超级服务器来提供流式服务是不可能的，因为<strong>规模太大</strong>，并且<strong>存在异构性</strong>。因此提供流式服务的<strong>分布式服务器</strong>被广泛应用。</p>\n<p>我们在平时观看视频时，有时会发生卡顿，并且提示我们缓存一会再看，如何解释它的原理呢？</p>\n<p><code>互联网提供给我们的是存储视频的流化服务，它可以实现辺下载辺看，就像河流一般，我们在从缓冲区中取视频内容，实现了高并发的视频传输。</code></p>\n<p>但不同的用户对于视频的要求不同，这可能受限于带宽，或者是设备。那如何解决这个问题呢？</p>\n<p>采用<strong>动态自适应的流化技术DASH</strong>，服务器端并不会有选择性的发送内容，但它会将视频分块，每块有不同的解析度，不同的编码标准，为了为客户端标识不同块的URL，服务器还维护一个<strong>告示文件</strong>用以提供不同块的URL。</p>\n<p>客户端首先获取到告示文件，然后<strong>周期性的测试</strong>服务器到客户端的<strong>带宽</strong>，根据带宽来<strong>实时</strong>地请求某一块，最后<strong>解析</strong>观看视频。</p>\n<p>假如视频流量出现超高并发，比如春晚直播，如果仅从央视的服务器去请求资源的话，那你将体会到什么叫做超高频延迟。但我们实际观看时，貌似很流畅，这是为什么呢?</p>\n<p>因为使用了CDN服务商的加速服务，加速的原理也很简洁，无非部署缓存节点。但如何部署呢？CDN服务商使用的部署策略通常有两种——</p>\n<ul>\n<li><code>策略1</code>：在本地ISP的区域内部署缓存节点，这样离用户最近，但未免投入太高。</li>\n<li><code>策略2</code>：靠近ISP的数据中心部署，效果也很不错，而且部署的节点相对较少，减少了成本。</li>\n</ul>\n<p>我们来看一个小例子来体会下CDN服务是如何被使用的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210224483.png\" alt=\"image-20210707210224483\"></p>\n<p>步骤：</p>\n<ol>\n<li><p>ICP预先部署资源到CDN节点</p>\n</li>\n<li><p>用户访问Netflix的注册网站；</p>\n</li>\n<li><p>重定向到部署在亚马逊云端的网站；</p>\n</li>\n<li><p>使用域名解析重定向的机制从最近的CDN节点中获取资源；</p>\n</li>\n<li><p>将动态自适应的资源返回给用户，</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>到第二章我们就将进入具体5层协议栈的描述，更具体地说，是从顶层<strong>应用层</strong>开始，渐进地学习计算机网络。我们知道，应用层是在传输层提供的服务上实现应用进程通信的，也就是<strong>借助操作系统使用Socket API的方式</strong>实现的。那基于Socket API应用层都实现了服务呢？常用的有<strong>Web,Http，FTP,Email，DNS，CDN</strong>。在讲述这些具体应用之前，我们会先对<strong>通用的原理</strong>作以介绍。然后展开描述这些应用层的服务。</p>\n<p>好啦，了解了概况，就让我们出发吧。。。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205341750.png\" alt=\"image-20210707205341750\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在开始正式的内容之前，我们有必要先建立有意识的学习习惯。</p>\n<p>为什么要学习应用层呢？应用层或者更具体的说是应用程序，<strong>应用程序是互联网存在的理由</strong>，在其以下的四层，它们的确实现了很多功能，但这些功能如果不能被集成应用到一个应用程序上，那分层的结构就只是纸上谈兵罢了。</p>\n<p>应用层也是与我们<strong>日常生活最贴近</strong>的一层，我们与电脑上可以实现<strong>人机交互</strong>的绝大部分应用都是应用层的应用。</p>\n<p>好啦，说了这么多，无非想表达一个观点，应用层很重要。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <code>我们将从应用层协议原理起笔，浓墨重彩的描述Web,Http,Ftp,Email,DNS,这几个应用层协议，落笔于P2P应用与CDN。</code></li>\n</ul>\n<h2 id=\"1-1-应用层协议原理\"><a href=\"#1-1-应用层协议原理\" class=\"headerlink\" title=\"1.1 应用层协议原理\"></a>1.1 应用层协议原理</h2><p>任何复杂的系统实现都是从一个小的灵感异或想法开始的。</p>\n<p>假如我们想做一个交易旧书的网站，并且让它实际的运营，那我们应该从哪里点亮这个火光呢？</p>\n<blockquote>\n<p>研发网络应用程序的<strong>核心是写出能够运行在不同的端系统和通过网络彼此通信的程序</strong>。</p>\n</blockquote>\n<p>也就是说我们重点关注如何用程序实现端系统间通信，而程序的书写首先必须是基于框架的，互联网应用的体系结构分为两种：CS架构和P2P架构。</p>\n<h3 id=\"CS服务体系\"><a href=\"#CS服务体系\" class=\"headerlink\" title=\"CS服务体系\"></a>CS服务体系</h3><p>CS服务体系指的是服务器和客户端组成的架构。</p>\n<p><code>服务器</code> ：服务器是<strong>一直运行着</strong>的，通过<strong>固定IP与端口号</strong>来访问的，<strong>可扩展性较差</strong>的终端设备；</p>\n<p><code>客户端</code>：客户端在网络中以<strong>动态IP</strong>的方式标识，并<strong>主动与服务器建立通信</strong>。</p>\n<h3 id=\"P2P服务体系\"><a href=\"#P2P服务体系\" class=\"headerlink\" title=\"P2P服务体系\"></a>P2P服务体系</h3><p>在P2P体系结构中，任何端系统既可以是客户端，也可以是服务器，这也使得它们的<strong>可扩展性强</strong>，又因为没有限制，所以<strong>任意两台端设备之间可以进行通信</strong>。但这也导致<strong>难以有效的管理</strong>体系中的端系统，在现实中的应用场景包括<strong>迅雷，Gnutella</strong>。</p>\n<hr>\n<p>我们发现，P2P的负载均衡能力强，而CS架构更容易维护，那可不可以取其所长，来做一种CS与P2P体系结构的混合体呢？</p>\n<p>别说，还真有人实现了。一个大学生做了一个名为<strong>Napster</strong>的应用。这个应用是用来提供<strong>文件传输</strong>的。一个用户想查询该系统中是否存在某个文件，首先她的主机向<strong>中心服务器</strong>查询资源的位置，要实现这个功能就需要使用<strong>CS体系</strong>，即每台主机上线以后，会<strong>在中心服务器上注册它所拥有的的资源</strong>。查询到存在这个资源后，中心服务器会返回给主机<strong>这个资源所在的主机位置</strong>，最后使用<strong>P2P体系</strong>完成<strong>两个节点间的文件传输</strong>即可。</p>\n<hr>\n<h3 id=\"分布式进程通信\"><a href=\"#分布式进程通信\" class=\"headerlink\" title=\"分布式进程通信\"></a>分布式进程通信</h3><p>再回到核心问题，在确定使用哪种体系的前提下，我们还需要解决通信的问题。而<strong>通信的实体是进程</strong>，也就是要解决<strong>分布式进程间通信</strong>的问题。但这个问题是宽泛的，我们不妨分而治之——</p>\n<ol>\n<li><strong>如何标识一个进程，怎样来寻址一个进程。</strong></li>\n<li><strong>传输层是如何为应用层提供服务的？</strong></li>\n<li><strong>如何使用传输层提供的服务来实现进程之间的报文交换。</strong></li>\n</ol>\n<p>换个角度来思考这三个问题，就是怎样找到要服务的用户，这个服务怎样提供给用户，用户怎样使用这个服务。带着这三个问题，我们出发吧——</p>\n<h4 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h4><p>我们通常使用<strong>32位的IP地址来唯一的标识一台主机</strong>，在主机之上，用<strong>端口号来标识特定的进程</strong>。比如HTTP,<strong>TCP的默认端口号就为80</strong>.进程可以使用TCP或者UDP的传输层协议进行通信。</p>\n<h4 id=\"问题二\"><a href=\"#问题二\" class=\"headerlink\" title=\"问题二\"></a>问题二</h4><p>前面提到，传输层通过接口向应用层提供服务。这个接口需要携带一些通信必须的信息，这种信息至少应该包含：要传输的报文，这个报文要传给谁，这个报文是从哪里传输来的。</p>\n<p>官方地说，我们需要知道<code>SDU,IP+TCP(UDP)端口，对方的IP+TCP(UDP)端口。</code></p>\n<p>但每次通过接口通信使单独传输这些信息实在有点繁琐。所以，将这些信息封装变得很有必要。</p>\n<p><code>应用进程通过一个称为套接字的软件接口向网络中发送报文和接收报文。</code>所谓套接字，也就是Socket .那如何来理解这个socket呢？</p>\n<p>我们先从它的作用入手<strong>，socket是用于指明应用进程会话的本地标识</strong>，我们可以打个比方来形象地理解——</p>\n<blockquote>\n<p>进程可类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接收进程对该报文进行处理。</p>\n</blockquote>\n<p>再从它的含义来看，socket是操作系统生成的一个整数，这个整数可以理解为<strong>传输信息的引用</strong>。这些信息具体的说，即是包含源IP，源port，目标IP，目标port的四元组。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205357679.png\" alt=\"image-20210707205357679\"></p>\n<p>我们不必关注四元组的信息，而只需要关注<strong>socket的状态</strong>即可。操作系统的文件系统同样应用了这样的思想，在打开一个文件时，<strong>OS返回一个文件句柄</strong>，而不是使用这个文件的目录名，文件名，这样使用简单且易管理。</p>\n<p>值得一提的是，四元组是针对TCP的socket信息，但对于使用UDP的服务来说，情况又有所不同。</p>\n<p>使用UDP提供的服务时，两个进程之间的通信不需要建立连接，即<strong>不面向连接</strong>，每个报文都是独立传输的，它的前后报文也可能被送到<strong>不同的分布式进程</strong>，也就是说，对于UDP的socket，即只需指明报文将发往何处，而不必关心报文来自哪里。所以<strong>Socket中封装对方的IP及端口</strong>即可，</p>\n<h3 id=\"问题三\"><a href=\"#问题三\" class=\"headerlink\" title=\"问题三\"></a>问题三</h3><p>问题三需要回答的是怎样约定传输的格式，动作。这就需要定义<strong>应用层的协议</strong>，那这个协议的遵守是如何体现的呢？通过<strong>编制程序</strong>，使用<strong>API</strong>来调用网络基础设施来提供通信服务传报文，解析报文，实现应用时序等。</p>\n<p>应用层的协议是如何定义的呢？它需要解决的具体包含哪些问题？</p>\n<ul>\n<li><p><code>应用层的协议定义了运行在不同端系统上的应用进程如何相互交换报文</code>。</p>\n</li>\n<li><p><code>它需要包含报文的类型，报文类型对应的语法，报文中字段的语义，报文所导致的动作。</code></p>\n</li>\n</ul>\n<h2 id=\"1-2-Web与http\"><a href=\"#1-2-Web与http\" class=\"headerlink\" title=\"1.2 Web与http\"></a>1.2 Web与http</h2><p>我们在学习工作时总会无可避免地访问web页面了，一个键盘，一声敲击，一个奇迹。这奇迹的背后似乎<code>有迹可循</code>——</p>\n<p>在我们浏览的网页中，包含图文，动画，视频等，为了更好地描述这些事物，它们有了通用的名字：<strong>对象</strong>。对象可以认为是<strong>HTML页面的最小组成单元</strong>。直观地看，在我们浏览一个页面时，不同的对象并非同时出现，显然它们有可能来自不同的目的地，那如何来<strong>标识由对象组成的HTML页面</strong>呢？</p>\n<p>这就需要<strong>URL</strong>(统一资源定位符)，URL表示资源的<strong>地点</strong>，即资源来自于互联网中哪个IP。如果只使用URL标识资源位置，未免有点宽泛。所以引入<strong>URI</strong>(统一资源标识符)就势在必行了。</p>\n<p>URI用字符串标识资源的<strong>位置</strong>。则URL是URI的子集，具体看下符合<strong>RFC标准</strong>的URI格式——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205411737.png\" alt=\"image-20210707205411737\"></p>\n<ul>\n<li><code>协议方案名：</code>更多被使用的是http，但使用<strong>SSL安全传输层</strong>服务的<strong>https</strong>必然将取代http.</li>\n<li><code>登录信息：</code>即用户认证，默认是匿名访问。</li>\n<li><code>服务器地址：</code>即服务器的域名。</li>\n<li><code>服务器端口号：</code> 这里的80端口指的就是TCP服务。</li>\n<li><code>文件路径：</code> 不能再具体的描述了。</li>\n<li><code>查询字符串：</code> 即参数，比如点开某件商品的详情页时需要附带该商品的ID与该客户的ID。</li>\n<li><code>片段标识符：</code> 无题。</li>\n</ul>\n<p>了解了页面的组成，以及资源如何标识，我们再来看下页面是如何展示给用户的——</p>\n<ol>\n<li>浏览器通过HTML表单或超链接请求指向一个<code>应用程序的URL</code>。</li>\n<li>服务器收发到用户的请求。</li>\n<li>服务器执行已接受创建的指定应用程序。</li>\n<li>应用程序通常是基于用户输入的内容，执行所需要的操作。</li>\n<li>应用程序把结果格式化为网络服务器和浏览器能够理解的文档，即我们所说的<code>HTML网页</code>。</li>\n<li>网络服务器最后将结果返回到浏览器中。</li>\n<li>浏览器使用解释器解析页面。</li>\n</ol>\n<p>这么多的步骤，想来应该会比较耗时，这也是起初web被戏称<strong>World wide wait</strong>的原因，如今网络节点的增加与带宽的提高让网页的传输有了一丝飞一般的感觉~</p>\n<h3 id=\"HTTP协议的引入\"><a href=\"#HTTP协议的引入\" class=\"headerlink\" title=\"HTTP协议的引入\"></a>HTTP协议的引入</h3><p>我们知道应用层的应用程序都需要遵循规范，那web应用程序需要遵循什么规范呢？</p>\n<p>自然是HTTP协议咯，HTTP协议全称是<strong>超文本传输协议</strong>。它的出现主要是为了解决<strong>文本传输</strong>的问题。一路走来经历了<strong>HTTP1.0,HTTP1.1,HTTP2.0</strong>.可见版本更迭异常缓慢。但这并不意味着HTTP不受人青睐。相反，由于它本身非常简单。开发者在它的基础上开发出了很多应用方法并投入使用，现在<strong>HTTP协议已经超出Web框架的局限</strong>，被用于各种各样的场景中。可见，简单也意味着丰富的可扩展性。</p>\n<h3 id=\"网络基础TCP-IP\"><a href=\"#网络基础TCP-IP\" class=\"headerlink\" title=\"网络基础TCP/IP\"></a>网络基础TCP/IP</h3><p>为了更好地理解HTTP，我们有必要先了解一下TCP/IP。</p>\n<p>我们所用的网络都是在TCP/IP协议族的基础上运行的，它约定了<strong>端系统间相互通信的规则</strong>。因为后面的小结会涉及到具体的TCP/IP协议族，这里我们只给出一个框架——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205429415.png\" alt=\"image-20210707205429415\"></p>\n<p>在TCP/IP协议族提供的网络基础上，HTTP按部就班地传输着报文。接下来我们将剥茧抽丝地<strong>解析报文传输</strong>的过程：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205540218.png\" alt=\"image-20210707205540218\"></p>\n<p>在这张图中，可以看到HTTP协议的职责在于<strong>生成目标Web服务器的请求报文，及对Web服务器请求内容的处理</strong>。</p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>HTTP报文都是以<strong>ASCII码</strong>的形式与人交互，请求报文和响应报文的格式是这样的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205553641.png\" alt=\"image-20210707205553641\"></p>\n<h3 id=\"HTTP请求报文\"><a href=\"#HTTP请求报文\" class=\"headerlink\" title=\"HTTP请求报文\"></a>HTTP请求报文</h3><p>这里给出一个请求报文的例子，我们来剖析它的每一个字段——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205631561.png\" alt=\"image-20210707205631561\"></p>\n<p>请求行中包括请求的方法，使用的协议及版本。</p>\n<ul>\n<li><code>Host:</code>请求资源所在的服务器，比如WWW.Baidu.com</li>\n<li><code>User-Agent:</code>HTTP客户端程序的信息</li>\n<li><code>Accept:</code>用户代理可以处理的<strong>媒体类型</strong>。</li>\n<li><code>Accept-Language:</code>优先的语言。</li>\n<li><code>Accept-Encoding:</code>优先的内容编码。</li>\n<li><code>DNT:</code>请求追踪字段，即<strong>用户不希望被追踪</strong>。</li>\n<li><code>Connection:</code>主要有两个用途：<strong>控制不再转发给代理的首部字段</strong>和<strong>持久连接</strong>的状态管理</li>\n<li><code>Pragma:</code>报文的<strong>指令</strong>。</li>\n<li><code>Cache-Control:</code>控制<strong>浏览器端缓存</strong>的行为</li>\n</ul>\n<p>其他的首部还有很多，我们就不一一列举了。</p>\n<h3 id=\"HTTP响应报文\"><a href=\"#HTTP响应报文\" class=\"headerlink\" title=\"HTTP响应报文\"></a>HTTP响应报文</h3><p>同样的，通过一个小例子我们简要认识一下HTTP响应报文——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205648733.png\" alt=\"image-20210707205648733\"></p>\n<p>首先是状态行，它的信息包括协议类型，版本，状态码，状态码对应的解释。</p>\n<p>再来看字段的解析：</p>\n<ul>\n<li><code>Date:</code>服务器端<strong>创建报文的日期时间</strong>，必选项。</li>\n<li><code>Server:</code>用于告知客户端当前<strong>服务器上安装的HTTP服务器应用程序</strong>的信息。</li>\n<li><code>Last-Modified:</code>资源<strong>最终修改的时间</strong>。</li>\n<li><code>ETag:</code>资源的匹配信息，只有当If-Match的字段值与ETag值<strong>匹配时，服务器才会接收请求</strong>。</li>\n<li><code>Accept-Ranges:</code>是否接收<strong>字节范围请求</strong>，当我们只需要一部分数据时，可以加这个参数来减少网络链路的带宽压力。</li>\n<li><code>Content-Length:</code>实体主体的长度，它的<strong>单位是字节</strong>，TCP提供的是字节流的服务，他不会维护信息的边界，所以需要一些辅助信息。</li>\n<li><code>Connection:</code>连接的状态，可选Keep-alive和Close</li>\n<li><code>Connect-Type:</code> 实体类型</li>\n</ul>\n<p>我们再从层间接口的角度来看Web是如何工作的。。。</p>\n<h3 id=\"Web的层间接口Socket\"><a href=\"#Web的层间接口Socket\" class=\"headerlink\" title=\"Web的层间接口Socket\"></a>Web的层间接口Socket</h3><p>HTTP协议使用是<strong>基于TCP的传输层服务</strong>，则服务器的<strong>80号端口</strong>会始终处于等待状态，客户端发起请求后，服务器端的<strong>守护socket</strong>在接收到请求以后，会生成一个该请求<strong>独有的socket</strong>，这个socket表示服务器端与特定客户端的<strong>会话关系</strong>。</p>\n<h3 id=\"无状态协议\"><a href=\"#无状态协议\" class=\"headerlink\" title=\"无状态协议\"></a>无状态协议</h3><p>HTTP协议是一个<strong>无状态</strong>的协议，它不会维护历史信息，这使得它能够<strong>支持的用户数量多</strong>，但比如说在登录网页以后，维护登录状态又是必不可少的。</p>\n<p>那如何使它可以记录状态呢？对HTTP协议本身做文章未免<strong>不是开发者的初衷</strong>，所以由<strong>客户端</strong>来维护历史信息，由于要维护的历史信息比较多，这里与用户交互的不是信息本身，而是指向这些信息的引用，小甜饼<strong>Cookie</strong>就这样应运而生了。</p>\n<p>我们通过下图来认识一下Cookie机制——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205705315.png\" alt=\"image-20210707205705315\"></p>\n<h3 id=\"持久连接\"><a href=\"#持久连接\" class=\"headerlink\" title=\"持久连接\"></a>持久连接</h3><p>HTTP1.0协议是不支持持久连接的，也就是每次发送报文时，都需要建立TCP连接——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205856780.png\" alt=\"image-20210707205856780\"></p>\n<p>这样每次请求时都会造成<strong>无谓的TCP连接和断开</strong>，增加通信量的消耗。</p>\n<p>因此在HTTP1.1中引入了持久连接，持久连接是指如果<strong>没有一方明确要求断开连接时，这个连接会一直保存</strong>。也就是说，持久连接是<code>双方端系统需要设置的</code>，而不是在通信过程中设定。</p>\n<p>持久连接使多数请求以<strong>管线化方式</strong>发送称为可能。这就可以实现<strong>高并发发送</strong>。类似于<strong>流水线</strong>。</p>\n<h3 id=\"HTTP首部字段的应用\"><a href=\"#HTTP首部字段的应用\" class=\"headerlink\" title=\"HTTP首部字段的应用\"></a>HTTP首部字段的应用</h3><p>我们通过<strong>搜索引擎</strong>来获取想要的web页面，那搜索引擎是如何找到web页面的呢？它会通过网络<strong>爬虫</strong>爬取到HTTP的<strong>首部字段</strong>，使用首部字段中的关键信息来建立<strong>索引</strong>，实现高效查找。</p>\n<h3 id=\"HTTP请求行与状态行浅析\"><a href=\"#HTTP请求行与状态行浅析\" class=\"headerlink\" title=\"HTTP请求行与状态行浅析\"></a>HTTP请求行与状态行浅析</h3><ul>\n<li><code>请求行：</code>这里我们主要描述用于告知服务器意图的方法：<ul>\n<li>如get用于请求访问已被URI识别的资源；</li>\n<li>POST方法用来传输实体的主体；</li>\n<li>PUT用于传输文件;</li>\n<li>HEAD用于请求报文首部</li>\n</ul>\n</li>\n<li><code>状态行：</code><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205842449.png\" alt=\"image-20210707205842449\"></li>\n<li></li>\n</ul>\n<h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><p>假设有这样一种需求，客户请求服务器资源时因为链路太长导致响应时间慢，老板要求你解决这个问题，这时根据你的经验有两种处理方式——</p>\n<ol>\n<li><strong>增加链路带宽</strong>，可行，但你被辞退了，因为解决方式太土豪；</li>\n<li><strong>在局域网内部增加缓存节点</strong>。也就是Web代理，购置一台服务器就好了，还可以通过增加缓存的命中率来<strong>减轻服务器的负载，降低网络的通信量</strong>，爽歪歪。老板直呼内行。</li>\n</ol>\n<p>缓存应该是学习的一大热点了，但凡缓存，就需要注意缓存一致性问题。首先我们要能发现缓存是否一致，也就是<strong>通过加时间字段</strong>。如果字段值超时了，Web代理就丢弃缓存内容。</p>\n<hr>\n<h3 id=\"加餐——HTTPS\"><a href=\"#加餐——HTTPS\" class=\"headerlink\" title=\"加餐——HTTPS\"></a>加餐——HTTPS</h3><p>先来看张图，可以看到在URL的前面有一个<strong>锁的标识</strong>，而我们所熟识的HTTP是不加密的，所以呢，这里的锁实际上标识使用的协议是HTTPS，我们的故事也将从这张图开始啦。。。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408101342730.png\" alt=\"image-20210408101342730\"></p>\n<p>我们知道，HTTP最大的特点与优点就是<strong>简单易用</strong>，但简单也必然带来一些问题：</p>\n<ul>\n<li><p><code>明文传输</code>：由于HTTP本身不具备加密的功能，自然就不可能对通信整体(即通信请求与通信内容)进行加密，而不加密的HTTP有被窃听的风险，如果我们使用<strong>wireShark抓包工具</strong>，就会收获满满——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210408102109238.png\" alt=\"image-20210408102109238\"></p>\n<p>这可不怎么靠谱，那怎样实现加密呢？考虑到发生数据泄露的位置可能是<strong>通信源或者通信链路</strong>，我们可以对症下药，对<strong>通信链路</strong>进行加密，这就引出了<strong>SSL安全套接字层/TLS安全层传输协议</strong>。当然对通信内容本身加密也是一种可行的idea,这里我们先着重介绍SSL。</p>\n<p>SSL采用一种叫做公开密钥加密的加密处理方式，我们常说的使用密钥加密，指的是客户端使用密钥加密，服务器端使用同一密钥解密，但这样显然面临一种困境：如果有第三方得到密钥，那就可以为所欲为。这里可以尝试客户端使用公开密钥加密，而服务器端使用私有秘钥解密的策略。</p>\n<p>两种策略各有千秋，那到底使用哪一种呢？</p>\n<p>HTTPS表示我全都要，HTTPS使用混合加密机制，在<strong>交换密钥环节使用公开密钥加密方式</strong>，之后的<strong>建立通信交换报文使用共享密钥加密方式</strong>。</p>\n</li>\n<li><p><code>身份验证</code>：HTTP协议中的请求与响应不会对同新方进行确认，也就是说任何人都可以发起请求，如果发起多次<strong>恶意请求，网站负载就会增大</strong>，显然需要机制来确认通信方的身份。</p>\n<p>SSL不仅提供加密处理，还使用了称之为<strong>证书</strong>的手段来身份认证，证书由靠谱的第三方机构颁发。</p>\n</li>\n<li><p><code>报文完整性</code>：在通信过程中，如果请求或者响应的内容遭到中间人的篡改，就会事与愿违，那如何来防止篡改呢？显然需要一种指代内容的唯一标识，<strong>MD5和SHA</strong>就是常用的方法，</p>\n</li>\n</ul>\n<p>现在，我们可以给出HTTPS的明确定义了：</p>\n<blockquote>\n<p>HTTPS = HTTP + 加密 + 认证 +完整性保护</p>\n</blockquote>\n<h2 id=\"1-3-FTP-amp-Email\"><a href=\"#1-3-FTP-amp-Email\" class=\"headerlink\" title=\"1.3 FTP&amp;Email\"></a>1.3 FTP&amp;Email</h2><p>在开发应用时，FTP的身影并不多，唯一一次见证它的背影是在使用<strong>Maven找包</strong>的时候，给我的直观感觉就是，这不就是<strong>文件系统</strong>嘛~</p>\n<p>鉴于它太古老了，我们只是简要描述一下它工作的流程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205929522.png\" alt=\"image-20210707205929522\"></p>\n<ol>\n<li>FTP的服务器始终守护在21号端口处等待连接，FTP的客户端发起连接请求，<strong>基于TCP的控制连接</strong>建立。</li>\n<li><strong>用户身份认证</strong>，认证后访问文件目录，也因此需要维护历史信息，即<strong>FTP是有状态的协议</strong>，值得一提的是，身份认证是使用<strong>明文传输</strong>，着实不可靠。</li>\n<li>服务器<strong>主动</strong>与客户端的20号端口建立<strong>数据连接</strong>，客户端下载数据，完结。</li>\n</ol>\n<hr>\n<p>这是一个么得感情的分割线~</p>\n<p>Email不同于FTP，它在工作交流，面试简历提交等方面<strong>应用非常广泛</strong>。Email由三部分构成：<strong>用户代理</strong>，也就是客户端软件，<strong>邮件服务器</strong>，<strong>协议</strong>。</p>\n<p>我们同样复现EMail的工作流程——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707205938954.png\" alt=\"image-20210707205938954\"></p>\n<ol>\n<li>首先用户在用户代理中写好邮件，用户代理通过<strong>STMP协议</strong>将邮件传输到<strong>用户邮箱服务器的队列</strong>中。</li>\n<li>邮箱服务器再将邮件从队列中提取出来，使用SMTP协议将邮件发送到目标服务器。</li>\n<li>目标服务器将邮件存储在<strong>目标用户的邮箱目录</strong>中。</li>\n<li>目标用户通过<strong>POP3协议</strong>从邮箱中拉取邮件阅读。</li>\n</ol>\n<p>Email使用<strong>7位的ASCII码</strong>编码，而中文需要两个字节描述，如果使用7位ASCII码传输时就会乱码。为了防止乱码，使用<strong>MIME多媒体扩展协议</strong>，这是基于<strong>Base64</strong>的编码，即<strong>将ASCII码序列化</strong>再传输。</p>\n<p>而使用POP3的拉取协议，显然不应该记录邮件都经由谁手，在什么时间写好这种敏感信息，所以它被设计为<strong>无状态协议</strong>。</p>\n<h2 id=\"1-5-DNS\"><a href=\"#1-5-DNS\" class=\"headerlink\" title=\"1.5 DNS\"></a>1.5 DNS</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>DNS不同于其他应用层协议，它是用来<strong>为其他应用协议提供服务</strong>的协议，DNS为人所知的功能是<strong>完成域名到IP地址的转换</strong>，且非常<strong>健壮</strong>。而这个转化实质上是由<strong>DNS系统</strong>来完成的。</p>\n<p>系统的设计是为了解决复杂问题，而DNS系统解决的核心问题就是如何完成域名到IP地址的转换，我们再将这个问题拆解为三个小问题——</p>\n<h3 id=\"1-如何命名一台设备？\"><a href=\"#1-如何命名一台设备？\" class=\"headerlink\" title=\"1.如何命名一台设备？\"></a>1.如何命名一台设备？</h3><p>如果我们想访问一个网站，那就需要在地址输入栏中输入网站的URI，而URI中显然需要<strong>包含易记的用来标识端系统位置</strong>的东西，这就是<strong>域名</strong>，域名是一个端系统的<strong>别名</strong>，易于记忆，显然<a href=\"http://www.baidu.com比起纯数字的方式交互起来友好地多./\">www.baidu.com比起纯数字的方式交互起来友好地多。</a></p>\n<p>既然有别名，那就一定有正规名称，也就是IP地址.IP地址被用来表示一台主机，同时也用于寻址。IP地址分为IPV4和IPV6两种。IPV4使用点分十进制的书写习惯，共有32位，IPV6则有128位，可标识的主机数量非常多。</p>\n<p>显然，日常使用时域名显然是更好的选择，域名在初期使用没有分层的结构，因为主机数量少，不会出现重名，只需要维护一张映射表就行了，维护起来游刃有余。</p>\n<p>但当主机数指数级增多以后，重名变得不可避免，<strong>分层式的命名</strong>开始大势所趋。这时只维护一张表也显然不够了，<strong>分布式数据库</strong>被引入。而既然是应用层协议，自然会使用到传输层的服务，DNS使用的就是相对简单的<strong>UDP协议</strong>，可见网络核心的功能其实是在网络边沿实现的，网络核心只要保证传输就ok了。</p>\n<p>再说回<strong>层次树状化</strong>的命名，首先从根开始，也就是顶级域名，顶级域名对应的是顶级服务器，全世界只有13台顶级，即<strong>根服务器</strong>。而且<strong>中国并没有</strong>，有人担忧万一根服务器被黑了，网络安全是否变的不可靠了。但实际上这对网络安全并没有什么大的影响。分布式足以解决这一看起来很棘手的问题。在这些顶级域下，又有很多<strong>子域</strong>，子域的类型分为两种，即<strong>通用的</strong>和<strong>国家的</strong>。最终演化到树叶，就是<strong>主机</strong>啦。</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210048205.png\" alt=\"image-20210707210048205\"></p>\n<p>如果将DNS的命名规则平面化的话，它可以这样表示：</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210104057.png\" alt=\"image-20210707210104057\"></p>\n<p>假如我们要访问耶鲁大学AI学院的网站。通俗的方式是首先找到顶级域名，再找到通用域名edu，然后找到edu下的yale,接着发现cs，最后定位到AI。从它宽泛的命名框架来看，域名适用于任何主机，这就意味着<strong>域名不代表地域，它只是一个逻辑的概念</strong>，而非物理上的。</p>\n<h3 id=\"2-如何解析转换关系？\"><a href=\"#2-如何解析转换关系？\" class=\"headerlink\" title=\"2.如何解析转换关系？\"></a>2.如何解析转换关系？</h3><p>解析关系直观地看，可以维护一张映射表，但考虑到性能，我们使用专门的名字服务器来存储这样的一张表，但当主机变多时，<strong>一个服务器容易宕机，且不好维护</strong>。</p>\n<p>这时需要演化为分布式的名字服务器，而完成其功能的实际上是<strong>分布式的数据库</strong>。</p>\n<p>在<strong>每一个区域Zone</strong>内需要维护一个名字服务器，它存储有这个区域内所有主机Ip与域名的<strong>映射关系</strong>，同时它也应该满足<strong>寻址</strong>的要求，这就需要维护指向路径的指针。因其完备的功能，因此也称其为权威服务器。</p>\n<p>那权威服务器是如何维护转换关系的呢？通过数据库中的<strong>资源记录</strong>。</p>\n<p>资源记录使用<strong>RR格式</strong>来维护<strong>域名到IP</strong>(或者其他标识)的映射关系。它包含如下字段——</p>\n<ul>\n<li><code>Domain_name:</code>域名，没什么可说的~</li>\n<li><code>Ttl:</code>生存时间，假如我现在要访问中国以外的一个域名，我所在区域的权威服务器会沿路径获取到这个域名与IP的映射关系，并将其是作为缓存记录下来，但它显然不常用，所以存活时间仅有<strong>两天</strong>。而对于区域内的域名，考虑到作为老大的职责，会<strong>长期缓存</strong>区域内小弟的映射关系。</li>\n<li><code>Class:</code>只要是因特网范围内的，值都为IN,在物联网时代，NOT IN将成为一种可能。</li>\n<li><code>Value:</code>可以是数字，域名或者ASCII码。</li>\n<li><code>Type:</code>资源记录的类型，它包括：<ul>\n<li><code>A</code>：name为主机，Value为IP地址</li>\n<li><code>CNMAE</code>:name为规范名字的别名，value是规范名字。</li>\n<li><code>NS</code>:name为域名，value为该域名权威服务器的名字</li>\n<li><code>MX</code>:value为name对应的邮件服务器的名字。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"DNS系统的工作原理\"><a href=\"#DNS系统的工作原理\" class=\"headerlink\" title=\"DNS系统的工作原理\"></a>DNS系统的工作原理</h4><ul>\n<li>应用首先调用解析器，解析器作为客户向名字服务器发出查询报文，该查询报文被封装在UDP段中。</li>\n<li>名字服务器返回响应报文。</li>\n</ul>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210144625.png\" alt=\"image-20210707210144625\"></p>\n<p>那名字服务器是如何获取到远端的IP映射关系呢？</p>\n<p>这里要分有缓存和没缓存两种情况讨论——</p>\n<ol>\n<li><code>存在缓存</code>：直接返回</li>\n<li><code>没有缓存</code>：<ol>\n<li><code>递归查询</code>，即从根服务器开始递，再从目标服务器的权威服务器开始归</li>\n<li><code>迭代查询</code>，即依次遍历每种可能。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-如何维护映射关系？\"><a href=\"#3-如何维护映射关系？\" class=\"headerlink\" title=\"3.如何维护映射关系？\"></a>3.如何维护映射关系？</h3><p>关系的维护无非增删改查，假如要在上级域的名字服务器中增加一个映射关系，那就往数据库中<strong>添加两条记录</strong>，分别指向<strong>新增的子域的域名</strong>和<strong>域名服务器的地址</strong>。这样在下次访问时会方便很多。但缓存有可能出现<strong>不一致</strong>的问题，因而在某些时候删除也是必要的。</p>\n<h3 id=\"报文结构\"><a href=\"#报文结构\" class=\"headerlink\" title=\"报文结构\"></a>报文结构</h3><p>最后，简单看下DNS协议的报文——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210157098.png\" alt=\"image-20210707210157098\"></p>\n<h2 id=\"1-6-P2P应用\"><a href=\"#1-6-P2P应用\" class=\"headerlink\" title=\"1.6 P2P应用\"></a>1.6 P2P应用</h2><p>因为我在毕业后所将从事的工作和P2P的体系架构<strong>大抵是没有太多交集</strong>的，所以这一小节的知识点我只<strong>简要描述原理</strong>。</p>\n<p>先入为主地说，P2P的产生是为了解决CS体系的缺陷，即<strong>服务器压力大，负载均衡能力弱，可靠性不好</strong>。而相应的，P2P体系在这些方面是要略胜一筹的。</p>\n<p>P2P体系常常被应用在<strong>文件分发，流媒体</strong>，在这些应用场景中，peer节点的压力比较轻。</p>\n<p>为了形象描述P2P体系，我们来看下面这张图——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210209024.png\" alt=\"image-20210707210209024\"></p>\n<p>这张图描述了两种体系结构随着客户端数量的增加，下载文件所消耗的时间，可以看到，CS体系呈现出线性的关系，而P2P则是类似于对数关系。</p>\n<p>如果单纯从下载性能方面来看的话，P2P早就风靡一时了。但因为它难以管理的缺陷，导致了它应用的并不多。</p>\n<p>我们来了解通用的P2P的管理模式——</p>\n<ul>\n<li><p><code>非结构化的P2P：</code>邻居节点间存在互通有无的关系，形成<strong>覆盖网</strong>。典型的应用是<strong>文件共享</strong>，即通过<strong>集中目录</strong>的方式，用户首先键入<strong>关键字</strong>，然后<strong>目录服务器</strong>告诉用户有哪些节点拥有该资源，用户建立<strong>TCP连接</strong>，再去请求某节点的资源。拥有该资源后，将自己拥有该资源的信息<strong>上报目录服务器</strong>，流程结束。</p>\n<p>但集中式的目录，存在<strong>单点故障，性能瓶颈，侵犯版权</strong>的问题。此外，查询时采用<strong>洪泛</strong>的方式有可能导致<strong>请求无限放大</strong>，所以有必要设置<strong>TTL或由节点维护历史信息</strong>避免成环。因此除了集中式的目录以外，还存在<strong>完全分布式</strong>和<strong>混合体</strong>的机制。混合体机制利用节点的<strong>不均匀性</strong>，某个对等点要么是属于一个组或者组长，查询时，上报组长，如果组内有，直接去请求，组内没有的话，则交由组长传递给其他组长。</p>\n<p>那如何找到唯一地那个文件呢，首先通过输入框的<strong>描述信息</strong>找到该文件的<strong>哈希值</strong>，然后将哈希值作为<strong>唯一Id</strong>查询返回结果</p>\n<p>这里还有一个有意思的模式，<strong>BitTorrow</strong>。在这种模式下，文件被分为很多块，每个节点各持一块，且每个节点维护一个位图，即<strong>BitMap</strong>，0标识不拥有此资源，1表示拥有此资源。为了使所有节点都拥有相同的资源，需要<strong>定期洪泛</strong>。</p>\n</li>\n<li><p><code>结构化的P2P：</code>节点与节点之间的关系是往往成<strong>网状或者环状</strong>的。在更新节点时始终维护节点间的关系，即根据哈希值更新环。</p>\n</li>\n</ul>\n<h2 id=\"1-7-CDN\"><a href=\"#1-7-CDN\" class=\"headerlink\" title=\"1.7 CDN\"></a>1.7 CDN</h2><p>在互联网中，视频类的流量占据所有流量的大部分，这也使得<strong>带宽的增加有用武之地</strong>。那视频的流量为什么这么大呢？</p>\n<p>视频是<strong>固定速度显示的图片序列</strong>，而图片是由许多<strong>像素点集成</strong>得到的。所以视频就会比较大，编码也会相应复杂一些。</p>\n<p>那针对太大的视频，应该做如何的处理呢？这就首先要看网络视频的特点——</p>\n<ul>\n<li>高码率</li>\n<li>可压缩</li>\n</ul>\n<p>所以降低视频流量的方式就是<strong>降低码率并做时空上的压缩</strong>，比如我国的AVS编码方式。</p>\n<p>我们再从整体的框架看，显然只用一台超级服务器来提供流式服务是不可能的，因为<strong>规模太大</strong>，并且<strong>存在异构性</strong>。因此提供流式服务的<strong>分布式服务器</strong>被广泛应用。</p>\n<p>我们在平时观看视频时，有时会发生卡顿，并且提示我们缓存一会再看，如何解释它的原理呢？</p>\n<p><code>互联网提供给我们的是存储视频的流化服务，它可以实现辺下载辺看，就像河流一般，我们在从缓冲区中取视频内容，实现了高并发的视频传输。</code></p>\n<p>但不同的用户对于视频的要求不同，这可能受限于带宽，或者是设备。那如何解决这个问题呢？</p>\n<p>采用<strong>动态自适应的流化技术DASH</strong>，服务器端并不会有选择性的发送内容，但它会将视频分块，每块有不同的解析度，不同的编码标准，为了为客户端标识不同块的URL，服务器还维护一个<strong>告示文件</strong>用以提供不同块的URL。</p>\n<p>客户端首先获取到告示文件，然后<strong>周期性的测试</strong>服务器到客户端的<strong>带宽</strong>，根据带宽来<strong>实时</strong>地请求某一块，最后<strong>解析</strong>观看视频。</p>\n<p>假如视频流量出现超高并发，比如春晚直播，如果仅从央视的服务器去请求资源的话，那你将体会到什么叫做超高频延迟。但我们实际观看时，貌似很流畅，这是为什么呢?</p>\n<p>因为使用了CDN服务商的加速服务，加速的原理也很简洁，无非部署缓存节点。但如何部署呢？CDN服务商使用的部署策略通常有两种——</p>\n<ul>\n<li><code>策略1</code>：在本地ISP的区域内部署缓存节点，这样离用户最近，但未免投入太高。</li>\n<li><code>策略2</code>：靠近ISP的数据中心部署，效果也很不错，而且部署的节点相对较少，减少了成本。</li>\n</ul>\n<p>我们来看一个小例子来体会下CDN服务是如何被使用的——</p>\n<p><img src=\"https://gitee.com//future727/imgs/raw/master/zyz_img3/image-20210707210224483.png\" alt=\"image-20210707210224483\"></p>\n<p>步骤：</p>\n<ol>\n<li><p>ICP预先部署资源到CDN节点</p>\n</li>\n<li><p>用户访问Netflix的注册网站；</p>\n</li>\n<li><p>重定向到部署在亚马逊云端的网站；</p>\n</li>\n<li><p>使用域名解析重定向的机制从最近的CDN节点中获取资源；</p>\n</li>\n<li><p>将动态自适应的资源返回给用户，</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>山高路远，静水深流。</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cln02j7km0001xjcc3fn14xvp","category_id":"cln02j7ks0004xjccdhtz1adt","_id":"cln02j7l0000fxjcccjr9hp5l"},{"post_id":"cln02j7kq0003xjccdu295qdn","category_id":"cln02j7ky000bxjcc0xun6qw1","_id":"cln02j7l4000nxjcc1ey3e9qk"},{"post_id":"cln02j7kv0007xjccbvrf83bs","category_id":"cln02j7ks0004xjccdhtz1adt","_id":"cln02j7l7000rxjcceaua5tk5"},{"post_id":"cln02j7kw0009xjccecmpbu64","category_id":"cln02j7l3000mxjcchp9dean8","_id":"cln02j7l8000vxjcc5vpa4lx8"},{"post_id":"cln02j7kz000dxjcc0zt6fjzb","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7l80011xjccbi5cauuj"},{"post_id":"cln02j7l0000exjcc4k511h5f","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7l90014xjccc0q71bk2"},{"post_id":"cln02j7l2000ixjcc3dse7roh","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7la0018xjcc8sehay6d"},{"post_id":"cln02j7l3000kxjcc09yd5fhw","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7lb001cxjcchufo6003"},{"post_id":"cln02j7l4000pxjccbeho5cw6","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7lb001exjcc4k2xau4s"},{"post_id":"cln02j7l4000qxjcc3b3o0vg6","category_id":"cln02j7lb001bxjcc38u57gfu","_id":"cln02j7lc001jxjcc90nugrqn"},{"post_id":"cln02j7lz001sxjccfvg23dfi","category_id":"cln02j7l3000mxjcchp9dean8","_id":"cln02j7m2001yxjccc6mv7h8g"},{"post_id":"cln02j7m0001vxjcc6h9v7zgv","category_id":"cln02j7l3000mxjcchp9dean8","_id":"cln02j7m30022xjcc5amag606"},{"post_id":"cln02j7m1001wxjccdlpa0gyu","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7m40024xjccfdq78pf7"},{"post_id":"cln02j7lw001rxjccf0ki4mc8","category_id":"cln02j7m0001txjcc3kd6buqf","_id":"cln02j7m50027xjcc7kb8fc94"},{"post_id":"cln02j7m2001xxjcccu6efpct","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7m50029xjcc81967qmf"},{"post_id":"cln02j7m30021xjcc3m1r1upz","category_id":"cln02j7l3000mxjcchp9dean8","_id":"cln02j7m6002cxjccchlk5ctf"},{"post_id":"cln02j7mt002nxjcccwm9gzpw","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7mu002rxjcc5e620pnc"},{"post_id":"cln02j7mq002jxjcc0drs4tjd","category_id":"cln02j7mt002lxjcce2s4atci","_id":"cln02j7mv002txjcc1offehwk"},{"post_id":"cln02j7n7002zxjcc74ic4m06","category_id":"cln02j7l7000sxjccc8la0ghj","_id":"cln02j7n80032xjcc4uaw94rs"}],"PostTag":[{"post_id":"cln02j7km0001xjcc3fn14xvp","tag_id":"cln02j7ku0005xjcc13wc24g6","_id":"cln02j7l3000jxjccd4b81x3w"},{"post_id":"cln02j7km0001xjcc3fn14xvp","tag_id":"cln02j7ky000cxjcc7jns7x8r","_id":"cln02j7l3000lxjcc5gdt8jq1"},{"post_id":"cln02j7kq0003xjccdu295qdn","tag_id":"cln02j7l0000hxjcceaq32r8j","_id":"cln02j7l7000uxjcceyumgqm6"},{"post_id":"cln02j7kq0003xjccdu295qdn","tag_id":"cln02j7l4000oxjcchoj41l1k","_id":"cln02j7l8000wxjcca5tw9un3"},{"post_id":"cln02j7kv0007xjccbvrf83bs","tag_id":"cln02j7l7000txjcc353xarfj","_id":"cln02j7l8000zxjcc2jvd2z5s"},{"post_id":"cln02j7kw0009xjccecmpbu64","tag_id":"cln02j7l8000yxjccejf7cw5y","_id":"cln02j7la0016xjccdlmp8x86"},{"post_id":"cln02j7kw0009xjccecmpbu64","tag_id":"cln02j7l80012xjcc27v0c2d0","_id":"cln02j7lb0019xjccc3qmcsi9"},{"post_id":"cln02j7kz000dxjcc0zt6fjzb","tag_id":"cln02j7l90015xjccbgolaurc","_id":"cln02j7lb001fxjccgloy3aym"},{"post_id":"cln02j7kz000dxjcc0zt6fjzb","tag_id":"cln02j7lb001axjccazp7dgwz","_id":"cln02j7lb001gxjcc0vbb198v"},{"post_id":"cln02j7l0000exjcc4k511h5f","tag_id":"cln02j7l90015xjccbgolaurc","_id":"cln02j7lc001ixjcc5ai0aq01"},{"post_id":"cln02j7l2000ixjcc3dse7roh","tag_id":"cln02j7l90015xjccbgolaurc","_id":"cln02j7lc001lxjcc4p6jcod4"},{"post_id":"cln02j7l3000kxjcc09yd5fhw","tag_id":"cln02j7l90015xjccbgolaurc","_id":"cln02j7lc001nxjccbyly0x03"},{"post_id":"cln02j7l4000pxjccbeho5cw6","tag_id":"cln02j7lc001mxjccfyxnaa3l","_id":"cln02j7lc001pxjccfrp79j1x"},{"post_id":"cln02j7l4000qxjcc3b3o0vg6","tag_id":"cln02j7lc001oxjcc9a1bg2sa","_id":"cln02j7ld001qxjcc5dk4aqua"},{"post_id":"cln02j7lw001rxjccf0ki4mc8","tag_id":"cln02j7m0001uxjcc6iv57oea","_id":"cln02j7m30020xjccah64cjtg"},{"post_id":"cln02j7lw001rxjccf0ki4mc8","tag_id":"cln02j7l80012xjcc27v0c2d0","_id":"cln02j7m40023xjcc1ssc75da"},{"post_id":"cln02j7m2001xxjcccu6efpct","tag_id":"cln02j7l90015xjccbgolaurc","_id":"cln02j7m50026xjccgkzqg8ok"},{"post_id":"cln02j7lz001sxjccfvg23dfi","tag_id":"cln02j7m2001zxjcc2ufp4y8p","_id":"cln02j7m50028xjcc71fiar9x"},{"post_id":"cln02j7lz001sxjccfvg23dfi","tag_id":"cln02j7l80012xjcc27v0c2d0","_id":"cln02j7m6002bxjcc98f69qw1"},{"post_id":"cln02j7m0001vxjcc6h9v7zgv","tag_id":"cln02j7m40025xjccereme2kn","_id":"cln02j7m8002exjccgudp89y4"},{"post_id":"cln02j7m0001vxjcc6h9v7zgv","tag_id":"cln02j7m5002axjccacvgfu71","_id":"cln02j7m8002fxjcceicofvdi"},{"post_id":"cln02j7m1001wxjccdlpa0gyu","tag_id":"cln02j7m6002dxjcc91lih7nw","_id":"cln02j7m8002hxjcc0nbh6mkt"},{"post_id":"cln02j7m30021xjcc3m1r1upz","tag_id":"cln02j7m8002gxjcchyty4pwt","_id":"cln02j7m8002ixjcc29xw19jh"},{"post_id":"cln02j7mt002nxjcccwm9gzpw","tag_id":"cln02j7l90015xjccbgolaurc","_id":"cln02j7mu002oxjcc2no5fjng"},{"post_id":"cln02j7mt002nxjcccwm9gzpw","tag_id":"cln02j7lb001axjccazp7dgwz","_id":"cln02j7mu002qxjcc4gg51703"},{"post_id":"cln02j7mq002jxjcc0drs4tjd","tag_id":"cln02j7m5002axjccacvgfu71","_id":"cln02j7mv002sxjccah9d7q4h"},{"post_id":"cln02j7mq002jxjcc0drs4tjd","tag_id":"cln02j7mt002mxjcc1exzaet7","_id":"cln02j7mv002vxjcc7u0f4kmf"},{"post_id":"cln02j7ms002kxjccgogm2avt","tag_id":"cln02j7lc001mxjccfyxnaa3l","_id":"cln02j7mv002wxjcce90r5mzt"},{"post_id":"cln02j7ms002kxjccgogm2avt","tag_id":"cln02j7mu002pxjccclnz9akr","_id":"cln02j7mv002xxjcccoww2raa"},{"post_id":"cln02j7ms002kxjccgogm2avt","tag_id":"cln02j7mv002uxjcchyk1cvj4","_id":"cln02j7mv002yxjccgtt45rmj"},{"post_id":"cln02j7n7002zxjcc74ic4m06","tag_id":"cln02j7lc001mxjccfyxnaa3l","_id":"cln02j7n80030xjcc75k65q4u"},{"post_id":"cln02j7n7002zxjcc74ic4m06","tag_id":"cln02j7mu002pxjccclnz9akr","_id":"cln02j7n80031xjcc8s8egmix"}],"Tag":[{"name":"JVM","_id":"cln02j7ku0005xjcc13wc24g6"},{"name":"Java","_id":"cln02j7ky000cxjcc7jns7x8r"},{"name":"Maven","_id":"cln02j7l0000hxjcceaq32r8j"},{"name":"IDEA","_id":"cln02j7l4000oxjcchoj41l1k"},{"name":"spring","_id":"cln02j7l7000txjcc353xarfj"},{"name":"数组","_id":"cln02j7l8000yxjccejf7cw5y"},{"name":"极客时间","_id":"cln02j7l80012xjcc27v0c2d0"},{"name":"操作系统","_id":"cln02j7l90015xjccbgolaurc"},{"name":"linux0.11","_id":"cln02j7lb001axjccazp7dgwz"},{"name":"计算机网络","_id":"cln02j7lc001mxjccfyxnaa3l"},{"name":"递归","_id":"cln02j7lc001oxjcc9a1bg2sa"},{"name":"Mysql","_id":"cln02j7m0001uxjcc6iv57oea"},{"name":"数据结构","_id":"cln02j7m2001zxjcc2ufp4y8p"},{"name":"排序算法","_id":"cln02j7m40025xjccereme2kn"},{"name":"java","_id":"cln02j7m5002axjccacvgfu71"},{"name":"intel8086汇编","_id":"cln02j7m6002dxjcc91lih7nw"},{"name":"链表","_id":"cln02j7m8002gxjcchyty4pwt"},{"name":"并发编程","_id":"cln02j7mt002mxjcc1exzaet7"},{"name":"抓包","_id":"cln02j7mu002pxjccclnz9akr"},{"name":"通用模式","_id":"cln02j7mv002uxjcchyk1cvj4"}]}}